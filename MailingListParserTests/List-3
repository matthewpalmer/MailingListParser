From zefmail at gmail.com  Thu Dec  3 13:52:48 2015
From: zefmail at gmail.com (Zef Houssney)
Date: Thu, 3 Dec 2015 12:52:48 -0700
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
Message-ID: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>

Hello. This is exciting!

I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.

The idea is to introduce a new syntax for Optional Binding:

Instead of:

if let foo = foo { }

You could simply use:

if let foo { }


I?ve written up a draft of a proposal here with additional information and motivations:
https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md


What do you think?

Thank you!

From xcvista at me.com  Thu Dec  3 14:01:16 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 04:01:16 +0800
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
Message-ID: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>

Dear Swift developers:

Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.

Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.

I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.

In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.

Max
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f4f78f67/attachment.p7s>

From adrian.kashivskyy at me.com  Thu Dec  3 14:15:55 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Thu, 03 Dec 2015 21:15:55 +0100
Subject: [swift-evolution] Proposal: Swift Open Source Project
and	Foundation replacements
In-Reply-To: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
Message-ID: <A42DCBDD-00ED-43C3-B754-405A67E8509F@me.com>

I believe the goal of swift-corelibs-foundation is to fully reimplement Foundation functionality in pure, platform-agnostic Swift, so that no bridging is required (at least on Linux). Maintaining Objective-C interoperability on Linux would be a too huge task at the current stage, in my opinion.

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Maxthon Chan <xcvista at me.com> w dniu 03.12.2015, o godz. 21:01:
>
> Dear Swift developers:
>
> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>
> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>
> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>
> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>
> Max_______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/6103376e/attachment.html>

From greg.casamento at gmail.com  Thu Dec  3 14:01:52 2015
From: greg.casamento at gmail.com (Gregory Casamento)
Date: Thu, 03 Dec 2015 20:01:52 +0000
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
Message-ID: <CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>

Way ahead of you
On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:

> Dear Swift developers:
>
> Maybe you have never heard of it, but there have been several ongoing
> efforts, like GNUstep and Cocotron, at maintaining an open source
> Foundation reimplementation for alternative operating systems like Linux.
> It seemed to me that the current release of Swift did not put such efforts
> into consideration and brutally broke compatibility between Swift and
> Objective-C on Linux. I understand the fact that Apple is unwilling to
> release source code of Foundation, and this is usually where those
> alternative implementations comes into play.
>
> Some of such projects, like GNUstep, are mature enough to allow existing
> AppKit applications written in Objective-C, like TextEdit and Chess, to be
> ported from OS X to Linux and Windows without changing too much, if any,
> code, taking all modern Objective-C features like ARC and object
> subscripting with stride, with a compatible version of LLVM compiler.
> Meanwhile, with the current version of Swift, even if the Swift code is
> written with calls to Objective-C runtime assuming the case on OS X, it is
> broken under Linux even with libobjc linked in.
>
> I am here suggesting keeping the Objective-C bridge intact at least when
> built with a compatible version of libobjc (and GNUstep project have one
> already.) This will allow users of such alternative Foundation
> reimplementations to use their favourite Foundation distribution in place
> of the version provided by the Swift project, retaining the code
> compatibility already established between OS X and Linux by those Swift
> reimplementations.
>
> In such an environment the alternative Foundation implementation will
> provide their own version of CoreFoundation and Foundation, implemented
> using C and Objective-C, as well as a libobjc that supports ARC. The Swift
> environment would be built without its own CoreFoundation and Foundation,
> but linking against the provided version instead, bridging calls just like
> OS X version of Swift does. This will also allow the new Swift platform to
> take full advantage of the AppKit came with the alternative Foundation,
> allow porting full OS X apps to Linux a lot easier. The above also applies
> for porting iOS apps, if the alternative Foundation implementation also
> comes with their own UIKit.
>
> Max_______________________________________________
> Gnustep-dev mailing list
> Gnustep-dev at gnu.org
> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/d4d00658/attachment-0001.html>

From david at hartbit.com  Thu Dec  3 14:26:50 2015
From: david at hartbit.com (David Hart)
Date: Thu, 3 Dec 2015 21:26:50 +0100
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
Message-ID: <ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>

I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:

- simplifying the language
- making code more explicit by removed by shorthand syntax
- removing redundant syntax for achieving the same behavior

You can see examples of this in the latest changes to the language:

- removal of the # symbol in the first argument name as a shorthand to defining the argument name twice
- removal of the ++ and -- prefix and postfix operators in Swift 3
- removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3

I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.

Just my 2 cents :)



Sent from my iPhone
> On 03 Dec 2015, at 20:52, Zef Houssney <zefmail at gmail.com> wrote:
>
> Hello. This is exciting!
>
> I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.
>
> The idea is to introduce a new syntax for Optional Binding:
>
> Instead of:
>
> if let foo = foo { }
>
> You could simply use:
>
> if let foo { }
>
>
> I?ve written up a draft of a proposal here with additional information and motivations:
> https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md
>
>
> What do you think?
>
> Thank you!
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From david at hartbit.com  Thu Dec  3 14:30:04 2015
From: david at hartbit.com (David Hart)
Date: Thu, 3 Dec 2015 21:30:04 +0100
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
Message-ID: <984BA2EC-2678-47F5-98C8-F001B0CD1572@hartbit.com>

I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.

Sent from my iPhone

> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com> wrote:
>
> Way ahead of you
>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:
>> Dear Swift developers:
>>
>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>
>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>
>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>
>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>
>> Max_______________________________________________
>> Gnustep-dev mailing list
>> Gnustep-dev at gnu.org
>> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/254049a5/attachment.html>

From daniel.j.stenmark at gmail.com  Thu Dec  3 14:32:03 2015
From: daniel.j.stenmark at gmail.com (Dan Stenmark)
Date: Thu, 3 Dec 2015 12:32:03 -0800
Subject: [swift-evolution] API Guidelines for Asynchronous Completion
Handlers?
Message-ID: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>

There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:

- Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
- Double Block (one for success, one for failure)
- Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ <http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/>)

Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?

Dan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/17433091/attachment.html>

From david at hartbit.com  Thu Dec  3 14:32:56 2015
From: david at hartbit.com (David Hart)
Date: Thu, 3 Dec 2015 21:32:56 +0100
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
Message-ID: <28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>

I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.

> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com> wrote:
>
> Way ahead of you
>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:
>> Dear Swift developers:
>>
>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>
>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>
>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>
>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>
>> Max_______________________________________________
>> Gnustep-dev mailing list
>> Gnustep-dev at gnu.org
>> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ff22357e/attachment-0001.html>

From greg.casamento at gmail.com  Thu Dec  3 14:37:05 2015
From: greg.casamento at gmail.com (Gregory Casamento)
Date: Thu, 3 Dec 2015 15:37:05 -0500
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
Message-ID: <CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>

David,

There wouldn't be any need to do it for every platform.   There is one
objective-C runtime GNUstep uses for every platform it runs on.   So there
is no need for it to be different.

Reimplementing everything in pure swift is silly because it would not allow
re-use of all of the objective-c that is out there which is one of the
advantages of swift in the first place.


GC

On Thu, Dec 3, 2015 at 3:32 PM, David Hart <david at hartbit.com> wrote:

> I also agree with Adrian. I would much prefer to see efforts put towards
> implementing a pure Swift foundation API than supporting a Cocoa
> implementation and bridge on every platform Swift will run on.
>
> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com>
> wrote:
>
> Way ahead of you
> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:
>
>> Dear Swift developers:
>>
>> Maybe you have never heard of it, but there have been several ongoing
>> efforts, like GNUstep and Cocotron, at maintaining an open source
>> Foundation reimplementation for alternative operating systems like Linux.
>> It seemed to me that the current release of Swift did not put such efforts
>> into consideration and brutally broke compatibility between Swift and
>> Objective-C on Linux. I understand the fact that Apple is unwilling to
>> release source code of Foundation, and this is usually where those
>> alternative implementations comes into play.
>>
>> Some of such projects, like GNUstep, are mature enough to allow existing
>> AppKit applications written in Objective-C, like TextEdit and Chess, to be
>> ported from OS X to Linux and Windows without changing too much, if any,
>> code, taking all modern Objective-C features like ARC and object
>> subscripting with stride, with a compatible version of LLVM compiler.
>> Meanwhile, with the current version of Swift, even if the Swift code is
>> written with calls to Objective-C runtime assuming the case on OS X, it is
>> broken under Linux even with libobjc linked in.
>>
>> I am here suggesting keeping the Objective-C bridge intact at least when
>> built with a compatible version of libobjc (and GNUstep project have one
>> already.) This will allow users of such alternative Foundation
>> reimplementations to use their favourite Foundation distribution in place
>> of the version provided by the Swift project, retaining the code
>> compatibility already established between OS X and Linux by those Swift
>> reimplementations.
>>
>> In such an environment the alternative Foundation implementation will
>> provide their own version of CoreFoundation and Foundation, implemented
>> using C and Objective-C, as well as a libobjc that supports ARC. The Swift
>> environment would be built without its own CoreFoundation and Foundation,
>> but linking against the provided version instead, bridging calls just like
>> OS X version of Swift does. This will also allow the new Swift platform to
>> take full advantage of the AppKit came with the alternative Foundation,
>> allow porting full OS X apps to Linux a lot easier. The above also applies
>> for porting iOS apps, if the alternative Foundation implementation also
>> comes with their own UIKit.
>>
>> Max_______________________________________________
>> Gnustep-dev mailing list
>> Gnustep-dev at gnu.org
>> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>


--
Gregory Casamento
GNUstep Lead Developer / OLC, Principal Consultant
http://www.gnustep.org - http://heronsperch.blogspot.com
http://ind.ie/phoenix/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/8c66aa9f/attachment.html>

From colin.cornaby at mac.com  Thu Dec  3 14:49:42 2015
From: colin.cornaby at mac.com (Colin Cornaby)
Date: Thu, 03 Dec 2015 20:49:42 +0000 (GMT)
Subject: [swift-evolution] KVO/KVC in Swift
Message-ID: <698345b3-3b27-476f-b830-c3708ec34071@me.com>

I looked through the Swift Foundation this morning to see if there was evidence of KVO/KVC, but I didn't find any. Apologies if I missed anything. I'm assuming KVO/KVC is still incompatible with pure Swift, but I was looking for evidence that maybe something had been added in NSObject.

We work in a lot of real time/signal-ly code so we've gotten a lot of good use out of KVO/KVC in Cocoa. I've seen a lot of value in using it when doing UI work as well, either through bindings on OS X (which seems a little unloved these days), or directly by observing key values on iOS. The willSet/didSet?functions?in Swift is a great step forward for variables in having some of this behavior, but it's still messy in situations where you are dealing with classes you don't control. For example, we're an API vendor, and KVC/KVO is?handy for providing a way for a customer to observe changes. But for a pure Swift API we'd have to provide and maintain some sort of larger callback structure, or have a workflow that encourages subclassing with customers adding their own getter/setter handlers.

Are there any plans to add anything like KVO or KVC to pure Swift, with maybe something the bridges to Obj-C KVO? Swift doesn't need to go down the road of full Obj-C style dynamism with method swizzling and all that. But some sort of key based inspection of objects, and language construct for getting callbacks on a property change would be great.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/3d5a2a23/attachment.html>

From greg.casamento at gmail.com  Thu Dec  3 14:51:29 2015
From: greg.casamento at gmail.com (Gregory Casamento)
Date: Thu, 3 Dec 2015 15:51:29 -0500
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
<CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
Message-ID: <CA+BLX-zuQXY6SRLwc8jGPuMtMuyD10GdDF5kW36a=Y2805gx8w@mail.gmail.com>

Additionally, GNUstep is a Nearly complete clone of cocoa that is well
tested and mature.   Building a Cocoa-inspired Swift implementation would,
quite honestly, miss the point entirely.

GC

On Thu, Dec 3, 2015 at 3:37 PM, Gregory Casamento <greg.casamento at gmail.com>
wrote:

> David,
>
> There wouldn't be any need to do it for every platform.   There is one
> objective-C runtime GNUstep uses for every platform it runs on.   So there
> is no need for it to be different.
>
> Reimplementing everything in pure swift is silly because it would not
> allow re-use of all of the objective-c that is out there which is one of
> the advantages of swift in the first place.
>
>
> GC
>
> On Thu, Dec 3, 2015 at 3:32 PM, David Hart <david at hartbit.com> wrote:
>
>> I also agree with Adrian. I would much prefer to see efforts put towards
>> implementing a pure Swift foundation API than supporting a Cocoa
>> implementation and bridge on every platform Swift will run on.
>>
>> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com>
>> wrote:
>>
>> Way ahead of you
>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:
>>
>>> Dear Swift developers:
>>>
>>> Maybe you have never heard of it, but there have been several ongoing
>>> efforts, like GNUstep and Cocotron, at maintaining an open source
>>> Foundation reimplementation for alternative operating systems like Linux.
>>> It seemed to me that the current release of Swift did not put such efforts
>>> into consideration and brutally broke compatibility between Swift and
>>> Objective-C on Linux. I understand the fact that Apple is unwilling to
>>> release source code of Foundation, and this is usually where those
>>> alternative implementations comes into play.
>>>
>>> Some of such projects, like GNUstep, are mature enough to allow existing
>>> AppKit applications written in Objective-C, like TextEdit and Chess, to be
>>> ported from OS X to Linux and Windows without changing too much, if any,
>>> code, taking all modern Objective-C features like ARC and object
>>> subscripting with stride, with a compatible version of LLVM compiler.
>>> Meanwhile, with the current version of Swift, even if the Swift code is
>>> written with calls to Objective-C runtime assuming the case on OS X, it is
>>> broken under Linux even with libobjc linked in.
>>>
>>> I am here suggesting keeping the Objective-C bridge intact at least when
>>> built with a compatible version of libobjc (and GNUstep project have one
>>> already.) This will allow users of such alternative Foundation
>>> reimplementations to use their favourite Foundation distribution in place
>>> of the version provided by the Swift project, retaining the code
>>> compatibility already established between OS X and Linux by those Swift
>>> reimplementations.
>>>
>>> In such an environment the alternative Foundation implementation will
>>> provide their own version of CoreFoundation and Foundation, implemented
>>> using C and Objective-C, as well as a libobjc that supports ARC. The Swift
>>> environment would be built without its own CoreFoundation and Foundation,
>>> but linking against the provided version instead, bridging calls just like
>>> OS X version of Swift does. This will also allow the new Swift platform to
>>> take full advantage of the AppKit came with the alternative Foundation,
>>> allow porting full OS X apps to Linux a lot easier. The above also applies
>>> for porting iOS apps, if the alternative Foundation implementation also
>>> comes with their own UIKit.
>>>
>>> Max_______________________________________________
>>> Gnustep-dev mailing list
>>> Gnustep-dev at gnu.org
>>> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
>
> --
> Gregory Casamento
> GNUstep Lead Developer / OLC, Principal Consultant
> http://www.gnustep.org - http://heronsperch.blogspot.com
> http://ind.ie/phoenix/
>



--
Gregory Casamento
GNUstep Lead Developer / OLC, Principal Consultant
http://www.gnustep.org - http://heronsperch.blogspot.com
http://ind.ie/phoenix/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/19c6cf4e/attachment-0001.html>

From xcvista at me.com  Thu Dec  3 14:51:44 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 04:51:44 +0800
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
<CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
Message-ID: <CD24E47A-39D1-4857-AA3F-1CBC46538ABA@me.com>

David

Given the fact that there are two active Foundation reimplementations out there means your Swift-only reimplementation of Foundation is reinventing wheels, in an incompatible way. (Cocoatron can at least take a few libraries from GNUstep if compiled correctly, but not this)

The silliest way of doing this is just ?endorse? someone* as the official Objective-C backend for Swift anywhere outside OS X and iOS and scratch this swift-corelibs-foundation entirely. Since both GNUstep and Cocotron runs under Linux, Windows and BSD instead of just Linux outside OS X and iOS, you get extra compatibility for free, from removing instead of adding code.

* preferably GNUstep in my own opinion, since they have better library coverage and they are the team that ships libobjc2 which fully supports ARC and every single modern Objective-C feature in a code-compatible way although not ABI-compatible, and the platform barrier rendered ABI compatibility pointless anyway

> On Dec 4, 2015, at 04:37, Gregory Casamento <greg.casamento at gmail.com> wrote:
>
> David,
>
> There wouldn't be any need to do it for every platform.   There is one objective-C runtime GNUstep uses for every platform it runs on.   So there is no need for it to be different.
>
> Reimplementing everything in pure swift is silly because it would not allow re-use of all of the objective-c that is out there which is one of the advantages of swift in the first place.
>
>
> GC
>
> On Thu, Dec 3, 2015 at 3:32 PM, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
> I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.
>
> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com <mailto:greg.casamento at gmail.com>> wrote:
>
>> Way ahead of you
>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com <mailto:xcvista at me.com>> wrote:
>> Dear Swift developers:
>>
>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>
>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>
>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>
>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>
>> Max_______________________________________________
>> Gnustep-dev mailing list
>> Gnustep-dev at gnu.org <mailto:Gnustep-dev at gnu.org>
>> https://lists.gnu.org/mailman/listinfo/gnustep-dev <https://lists.gnu.org/mailman/listinfo/gnustep-dev>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>
> --
> Gregory Casamento
> GNUstep Lead Developer / OLC, Principal Consultant
> http://www.gnustep.org <http://www.gnustep.org/> - http://heronsperch.blogspot.com <http://heronsperch.blogspot.com/>
> http://ind.ie/phoenix/ <http://ind.ie/phoenix/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/adc5b570/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/adc5b570/attachment.p7s>

From david at hartbit.com  Thu Dec  3 14:52:16 2015
From: david at hartbit.com (David Hart)
Date: Thu, 3 Dec 2015 21:52:16 +0100
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
<CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
Message-ID: <B2E3357F-329C-4458-B335-90480C0B318C@hartbit.com>

GC,

I just went to check the code for the corelibs and saw that the current iteration is a pretty close direct API mapping of the Objective-C Foundation framework. If this stays the case, then I think I agree with you.

I was under the impression (my bad for not investigating beforehand) was that corelibs was an original library that provided the functionality of the Foundation framework but using all the power and idioms of Swift. I would have preferred that.

David.

> On 03 Dec 2015, at 21:37, Gregory Casamento <greg.casamento at gmail.com> wrote:
>
> David,
>
> There wouldn't be any need to do it for every platform.   There is one objective-C runtime GNUstep uses for every platform it runs on.   So there is no need for it to be different.
>
> Reimplementing everything in pure swift is silly because it would not allow re-use of all of the objective-c that is out there which is one of the advantages of swift in the first place.
>
>
> GC
>
> On Thu, Dec 3, 2015 at 3:32 PM, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
> I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.
>
> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com <mailto:greg.casamento at gmail.com>> wrote:
>
>> Way ahead of you
>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com <mailto:xcvista at me.com>> wrote:
>> Dear Swift developers:
>>
>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>
>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>
>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>
>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>
>> Max_______________________________________________
>> Gnustep-dev mailing list
>> Gnustep-dev at gnu.org <mailto:Gnustep-dev at gnu.org>
>> https://lists.gnu.org/mailman/listinfo/gnustep-dev <https://lists.gnu.org/mailman/listinfo/gnustep-dev>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>
> --
> Gregory Casamento
> GNUstep Lead Developer / OLC, Principal Consultant
> http://www.gnustep.org <http://www.gnustep.org/> - http://heronsperch.blogspot.com <http://heronsperch.blogspot.com/>
> http://ind.ie/phoenix/ <http://ind.ie/phoenix/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/d64c447a/attachment-0001.html>

From xcvista at me.com  Thu Dec  3 14:58:38 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 04:58:38 +0800
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <B2E3357F-329C-4458-B335-90480C0B318C@hartbit.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
<CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
<B2E3357F-329C-4458-B335-90480C0B318C@hartbit.com>
Message-ID: <1732A59B-F7BA-4850-8CAE-4257BB0EAA59@me.com>

If it don?t, just notify GNUstep team and they will add it.

> On Dec 4, 2015, at 04:52, David Hart <david at hartbit.com> wrote:
>
> GC,
>
> I just went to check the code for the corelibs and saw that the current iteration is a pretty close direct API mapping of the Objective-C Foundation framework. If this stays the case, then I think I agree with you.
>
> I was under the impression (my bad for not investigating beforehand) was that corelibs was an original library that provided the functionality of the Foundation framework but using all the power and idioms of Swift. I would have preferred that.
>
> David.
>
>> On 03 Dec 2015, at 21:37, Gregory Casamento <greg.casamento at gmail.com <mailto:greg.casamento at gmail.com>> wrote:
>>
>> David,
>>
>> There wouldn't be any need to do it for every platform.   There is one objective-C runtime GNUstep uses for every platform it runs on.   So there is no need for it to be different.
>>
>> Reimplementing everything in pure swift is silly because it would not allow re-use of all of the objective-c that is out there which is one of the advantages of swift in the first place.
>>
>>
>> GC
>>
>> On Thu, Dec 3, 2015 at 3:32 PM, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
>> I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.
>>
>> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com <mailto:greg.casamento at gmail.com>> wrote:
>>
>>> Way ahead of you
>>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com <mailto:xcvista at me.com>> wrote:
>>> Dear Swift developers:
>>>
>>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>>
>>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>>
>>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>>
>>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>>
>>> Max_______________________________________________
>>> Gnustep-dev mailing list
>>> Gnustep-dev at gnu.org <mailto:Gnustep-dev at gnu.org>
>>> https://lists.gnu.org/mailman/listinfo/gnustep-dev <https://lists.gnu.org/mailman/listinfo/gnustep-dev>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>>
>> --
>> Gregory Casamento
>> GNUstep Lead Developer / OLC, Principal Consultant
>> http://www.gnustep.org <http://www.gnustep.org/> - http://heronsperch.blogspot.com <http://heronsperch.blogspot.com/>
>> http://ind.ie/phoenix/ <http://ind.ie/phoenix/>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/66f225f9/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/66f225f9/attachment.p7s>

From clattner at apple.com  Thu Dec  3 15:00:38 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 13:00:38 -0800
Subject: [swift-evolution] KVO/KVC in Swift
In-Reply-To: <698345b3-3b27-476f-b830-c3708ec34071@me.com>
References: <698345b3-3b27-476f-b830-c3708ec34071@me.com>
Message-ID: <0CF4FFB3-14FB-48AA-8F2D-7CDC7A0BCA1C@apple.com>

On Dec 3, 2015, at 12:49 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
> I looked through the Swift Foundation this morning to see if there was evidence of KVO/KVC, but I didn't find any. Apologies if I missed anything. I'm assuming KVO/KVC is still incompatible with pure Swift, but I was looking for evidence that maybe something had been added in NSObject.
> ..
>
> Are there any plans to add anything like KVO or KVC to pure Swift, with maybe something the bridges to Obj-C KVO?

Hi Colin,

This is one of *many* things that we are interested in working on some day, but we need to stay focused on shorter term goals (like getting to ABI stability) to make sure we are successful with those.  If you?re working on Apple platforms, Swift does interoperate with the Objective-C KVO implementation, using the ?dynamic" keyword.

-Chris


From xcvista at me.com  Thu Dec  3 15:13:52 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 05:13:52 +0800
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
Message-ID: <8FB054A7-39D0-4DA5-9B75-342C0B8D8D81@me.com>

I am talking scaling projects back here. If you allow this bridging from the get-go you don't need anything other than the compiler, the standard libraries and half a runtime. Not even libdispatch or CoreFoundation is needed in this project since the Objective-C backend's authors are already maintaining it for you.

As a bonus point, if you can make the build system take Swift and Objective-C equally and not depend on Swift or Objective-C, the authors of the backend may even migrate their build system to the one here (since Cocotron does not have its own build system, and GNUstep's one is badly documented, clunky and hard to use)

Sent from my iPad

> On Dec 4, 2015, at 04:32, David Hart <david at hartbit.com> wrote:
>
> I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.
>
>> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com> wrote:
>>
>> Way ahead of you
>>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:
>>> Dear Swift developers:
>>>
>>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>>
>>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>>
>>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>>
>>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>>
>>> Max_______________________________________________
>>> Gnustep-dev mailing list
>>> Gnustep-dev at gnu.org
>>> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/9eaa7dca/attachment-0001.html>

From austinzheng at gmail.com  Thu Dec  3 15:14:33 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Thu, 3 Dec 2015 13:14:33 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
Message-ID: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>

Hi all,

There are quite a few programming languages that provide support for
numeric types apart from the customary floating-point and fixed-width
integer types. Prominent examples of additional numeric types include
rational numbers, arbitrary-width integer types, and fixed-point numbers.
Many of these numeric types are applicable to a wide variety of problem
domains.

Swift seems like it would be a good fit for stdlib implementation of some
of these numeric types. Structs and value semantics, literal
initialization, and operator overloading would allow such types to be
treated as first-class citizens. Is the community amenable to such a
proposal, which would entail the data structures themselves, arithmetic
operations, and interoperation between different numeric types to form a
numerical tower of sorts?

Best regards,
Austin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/c2861e33/attachment.html>

From zefmail at gmail.com  Thu Dec  3 15:17:34 2015
From: zefmail at gmail.com (Zef Houssney)
Date: Thu, 3 Dec 2015 14:17:34 -0700
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
Message-ID: <6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>

Thanks for your thoughts David!

I would argue that it does support stated objectives of Swift, like "the syntax is concise yet expressive.?

In the majority of cases having a lot of esoteric syntax is a problem. However, with this being such a fundamental part of every day programming in Swift, I find it to be a perfect place to reduce friction. I also find it to be quite understandable and intuitive, unlike the three examples of Swift 3 changes that you gave, which are more specialized and less frequently encountered.

Also, I just noticed that this isn?t unprecedented and that a similar idiom actually currently used in Swift to assign constants when pattern matching inside a Switch:

case let (x, y):

That is doing fundamentally the same thing that I?m suggesting. It assigns a constant without using `=`, because the value is already known.

Zef



> On Dec 3, 2015, at 1:26 PM, David Hart <david at hartbit.com> wrote:
>
> I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:
>
> - simplifying the language
> - making code more explicit by removed by shorthand syntax
> - removing redundant syntax for achieving the same behavior
>
> You can see examples of this in the latest changes to the language:
>
> - removal of the # symbol in the first argument name as a shorthand to defining the argument name twice
> - removal of the ++ and -- prefix and postfix operators in Swift 3
> - removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3
>
> I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.
>
> Just my 2 cents :)
>
>
>
> Sent from my iPhone
>> On 03 Dec 2015, at 20:52, Zef Houssney <zefmail at gmail.com> wrote:
>>
>> Hello. This is exciting!
>>
>> I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.
>>
>> The idea is to introduce a new syntax for Optional Binding:
>>
>> Instead of:
>>
>> if let foo = foo { }
>>
>> You could simply use:
>>
>> if let foo { }
>>
>>
>> I?ve written up a draft of a proposal here with additional information and motivations:
>> https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md
>>
>>
>> What do you think?
>>
>> Thank you!
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution


From adrian.kashivskyy at me.com  Thu Dec  3 15:19:55 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Thu, 03 Dec 2015 22:19:55 +0100
Subject: [swift-evolution] KVO/KVC in Swift
In-Reply-To: <0CF4FFB3-14FB-48AA-8F2D-7CDC7A0BCA1C@apple.com>
References: <698345b3-3b27-476f-b830-c3708ec34071@me.com>
<0CF4FFB3-14FB-48AA-8F2D-7CDC7A0BCA1C@apple.com>
Message-ID: <EBE5DA21-BE57-40FC-BC09-455CFE83D56A@me.com>

Colin,

Until KVC/KVO is supported, you may be interested in using constructs like Observable<T>. Here are some illustrative libraries that make use of it: SwiftBond/Bond <https://github.com/SwiftBond/Bond>, slazyk/Observable-Swift <https://github.com/slazyk/Observable-Swift>.


Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Chris Lattner <clattner at apple.com> w dniu 03.12.2015, o godz. 22:00:
>
> On Dec 3, 2015, at 12:49 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>> I looked through the Swift Foundation this morning to see if there was evidence of KVO/KVC, but I didn't find any. Apologies if I missed anything. I'm assuming KVO/KVC is still incompatible with pure Swift, but I was looking for evidence that maybe something had been added in NSObject.
>> ..
>>
>> Are there any plans to add anything like KVO or KVC to pure Swift, with maybe something the bridges to Obj-C KVO?
>
> Hi Colin,
>
> This is one of *many* things that we are interested in working on some day, but we need to stay focused on shorter term goals (like getting to ABI stability) to make sure we are successful with those.  If you?re working on Apple platforms, Swift does interoperate with the Objective-C KVO implementation, using the ?dynamic" keyword.
>
> -Chris
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ddb2054b/attachment.html>

From xcvista at me.com  Thu Dec  3 15:27:43 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 05:27:43 +0800
Subject: [swift-evolution] Proposal: Swift Open Source Project and
Foundation replacements
In-Reply-To: <B2E3357F-329C-4458-B335-90480C0B318C@hartbit.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<CA+BLX-woXwLfbaxy=xHTF-=O=HTEHhzwkhA+5ShDY0fCbAteZw@mail.gmail.com>
<28C4FA3A-8650-40A4-AE99-8E27A21F3323@hartbit.com>
<CA+BLX-wpiDS+65Z6vTBJjbMcKHC14=6+QgT+X23hR5nsf5xoTA@mail.gmail.com>
<B2E3357F-329C-4458-B335-90480C0B318C@hartbit.com>
Message-ID: <92B2DB22-844F-4E79-BF0E-01BF03B78363@me.com>

I am already seeing incompatibilities showing up on this list between this OC-less Swift and the OC-backed Swift that could have been avoided if this project supports OC bridging and some OC backend is provided.

Sent from my iPad

> On Dec 4, 2015, at 04:52, David Hart <david at hartbit.com> wrote:
>
> GC,
>
> I just went to check the code for the corelibs and saw that the current iteration is a pretty close direct API mapping of the Objective-C Foundation framework. If this stays the case, then I think I agree with you.
>
> I was under the impression (my bad for not investigating beforehand) was that corelibs was an original library that provided the functionality of the Foundation framework but using all the power and idioms of Swift. I would have preferred that.
>
> David.
>
>> On 03 Dec 2015, at 21:37, Gregory Casamento <greg.casamento at gmail.com> wrote:
>>
>> David,
>>
>> There wouldn't be any need to do it for every platform.   There is one objective-C runtime GNUstep uses for every platform it runs on.   So there is no need for it to be different.
>>
>> Reimplementing everything in pure swift is silly because it would not allow re-use of all of the objective-c that is out there which is one of the advantages of swift in the first place.
>>
>>
>> GC
>>
>>> On Thu, Dec 3, 2015 at 3:32 PM, David Hart <david at hartbit.com> wrote:
>>> I also agree with Adrian. I would much prefer to see efforts put towards implementing a pure Swift foundation API than supporting a Cocoa implementation and bridge on every platform Swift will run on.
>>>
>>>> On 03 Dec 2015, at 21:01, Gregory Casamento <greg.casamento at gmail.com> wrote:
>>>>
>>>> Way ahead of you
>>>>> On Thu, Dec 3, 2015 at 15:01 Maxthon Chan <xcvista at me.com> wrote:
>>>>> Dear Swift developers:
>>>>>
>>>>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>>>>>
>>>>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>>>>
>>>>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>>>>
>>>>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>>>>
>>>>> Max_______________________________________________
>>>>> Gnustep-dev mailing list
>>>>> Gnustep-dev at gnu.org
>>>>> https://lists.gnu.org/mailman/listinfo/gnustep-dev
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> --
>> Gregory Casamento
>> GNUstep Lead Developer / OLC, Principal Consultant
>> http://www.gnustep.org - http://heronsperch.blogspot.com
>> http://ind.ie/phoenix/
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/512e695e/attachment-0001.html>

From clattner at apple.com  Thu Dec  3 16:05:55 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 14:05:55 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
Message-ID: <DD59217A-15EF-456E-B593-A0E2FBEC4B9E@apple.com>

On Dec 3, 2015, at 1:14 PM, Austin Zheng <austinzheng at gmail.com> wrote:
> Hi all,
>
> There are quite a few programming languages that provide support for numeric types apart from the customary floating-point and fixed-width integer types. Prominent examples of additional numeric types include rational numbers, arbitrary-width integer types, and fixed-point numbers. Many of these numeric types are applicable to a wide variety of problem domains.

Hi Austin, great to hear from you:

It would be great to consider this.  We?ve specifically recently discussed BigInt support, for example.

One of the things that we?d like to see for Swift 3 is a revised set of numerics protocols, to make it possible to write generic numeric algorithms.  One concern I have with this is that abstracting over (e.g.) IEEE and rational numbers may overly complicate the protocols necessary to get simple things done.

That said, I?m not an expert on this area, so I?m cc?ing some people who are :-)

-Chris

>
> Swift seems like it would be a good fit for stdlib implementation of some of these numeric types. Structs and value semantics, literal initialization, and operator overloading would allow such types to be treated as first-class citizens. Is the community amenable to such a proposal, which would entail the data structures themselves, arithmetic operations, and interoperation between different numeric types to form a numerical tower of sorts?
>
> Best regards,
> Austin
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/1bc97b56/attachment.html>

From me at tal.by  Thu Dec  3 16:12:06 2015
From: me at tal.by (Tal Atlas)
Date: Thu, 03 Dec 2015 22:12:06 +0000
Subject: [swift-evolution] Proposal for generic protocols
Message-ID: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>

With the awesome expansion of protocol oriented programming that swift has
allowed, the lack of generic protocols has felt noticeably lacking and
painful in some cases. I made an in depth proposal here:
https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md

But the tl;dr is this:

protocol Validator<TypeToValidate> {
var value: TypeToValidate { get set }
var valueIfValid: TypeToValidate? { get }
}

struct FooStringValidator: Validator<String> {
//... implementation
}

let stringValidator: Validator<String>

Look forward to hearing some feedback.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/5a83e7f3/attachment.html>

From sean at fifthace.com  Thu Dec  3 16:12:10 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 16:12:10 -0600
Subject: [swift-evolution] Idea for declaring expected types and value ranges
Message-ID: <7947780C-63D3-403E-99F5-43034F990F20@fifthace.com>

It may be nice to have a keyword that tells the compiler to try to statically prove certain conditions are true after some point without needing to leave the scope or wrap it in an if-let or something else that happens at runtime. This way the compiler could check the validity of the assertion and it would do so at compile time.

For example, imagine using something like this to unwrap an optional beyond a certain point in the function body:

func doSomething() -> Int {
var something: Int? = nil

if something == nil {
something = 42
}

require something: Int

return something * 2
}

The compiler would be expected to prove that at the ?require? line, ?something? could be an ?Int? (non-optional). If the compiler cannot prove that, it is an error. If it can prove it, the type of the variable is effectively changed from that point on (the compiler effectively changes all instances of ?something? to ?something!? - but it knows it should never fail which might mean it could avoid doing certain checks and it eliminates a piece of state from the mind of the programmer).

This idea could be extended in other ways, potentially, if you could specify rules in a flexible enough way. For example, imagine being able to declare a constraint on the ranges of basic value types:

require x in 0?1
let result = someValue * x

Ideally, the compiler would then attempt to prove that x must always be in the range of 0?1 at this point. If it cannot prove this to be true, then it would be a compiler error.

Going farther, you could use the same thing on type declarations themselves so you could have a Float that could only contain 0?1:

var scaler: Float in 0?1

Or build a function that has constrained input ranges:

func scale(x: Float in 0?1) -> Float {
return someValue * x
}

I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:

func scale(x: Float in! 0?1) -> Float {
return someValue * x
}

In this scenario the compiler would probably still try to prove it statically - and if it could, it?d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.

l8r
Sean


From clattner at apple.com  Thu Dec  3 16:13:59 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 14:13:59 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
Message-ID: <F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>


> On Dec 3, 2015, at 12:01 PM, Maxthon Chan <xcvista at me.com> wrote:
>
> Dear Swift developers:
>
> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.

Hi Maxthon,

Thanks for your interest, we?re definitely aware of GNUstep and Cocotron.

As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.

We?re aware that this means that it will take longer for the Swift Foundation to be fully operational and useful, but that is a tradeoff we?re willing to make.  You are of course welcome to make Swift work with GNUstep or Cocotron if you?re interested in doing that, but that seems outside the charter of the work on Swift Foundation.

-Chris


>
> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>
> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>
> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>
> Max_______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev


From dgregor at apple.com  Thu Dec  3 16:15:07 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Thu, 3 Dec 2015 14:15:07 -0800
Subject: [swift-evolution] API Guidelines for Asynchronous
Completion	Handlers?
In-Reply-To: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
Message-ID: <9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>


> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>
> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>
> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
> - Double Block (one for success, one for failure)
> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ <http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/>)
>
> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?

This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.

- Doug


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/bcce16d6/attachment-0001.html>

From kevin at sb.org  Thu Dec  3 16:18:25 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 14:18:25 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
Message-ID: <1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>

It's actually not doing the same thing, and what you're suggesting has
no precedent. `case let (x, y)` is completely unrelated; it does not
look up existing bindings for the identifiers `x` and `y`, but instead
is matching against a previously-specified value. But in your proposed
`if let foo {`, you do not specify the value anywhere, and instead rely
on the assumption that you're trying to match against an existing value
with the same identifier. But nowhere else in the language does it ever
assume that any identifier has any relation to another identifier that
it shadows. And nowhere else in the language does it make an assumption
about what data you want to operate over. Furthermore, to anyone not
already familiar with the proposed rule, `if let foo {` is meaningless;
it does not tell the reader what it's actually doing, and its behavior
cannot be inferred from any other language rule.

-Kevin Ballard

On Thu, Dec 3, 2015, at 01:17 PM, Zef Houssney wrote:
> Thanks for your thoughts David!
>
> I would argue that it does support stated objectives of Swift, like "the
> syntax is concise yet expressive.?
>
> In the majority of cases having a lot of esoteric syntax is a problem.
> However, with this being such a fundamental part of every day programming
> in Swift, I find it to be a perfect place to reduce friction. I also find
> it to be quite understandable and intuitive, unlike the three examples of
> Swift 3 changes that you gave, which are more specialized and less
> frequently encountered.
>
> Also, I just noticed that this isn?t unprecedented and that a similar
> idiom actually currently used in Swift to assign constants when pattern
> matching inside a Switch:
>
> case let (x, y):
>
> That is doing fundamentally the same thing that I?m suggesting. It
> assigns a constant without using `=`, because the value is already known.
>
> Zef
>
>
>
> > On Dec 3, 2015, at 1:26 PM, David Hart <david at hartbit.com> wrote:
> >
> > I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:
> >
> > - simplifying the language
> > - making code more explicit by removed by shorthand syntax
> > - removing redundant syntax for achieving the same behavior
> >
> > You can see examples of this in the latest changes to the language:
> >
> > - removal of the # symbol in the first argument name as a shorthand to defining the argument name twice
> > - removal of the ++ and -- prefix and postfix operators in Swift 3
> > - removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3
> >
> > I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.
> >
> > Just my 2 cents :)
> >
> >
> >
> > Sent from my iPhone
> >> On 03 Dec 2015, at 20:52, Zef Houssney <zefmail at gmail.com> wrote:
> >>
> >> Hello. This is exciting!
> >>
> >> I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.
> >>
> >> The idea is to introduce a new syntax for Optional Binding:
> >>
> >> Instead of:
> >>
> >> if let foo = foo { }
> >>
> >> You could simply use:
> >>
> >> if let foo { }
> >>
> >>
> >> I?ve written up a draft of a proposal here with additional information and motivations:
> >> https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md
> >>
> >>
> >> What do you think?
> >>
> >> Thank you!
> >> _______________________________________________
> >> swift-evolution mailing list
> >> swift-evolution at swift.org
> >> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From sean at fifthace.com  Thu Dec  3 16:19:07 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 16:19:07 -0600
Subject: [swift-evolution] Change the name of the boolean operators?
Message-ID: <98BDCA96-8C8A-4433-A09C-27F1E4BDE1C1@fifthace.com>

I would like to propose that &&, ||, !, etc are replaced with keywords such as ?and?, ?or?, ?not?, etc. As small as this may seem, it is one of my favorite things about Python that, IMO, can dramatically improve readability.

l8r
Sean


From jtbandes at gmail.com  Thu Dec  3 16:23:21 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Thu, 3 Dec 2015 14:23:21 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
Message-ID: <CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>

On Thu, Dec 3, 2015 at 2:13 PM, Chris Lattner <clattner at apple.com> wrote:

>
> As others have surmised, the goal for the Swift Foundation project is to
> provide a pure-swift implementation (which reuses widely-available C
> libraries) of important Foundation APIs that do *not* depend on the
> Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing
> Foundation implementation didn?t allow us to achieve those goals, so we
> didn?t go with those approaches.
>

This is great, but is the goal also to exactly duplicate all the
idiosyncrasies of the Obj-C Foundation?

Quiz: what's the result of NSURL(string: "http://one/two;three/four")?.
URLByAppendingPathComponent("five") ?

If, as I would hope, corelibs-foundation is an opportunity to make simpler
APIs that resolve some of these weirdnesses, then should the class names
(NSURL, NSFileHandle, etc.) really be the same?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/07a05285/attachment.html>

From gribozavr at gmail.com  Thu Dec  3 16:24:08 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Thu, 3 Dec 2015 14:24:08 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
Message-ID: <CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>

On Thu, Dec 3, 2015 at 1:14 PM, Austin Zheng <austinzheng at gmail.com> wrote:
>
> Hi all,
>
> There are quite a few programming languages that provide support for numeric types apart from the customary floating-point and fixed-width integer types. Prominent examples of additional numeric types include rational numbers, arbitrary-width integer types, and fixed-point numbers. Many of these numeric types are applicable to a wide variety of problem domains.

>
> Swift seems like it would be a good fit for stdlib implementation of some of these numeric types. Structs and value semantics, literal initialization, and operator overloading would allow such types to be treated as first-class citizens. Is the community amenable to such a proposal, which would entail the data structures themselves, arithmetic operations, and interoperation between different numeric types to form a numerical tower of sorts?

Hi Austin,

We are interested in improving our numerics support, and we are
definitely interested in hearing your ideas in this space.  You don't
have to write a full proposal though.  Just an extended email to
swift-evolution would be a good start.

You can find the current prototype for library support for integers
here: https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From adrian.kashivskyy at me.com  Thu Dec  3 16:29:17 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Thu, 03 Dec 2015 23:29:17 +0100
Subject: [swift-evolution] Idea for declaring expected types and value
ranges
In-Reply-To: <7947780C-63D3-403E-99F5-43034F990F20@fifthace.com>
References: <7947780C-63D3-403E-99F5-43034F990F20@fifthace.com>
Message-ID: <85C58C19-968A-41B4-B924-923A1B7E038D@me.com>

How is this different from guard or precondition()?

func f(x: Int) {
guard (0...1).contains(x) else {
return
}
// use x
}

func f(x: Int) {
precondition((0...1).contains(x))
// use x
}

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Sean Heber <sean at fifthace.com> w dniu 03.12.2015, o godz. 23:12:
>
> It may be nice to have a keyword that tells the compiler to try to statically prove certain conditions are true after some point without needing to leave the scope or wrap it in an if-let or something else that happens at runtime. This way the compiler could check the validity of the assertion and it would do so at compile time.
>
> For example, imagine using something like this to unwrap an optional beyond a certain point in the function body:
>
> func doSomething() -> Int {
>  var something: Int? = nil
>
>  if something == nil {
>     something = 42
>  }
>
>  require something: Int
>
>  return something * 2
> }
>
> The compiler would be expected to prove that at the ?require? line, ?something? could be an ?Int? (non-optional). If the compiler cannot prove that, it is an error. If it can prove it, the type of the variable is effectively changed from that point on (the compiler effectively changes all instances of ?something? to ?something!? - but it knows it should never fail which might mean it could avoid doing certain checks and it eliminates a piece of state from the mind of the programmer).
>
> This idea could be extended in other ways, potentially, if you could specify rules in a flexible enough way. For example, imagine being able to declare a constraint on the ranges of basic value types:
>
> require x in 0?1
> let result = someValue * x
>
> Ideally, the compiler would then attempt to prove that x must always be in the range of 0?1 at this point. If it cannot prove this to be true, then it would be a compiler error.
>
> Going farther, you could use the same thing on type declarations themselves so you could have a Float that could only contain 0?1:
>
> var scaler: Float in 0?1
>
> Or build a function that has constrained input ranges:
>
> func scale(x: Float in 0?1) -> Float {
>  return someValue * x
> }
>
> I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:
>
> func scale(x: Float in! 0?1) -> Float {
>  return someValue * x
> }
>
> In this scenario the compiler would probably still try to prove it statically - and if it could, it?d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.
>
> l8r
> Sean
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/1c84a551/attachment-0001.html>

From colin.cornaby at mac.com  Thu Dec  3 16:31:51 2015
From: colin.cornaby at mac.com (Colin Cornaby)
Date: Thu, 03 Dec 2015 22:31:51 +0000 (GMT)
Subject: [swift-evolution] KVO/KVC in Swift
Message-ID: <dcee3113-8b65-4d80-b3fc-f17b659c2923@me.com>

For our application projects, I've certainly been keeping an eye on alternatives (we're still very early in our Swift transition.) But for applications we're only working on Cocoa platforms, so the need for an alternative hasn't been as pressing (we're just continuing to use KVC/KVO using NSObject subclasses.)

As an API developer as well, I'm a little hesitant to commit to any of the alternatives. There is a lot of advantages in assuming a developer using your API on an Apple platform is familiar with Cocoa (and going forward, that a Swift developer is familiar with Foundation), and any new construct?you add outside of that simply adds more learning overhead. There's also the possibility that the dependency we use is incompatible with a version inside the user's application (which can be dealt with, just a little messy.) This also isn't an issue for us at this point (without ABI stability we can't ship a closed source library without a lot of pain, and we're still only supporting Cocoa platforms.)

One of the reasons I'd love to see Apple lead on this is that I'd like to see it as a language paradigm all of our developers will be familiar with. Open source Swift means that we could dramatically expand our developer base of our API to other platforms, but it also means we need to be able to get away from Cocoa functionality.

Glad to see it's on the list of things to do, but also glad to see ABI stability being discussed so much. ABI stability is the biggest stop-ship for us for porting our SDKs to Swift. :)

On Dec 03, 2015, at 01:19 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:

Colin,

Until KVC/KVO is supported, you may be interested in using constructs like Observable<T>. Here are some illustrative libraries that make use of it: SwiftBond/Bond,?slazyk/Observable-Swift.

Pozdrawiam ? Regards,
Adrian Kashivskyy

Wiadomo?? napisana przez Chris Lattner <clattner at apple.com> w dniu 03.12.2015, o godz. 22:00:
On Dec 3, 2015, at 12:49 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
I looked through the Swift Foundation this morning to see if there was evidence of KVO/KVC, but I didn't find any. Apologies if I missed anything. I'm assuming KVO/KVC is still incompatible with pure Swift, but I was looking for evidence that maybe something had been added in NSObject.
..

Are there any plans to add anything like KVO or KVC to pure Swift, with maybe something the bridges to Obj-C KVO?

Hi Colin,

This is one of *many* things that we are interested in working on some day, but we need to stay focused on shorter term goals (like getting to ABI stability) to make sure we are successful with those. ?If you?re working on Apple platforms, Swift does interoperate with the Objective-C KVO implementation, using the ?dynamic" keyword.

-Chris

_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/58242fb8/attachment.html>

From jtbandes at gmail.com  Thu Dec  3 16:31:24 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Thu, 3 Dec 2015 14:31:24 -0800
Subject: [swift-evolution] Idea for declaring expected types and value
ranges
In-Reply-To: <85C58C19-968A-41B4-B924-923A1B7E038D@me.com>
References: <7947780C-63D3-403E-99F5-43034F990F20@fifthace.com>
<85C58C19-968A-41B4-B924-923A1B7E038D@me.com>
Message-ID: <CADcs6kPSnKyq+0Hs+c4SG7Qhc8L4q41qdrd3_xsR06YDY7sbtQ@mail.gmail.com>

Part of this suggestion seems to be achievable using `guard`. Some,
however, isn't.

Folks may be interested in reading about Refinement Types:
https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types

On Thu, Dec 3, 2015 at 2:29 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com>
wrote:

> How is this different from guard or precondition()?
>
> func f(x: Int) {
>     guard (0...1).contains(x) else {
>         return
>     }
>     // use x
> }
>
> func f(x: Int) {
>     precondition((0...1).contains(x))
>     // use x
> }
>
> Pozdrawiam ? Regards,
> Adrian Kashivskyy
>
> Wiadomo?? napisana przez Sean Heber <sean at fifthace.com> w dniu
> 03.12.2015, o godz. 23:12:
>
> It may be nice to have a keyword that tells the compiler to try to
> statically prove certain conditions are true after some point without
> needing to leave the scope or wrap it in an if-let or something else that
> happens at runtime. This way the compiler could check the validity of the
> assertion and it would do so at compile time.
>
> For example, imagine using something like this to unwrap an optional
> beyond a certain point in the function body:
>
> func doSomething() -> Int {
>  var something: Int? = nil
>
>  if something == nil {
>     something = 42
>  }
>
>  require something: Int
>
>  return something * 2
> }
>
> The compiler would be expected to prove that at the ?require? line,
> ?something? could be an ?Int? (non-optional). If the compiler cannot prove
> that, it is an error. If it can prove it, the type of the variable is
> effectively changed from that point on (the compiler effectively changes
> all instances of ?something? to ?something!? - but it knows it should never
> fail which might mean it could avoid doing certain checks and it eliminates
> a piece of state from the mind of the programmer).
>
> This idea could be extended in other ways, potentially, if you could
> specify rules in a flexible enough way. For example, imagine being able to
> declare a constraint on the ranges of basic value types:
>
> require x in 0?1
> let result = someValue * x
>
> Ideally, the compiler would then attempt to prove that x must always be in
> the range of 0?1 at this point. If it cannot prove this to be true, then it
> would be a compiler error.
>
> Going farther, you could use the same thing on type declarations
> themselves so you could have a Float that could only contain 0?1:
>
> var scaler: Float in 0?1
>
> Or build a function that has constrained input ranges:
>
> func scale(x: Float in 0?1) -> Float {
>  return someValue * x
> }
>
> I like the idea of this always being a compile-time check when possible,
> but it could also be useful to force the requirement to be evaluated at
> runtime by adding a force operator to it:
>
> func scale(x: Float in! 0?1) -> Float {
>  return someValue * x
> }
>
> In this scenario the compiler would probably still try to prove it
> statically - and if it could, it?d skip runtime checks - but if it cannot,
> it would then insert runtime guards that catch requirement failures and
> crash as necessary - similar to a forced unwrap - instead of being a
> compile time error.
>
> l8r
> Sean
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/23d6d33c/attachment.html>

From clattner at apple.com  Thu Dec  3 16:34:37 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 14:34:37 -0800
Subject: [swift-evolution] Change the name of the boolean operators?
In-Reply-To: <98BDCA96-8C8A-4433-A09C-27F1E4BDE1C1@fifthace.com>
References: <98BDCA96-8C8A-4433-A09C-27F1E4BDE1C1@fifthace.com>
Message-ID: <DE022393-DFC9-4171-94A1-8D24502829C8@apple.com>


> On Dec 3, 2015, at 2:19 PM, Sean Heber <sean at fifthace.com> wrote:
>
> I would like to propose that &&, ||, !, etc are replaced with keywords such as ?and?, ?or?, ?not?, etc. As small as this may seem, it is one of my favorite things about Python that, IMO, can dramatically improve readability.

Hi Sean,

We?ve briefly considered this in the past.  However, this doesn?t align well with the design of swift, which partitions infix and prefix operators into their own namespace (composed of operator characters) and normal identifiers (composed of ?identifier characters?).  You can see the grammar for this in the Swift Programming Language Reference.

-Chris

From sean at fifthace.com  Thu Dec  3 16:36:16 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 16:36:16 -0600
Subject: [swift-evolution] Idea for declaring expected types and value
ranges
In-Reply-To: <85C58C19-968A-41B4-B924-923A1B7E038D@me.com>
References: <7947780C-63D3-403E-99F5-43034F990F20@fifthace.com>
<85C58C19-968A-41B4-B924-923A1B7E038D@me.com>
Message-ID: <F948D517-1E69-48DF-9C2F-3DA017A73B75@fifthace.com>

The primary difference would be that I?m suggesting the checks would be occurring at compile-time rather than run-time (unless it was forced to be runtime with !). The idea of applying range (or perhaps other kinds of rules) on values is something that, I think, would be quite useful in many applications and is, perhaps, a different concept.

l8r
Sean


> On Dec 3, 2015, at 4:29 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
> How is this different from guard or precondition()?
>
> func f(x: Int) {
>     guard (0...1).contains(x) else {
>         return
>     }
>     // use x
> }
>
> func f(x: Int) {
>     precondition((0...1).contains(x))
>     // use x
> }
>
> Pozdrawiam ? Regards,
> Adrian Kashivskyy
>
>> Wiadomo?? napisana przez Sean Heber <sean at fifthace.com> w dniu 03.12.2015, o godz. 23:12:
>>
>> It may be nice to have a keyword that tells the compiler to try to statically prove certain conditions are true after some point without needing to leave the scope or wrap it in an if-let or something else that happens at runtime. This way the compiler could check the validity of the assertion and it would do so at compile time.
>>
>> For example, imagine using something like this to unwrap an optional beyond a certain point in the function body:
>>
>> func doSomething() -> Int {
>>  var something: Int? = nil
>>
>>  if something == nil {
>>     something = 42
>>  }
>>
>>  require something: Int
>>
>>  return something * 2
>> }
>>
>> The compiler would be expected to prove that at the ?require? line, ?something? could be an ?Int? (non-optional). If the compiler cannot prove that, it is an error. If it can prove it, the type of the variable is effectively changed from that point on (the compiler effectively changes all instances of ?something? to ?something!? - but it knows it should never fail which might mean it could avoid doing certain checks and it eliminates a piece of state from the mind of the programmer).
>>
>> This idea could be extended in other ways, potentially, if you could specify rules in a flexible enough way. For example, imagine being able to declare a constraint on the ranges of basic value types:
>>
>> require x in 0?1
>> let result = someValue * x
>>
>> Ideally, the compiler would then attempt to prove that x must always be in the range of 0?1 at this point. If it cannot prove this to be true, then it would be a compiler error.
>>
>> Going farther, you could use the same thing on type declarations themselves so you could have a Float that could only contain 0?1:
>>
>> var scaler: Float in 0?1
>>
>> Or build a function that has constrained input ranges:
>>
>> func scale(x: Float in 0?1) -> Float {
>>  return someValue * x
>> }
>>
>> I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:
>>
>> func scale(x: Float in! 0?1) -> Float {
>>  return someValue * x
>> }
>>
>> In this scenario the compiler would probably still try to prove it statically - and if it could, it?d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.
>>
>> l8r
>> Sean
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From jtbandes at gmail.com  Thu Dec  3 16:37:08 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Thu, 3 Dec 2015 14:37:08 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
Message-ID: <CADcs6kPg9oQEsUSz0T-ThtY2VCtKnQSwAPY1nrDyi8r6RiNR8A@mail.gmail.com>

Thanks, Tony.

On Thu, Dec 3, 2015 at 2:33 PM, Tony Parker <anthony.parker at apple.com>
wrote:

> It?s tricky stuff, and the goal is to get it as standards compliant as
> possible. If we use this implementation for all Swift clients then we can
> get a consistent answer everywhere - and even better, fix bugs everywhere
> at the same time.
>

Agreed. I look forward to it :)  I'm just concerned that users will expect
behavior to exactly match their equivalent Obj-C code. If these bugs are
fixed / APIs are refined in corelibs-foundation, that expectation might be
broken.


> So if you find some of the interface confusing (or wrong), then file a bug
> for us at bugs.swift.org. We can take this opportunity to try to make it
> better for everyone.
>

Will do!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/8cf74d14/attachment.html>

From david at hartbit.com  Thu Dec  3 16:39:55 2015
From: david at hartbit.com (David Hart)
Date: Thu, 3 Dec 2015 23:39:55 +0100
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
Message-ID: <BECB1E47-0683-40FB-9AD0-E57AB6499D17@hartbit.com>

I have been waiting a long time for something like this. I?m 100% behind this.

> On 03 Dec 2015, at 23:12, Tal Atlas <me at tal.by> wrote:
>
> With the awesome expansion of protocol oriented programming that swift has allowed, the lack of generic protocols has felt noticeably lacking and painful in some cases. I made an in depth proposal here: https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md <https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md>
>
> But the tl;dr is this:
>
> protocol Validator<TypeToValidate> {
>   var value: TypeToValidate { get set }
>   var valueIfValid: TypeToValidate? { get }
> }
>
> struct FooStringValidator: Validator<String> {
>   //... implementation
> }
>
> let stringValidator: Validator<String>
>
> Look forward to hearing some feedback.
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/54cf7352/attachment.html>

From clattner at apple.com  Thu Dec  3 16:42:35 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 14:42:35 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
Message-ID: <B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>


> On Dec 3, 2015, at 2:18 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> It's actually not doing the same thing, and what you're suggesting has
> no precedent.
...
> Furthermore, to anyone not
> already familiar with the proposed rule, `if let foo {` is meaningless;
> it does not tell the reader what it's actually doing, and its behavior
> cannot be inferred from any other language rule.

Right.

?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.

I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.

Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.

-Chris


>
> -Kevin Ballard
>
> On Thu, Dec 3, 2015, at 01:17 PM, Zef Houssney wrote:
>> Thanks for your thoughts David!
>>
>> I would argue that it does support stated objectives of Swift, like "the
>> syntax is concise yet expressive.?
>>
>> In the majority of cases having a lot of esoteric syntax is a problem.
>> However, with this being such a fundamental part of every day programming
>> in Swift, I find it to be a perfect place to reduce friction. I also find
>> it to be quite understandable and intuitive, unlike the three examples of
>> Swift 3 changes that you gave, which are more specialized and less
>> frequently encountered.
>>
>> Also, I just noticed that this isn?t unprecedented and that a similar
>> idiom actually currently used in Swift to assign constants when pattern
>> matching inside a Switch:
>>
>> case let (x, y):
>>
>> That is doing fundamentally the same thing that I?m suggesting. It
>> assigns a constant without using `=`, because the value is already known.
>>
>> Zef
>>
>>
>>
>>> On Dec 3, 2015, at 1:26 PM, David Hart <david at hartbit.com> wrote:
>>>
>>> I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:
>>>
>>> - simplifying the language
>>> - making code more explicit by removed by shorthand syntax
>>> - removing redundant syntax for achieving the same behavior
>>>
>>> You can see examples of this in the latest changes to the language:
>>>
>>> - removal of the # symbol in the first argument name as a shorthand to defining the argument name twice
>>> - removal of the ++ and -- prefix and postfix operators in Swift 3
>>> - removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3
>>>
>>> I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.
>>>
>>> Just my 2 cents :)
>>>
>>>
>>>
>>> Sent from my iPhone
>>>> On 03 Dec 2015, at 20:52, Zef Houssney <zefmail at gmail.com> wrote:
>>>>
>>>> Hello. This is exciting!
>>>>
>>>> I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.
>>>>
>>>> The idea is to introduce a new syntax for Optional Binding:
>>>>
>>>> Instead of:
>>>>
>>>> if let foo = foo { }
>>>>
>>>> You could simply use:
>>>>
>>>> if let foo { }
>>>>
>>>>
>>>> I?ve written up a draft of a proposal here with additional information and motivations:
>>>> https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md
>>>>
>>>>
>>>> What do you think?
>>>>
>>>> Thank you!
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From jgroff at apple.com  Thu Dec  3 16:43:24 2015
From: jgroff at apple.com (Joe Groff)
Date: Thu, 03 Dec 2015 14:43:24 -0800
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
Message-ID: <D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>


> On Dec 3, 2015, at 2:12 PM, Tal Atlas <me at tal.by> wrote:
>
> With the awesome expansion of protocol oriented programming that swift has allowed, the lack of generic protocols has felt noticeably lacking and painful in some cases. I made an in depth proposal here: https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md <https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md>
>
> But the tl;dr is this:
>
> protocol Validator<TypeToValidate> {
>   var value: TypeToValidate { get set }
>   var valueIfValid: TypeToValidate? { get }
> }
>
> struct FooStringValidator: Validator<String> {
>   //... implementation
> }
>
> let stringValidator: Validator<String>

The lack of protocol type erasure when associated types are involved is definitely a big problem, and one we'd like to address. However, I don't think moving wholesale to modeling associated types this way is feasible. Many of the standard library protocols have a lot of associated types. 'CollectionType' for instance has its 'Index' type while also inheriting a 'Generator' from SequenceType, and neither of these is what you typically want to parameterize a collection on?you'd want 'CollectionType<Int>' ideally to refer to a collection whose *Element* is Int without having to fully specify the generator and index if you don't care about them. Swift's protocols also support type system features that make some erased protocol types not actual models of their own protocols; `Equatable` is notorious for this, since a type being `Equatable` to its own values does not mean it can be equated to arbitrary other types; `1 == "1"` is nonsense for instance. We have a number of issues that need to be considered here; don't worry, we are considering them!

-Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/f5e92e56/attachment-0001.html>

From david at hartbit.com  Thu Dec  3 16:52:55 2015
From: david at hartbit.com (David Hart)
Date: Thu, 3 Dec 2015 23:52:55 +0100
Subject: [swift-evolution] API Guidelines for Asynchronous
Completion	Handlers?
In-Reply-To: <9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
Message-ID: <E66B6A43-66FF-43BD-808F-87D5A32FE2D2@hartbit.com>

A couple of points to think about:

- Seems to me like Swift's error handling should be discussed at the same time because asynchronous callbacks is the only case where we need to revert back to using NSError instead of using Swift?s error handling. What can the language do for us?

- This is slightly off-topic, but do we profit from Swift as a new language to move to a completely different paradigm like Promises?

David

> On 03 Dec 2015, at 23:15, Douglas Gregor <dgregor at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com <mailto:daniel.j.stenmark at gmail.com>> wrote:
>>
>> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>>
>> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
>> - Double Block (one for success, one for failure)
>> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ <http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/>)
>>
>> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?
>
> This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.
>
> 	- Doug
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/31cdcf07/attachment.html>

From anthony.parker at apple.com  Thu Dec  3 16:33:04 2015
From: anthony.parker at apple.com (Tony Parker)
Date: Thu, 03 Dec 2015 14:33:04 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
Message-ID: <48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>

Hi Jacob,

> On Dec 3, 2015, at 2:23 PM, Jacob Bandes-Storch <jtbandes at gmail.com> wrote:
>
> On Thu, Dec 3, 2015 at 2:13 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>
> As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.
>
> This is great, but is the goal also to exactly duplicate all the idiosyncrasies of the Obj-C Foundation?
>
> Quiz: what's the result of NSURL(string: "http://one/two;three/four <http://one/two;three/four>")?.URLByAppendingPathComponent("five") ?
>
> If, as I would hope, corelibs-foundation is an opportunity to make simpler APIs that resolve some of these weirdnesses, then should the class names (NSURL, NSFileHandle, etc.) really be the same?
>
>  _______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev

I think NSURL is actually a pretty great example of an API that we want to be the same on all platforms. There is quite a bit of logic backing it (along with something like NSURLComponents). Check out some of it here:

https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c

(and that CF code is reflected up into NSURLComponents)

It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.

So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org. We can take this opportunity to try to make it better for everyone.

Thanks,
- Tony



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/9fefbcac/attachment-0001.html>

From anthony.parker at apple.com  Thu Dec  3 16:46:43 2015
From: anthony.parker at apple.com (Tony Parker)
Date: Thu, 03 Dec 2015 14:46:43 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <CADcs6kPg9oQEsUSz0T-ThtY2VCtKnQSwAPY1nrDyi8r6RiNR8A@mail.gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<CADcs6kPg9oQEsUSz0T-ThtY2VCtKnQSwAPY1nrDyi8r6RiNR8A@mail.gmail.com>
Message-ID: <1EE658E9-D747-4322-9E47-DA22AD261097@apple.com>


> On Dec 3, 2015, at 2:37 PM, Jacob Bandes-Storch <jtbandes at gmail.com> wrote:
>
> Thanks, Tony.
>
> On Thu, Dec 3, 2015 at 2:33 PM, Tony Parker <anthony.parker at apple.com <mailto:anthony.parker at apple.com>> wrote:
> It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.
>
> Agreed. I look forward to it :)  I'm just concerned that users will expect behavior to exactly match their equivalent Obj-C code. If these bugs are fixed / APIs are refined in corelibs-foundation, that expectation might be broken.

Indeed, a very good point and something we are actively thinking about.

An important goal of our project is to provide a layer of OS independence and portability. There may be times when we have a bug in the Obj-C implementation that we therefore decide to reflect in the Swift implementation as well, because the inconsistency would otherwise be a problem. Hopefully this doesn?t happen too often. I?d rather fix the bug in the Obj-C implementation as well, but there are always going to be tradeoffs to make.

We have lots of experience making changes to Foundation underneath apps and keeping things compatible. I think we?ll certainly be using some of that as we move forward with the Swift Foundation implementation as well. For example, we may choose to deprecate a confusing (or wrong) API and replace it with something better. We?d like the bar for changing API to be very high, though, so that we can provide as much stability to clients as possible.

Thanks,
- Tony


>
> So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org <http://bugs.swift.org/>. We can take this opportunity to try to make it better for everyone.
>
> Will do!

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/bc31b358/attachment-0001.html>

From kevin at sb.org  Thu Dec  3 16:57:09 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 14:57:09 -0800
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <BECB1E47-0683-40FB-9AD0-E57AB6499D17@hartbit.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
<BECB1E47-0683-40FB-9AD0-E57AB6499D17@hartbit.com>
Message-ID: <1449183429.2532320.457498305.07DD4C9B@webmail.messagingengine.com>

Changing all typealiases in protocols to generic arguments is a pretty
significant change to the language, with a very large impact on existing
code. It also opens the door to implementing the same protocol with
different types, which is something that Swift does not currently allow.

I think Rust's trait system is a good example of the right way to do
this. Rust traits are like Swift protocols, but they started out with
only generics, no associated types. Later on they gained associated
types as well (with the same limitation that Swift protocols have,
where any trait with an associated type cannot be used as a "trait
object"). The end result is Rust traits can have both generics and
associated types, and the choice of which to use depends on what it's
for. Also, a type in Rust can implement the same trait with different
generic parameters (but for any parameterized trait, it can only have
one implementation regardless of associated types). This is also how
Rust has implemented multi-dispatch (Rust does not have method
overloading in general). And the way you're supposed to think about
this is generic type parameters to a trait are "input types", and
associated types are "output types". So any given type can implement
the same protocol as many times as it wants with distinct input types,
but for every set of input types, there is only one set of output
types. And this works very well.

An example of how this is used is the trait that powers the + operator,
called std::ops::Add. It's defined as

pub trait Add<RHS = Self> {    type Output;    fn add[1](self, rhs: RHS)
-> Self::Output[2]; }

(the `= Self` bit is a defaulted type parameter)

This means that for any given type T, it can support addition with any
number of other types, but for every pair of types (T,U), the expression
`T + U` can only ever have one return value. To demonstrate how this
would work in Swift, you can imagine supporting `+` with NSNumber
against different numeric types:

extension NSNumber: Add<Int> {? ? typealias Output = Int? ? func
add(rhs: Int) -> Int {? ? ? ? return integerValue + rhs? ? } }

extension NSNumber: Add<UInt> {? ? typealias Output = UInt? ? func
add(rhs: UInt) -> UInt {? ? ? ? return unsignedIntegerValue + rhs? ? } }

// etc...

Besides the clean distinction between "input" and "output" types, this
also allows various traits to have only one or the other. For example,
Rust's equivalent to Swift's Generator is std::iter::Iterator, which has
an associated type for the iterated element. And it makes a lot of sense
for Iterator to use an associated type for this instead of a type
parameter, because it's confusing to have a sequence that can yield
multiple different element types from a call to `seq.generate()` (or in
Rust's case, `seq.iter()`) which would require an explicit type
annotation. And it's even worse when you realize that most code that
iterates over sequences doesn't even care about the concrete generator
type, but the type annotation requires declaring that concrete type (the
alternative, declaring it as `GeneratorType<T>`, will wrap the concrete
type in a protocol object and incur the overhead of extra allocation +
dynamic function dispatch if the optimizer can't remove it).

tl;dr: I want both type parameters and associated types for protocols

-Kevin Ballard

On Thu, Dec 3, 2015, at 02:39 PM, David Hart wrote:
> I have been waiting a long time for something like this. I?m 100%
> behind this.
>
>> On 03 Dec 2015, at 23:12, Tal Atlas <me at tal.by> wrote:
>>
>> With the awesome expansion of protocol oriented programming that
>> swift has allowed, the lack of generic protocols has felt noticeably
>> lacking and painful in some cases. I made an in depth proposal here:
>> https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md
>>
>> But the tl;dr is this:
>>
>> protocol Validator<TypeToValidate> {? var value: TypeToValidate { get
>> set }? var valueIfValid: TypeToValidate? { get } }
>>
>> struct FooStringValidator: Validator<String> {? //...
>> implementation }
>>
>> let stringValidator: Validator<String>
>>
>> Look forward to hearing some feedback.
>>
_______________________________________________
>> swift-evolution mailing list swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution



Links:

1. https://doc.rust-lang.org/stable/std/ops/trait.Add.html#tymethod.add
2. https://doc.rust-lang.org/stable/std/ops/trait.Add.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/e1684260/attachment.html>

From felix.gabel at me.com  Thu Dec  3 16:59:45 2015
From: felix.gabel at me.com (Felix Gabel)
Date: Thu, 03 Dec 2015 23:59:45 +0100
Subject: [swift-evolution]  Proposal: Sealed protocols
Message-ID: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>

Hey everyone,

I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.

Example:

public sealed protocol FooType {
// this protocol can be conformed to only in scope of the library itself
// it can NOT be conformed to by any object declared outside the library
}

What do you think?

Thank you for your time,
Felix

From dgregor at apple.com  Thu Dec  3 17:09:56 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Thu, 3 Dec 2015 15:09:56 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
Message-ID: <8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>


> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com> wrote:
>
> Hey everyone,
>
> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>
> Example:
>
> public sealed protocol FooType {
>    // this protocol can be conformed to only in scope of the library itself
>    // it can NOT be conformed to by any object declared outside the library
> }
>
> What do you think?


Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??

- Doug


From a.michail at me.com  Thu Dec  3 17:10:01 2015
From: a.michail at me.com (Amir Michail)
Date: Thu, 03 Dec 2015 18:10:01 -0500
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
Message-ID: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>

In particular, this should not be required in boolean contexts.

Is there any good reason why certain contexts require the ?!? suffix?

From kevin at sb.org  Thu Dec  3 17:10:37 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 15:10:37 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
Message-ID: <1449184237.2534605.457505073.278231F9@webmail.messagingengine.com>

An alternative that would have the same effect is to allow protocols to
require conformance to other protocols with a lesser visibility. Because
no external type could conform to the private/internal protocol
requirement, they can't declare conformance to the public protocol
either. The only way they could conform is if the library adds
conformance to the private protocol to some public class, and then
external code can conform to the public protocol in subclasses, which
seems like a potentially-desirable thing (just yesterday someone asked
on IRC if there was a way to declare a protocol that could only be
conformed-to by UIViewController subclasses).

This would look something like

private protocol Restricted {}

public protocol SealedProto: Restricted {
// ...
}

The best part about this proposal is it doesn't require adding any new
syntax or rules to the language, it only requires relaxing the rule that
says a protocol cannot require conformance to another protocol of lesser
visibility.

-Kevin Ballard

On Thu, Dec 3, 2015, at 02:59 PM, Felix Gabel wrote:
> Hey everyone,
>
> I hereby propose adding a ?sealed? modifier for protocols to enable
> library developers to declare protocols that can be only conformed to in
> the scope of the library itself. This is similar to a ?sealed trait? in
> Scala with the difference that it does not limit the protocol to be only
> applicable in the file it is declared in.
>
> Example:
>
> public sealed protocol FooType {
>     // this protocol can be conformed to only in scope of the library
>     itself
>     // it can NOT be conformed to by any object declared outside the
>     library
> }
>
> What do you think?
>
> Thank you for your time,
> Felix
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From mehdi.amini at apple.com  Thu Dec  3 17:13:02 2015
From: mehdi.amini at apple.com (Mehdi Amini)
Date: Thu, 03 Dec 2015 15:13:02 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
Message-ID: <5220FBE7-D3E1-42DE-AD46-BA7CFB79BC80@apple.com>


> On Dec 3, 2015, at 3:09 PM, Douglas Gregor <dgregor at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com> wrote:
>>
>> Hey everyone,
>>
>> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>>
>> Example:
>>
>> public sealed protocol FooType {
>>   // this protocol can be conformed to only in scope of the library itself
>>   // it can NOT be conformed to by any object declared outside the library
>> }
>>
>> What do you think?
>
>
> Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??

I can foresee how a whole module optimization would be able to do better devirtualization in this case, knowing the full possible set of type of instance.

?
Mehdi


From jgroff at apple.com  Thu Dec  3 17:13:08 2015
From: jgroff at apple.com (Joe Groff)
Date: Thu, 03 Dec 2015 15:13:08 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
Message-ID: <DDE9D0B8-0770-482D-850A-A9A3B5D3A274@apple.com>


> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com> wrote:
>
> Hey everyone,
>
> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>
> Example:
>
> public sealed protocol FooType {
>    // this protocol can be conformed to only in scope of the library itself
>    // it can NOT be conformed to by any object declared outside the library
> }
>
> What do you think?

My first reaction is that enums already provide a way to model closed sum types. Enums do have some syntactic disadvantages compared to protocol types, since there's no automatic subtyping with enums like there are with protocols, but it might be worth considering ways we can improve that rather than adding redundant language features.

-Joe

From fox.ios.dev at gmail.com  Thu Dec  3 17:13:13 2015
From: fox.ios.dev at gmail.com (Richard Fox)
Date: Thu, 03 Dec 2015 23:13:13 +0000
Subject: [swift-evolution] If-let Shortcut Syntax
Message-ID: <CAKK64=hzAqafTWUDf=AY79nzX6J6Ake6VA9tFkYeaon_d5OBdQ@mail.gmail.com>

Hi all,

I propose a shortened syntax for using if-let with local names unwrapping
higher order optionals of the same name. i. e.

if let a {
//code
}

as a shortcut for this:

if let a = a{
//code
}


>From my observations echoing the local let variable name on the optional
being unwrapped seems to have become the commonly used practice.

I do not see this conflicting with any existing code.

My only thought's on potential pitfalls are if there is a local variable
and higher order variable both with the same name, as there may be
confusion as to which you are unwrapping.  Although I don't see this as a
huge issue, as fault for such an error seems like it would weigh mostly on
architectural mistakes.

Also I think this would go hand in hand with a guard implementation of the
same nature

guard let a else{
//code
}


Thanks,
Rich Fox
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ccca9b12/attachment.html>

From adrian.kashivskyy at me.com  Thu Dec  3 17:17:19 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 00:17:19 +0100
Subject: [swift-evolution] If-let Shortcut Syntax
In-Reply-To: <CAKK64=hzAqafTWUDf=AY79nzX6J6Ake6VA9tFkYeaon_d5OBdQ@mail.gmail.com>
References: <CAKK64=hzAqafTWUDf=AY79nzX6J6Ake6VA9tFkYeaon_d5OBdQ@mail.gmail.com>
Message-ID: <92FDF34B-80F4-43E8-AAD8-C65174C239F2@me.com>

I believe that's a duplicate of "Proposal: Optional Binding Shorthand Syntax". Let me quote Chris Lattner on that:

> Right.
>
> ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.
>
> I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>
> Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.
>
> -Chris

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Richard Fox <fox.ios.dev at gmail.com> w dniu 04.12.2015, o godz. 00:13:
>
> Hi all,
>
> I propose a shortened syntax for using if-let with local names unwrapping higher order optionals of the same name. i. e.
> if let a {
>   //code
> }
> as a shortcut for this:
>
> if let a = a{
>   //code
> }
>
> From my observations echoing the local let variable name on the optional being unwrapped seems to have become the commonly used practice.
>
> I do not see this conflicting with any existing code.
>
> My only thought's on potential pitfalls are if there is a local variable and higher order variable both with the same name, as there may be confusion as to which you are unwrapping.  Although I don't see this as a huge issue, as fault for such an error seems like it would weigh mostly on architectural mistakes.
>
> Also I think this would go hand in hand with a guard implementation of the same nature
> guard let a else{
>   //code
> }
>
> Thanks,
> Rich Fox
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/c99c3a04/attachment-0001.html>

From gribozavr at gmail.com  Thu Dec  3 17:25:46 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Thu, 3 Dec 2015 15:25:46 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
Message-ID: <CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>

On Thu, Dec 3, 2015 at 3:09 PM, Douglas Gregor <dgregor at apple.com> wrote:
>
>> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com> wrote:
>>
>> Hey everyone,
>>
>> I hereby propose adding a ?sealed? modifier for protocols to enable
library developers to declare protocols that can be only conformed to in
the scope of the library itself. This is similar to a ?sealed trait? in
Scala with the difference that it does not limit the protocol to be only
applicable in the file it is declared in.
>>
>> Example:
>>
>> public sealed protocol FooType {
>>    // this protocol can be conformed to only in scope of the library
itself
>>    // it can NOT be conformed to by any object declared outside the
library
>> }
>>
>> What do you think?
>
>
> Can you elaborate on why a Swift developer would want to distinguish
between ?public sealed? and ?internal??

There are cases when the library isn't designed to support new conformances
for the protocol, but the protocol is public because other public APIs are
expressed in terms of it.

We have a case for it in the standard library, 'protocol
AnyCollectionType'.  Foundation also has a use case -- property list types.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ab0c1961/attachment.html>

From dave.thornton at me.com  Thu Dec  3 17:22:10 2015
From: dave.thornton at me.com (Dave Thornton)
Date: Fri, 04 Dec 2015 00:22:10 +0100
Subject: [swift-evolution] SwiftScript
Message-ID: <6F099260-9FF0-418B-AD8B-30CEF79A1AF0@me.com>

Swift is great.  I'd like to see a syntactically equivalent script language available for OS X, iOS and other platforms.

This is a big task, and one that probably falls way outside of the objectives of the core swift language evolution.

But... Does anyone else think it's a good idea / bad idea?  How and where should we start ?

Sent from my iPad

From clattner at apple.com  Thu Dec  3 17:32:17 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 15:32:17 -0800
Subject: [swift-evolution] SwiftScript
In-Reply-To: <6F099260-9FF0-418B-AD8B-30CEF79A1AF0@me.com>
References: <6F099260-9FF0-418B-AD8B-30CEF79A1AF0@me.com>
Message-ID: <AFDA4868-4D08-45B5-A73D-625B8D592983@apple.com>


> On Dec 3, 2015, at 3:22 PM, Dave Thornton <dave.thornton at me.com> wrote:
>
> Swift is great.  I'd like to see a syntactically equivalent script language available for OS X, iOS and other platforms.
>
> This is a big task, and one that probably falls way outside of the objectives of the core swift language evolution.
>
> But... Does anyone else think it's a good idea / bad idea?  How and where should we start ?

I?m not sure if this is specifically what you?re thinking of, but we aren?t interested in a language variant or dialect as part of the Swift project.  Instead, we?d prefer to improve the Swift language itself to be appealing for solving the problems that people use scripting languages for.

-Chris

From erica at ericasadun.com  Thu Dec  3 17:32:10 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Thu, 3 Dec 2015 16:32:10 -0700
Subject: [swift-evolution] C-style For Loops
Message-ID: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>

Does Swift still needs C-style for loops with conditions and incrementers?



More Swift-like construction is already available with for-in-statements and stride.
This would naturally starve the most common point for -- and ++ operators as well.

-- E

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/657231e9/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Screen Shot 2015-12-03 at 4.30.15 PM.png
Type: image/png
Size: 27490 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/657231e9/attachment-0001.png>

From matthew at anandabits.com  Thu Dec  3 17:32:51 2015
From: matthew at anandabits.com (Anandabits)
Date: Thu, 3 Dec 2015 17:32:51 -0600
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
<CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>
Message-ID: <51BBEE3F-066E-4657-AE98-97D344933A25@anandabits.com>


>
> There are cases when the library isn't designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.
>
> We have a case for it in the standard library, 'protocol AnyCollectionType'.  Foundation also has a use case -- property list types.

I have had cases for this as well.  Joe Groff's suggestion of adding more convenient syntax for sum types as an alternative may be an acceptable alternative for the cases I have seen, although I would need to have a better idea of what that might look like.  Joe, have you written a proposal for this?

Matthew

From dgregor at apple.com  Thu Dec  3 17:33:05 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Thu, 3 Dec 2015 15:33:05 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <5220FBE7-D3E1-42DE-AD46-BA7CFB79BC80@apple.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
<5220FBE7-D3E1-42DE-AD46-BA7CFB79BC80@apple.com>
Message-ID: <B62E861D-111E-43AD-944E-1FAEE00A7066@apple.com>


> On Dec 3, 2015, at 3:13 PM, Mehdi Amini <mehdi.amini at apple.com> wrote:
>
>>
>> On Dec 3, 2015, at 3:09 PM, Douglas Gregor <dgregor at apple.com> wrote:
>>
>>
>>> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com> wrote:
>>>
>>> Hey everyone,
>>>
>>> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>>>
>>> Example:
>>>
>>> public sealed protocol FooType {
>>>  // this protocol can be conformed to only in scope of the library itself
>>>  // it can NOT be conformed to by any object declared outside the library
>>> }
>>>
>>> What do you think?
>>
>>
>> Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??
>
> I can foresee how a whole module optimization would be able to do better devirtualization in this case, knowing the full possible set of type of instance.

Are you perhaps thinking of the different between ?public? and ?public sealed?? Both ?public sealed? and ?internal? allow whole module optimization to know the complete set of types that conform to the protocol. In the former case, that?s true because it?s the semantics of ?sealed?; in the latter case, that?s true because the protocol isn?t visible outside of the module.

- Doug

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/9a985d81/attachment.html>

From clattner at apple.com  Thu Dec  3 17:34:37 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 15:34:37 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
Message-ID: <210806FA-E80A-49AA-89A3-8568E236FBC0@apple.com>


> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
> Does Swift still needs C-style for loops with conditions and incrementers?
>
> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>
> More Swift-like construction is already available with for-in-statements and stride.
> This would naturally starve the most common point for -- and ++ operators as well.

I am certainly open to considering dropping the C-style for loop.  IMO, it is a rarely used feature of Swift that doesn?t carry its weight.  Many of the reasons to remove them align with the rationale for removing -- and ++.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/dd0c2f7e/attachment.html>

From dgregor at apple.com  Thu Dec  3 17:36:51 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Thu, 3 Dec 2015 15:36:51 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
Message-ID: <75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>


> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
> Does Swift still needs C-style for loops with conditions and incrementers?
>
> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>
> More Swift-like construction is already available with for-in-statements and stride.
> This would naturally starve the most common point for -- and ++ operators as well.

My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.

- Doug


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/8fb334e5/attachment.html>

From mehdi.amini at apple.com  Thu Dec  3 17:36:57 2015
From: mehdi.amini at apple.com (Mehdi Amini)
Date: Thu, 03 Dec 2015 15:36:57 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <B62E861D-111E-43AD-944E-1FAEE00A7066@apple.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
<5220FBE7-D3E1-42DE-AD46-BA7CFB79BC80@apple.com>
<B62E861D-111E-43AD-944E-1FAEE00A7066@apple.com>
Message-ID: <E5F0FA3B-B0BC-4791-ABDC-98822DE24E98@apple.com>


> On Dec 3, 2015, at 3:33 PM, Douglas Gregor <dgregor at apple.com> wrote:
>
>>
>> On Dec 3, 2015, at 3:13 PM, Mehdi Amini <mehdi.amini at apple.com <mailto:mehdi.amini at apple.com>> wrote:
>>
>>>
>>> On Dec 3, 2015, at 3:09 PM, Douglas Gregor <dgregor at apple.com <mailto:dgregor at apple.com>> wrote:
>>>
>>>
>>>> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com <mailto:felix.gabel at me.com>> wrote:
>>>>
>>>> Hey everyone,
>>>>
>>>> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>>>>
>>>> Example:
>>>>
>>>> public sealed protocol FooType {
>>>>  // this protocol can be conformed to only in scope of the library itself
>>>>  // it can NOT be conformed to by any object declared outside the library
>>>> }
>>>>
>>>> What do you think?
>>>
>>>
>>> Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??
>>
>> I can foresee how a whole module optimization would be able to do better devirtualization in this case, knowing the full possible set of type of instance.
>
> Are you perhaps thinking of the different between ?public? and ?public sealed?? Both ?public sealed? and ?internal? allow whole module optimization to know the complete set of types that conform to the protocol. In the former case, that?s true because it?s the semantics of ?sealed?; in the latter case, that?s true because the protocol isn?t visible outside of the module.

Oh yes you?re right, I meant it for the difference between ?public? and ?public sealed?, but that wasn?t your question?

?
Mehdi

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/61b1ab50/attachment-0001.html>

From jgroff at apple.com  Thu Dec  3 17:38:13 2015
From: jgroff at apple.com (Joe Groff)
Date: Thu, 03 Dec 2015 15:38:13 -0800
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <51BBEE3F-066E-4657-AE98-97D344933A25@anandabits.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
<CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>
<51BBEE3F-066E-4657-AE98-97D344933A25@anandabits.com>
Message-ID: <21CD77D2-A9AB-429D-9095-F68EB0E198E4@apple.com>


> On Dec 3, 2015, at 3:32 PM, Anandabits <matthew at anandabits.com> wrote:
>
>
>>
>> There are cases when the library isn't designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.
>>
>> We have a case for it in the standard library, 'protocol AnyCollectionType'.  Foundation also has a use case -- property list types.
>
> I have had cases for this as well.  Joe Groff's suggestion of adding more convenient syntax for sum types as an alternative may be an acceptable alternative for the cases I have seen, although I would need to have a better idea of what that might look like.  Joe, have you written a proposal for this?

Only vague notions, nothing ready to formally propose. Optional has hardcoded support for being a supertype of its `Some` payload; it might be worth surfacing that as a language feature other enums can also take advantage of:

enum Optional<Wrapped> {
// Strawman: 'sub case' declares a case whose type becomes a subtype of the enum
sub case Some(Wrapped)
case None
}
enum Result<Success, Error: ErrorType> {
sub case OK(Success)
case Error(Error)
}

There would need to be constraints so that two 'sub cases' are never able to have overlapping payload types?otherwise with something like Either<Int, Int>, it'd be ambiguous which side of Either Int promotes to. OTOH, optional subtyping also causes some issues (1 < nil works being one of the more prominent ones), so we may not want to dig the subtyping hole deeper either?like I said, only vague notions.

-Joe

From ctxppc at gmail.com  Thu Dec  3 17:40:22 2015
From: ctxppc at gmail.com (Constantino Tsarouhas)
Date: Fri, 4 Dec 2015 00:40:22 +0100
Subject: [swift-evolution] SwiftScript
In-Reply-To: <mailman.340.1449185578.954.swift-evolution@swift.org>
References: <mailman.340.1449185578.954.swift-evolution@swift.org>
Message-ID: <A78F30D7-D657-415E-A651-87B0BA468BDE@gmail.com>

Swift can already be used as a scripting language on OS X. Just chmod+x and shebang the file (#!/usr/bin/env xcrun swift -i).

As for using it on iOS and the web in the same way as JavaScript/ECMAScript, I personally think Swift is too young for that. IIRC, the authors wanted to go for systems programming next. But I certainly hope Swift?s popularity explodes into all kinds of domains and environments. :-)


> On 04 Dec 2015, at 00:32, swift-evolution-request at swift.org wrote:
>
> From: Dave Thornton <dave.thornton at me.com <mailto:dave.thornton at me.com>>
> Date: 4 December 2015 at 00:22:10 GMT+1
> To: swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> Subject: [swift-evolution] SwiftScript
>
>
> Swift is great.  I'd like to see a syntactically equivalent script language available for OS X, iOS and other platforms.
>
> This is a big task, and one that probably falls way outside of the objectives of the core swift language evolution.
>
> But... Does anyone else think it's a good idea / bad idea?  How and where should we start ?
>
> Sent from my iPad

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/bfb28cb2/attachment.html>

From david at owensd.io  Thu Dec  3 17:41:03 2015
From: david at owensd.io (David Owens II)
Date: Thu, 3 Dec 2015 15:41:03 -0800
Subject: [swift-evolution] SwiftScript
In-Reply-To: <AFDA4868-4D08-45B5-A73D-625B8D592983@apple.com>
References: <6F099260-9FF0-418B-AD8B-30CEF79A1AF0@me.com>
<AFDA4868-4D08-45B5-A73D-625B8D592983@apple.com>
Message-ID: <2A69A797-8EEE-4117-B558-EA01B88D990F@owensd.io>

I started a GitHub project (Apous) to test out the feasibility of using Swift like this. Now that Swift has a built-in package manager (including static lib creation), this is already possible today with just a few wrappers to invoke the compiling and running. Nothing else is really needed from the languages other than core libs implemented for the target platforms and additional libraries to flush out what is missing to make it more useful.

-David

> On Dec 3, 2015, at 3:32 PM, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 3:22 PM, Dave Thornton <dave.thornton at me.com> wrote:
>>
>> Swift is great.  I'd like to see a syntactically equivalent script language available for OS X, iOS and other platforms.
>>
>> This is a big task, and one that probably falls way outside of the objectives of the core swift language evolution.
>>
>> But... Does anyone else think it's a good idea / bad idea?  How and where should we start ?
>
> I?m not sure if this is specifically what you?re thinking of, but we aren?t interested in a language variant or dialect as part of the Swift project.  Instead, we?d prefer to improve the Swift language itself to be appealing for solving the problems that people use scripting languages for.
>
> -Chris
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From david_smith at apple.com  Thu Dec  3 17:41:40 2015
From: david_smith at apple.com (David Smith)
Date: Thu, 03 Dec 2015 15:41:40 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
Message-ID: <FBAC1A0F-9CD1-4658-8746-C09A8824F54F@apple.com>


> On Dec 3, 2015, at 3:36 PM, Douglas Gregor <dgregor at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>
>> Does Swift still needs C-style for loops with conditions and incrementers?
>>
>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>
>> More Swift-like construction is already available with for-in-statements and stride.
>> This would naturally starve the most common point for -- and ++ operators as well.
>
> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>
> 	- Doug
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

Every time I?ve used a C-style for loop in Swift it was because I forgot that .indices existed. If it?s removed, a fixme pointing that direction might be useful.

David

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/7c334f1b/attachment-0001.html>

From a.michail at me.com  Thu Dec  3 17:42:03 2015
From: a.michail at me.com (Amir Michail)
Date: Thu, 03 Dec 2015 18:42:03 -0500
Subject: [swift-evolution] ? suffix for <, >, <=,
>= comparisons with optionals to prevent subtle bugs
Message-ID: <09C1AEA6-1707-44FB-BCA0-16A554706E03@me.com>

Such comparisons with optionals can result in hard to find bugs.

For example consider:

let f = x < 5  // x is of type Int? and may be nil

The proposed ? suffix would be used as follows and makes the possibility of nil very clear:

let f = x? < 5



From keithbsmiley at gmail.com  Thu Dec  3 17:43:43 2015
From: keithbsmiley at gmail.com (Keith Smiley)
Date: Thu, 3 Dec 2015 15:43:43 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
Message-ID: <20151203234343.GB723@bryant.sfhq.lyft.internal>

For what it's worth we don't have a single C style for loop in the Lyft
codebase.

--
Keith Smiley

On 12/03, Douglas Gregor wrote:
>
> > On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
> >
> > Does Swift still needs C-style for loops with conditions and incrementers?
> >
> > <Screen Shot 2015-12-03 at 4.30.15 PM.png>
> >
> > More Swift-like construction is already available with for-in-statements and stride.
> > This would naturally starve the most common point for -- and ++ operators as well.
>
> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>
> 	- Doug
>
>

> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From andy at andymatuschak.org  Thu Dec  3 17:46:27 2015
From: andy at andymatuschak.org (Andy Matuschak)
Date: Thu, 3 Dec 2015 15:46:27 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <20151203234343.GB723@bryant.sfhq.lyft.internal>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
Message-ID: <C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>

Just checked; ditto Khan Academy.

> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com> wrote:
>
> For what it's worth we don't have a single C style for loop in the Lyft
> codebase.
>
> --
> Keith Smiley
>
> On 12/03, Douglas Gregor wrote:
>>
>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>
>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>
>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>
>>> More Swift-like construction is already available with for-in-statements and stride.
>>> This would naturally starve the most common point for -- and ++ operators as well.
>>
>> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>>
>> 	- Doug
>>
>>
>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From devteam.codafi at gmail.com  Thu Dec  3 17:47:32 2015
From: devteam.codafi at gmail.com (Developer)
Date: Thu, 3 Dec 2015 18:47:32 -0500
Subject: [swift-evolution] Revisiting Optionals as Sequences
Message-ID: <16791B8B-0B01-461A-837B-1C66C8AC26BE@gmail.com>

A few months ago I sent a pair of radars (22414579 nee 22448207 and 21961711) about Optional?s extant overloading of flatMap and how it doesn?t align with either the STL or the reasons given for the closing of both radars.

> This issue behaves as intended based on the following:
>
> Yes, we are aware that this overload of flatMap could be viewed as unconventional. Nevertheless, it is useful and fits the overload set in general, if you view Optional as a sequence of zero or one T. It resembles this overload, where the closure returns an arbitrary sequence:
>
> extension SequenceType {
>   public func flatMap<S : SequenceType>(transform: (Generator.Element) -> S) -> [S.Generator.Element]
> }
>
> The type checker ensures that there is no ambiguity between the two overloads, and we don't see a reason to give one of the overloads a different name (and force users to learn it, and differentiate between the two), since conceptually the operation is the same.

If Swift wishes to regard Optionals as collections with 1 or 0 elements, then I propose that it should reflect that thinking with additions to the standard library.

Possible changes include:

1) Remove or rename Optional?s flatMap.
This would cause a bit of breaking behavior, but it?s nothing some fixits couldn?t help with.

2) Add a SequenceType instance for Optional.
This kills 2 birds with 1 stone in that, if the radar rejection is to ring true, Optional should have a SequenceType instance in the STL, and such an instance would automatically come with its own proper overloading flatMap necessitating change 1.

Over in TypeLift land we?ve already implemented what we believe the SequenceType extensions should look like (https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 <https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145>).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/29620825/attachment.html>

From clattner at apple.com  Thu Dec  3 17:49:32 2015
From: clattner at apple.com (Chris Lattner)
Date: Thu, 03 Dec 2015 15:49:32 -0800
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
Message-ID: <005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>


> On Dec 3, 2015, at 3:10 PM, Amir Michail <a.michail at me.com> wrote:
>
> In particular, this should not be required in boolean contexts.
>
> Is there any good reason why certain contexts require the ?!? suffix?

! is used to in multiple different ways for IUO?s.  What specifically are you objecting to?  Please give an example, thanks!

-Chris


From a.michail at me.com  Thu Dec  3 18:03:28 2015
From: a.michail at me.com (Amir Michail)
Date: Thu, 03 Dec 2015 19:03:28 -0500
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
Message-ID: <BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>


> On Dec 3, 2015, at 6:49 PM, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 3:10 PM, Amir Michail <a.michail at me.com> wrote:
>>
>> In particular, this should not be required in boolean contexts.
>>
>> Is there any good reason why certain contexts require the ?!? suffix?
>
> ! is used to in multiple different ways for IUO?s.  What specifically are you objecting to?  Please give an example, thanks!
>
> -Chris
>

I really don?t like having to put the ! suffix in boolean contexts:

"if displayFlag! { ... }" instead of "if displayFlag { ? }" etc.

If you also want a way to compare with nil, then maybe have this for implicitly unwrapped optionals:

if displayFlag? == nil { ? }

From rayfix at gmail.com  Thu Dec  3 18:14:36 2015
From: rayfix at gmail.com (Ray Fix)
Date: Thu, 3 Dec 2015 16:14:36 -0800
Subject: [swift-evolution] Pluggable hash algorithm for containers
Message-ID: <8F9F94DC-3991-457C-A145-FD3CC887D535@gmail.com>

Last year, Howard Hinnant proposed a composable hash algorithm framework for C++ that I was impressed with.

His proposal is here: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html>
A live presentation is here: https://www.youtube.com/watch?v=Njjp_MJsgt8 <https://www.youtube.com/watch?v=Njjp_MJsgt8>

A type with multiple fields you inevitably want to do a hash_combine but this pollutes the hashing algorithm.  It turns out that (nearly) all hashing algorithms can be abstracted into 3 phases: initialization, digestion and finalization.  It might be cool if Swift Hashable adopted this pluggable architecture.

1. Easily adopt Hashable
2. Easily change and compare hash algorithms based on performance / security needs
3. Make good hash implementations trivial for users.

Wondering if anyone has thought about this already / if it would be worthwhile pursuing more.

Best wishes,
Ray

PS:  I have always thought that it is a bummer that compound types such as tuples can?t conform to protocols and therefore be Hashable.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/5717295b/attachment-0001.html>

From jtbandes at gmail.com  Thu Dec  3 18:17:26 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Thu, 3 Dec 2015 16:17:26 -0800
Subject: [swift-evolution] ? suffix for <, >, <=,
>= comparisons with optionals to prevent subtle bugs
In-Reply-To: <09C1AEA6-1707-44FB-BCA0-16A554706E03@me.com>
References: <09C1AEA6-1707-44FB-BCA0-16A554706E03@me.com>
Message-ID: <CADcs6kNwuvZsWzbE2h8oNacViG3cN5iDz+SP12K8u6h5nhcEyg@mail.gmail.com>

Agreed ? or, I think, these operators could/should simply be removed.

I filed <rdar://22833869> about this a while ago, which was marked as
Duplicate/<rdar://16966712>.

Summary:
> This returns true:
>     (nil as Int?) < 0
> This also returns true, which makes even less sense:
>     (nil as Int?) < Int.min



Expected Results:
> nil < 0, nil > 0, and nil == 0, should all be false. nil != 0 should be true.
> Alternatively, just *don't* provide < and > operators that accept optional arguments.



Actual Results:
> nil < 0 is true. Others are as expected.


See also: https://twitter.com/jtbandes/status/646914031433871364


Jacob

On Thu, Dec 3, 2015 at 3:42 PM, Amir Michail <a.michail at me.com> wrote:

> Such comparisons with optionals can result in hard to find bugs.
>
> For example consider:
>
> let f = x < 5  // x is of type Int? and may be nil
>
> The proposed ? suffix would be used as follows and makes the possibility
> of nil very clear:
>
> let f = x? < 5
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/9f82f0c4/attachment.html>

From felix.gabel at me.com  Thu Dec  3 18:24:25 2015
From: felix.gabel at me.com (Felix Gabel)
Date: Fri, 04 Dec 2015 01:24:25 +0100
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <DDE9D0B8-0770-482D-850A-A9A3B5D3A274@apple.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<DDE9D0B8-0770-482D-850A-A9A3B5D3A274@apple.com>
Message-ID: <A61FCD15-239A-4B10-9078-C1BAD2E5DE62@me.com>


> On Dec 4, 2015, at 12:13 AM, Joe Groff <jgroff at apple.com> wrote:
>
>>
>> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com> wrote:
>>
>> Hey everyone,
>>
>> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>>
>> Example:
>>
>> public sealed protocol FooType {
>>   // this protocol can be conformed to only in scope of the library itself
>>   // it can NOT be conformed to by any object declared outside the library
>> }
>>
>> What do you think?
>
> My first reaction is that enums already provide a way to model closed sum types. Enums do have some syntactic disadvantages compared to protocol types, since there's no automatic subtyping with enums like there are with protocols, but it might be worth considering ways we can improve that rather than adding redundant language features.
>
> -Joe

The problem using an enum in this case is that the overall complexity will increase with every case that is being introduced. Using a sealed protocol a library developer can define a set of conforming types, that is applicable for usage.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/30a77aa0/attachment.html>

From kevin at sb.org  Thu Dec  3 18:33:52 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 16:33:52 -0800
Subject: [swift-evolution] ? suffix for <, >, <=,
>= comparisons with optionals to prevent subtle bugs
In-Reply-To: <CADcs6kNwuvZsWzbE2h8oNacViG3cN5iDz+SP12K8u6h5nhcEyg@mail.gmail.com>
References: <09C1AEA6-1707-44FB-BCA0-16A554706E03@me.com>
<CADcs6kNwuvZsWzbE2h8oNacViG3cN5iDz+SP12K8u6h5nhcEyg@mail.gmail.com>
Message-ID: <1449189232.2552846.457565097.7AC856D7@webmail.messagingengine.com>

I completely disagree. Being able to compare `Optional` values is very
handy in a lot of cases. Adding special syntax for this is just
unnecessary language complication, especially as the proposed syntax
conflicts with the existing meaning of the postfix-? operator and the
optional-chaining operator.

-Kevin Ballard

On Thu, Dec 3, 2015, at 04:17 PM, Jacob Bandes-Storch wrote:
> Agreed ? or, I think, these operators could/should simply be removed.
>
> I filed <rdar://22833869> about this a while ago, which was marked as
> Duplicate/<rdar://16966712>.
>
>> Summary:
>>
>> This returns true:
(nil as Int?) < 0 This also returns true, which makes even less
sense: (nil as Int?) < Int.min
>>
>>
>> Expected Results:
>>
>> nil < 0, nil > 0, and nil == 0, should all be false. nil != 0 should
>> be true.
Alternatively, just *don't* provide < and > operators that accept
optional arguments.
>>
>>
>> Actual Results:
>>
>> nil < 0 is true. Others are as expected.
>>
>
>
> See also: https://twitter.com/jtbandes/status/646914031433871364
>
>
> Jacob
>
> On Thu, Dec 3, 2015 at 3:42 PM, Amir Michail <a.michail at me.com> wrote:
>> Such comparisons with optionals can result in hard to find bugs.
>>
>>
For example consider:
>>
>>
let f = x < 5? // x is of type Int? and may be nil
>>
>>
The proposed ? suffix would be used as follows and makes the possibility
of nil very clear:
>>
>>
let f = x? < 5
>>
>>
>>
_______________________________________________
>>
swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/611af7d6/attachment.html>

From a.michail at me.com  Thu Dec  3 18:35:51 2015
From: a.michail at me.com (Amir Michail)
Date: Thu, 03 Dec 2015 19:35:51 -0500
Subject: [swift-evolution] You should be able to label a 1-tuple return
value as a way to document the return value.
Message-ID: <277F7B9E-3DEF-4C47-A3E1-6BE10D7DE23C@me.com>

For example:

func f(n:Int) -> (errorValue:Int) {
...
}

print(f(5).errorValue)


From jtbandes at gmail.com  Thu Dec  3 18:40:03 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Thu, 3 Dec 2015 16:40:03 -0800
Subject: [swift-evolution] ? suffix for <, >, <=,
>= comparisons with optionals to prevent subtle bugs
In-Reply-To: <1449189232.2552846.457565097.7AC856D7@webmail.messagingengine.com>
References: <09C1AEA6-1707-44FB-BCA0-16A554706E03@me.com>
<CADcs6kNwuvZsWzbE2h8oNacViG3cN5iDz+SP12K8u6h5nhcEyg@mail.gmail.com>
<1449189232.2552846.457565097.7AC856D7@webmail.messagingengine.com>
Message-ID: <CADcs6kO9gzexS0SDU3jwZJXmU53c5=EmJFu5C49idC9JUFEeSg@mail.gmail.com>

To me it seems logical that comparing Optional<Int> with Int (or another
Optional<Int>), if it's allowed at all, should return Optional<Bool>. Since
conditional statements only accept Bool, the user is forced to handle the
nil case explicitly.

Jacob

On Thu, Dec 3, 2015 at 4:33 PM, Kevin Ballard <kevin at sb.org> wrote:

> I completely disagree. Being able to compare `Optional` values is very
> handy in a lot of cases. Adding special syntax for this is just unnecessary
> language complication, especially as the proposed syntax conflicts with the
> existing meaning of the postfix-? operator and the optional-chaining
> operator.
>
> -Kevin Ballard
>
> On Thu, Dec 3, 2015, at 04:17 PM, Jacob Bandes-Storch wrote:
>
> Agreed ? or, I think, these operators could/should simply be removed.
>
> I filed <rdar://22833869> about this a while ago, which was marked as
> Duplicate/<rdar://16966712>.
>
>
> Summary:
> This returns true:
>     (nil as Int?) < 0
> This also returns true, which makes even less sense:
>     (nil as Int?) < Int.min
>
>
> Expected Results:
> nil < 0, nil > 0, and nil == 0, should all be false. nil != 0 should be true.
> Alternatively, just *don't* provide < and > operators that accept optional arguments.
>
>
> Actual Results:
> nil < 0 is true. Others are as expected.
>
>
> See also: https://twitter.com/jtbandes/status/646914031433871364
>
>
> Jacob
>
> On Thu, Dec 3, 2015 at 3:42 PM, Amir Michail <a.michail at me.com> wrote:
>
> Such comparisons with optionals can result in hard to find bugs.
>
> For example consider:
>
> let f = x < 5  // x is of type Int? and may be nil
>
> The proposed ? suffix would be used as follows and makes the possibility
> of nil very clear:
>
> let f = x? < 5
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> *_______________________________________________*
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/81254b24/attachment-0001.html>

From a.michail at me.com  Thu Dec  3 18:40:30 2015
From: a.michail at me.com (Amir Michail)
Date: Thu, 03 Dec 2015 19:40:30 -0500
Subject: [swift-evolution] if case 1, 2,
3 = x { ... } results in error in swift 2
Message-ID: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>

But "if case 1...3 = x { ... }" works.

Why?

From adrian.kashivskyy at me.com  Thu Dec  3 18:43:46 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 01:43:46 +0100
Subject: [swift-evolution] Proposal: Typed throws
Message-ID: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>

I'm sure you heard this request like a billion times already, but I'd like to be official and make a proper proposal for that. So having said that, I hereby propose adding support for typed `throws` annotations.

If a function can throw, it is often known what type of error it may throw. Consider this piece of code:

> enum NetworkError: ErrorType {
> 	case RequestTimeout
> 	case UnreachableHost
> }
>
> enum SearchError: ErrorType {
> 	case InvalidQuery
> }
>
> func search(query: String) throws {}
>
> func m() {
> 	do {
> 		try search("foo")
> 	} catch SearchError.InvalidQuery {
> 		print("your query is invalid")
> 	} catch is NetworkError {
> 		print("please check your internet connection")
> 	} catch {
> 		print("an unknown error occurred") // ???
> 	}
> }


In order for `do-catch` to be exhaustive, the vague `catch` block is required by the compiler, and inside of it, one has literally no idea what kind of error they deal with. This is useless or even dangerous for error handling, because the last `catch` often looks like this:

> catch {
> 	// don't know what that is, let's ignore that
> }

The situation above can be resolved by introducing typed error handling, so that the `search` function may be refactored to:

> func search(query: String) throws SearchError, NetworkError {}

Then, the requirement for last, opaque `catch` block can be completely removed as the compiler will make sure that only errors of the allowed types be thrown from `search`.

I will be happy to hear your comments on this.

?????

As a bonus, I prepared a short FAQ for my proposal:

Q: What if my function throws multiple error types?

Use comma-separated list of error types.

> func f() throws SomeError, OtherError {}

Q: What if I `try` a function which throws something completely different?

Then you have three possibilities:

1. You resolve the error in scope of the function, inside a `catch` block.
2. You convert it into a compatible type and `throw` it.
3. You annotate your `func` to be throwing that particular error as well.

Q: What about `rethrows`?

`rethrows` should become generic and throw anything that the closure arguments can throw.

> func f(g: () throws SomeError -> Void, h: () throws OtherError -> Void) rethrows {}
>
> // behaves like
>
> func f(g: () throws SomeError -> Void, h: () throws OtherError -> Void) throws SomeError, OtherError {}

Q: What if I want to use the old behavior?

Just annotate as `throws ErrorType` and you can throw anything from there.

> func f() throws ErrorType {}


Q: Is the failure path really as important as the success path?

Yes, it is.

Pozdrawiam ? Regards,
Adrian Kashivskyy

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/7448ed12/attachment.html>

From felix.gabel at me.com  Thu Dec  3 18:45:16 2015
From: felix.gabel at me.com (Felix Gabel)
Date: Fri, 04 Dec 2015 01:45:16 +0100
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
<CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>
Message-ID: <F1736E33-4853-4A20-BC5E-30A139712DB6@me.com>


> On Dec 4, 2015, at 12:25 AM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Thu, Dec 3, 2015 at 3:09 PM, Douglas Gregor <dgregor at apple.com <mailto:dgregor at apple.com>> wrote:
> >
> >> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com <mailto:felix.gabel at me.com>> wrote:
> >>
> >> Hey everyone,
> >>
> >> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
> >>
> >> Example:
> >>
> >> public sealed protocol FooType {
> >>    // this protocol can be conformed to only in scope of the library itself
> >>    // it can NOT be conformed to by any object declared outside the library
> >> }
> >>
> >> What do you think?
> >
> >
> > Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??
>
> There are cases when the library isn't designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.
>
> We have a case for it in the standard library, 'protocol AnyCollectionType'.  Foundation also has a use case -- property list types.
>
> Dmitri

- protocols starting with an underscore (_ArrayBufferType, _IntegerType, etc) would benefit from the ?sealed? modifier, because the contract right now only implicitly says: ?public but please don?t use?.
- another use case is grouping a set of types regardless their origin and limit the ability to extend the provided number of types by external forces


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/eff0486f/attachment.html>

From adrian.kashivskyy at me.com  Thu Dec  3 18:47:21 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 01:47:21 +0100
Subject: [swift-evolution] if case 1, 2,
3 = x { ... } results in error in swift 2
In-Reply-To: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>
References: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>
Message-ID: <3E89D917-A78F-47D8-BE6A-2099DED99535@me.com>

IIRC multiple case patterns in `if-case` are not yet supported due to compiler limitations.

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Amir Michail <a.michail at me.com> w dniu 04.12.2015, o godz. 01:40:
>
> But "if case 1...3 = x { ... }" works.
>
> Why?
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/1d47dcf3/attachment.html>

From eric.chamberlain at arctouch.com  Thu Dec  3 18:50:38 2015
From: eric.chamberlain at arctouch.com (Eric Chamberlain)
Date: Thu, 3 Dec 2015 16:50:38 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
Message-ID: <317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>

We?ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.

--
Eric Chamberlain, Lead Architect - iOS
ArcTouch - App Development Studio

Custom apps for world-class brands and the Fortune 500
arctouch.com/work | arctouch.com/blog



> On Dec 3, 2015, at 3:46 PM, Andy Matuschak <andy at andymatuschak.org> wrote:
>
> Just checked; ditto Khan Academy.
>
>> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com> wrote:
>>
>> For what it's worth we don't have a single C style for loop in the Lyft
>> codebase.
>>
>> --
>> Keith Smiley
>>
>> On 12/03, Douglas Gregor wrote:
>>>
>>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>
>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>
>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>
>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>
>>> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>>>
>>> 	- Doug
>>>
>>>
>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/2aafa092/attachment-0001.html>

From kevin at sb.org  Thu Dec  3 18:51:35 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 16:51:35 -0800
Subject: [swift-evolution] if case 1, 2,
3 = x { ... } results in error in swift 2
In-Reply-To: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>
References: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>
Message-ID: <1449190295.2732340.457576489.44D0C661@webmail.messagingengine.com>

`if case 1, 2, 3 = x {` does not work because case statements can only
contain a single pattern when used in an if/for/while. Only when found
in `switch` statements can they contain multiple comma-separated
patterns.

`if case 1...3 = x {` works because this a single pattern `1...3`, and
it's equivalent to saying `if 1...3 ~= x {` (`~=` is the operator that
is used for doing value comparisons in patterns, and it's implemented
for all `IntervalType`s to call `interval.contains(x)`).

Also, this seems like a question that's more appropriate for swift-users
than swift-evolution.

On Thu, Dec 3, 2015, at 04:40 PM, Amir Michail wrote:
> But "if case 1...3 = x { ... }" works.
>
> Why?
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From kevin at sb.org  Thu Dec  3 18:52:45 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 16:52:45 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
Message-ID: <1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>

Every time I've tried to use a C-style for loop, I've ended up switching
to a while loop because my iteration variable ended up having the wrong
type (e.g. having an optional type when the value must be non-optional
for the body to execute). The Postmates codebase contains no instances
of C-style for loops in Swift.

-Kevin Ballard

On Thu, Dec 3, 2015, at 04:50 PM, Eric Chamberlain wrote:
> We?ve developed a number of Swift apps for various clients over the
> past year and have not needed C style for loops either.
>
>
> --
> Eric Chamberlain, Lead Architect - iOS ArcTouch - App
> Development Studio
>
> Custom apps for world-class brands and the Fortune 500
> arctouch.com/work | arctouch.com/blog
>
>
>
>
>> On Dec 3, 2015, at 3:46 PM, Andy Matuschak
>> <andy at andymatuschak.org> wrote:
>>
>> Just checked; ditto Khan Academy.
>>
>>> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com>
>>> wrote:
>>>
>>> For what it's worth we don't have a single C style for loop in the
>>> Lyft codebase.
>>>
>>> --
>>> Keith Smiley
>>>
>>> On 12/03, Douglas Gregor wrote:
>>>>
>>>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com>
>>>>> wrote:
>>>>>
>>>>> Does Swift still needs C-style for loops with conditions and
>>>>> incrementers?
>>>>>
>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>
>>>>> More Swift-like construction is already available with for-in-
>>>>> statements and stride. This would naturally starve the most common
>>>>> point for -- and ++ operators as well.
>>>>
>>>> My intuition *completely* agrees that Swift no longer needs C-style
>>>> for loops. We have richer, better-structured looping and functional
>>>> algorithms. That said, one bit of data I?d like to see is how often
>>>> C-style for loops are actually used in Swift. It?s something a
>>>> quick crawl through Swift sources on GitHub could establish. If the
>>>> feature feels anachronistic and is rarely used, it?s a good
>>>> candidate for removal.
>>>>
>>>> - Doug
>>>>
>>>>
>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/f2110093/attachment.html>

From adrian.kashivskyy at me.com  Thu Dec  3 18:53:36 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 01:53:36 +0100
Subject: [swift-evolution] Proposal: Sealed protocols
In-Reply-To: <F1736E33-4853-4A20-BC5E-30A139712DB6@me.com>
References: <61A2A8D8-3923-498C-8D22-DA15A2739F63@me.com>
<8ED111FF-1DC1-4231-B112-50EB420C9884@apple.com>
<CA+Y5xYdZW+Jwn8mC+xohSPLgLy0hghAJM3a3s_ibwkfB_Cc2bw@mail.gmail.com>
<F1736E33-4853-4A20-BC5E-30A139712DB6@me.com>
Message-ID: <937D2E61-688E-423F-B060-5E8870D869AE@me.com>

> protocols starting with an underscore (_ArrayBufferType, _IntegerType, etc) would benefit from the ?sealed? modifier, because the contract right now only implicitly says: ?public but please don?t use?.

I think it's wiser to refactor those protocols to be public and fully usable than to insert another access modifier to a language. Contracts that say "public but please don?t use" are generally a sign of design that is poor or limited by language/compiler.

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Felix Gabel <felix.gabel at me.com> w dniu 04.12.2015, o godz. 01:45:
>
>>
>> On Dec 4, 2015, at 12:25 AM, Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>> wrote:
>>
>> On Thu, Dec 3, 2015 at 3:09 PM, Douglas Gregor <dgregor at apple.com <mailto:dgregor at apple.com>> wrote:
>> >
>> >> On Dec 3, 2015, at 2:59 PM, Felix Gabel <felix.gabel at me.com <mailto:felix.gabel at me.com>> wrote:
>> >>
>> >> Hey everyone,
>> >>
>> >> I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.
>> >>
>> >> Example:
>> >>
>> >> public sealed protocol FooType {
>> >>    // this protocol can be conformed to only in scope of the library itself
>> >>    // it can NOT be conformed to by any object declared outside the library
>> >> }
>> >>
>> >> What do you think?
>> >
>> >
>> > Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??
>>
>> There are cases when the library isn't designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.
>>
>> We have a case for it in the standard library, 'protocol AnyCollectionType'.  Foundation also has a use case -- property list types.
>>
>> Dmitri
>
> - protocols starting with an underscore (_ArrayBufferType, _IntegerType, etc) would benefit from the ?sealed? modifier, because the contract right now only implicitly says: ?public but please don?t use?.
> - another use case is grouping a set of types regardless their origin and limit the ability to extend the provided number of types by external forces
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/791855cc/attachment-0001.html>

From a.michail at me.com  Thu Dec  3 18:55:18 2015
From: a.michail at me.com (Amir Michail)
Date: Thu, 03 Dec 2015 19:55:18 -0500
Subject: [swift-evolution] if case 1, 2,
3 = x { ... } results in error in swift 2
In-Reply-To: <1449190295.2732340.457576489.44D0C661@webmail.messagingengine.com>
References: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>
<1449190295.2732340.457576489.44D0C661@webmail.messagingengine.com>
Message-ID: <33E610B6-6CE9-4AAF-86A7-DB98F610E3DB@me.com>


> On Dec 3, 2015, at 7:51 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> `if case 1, 2, 3 = x {` does not work because case statements can only
> contain a single pattern when used in an if/for/while. Only when found
> in `switch` statements can they contain multiple comma-separated
> patterns.

But why aren?t multiple comma-separated patterns supported in if/for/while just like in switch statements?

I think they should be.

>
> `if case 1...3 = x {` works because this a single pattern `1...3`, and
> it's equivalent to saying `if 1...3 ~= x {` (`~=` is the operator that
> is used for doing value comparisons in patterns, and it's implemented
> for all `IntervalType`s to call `interval.contains(x)`).
>
> Also, this seems like a question that's more appropriate for swift-users
> than swift-evolution.
>
> On Thu, Dec 3, 2015, at 04:40 PM, Amir Michail wrote:
>> But "if case 1...3 = x { ... }" works.
>>
>> Why?
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From erica at ericasadun.com  Thu Dec  3 19:00:09 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Thu, 3 Dec 2015 18:00:09 -0700
Subject: [swift-evolution] NDAs, Open Source, and the Iron Curtain
Message-ID: <E5BD5629-914C-4542-AD2F-5679970B5FC4@ericasadun.com>

Can we take it as a given that all language development is now out and in the clear and that, outside of specific dev-tool enhancements, we will transparently see the full progression of incorporated, proposed, and planned changes through this list, the repo, and the swift.org <http://swift.org/> site?

Thanks in advance for clarification. -- Erica

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/b8e3d8a1/attachment.html>

From kevin at sb.org  Thu Dec  3 19:04:41 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 17:04:41 -0800
Subject: [swift-evolution] if case 1, 2,
3 = x { ... } results in error in swift 2
In-Reply-To: <33E610B6-6CE9-4AAF-86A7-DB98F610E3DB@me.com>
References: <4862E074-C4AF-4153-9258-E5DD004376CA@me.com>
<1449190295.2732340.457576489.44D0C661@webmail.messagingengine.com>
<33E610B6-6CE9-4AAF-86A7-DB98F610E3DB@me.com>
Message-ID: <1449191081.3373125.457586625.001C3E32@webmail.messagingengine.com>

Ah, so you're proposing that the syntax be changed, rather than merely
asking why the code doesn't work? That makes sense.

As for why it's not supported now, I don't know. Maybe there's some
syntactic ambiguity in allowing it? Or maybe there was just concern
about it being confusing. Hopefully someone involved in the
implementation of it can answer this.

-Kevin Ballard

On Thu, Dec 3, 2015, at 04:55 PM, Amir Michail wrote:
>
> > On Dec 3, 2015, at 7:51 PM, Kevin Ballard <kevin at sb.org> wrote:
> >
> > `if case 1, 2, 3 = x {` does not work because case statements can only
> > contain a single pattern when used in an if/for/while. Only when found
> > in `switch` statements can they contain multiple comma-separated
> > patterns.
>
> But why aren?t multiple comma-separated patterns supported in
> if/for/while just like in switch statements?
>
> I think they should be.
>
> >
> > `if case 1...3 = x {` works because this a single pattern `1...3`, and
> > it's equivalent to saying `if 1...3 ~= x {` (`~=` is the operator that
> > is used for doing value comparisons in patterns, and it's implemented
> > for all `IntervalType`s to call `interval.contains(x)`).
> >
> > Also, this seems like a question that's more appropriate for swift-users
> > than swift-evolution.
> >
> > On Thu, Dec 3, 2015, at 04:40 PM, Amir Michail wrote:
> >> But "if case 1...3 = x { ... }" works.
> >>
> >> Why?
> >> _______________________________________________
> >> swift-evolution mailing list
> >> swift-evolution at swift.org
> >> https://lists.swift.org/mailman/listinfo/swift-evolution
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>

From xcvista at me.com  Thu Dec  3 19:57:18 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 09:57:18 +0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
Message-ID: <6F2B93A1-6414-4910-B280-80292A1BCF64@me.com>

Swift without Objective-C support will miss out a few important pieces that is crucial to the success of Objective-C outside OS X:

1) AppKit and UIKit. Both GNUstep and Cocotron have their version of AppKit and GNUstep even have a version of UIKit. Missing this means there is no way writing portable Swift app that have any form of GUI.
2) WebObjects. I know that Apple deprecated WebObjects for Objective-C long ago, but its clone in GNUstep is still used and maintained. Missing out this means that you cannot easily write Web applications using Swift on Linux without going back to CGI or FastCGI - kind of defeats its purpose isn?t it?
3) Code compatibility. One of the best features of both Cocotron and GNUstep is that it allows OS X app to be ported to other platforms without changing its code. This Swift apparently won?t do this.

Max

> On Dec 4, 2015, at 06:13, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 12:01 PM, Maxthon Chan <xcvista at me.com> wrote:
>>
>> Dear Swift developers:
>>
>> Maybe you have never heard of it, but there have been several ongoing efforts, like GNUstep and Cocotron, at maintaining an open source Foundation reimplementation for alternative operating systems like Linux. It seemed to me that the current release of Swift did not put such efforts into consideration and brutally broke compatibility between Swift and Objective-C on Linux. I understand the fact that Apple is unwilling to release source code of Foundation, and this is usually where those alternative implementations comes into play.
>
> Hi Maxthon,
>
> Thanks for your interest, we?re definitely aware of GNUstep and Cocotron.
>
> As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.
>
> We?re aware that this means that it will take longer for the Swift Foundation to be fully operational and useful, but that is a tradeoff we?re willing to make.  You are of course welcome to make Swift work with GNUstep or Cocotron if you?re interested in doing that, but that seems outside the charter of the work on Swift Foundation.
>
> -Chris
>
>
>>
>> Some of such projects, like GNUstep, are mature enough to allow existing AppKit applications written in Objective-C, like TextEdit and Chess, to be ported from OS X to Linux and Windows without changing too much, if any, code, taking all modern Objective-C features like ARC and object subscripting with stride, with a compatible version of LLVM compiler. Meanwhile, with the current version of Swift, even if the Swift code is written with calls to Objective-C runtime assuming the case on OS X, it is broken under Linux even with libobjc linked in.
>>
>> I am here suggesting keeping the Objective-C bridge intact at least when built with a compatible version of libobjc (and GNUstep project have one already.) This will allow users of such alternative Foundation reimplementations to use their favourite Foundation distribution in place of the version provided by the Swift project, retaining the code compatibility already established between OS X and Linux by those Swift reimplementations.
>>
>> In such an environment the alternative Foundation implementation will provide their own version of CoreFoundation and Foundation, implemented using C and Objective-C, as well as a libobjc that supports ARC. The Swift environment would be built without its own CoreFoundation and Foundation, but linking against the provided version instead, bridging calls just like OS X version of Swift does. This will also allow the new Swift platform to take full advantage of the AppKit came with the alternative Foundation, allow porting full OS X apps to Linux a lot easier. The above also applies for porting iOS apps, if the alternative Foundation implementation also comes with their own UIKit.
>>
>> Max_______________________________________________
>> swift-corelibs-dev mailing list
>> swift-corelibs-dev at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev
>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8006ccb1/attachment.p7s>

From xcvista at me.com  Thu Dec  3 20:01:49 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 10:01:49 +0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <1EE658E9-D747-4322-9E47-DA22AD261097@apple.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<CADcs6kPg9oQEsUSz0T-ThtY2VCtKnQSwAPY1nrDyi8r6RiNR8A@mail.gmail.com>
<1EE658E9-D747-4322-9E47-DA22AD261097@apple.com>
Message-ID: <2D3BF3C1-E974-4018-A9DE-29D807CE735C@me.com>

Both GNUstep and Cocotron have already achieved this ?OS independence and portability? better than you think, on a wider variety of platforms - Linux as well as Windows and FreeBSD. So if you open up the Objective-C compatibility layer and leave the Foundation to them you may have even better OS independence.

> On Dec 4, 2015, at 06:46, Tony Parker <anthony.parker at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 2:37 PM, Jacob Bandes-Storch <jtbandes at gmail.com <mailto:jtbandes at gmail.com>> wrote:
>>
>> Thanks, Tony.
>>
>> On Thu, Dec 3, 2015 at 2:33 PM, Tony Parker <anthony.parker at apple.com <mailto:anthony.parker at apple.com>> wrote:
>> It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.
>>
>> Agreed. I look forward to it :)  I'm just concerned that users will expect behavior to exactly match their equivalent Obj-C code. If these bugs are fixed / APIs are refined in corelibs-foundation, that expectation might be broken.
>
> Indeed, a very good point and something we are actively thinking about.
>
> An important goal of our project is to provide a layer of OS independence and portability. There may be times when we have a bug in the Obj-C implementation that we therefore decide to reflect in the Swift implementation as well, because the inconsistency would otherwise be a problem. Hopefully this doesn?t happen too often. I?d rather fix the bug in the Obj-C implementation as well, but there are always going to be tradeoffs to make.
>
> We have lots of experience making changes to Foundation underneath apps and keeping things compatible. I think we?ll certainly be using some of that as we move forward with the Swift Foundation implementation as well. For example, we may choose to deprecate a confusing (or wrong) API and replace it with something better. We?d like the bar for changing API to be very high, though, so that we can provide as much stability to clients as possible.
>
> Thanks,
> - Tony
>
>
>>
>> So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org <http://bugs.swift.org/>. We can take this opportunity to try to make it better for everyone.
>>
>> Will do!
>
>
> _______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/1caf06bc/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/1caf06bc/attachment-0001.p7s>

From me at tal.by  Thu Dec  3 20:10:06 2015
From: me at tal.by (Tal Atlas)
Date: Fri, 04 Dec 2015 02:10:06 +0000
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
<D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>
Message-ID: <CA+ddMk2FP8t=KiZEfMbdZQXkir6db+4TiWWe-FEUymToreyaeQ@mail.gmail.com>

Thanks for the great info. I made this because I didn't see anything on the
current plan and I really hope that whatever comes out has the power and
ease of the proposal.

Thanks again for the great responses.

On Thu, Dec 3, 2015 at 5:43 PM Joe Groff <jgroff at apple.com> wrote:

>
> On Dec 3, 2015, at 2:12 PM, Tal Atlas <me at tal.by> wrote:
>
> With the awesome expansion of protocol oriented programming that swift has
> allowed, the lack of generic protocols has felt noticeably lacking and
> painful in some cases. I made an in depth proposal here:
> https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md
>
> But the tl;dr is this:
>
> protocol Validator<TypeToValidate> {
>   var value: TypeToValidate { get set }
>   var valueIfValid: TypeToValidate? { get }
> }
>
> struct FooStringValidator: Validator<String> {
>   //... implementation
> }
>
> let stringValidator: Validator<String>
>
>
> The lack of protocol type erasure when associated types are involved is
> definitely a big problem, and one we'd like to address. However, I don't
> think moving wholesale to modeling associated types this way is feasible.
> Many of the standard library protocols have a lot of associated types.
> 'CollectionType' for instance has its 'Index' type while also inheriting a
> 'Generator' from SequenceType, and neither of these is what you typically
> want to parameterize a collection on?you'd want 'CollectionType<Int>'
> ideally to refer to a collection whose *Element* is Int without having to
> fully specify the generator and index if you don't care about them. Swift's
> protocols also support type system features that make some erased protocol
> types not actual models of their own protocols; `Equatable` is notorious
> for this, since a type being `Equatable` to its own values does not mean it
> can be equated to arbitrary other types; `1 == "1"` is nonsense for
> instance. We have a number of issues that need to be considered here; don't
> worry, we are considering them!
>
> -Joe
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8c55520b/attachment.html>

From jgroff at apple.com  Thu Dec  3 20:19:22 2015
From: jgroff at apple.com (Joe Groff)
Date: Thu, 03 Dec 2015 18:19:22 -0800
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <CA+ddMk2FP8t=KiZEfMbdZQXkir6db+4TiWWe-FEUymToreyaeQ@mail.gmail.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
<D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>
<CA+ddMk2FP8t=KiZEfMbdZQXkir6db+4TiWWe-FEUymToreyaeQ@mail.gmail.com>
Message-ID: <A89CD21B-A476-4203-9DC8-57E0BB0A5732@apple.com>


> On Dec 3, 2015, at 6:10 PM, Tal Atlas <me at tal.by> wrote:
>
> Thanks for the great info. I made this because I didn't see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal.
>
> Thanks again for the great responses.

No problem, thank you for writing this up! If you want to think about this more, some things you might consider:

- What changes would be necessary to the standard library to make the most of this feature? Some particular problems we'd like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons' Swift diary posts at http://inessential.com/swiftdiary for an example of why the latter is important.
- A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.

Thanks again!

-Joe

From david at alkaline-solutions.com  Thu Dec  3 20:25:21 2015
From: david at alkaline-solutions.com (David Waite)
Date: Thu, 3 Dec 2015 19:25:21 -0700
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
Message-ID: <2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>

I might argue that if let is already an odd case; people often read it equivalent to "if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, 'let x=x? on its own could not have the same behavior.

In that spirit, I propose an alternative feature:

if foo? { ? }

where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.

so for example:

func foo(x:Int?) {
if var x = x { // var so it can be assigned
x++
}
print(x)
}

foo(1) // => 1, updating the aliased x does not do anything

# working code in Swift 1.2
func bar(x:Int?) {
var y=x
if let x=x {
y=x+1
}
print(y)
}
bar(1) # => Optional(2)

# proposed
func proposed(x:Int?) {
var y = x // since swift 3 won't have var function arguments
if y? { // var so it can be assigned
y++
}
print(y)
}

proposed(1) // => Optional(2)

-DW

> On Dec 3, 2015, at 3:42 PM, Chris Lattner <clattner at apple.com> wrote:
>
>
> ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.
>
> I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>
> Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.
>
> -Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ca68b90b/attachment-0001.html>

From taruntyagi697 at gmail.com  Thu Dec  3 20:34:30 2015
From: taruntyagi697 at gmail.com (Tarun Tyagi)
Date: Fri, 4 Dec 2015 08:04:30 +0530
Subject: [swift-evolution] Proposal : Introduction of System Defined UI
Variables - ScreenSize, IsPad.
Message-ID: <85FE8CE6-1712-4F65-9173-8DF83B1A17B4@gmail.com>

Hi Guys

I would like to propose a small addition. Please have a look at following and let me know your thoughts -

Proposal : Introduction of System Defined UI Variables - ScreenSize, IsPad.

Motivation : All of us know that we have a pretty good set of methods that can provide us this information. UIScreen is there to provide this. But when the app supports autorotation, in landscape, it's width becomes height and vice-versa, leaving developer to figure out what the current width and height is.
This forces developer to write some lines of unnecessary code every time an app starts supporting autorotation. If we had system defined variables, we could easily rely on them, regardless of current orientation.

Use Case : When app receives an autorotation event, we need to perform changes to our UI accordingly where it needs these ScreenSize(updated) & IsPad variables.

Note : Everybody is aware that -
Autolayout takes care of the most issues down this line.
Calculations(on mere change of orientation) are rarely needed when you correctly use Autolayout.

But we can never rule out the possibility. A system defined variable comes to quick rescue.


Does it go along Swift's Evolution?
Obviously, a short and smart addition to developer toolkit.


Does it break any existing code?
Absolutely No.


Advantages : A lot of unnecessary code can be abstracted from user providing a clean interface that facilitates the needed info (updated to current orientation) using a reliable system variable.

Has it been considered before?
Yes, revised autorotation approach (Adaptive)

func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator)

is a place to look at. Yes, it specifically handles the use case that I described above. But does it eliminate the need of ScreenSize? Not Completely.


It gets along with a super smart language Swift's evolution direction and should be welcomed by most of the developers.

Let me know your thoughts.


Thanks!

Tarun.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8f2db525/attachment.html>

From david_smith at apple.com  Thu Dec  3 20:36:37 2015
From: david_smith at apple.com (David Smith)
Date: Thu, 03 Dec 2015 18:36:37 -0800
Subject: [swift-evolution] Proposal : Introduction of System Defined UI
Variables - ScreenSize, IsPad.
In-Reply-To: <85FE8CE6-1712-4F65-9173-8DF83B1A17B4@gmail.com>
References: <85FE8CE6-1712-4F65-9173-8DF83B1A17B4@gmail.com>
Message-ID: <40A81810-5710-4058-98F8-D583EF8FA4FE@apple.com>

Hi Tarun,

What were you envisioning the value of these would be on devices with no screen? This seems like a proposal more suited to a UI framework.

David

> On Dec 3, 2015, at 6:34 PM, Tarun Tyagi <taruntyagi697 at gmail.com> wrote:
>
> Hi Guys
>
> I would like to propose a small addition. Please have a look at following and let me know your thoughts -
>
> Proposal : Introduction of System Defined UI Variables - ScreenSize, IsPad.
>
> Motivation : All of us know that we have a pretty good set of methods that can provide us this information. UIScreen is there to provide this. But when the app supports autorotation, in landscape, it's width becomes height and vice-versa, leaving developer to figure out what the current width and height is.
> This forces developer to write some lines of unnecessary code every time an app starts supporting autorotation. If we had system defined variables, we could easily rely on them, regardless of current orientation.
>
> Use Case : When app receives an autorotation event, we need to perform changes to our UI accordingly where it needs these ScreenSize(updated) & IsPad variables.
>
> Note : Everybody is aware that -
> Autolayout takes care of the most issues down this line.
> Calculations(on mere change of orientation) are rarely needed when you correctly use Autolayout.
>
> But we can never rule out the possibility. A system defined variable comes to quick rescue.
>
>
> Does it go along Swift's Evolution?
> Obviously, a short and smart addition to developer toolkit.
>
>
> Does it break any existing code?
> Absolutely No.
>
>
> Advantages : A lot of unnecessary code can be abstracted from user providing a clean interface that facilitates the needed info (updated to current orientation) using a reliable system variable.
>
> Has it been considered before?
> Yes, revised autorotation approach (Adaptive)
>
> func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator)
>
> is a place to look at. Yes, it specifically handles the use case that I described above. But does it eliminate the need of ScreenSize? Not Completely.
>
>
> It gets along with a super smart language Swift's evolution direction and should be welcomed by most of the developers.
>
> Let me know your thoughts.
>
>
> Thanks!
>
> Tarun.
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/eb7dac83/attachment-0001.html>

From austinzheng at gmail.com  Thu Dec  3 20:52:20 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Thu, 3 Dec 2015 18:52:20 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
Message-ID: <CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>

Thanks, Chris and Dmitri! I will do some research and write something up
over the weekend.

Austin

On Thu, Dec 3, 2015 at 2:24 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:

> On Thu, Dec 3, 2015 at 1:14 PM, Austin Zheng <austinzheng at gmail.com>
> wrote:
> >
> > Hi all,
> >
> > There are quite a few programming languages that provide support for
> numeric types apart from the customary floating-point and fixed-width
> integer types. Prominent examples of additional numeric types include
> rational numbers, arbitrary-width integer types, and fixed-point numbers.
> Many of these numeric types are applicable to a wide variety of problem
> domains.
>
> >
> > Swift seems like it would be a good fit for stdlib implementation of
> some of these numeric types. Structs and value semantics, literal
> initialization, and operator overloading would allow such types to be
> treated as first-class citizens. Is the community amenable to such a
> proposal, which would entail the data structures themselves, arithmetic
> operations, and interoperation between different numeric types to form a
> numerical tower of sorts?
>
> Hi Austin,
>
> We are interested in improving our numerics support, and we are
> definitely interested in hearing your ideas in this space.  You don't
> have to write a full proposal though.  Just an extended email to
> swift-evolution would be a good start.
>
> You can find the current prototype for library support for integers
> here:
> https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/d1153422/attachment.html>

From kenferry at gmail.com  Thu Dec  3 20:58:38 2015
From: kenferry at gmail.com (Ken Ferry)
Date: Thu, 3 Dec 2015 18:58:38 -0800
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <A89CD21B-A476-4203-9DC8-57E0BB0A5732@apple.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
<D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>
<CA+ddMk2FP8t=KiZEfMbdZQXkir6db+4TiWWe-FEUymToreyaeQ@mail.gmail.com>
<A89CD21B-A476-4203-9DC8-57E0BB0A5732@apple.com>
Message-ID: <C52A0CA9-832D-4983-AC9D-7A874D187926@gmail.com>

How about something along the lines of

protocol Foo {
func doThing() -> <C:CollectionType, C.Generator.Element == Int>C
}

let coll : <MyColl>MyColl = foo.doThing()
print("got \(coll)!")

which compiles to be equivalent to

protocol Foo {
func doThing(callback:FooDoThingCallback)
}

protocol FooDoThingCallback {
func callback<C : CollectionType where C.Generator.Element == Int>(coll:C)
}

foo.doThing(MyCallback())
struct MyCallback : FooDoThingCallback {
func callback<C : CollectionType where C.Generator.Element == Int>(coll:C) {
print("got \(coll)!")
}
}

-ken

> On Dec 3, 2015, at 6:19 PM, Joe Groff <jgroff at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 6:10 PM, Tal Atlas <me at tal.by> wrote:
>>
>> Thanks for the great info. I made this because I didn't see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal.
>>
>> Thanks again for the great responses.
>
> No problem, thank you for writing this up! If you want to think about this more, some things you might consider:
>
> - What changes would be necessary to the standard library to make the most of this feature? Some particular problems we'd like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons' Swift diary posts at http://inessential.com/swiftdiary for an example of why the latter is important.
> - A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.
>
> Thanks again!
>
> -Joe
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/dc79ce2e/attachment.html>

From kenferry at gmail.com  Thu Dec  3 20:59:12 2015
From: kenferry at gmail.com (Ken Ferry)
Date: Thu, 3 Dec 2015 18:59:12 -0800
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <A89CD21B-A476-4203-9DC8-57E0BB0A5732@apple.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
<D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>
<CA+ddMk2FP8t=KiZEfMbdZQXkir6db+4TiWWe-FEUymToreyaeQ@mail.gmail.com>
<A89CD21B-A476-4203-9DC8-57E0BB0A5732@apple.com>
Message-ID: <7DEF8225-B295-4329-8C72-DEC1449EE1B2@gmail.com>

How about something along the lines of

protocol Foo {
func doThing() -> <C:CollectionType, C.Generator.Element == Int>C
}

let coll : <MyColl>MyColl = foo.doThing()
print("got \(coll)!")

which compiles to be equivalent to

protocol Foo {
func doThing(callback:FooDoThingCallback)
}

protocol FooDoThingCallback {
func callback<C : CollectionType where C.Generator.Element == Int>(coll:C)
}

foo.doThing(MyCallback())
struct MyCallback : FooDoThingCallback {
func callback<C : CollectionType where C.Generator.Element == Int>(coll:C) {
print("got \(coll)!")
}
}

-ken

> On Dec 3, 2015, at 6:19 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>
>
>> On Dec 3, 2015, at 6:10 PM, Tal Atlas <me at tal.by <mailto:me at tal.by>> wrote:
>>
>> Thanks for the great info. I made this because I didn't see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal.
>>
>> Thanks again for the great responses.
>
> No problem, thank you for writing this up! If you want to think about this more, some things you might consider:
>
> - What changes would be necessary to the standard library to make the most of this feature? Some particular problems we'd like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons' Swift diary posts at http://inessential.com/swiftdiary <http://inessential.com/swiftdiary> for an example of why the latter is important.
> - A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.
>
> Thanks again!
>
> -Joe
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/df77e5f8/attachment-0001.html>

From sean at fifthace.com  Thu Dec  3 21:13:16 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 21:13:16 -0600
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
Message-ID: <463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>

What about lifting the whole concept out of "if" or "guard" and making a new construct that directly communicates the intent?

For example:

when foo { ... }

Which could be combined with "where" to generate an if-like construct:

when foo where foo.isSomething { ... }

Inside the code block, you can access foo directly and it isn't shadowed - so if it was a var, it is mutable, etc.

l8r
Sean


> On Dec 3, 2015, at 8:25 PM, David Waite <david at alkaline-solutions.com> wrote:
>
> I might argue that if let is already an odd case; people often read it equivalent to "if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, 'let x=x? on its own could not have the same behavior.
>
> In that spirit, I propose an alternative feature:
>
> if foo? { ? }
>
> where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.
>
> so for example:
>
>  func foo(x:Int?) {
>      if var x = x { // var so it can be assigned
>          x++
>      }
>      print(x)
>  }
>
> foo(1) // => 1, updating the aliased x does not do anything
>
> # working code in Swift 1.2
>  func bar(x:Int?) {
>      var y=x
>      if let x=x {
>          y=x+1
>      }
>      print(y)
>  }
> bar(1) # => Optional(2)
>
> # proposed
> func proposed(x:Int?) {
>      var y = x // since swift 3 won't have var function arguments
>      if y? { // var so it can be assigned
>          y++
>      }
>      print(y)
>  }
>
> proposed(1) // => Optional(2)
>
> -DW
>
>> On Dec 3, 2015, at 3:42 PM, Chris Lattner <clattner at apple.com> wrote:
>>
>>
>> ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.
>>
>> I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>>
>> Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.
>>
>> -Chris
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/6a96e180/attachment.html>

From kenferry at gmail.com  Thu Dec  3 21:31:44 2015
From: kenferry at gmail.com (Ken Ferry)
Date: Thu, 3 Dec 2015 19:31:44 -0800
Subject: [swift-evolution] Proposal for generic protocols
In-Reply-To: <7DEF8225-B295-4329-8C72-DEC1449EE1B2@gmail.com>
References: <CA+ddMk36QSJip81UPKr3dXKfTLp695p75ayyvtmsdGk6Q7zEaw@mail.gmail.com>
<D2946B1F-795A-48A6-9C28-510C1FEE5864@apple.com>
<CA+ddMk2FP8t=KiZEfMbdZQXkir6db+4TiWWe-FEUymToreyaeQ@mail.gmail.com>
<A89CD21B-A476-4203-9DC8-57E0BB0A5732@apple.com>
<7DEF8225-B295-4329-8C72-DEC1449EE1B2@gmail.com>
Message-ID: <352AC434-EF52-46B4-B4B3-30633D67004C@gmail.com>

Oops, I messed that up a bit. I meant equivalent codegen to

protocol Foo {
func doThing<CB : FooDoThingCallback>(callback:CB)
}

protocol FooDoThingCallback {
func callback<C : CollectionType where C.Generator.Element == Int>(coll:C)
}

foo.doThing(Callback())
struct Callback : FooDoThingCallback {
func callback<C : CollectionType where C.Generator.Element == Int>(coll:C) {
print("got \(coll)!")
}
}


> On Dec 3, 2015, at 6:59 PM, Ken Ferry <kenferry at gmail.com> wrote:
>
> How about something along the lines of
>
> 	protocol Foo {
> 	    func doThing() -> <C:CollectionType, C.Generator.Element == Int>C
> 	}
>
> 	let coll : <MyColl>MyColl = foo.doThing()
> 	print("got \(coll)!")
>
> which compiles to be equivalent to
>
> 	protocol Foo {
> 	    func doThing(callback:FooDoThingCallback)
> 	}
>
> 	protocol FooDoThingCallback {
> 	    func callback<C : CollectionType where C.Generator.Element == Int>(coll:C)
> 	}
>
> 	    foo.doThing(MyCallback())
>   	struct MyCallback : FooDoThingCallback {
>             func callback<C : CollectionType where C.Generator.Element == Int>(coll:C) {
> 	        print("got \(coll)!")
> 	    }
> 	}
>
> -ken
>
>> On Dec 3, 2015, at 6:19 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>
>>
>>> On Dec 3, 2015, at 6:10 PM, Tal Atlas <me at tal.by <mailto:me at tal.by>> wrote:
>>>
>>> Thanks for the great info. I made this because I didn't see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal.
>>>
>>> Thanks again for the great responses.
>>
>> No problem, thank you for writing this up! If you want to think about this more, some things you might consider:
>>
>> - What changes would be necessary to the standard library to make the most of this feature? Some particular problems we'd like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons' Swift diary posts at http://inessential.com/swiftdiary <http://inessential.com/swiftdiary> for an example of why the latter is important.
>> - A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.
>>
>> Thanks again!
>>
>> -Joe
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/66e11ec2/attachment-0001.html>

From cheyo at masters3d.com  Thu Dec  3 21:58:19 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Thu, 3 Dec 2015 21:58:19 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
Message-ID: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>

Would you consider replacing the C style ?: ternary operator to something
that does not use the question mark and colon ?

The use of "?" can be confusing when speed reading code with optionals.

Consider this code as somebody learning swift as their first language.

let result = !condition ? 1 : 2

Some alternatives:

Haskel

if predicate then expr1 else expr2

Python

result = x if a > b else y

The advantage of not using the question mark is that the language will be
more consistency on the use of "?" to mean only optionals.


References:
https://devforums.apple.com/message/1020139#1020139
https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/0c2152f9/attachment.html>

From gribozavr at gmail.com  Thu Dec  3 22:29:06 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Thu, 3 Dec 2015 20:29:06 -0800
Subject: [swift-evolution] Pluggable hash algorithm for containers
In-Reply-To: <8F9F94DC-3991-457C-A145-FD3CC887D535@gmail.com>
References: <8F9F94DC-3991-457C-A145-FD3CC887D535@gmail.com>
Message-ID: <CA+Y5xYc_M3S+hPERVd4kHvjZARgD=2srgN4a0wJ4OAAhqQw42Q@mail.gmail.com>

On Thu, Dec 3, 2015 at 4:14 PM, Ray Fix <rayfix at gmail.com> wrote:
>
> Last year, Howard Hinnant proposed a composable hash algorithm framework for C++ that I was impressed with.
>
> His proposal is here: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html
> A live presentation is here: https://www.youtube.com/watch?v=Njjp_MJsgt8
>
> A type with multiple fields you inevitably want to do a hash_combine but this pollutes the hashing algorithm.  It turns out that (nearly) all hashing algorithms can be abstracted into 3 phases: initialization, digestion and finalization.  It might be cool if Swift Hashable adopted this pluggable architecture.

Hi Ray,

A prototype is here (written before Howard's talk, so it probably uses
different terms):

https://github.com/apple/swift/blob/master/validation-test/stdlib/HashingPrototype.swift

However, I couldn't make it interoperate with NSObject.hash in both
directions: you should be able to override 'var hash' and get an
implementation of Hashable based on that, and vice versa.  It could be
solvable with protocol extensions now, I haven't looked at that
prototype for more than a year -- help and patches appreciated.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From dan.appel00 at gmail.com  Thu Dec  3 22:48:04 2015
From: dan.appel00 at gmail.com (Dan Appel)
Date: Fri, 04 Dec 2015 04:48:04 +0000
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
Message-ID: <CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>

I agree that ternary can make code unreadable, especially so with the ???.
I personally like the Haskel option the most, but it introduces a new
keyword ?then?, which isn?t great either. Python?s "y if x else z" is
therefore, in my opinion, the best alternative.

Also, I found it interesting how split the Rust community was about
removing the ternary operator.

?
Dan Appel

On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com> wrote:

> Would you consider replacing the C style ?: ternary operator to something
> that does not use the question mark and colon ?
>
> The use of "?" can be confusing when speed reading code with optionals.
>
> Consider this code as somebody learning swift as their first language.
>
> let result = !condition ? 1 : 2
>
> Some alternatives:
>
> Haskel
>
> if predicate then expr1 else expr2
>
> Python
>
> result = x if a > b else y
>
> The advantage of not using the question mark is that the language will be
> more consistency on the use of "?" to mean only optionals.
>
>
> References:
> https://devforums.apple.com/message/1020139#1020139
> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/121b0e2f/attachment.html>

From bee.ography at gmail.com  Thu Dec  3 22:53:51 2015
From: bee.ography at gmail.com (Bee)
Date: Fri, 4 Dec 2015 11:53:51 +0700
Subject: [swift-evolution] More verbose logical operators
Message-ID: <CAL-BAQtNH_jO+zTZoQ4MtD=LnCsjH2tHpifoHhbN=aO8M69Q+Q@mail.gmail.com>

Hi all,

Swift is said to be a verbose and easy to read programming language.
However, I see Swift is still using cryptic symbols for logical operators.

! for not
|| for or
&& for and

Here I propose a new logical operators that are more swiftish.

'not' for not
'or' for or
'and' for and

So, instead of:

if !foo1 || foo2 && foo3 { ? }

we could write it as:

if not foo1 or foo2 and foo3 { ? }

which is much more readable because it's less cryptic.

What do you think?

Thank you.

Regards,

--
-Bee-
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/34885f80/attachment.html>

From zefmail at gmail.com  Thu Dec  3 22:57:39 2015
From: zefmail at gmail.com (Zef Houssney)
Date: Thu, 3 Dec 2015 21:57:39 -0700
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
Message-ID: <DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>

Interesting thoughts! And thanks for the consideration Chris. Just a couple more thoughts and I?ll drop this :)

Chris, I love the way you put this:

> Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.

In my view, this proposal is aligned with that goal and it?s as much about readability as anything. I find this first example so much more readable at a glance, and I consider the duplicate names and equals sign to be in the boilerplate/noise category:

if let thing, otherThing, moreThings where thing > 0 { }
if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing > 0 { }


Kevin, in regard to this:

> Furthermore, to anyone not already familiar with the proposed rule, `if let foo {` is meaningless


I agree with David in that the existing syntax is already at the point where your statement is also true. There is nothing in the current syntax that indicates that you are unwrapping the optional. It?s only through learning or familiarity with other languages that one understands it. The = indicates assignment, but the unwrapping is learned and specific to that context. The jump to this seems super easy to grok.

Also my point isn?t that it?s doing the same thing technically, but that it?s a similar concept ? assigning to a constant with the value derived implicitly by the context instead of directly through ?=?.

The idea of another keyword like ?when? also seems plausible to me, though it?s a much more drastic change.




> On Dec 3, 2015, at 8:13 PM, Sean Heber <sean at fifthace.com> wrote:
>
> What about lifting the whole concept out of "if" or "guard" and making a new construct that directly communicates the intent?
>
> For example:
>
> when foo { ... }
>
> Which could be combined with "where" to generate an if-like construct:
>
> when foo where foo.isSomething { ... }
>
> Inside the code block, you can access foo directly and it isn't shadowed - so if it was a var, it is mutable, etc.
>
> l8r
> Sean
>
>
> On Dec 3, 2015, at 8:25 PM, David Waite <david at alkaline-solutions.com <mailto:david at alkaline-solutions.com>> wrote:
>
>> I might argue that if let is already an odd case; people often read it equivalent to "if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, 'let x=x? on its own could not have the same behavior.
>>
>> In that spirit, I propose an alternative feature:
>>
>> if foo? { ? }
>>
>> where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.
>>
>> so for example:
>>
>>  func foo(x:Int?) {
>>      if var x = x { // var so it can be assigned
>>          x++
>>      }
>>      print(x)
>>  }
>>
>> foo(1) // => 1, updating the aliased x does not do anything
>>
>> # working code in Swift 1.2
>>  func bar(x:Int?) {
>>      var y=x
>>      if let x=x {
>>          y=x+1
>>      }
>>      print(y)
>>  }
>> bar(1) # => Optional(2)
>>
>> # proposed
>> func proposed(x:Int?) {
>>      var y = x // since swift 3 won't have var function arguments
>>      if y? { // var so it can be assigned
>>          y++
>>      }
>>      print(y)
>>  }
>>
>> proposed(1) // => Optional(2)
>>
>> -DW
>>
>>> On Dec 3, 2015, at 3:42 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>
>>>
>>> ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.
>>>
>>> I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>>>
>>> Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.
>>>
>>> -Chris
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/beba2cdf/attachment-0001.html>

From keithbsmiley at gmail.com  Thu Dec  3 23:01:39 2015
From: keithbsmiley at gmail.com (Keith Smiley)
Date: Thu, 3 Dec 2015 21:01:39 -0800
Subject: [swift-evolution] More verbose logical operators
In-Reply-To: <CAL-BAQtNH_jO+zTZoQ4MtD=LnCsjH2tHpifoHhbN=aO8M69Q+Q@mail.gmail.com>
References: <CAL-BAQtNH_jO+zTZoQ4MtD=LnCsjH2tHpifoHhbN=aO8M69Q+Q@mail.gmail.com>
Message-ID: <20151204050139.GA93010@bryant.web-pass.com>

There was another post about this earlier today as well:

https://lists.swift.org/pipermail/swift-evolution/2015-December/000032.html

--
Keith Smiley

On 12/04, Bee wrote:
> Hi all,
>
> Swift is said to be a verbose and easy to read programming language.
> However, I see Swift is still using cryptic symbols for logical operators.
>
> ! for not
> || for or
> && for and
>
> Here I propose a new logical operators that are more swiftish.
>
> 'not' for not
> 'or' for or
> 'and' for and
>
> So, instead of:
>
> if !foo1 || foo2 && foo3 { ? }
>
> we could write it as:
>
> if not foo1 or foo2 and foo3 { ? }
>
> which is much more readable because it's less cryptic.
>
> What do you think?
>
> Thank you.
>
> Regards,
>
> --
> -Bee-

> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From bee.ography at gmail.com  Thu Dec  3 23:03:11 2015
From: bee.ography at gmail.com (Bee)
Date: Fri, 4 Dec 2015 12:03:11 +0700
Subject: [swift-evolution] More verbose logical operators
In-Reply-To: <20151204050139.GA93010@bryant.web-pass.com>
References: <CAL-BAQtNH_jO+zTZoQ4MtD=LnCsjH2tHpifoHhbN=aO8M69Q+Q@mail.gmail.com>
<20151204050139.GA93010@bryant.web-pass.com>
Message-ID: <CAL-BAQtH_TpXV2vrJ4T476psT-jaoKe=O0Cdtj9Kc=fQCJSoww@mail.gmail.com>

Oh, I see. Too bad actually.

I'm sorry for not knowing that. I'm a new member here.


On Fri, Dec 4, 2015 at 12:01 PM, Keith Smiley <keithbsmiley at gmail.com>
wrote:

> There was another post about this earlier today as well:
>
> https://lists.swift.org/pipermail/swift-evolution/2015-December/000032.html
>
> --
> Keith Smiley
>
> On 12/04, Bee wrote:
> > Hi all,
> >
> > Swift is said to be a verbose and easy to read programming language.
> > However, I see Swift is still using cryptic symbols for logical
> operators.
> >
> > ! for not
> > || for or
> > && for and
> >
> > Here I propose a new logical operators that are more swiftish.
> >
> > 'not' for not
> > 'or' for or
> > 'and' for and
> >
> > So, instead of:
> >
> > if !foo1 || foo2 && foo3 { ? }
> >
> > we could write it as:
> >
> > if not foo1 or foo2 and foo3 { ? }
> >
> > which is much more readable because it's less cryptic.
> >
> > What do you think?
> >
> > Thank you.
> >
> > Regards,
> >
> > --
> > -Bee-
>
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
>


--
-Bee-
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/022393ee/attachment.html>

From sean at fifthace.com  Thu Dec  3 23:08:11 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 23:08:11 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
Message-ID: <C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>

I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.

l8r
Sean

> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>
> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>
> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>
> ?
> Dan Appel
>
>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>
>> The use of "?" can be confusing when speed reading code with optionals.
>>
>> Consider this code as somebody learning swift as their first language.
>> let result = !condition ? 1 : 2
>>
>>
>> Some alternatives:
>>
>> Haskel
>> if predicate then expr1 else expr2
>> Python
>> result = x if a > b else y
>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>
>>
>> References:
>> https://devforums.apple.com/message/1020139#1020139
>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/5080a8e4/attachment.html>

From dan.appel00 at gmail.com  Thu Dec  3 23:14:01 2015
From: dan.appel00 at gmail.com (Dan Appel)
Date: Fri, 04 Dec 2015 05:14:01 +0000
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
<DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
Message-ID: <CADQN+5YxLkTi8Bs1eUrZ6X_wJkzfiz=mG=o5JYUE7D3FZ_Rs9A@mail.gmail.com>

I would like to add on to your idea and propose mixing in David's
suggestion:

if let thing?, otherThing?, moreThings? where thing > 0 { }


I think this makes it clearer that the variables are optionals, which could
lead newcomers to infer that they are being unwrapped. Just my two cents.

Also,

I agree with David in that the existing syntax is already at the point
where your statement is also true.


is fair, but it is made significantly clearer that there is some sort of
assignment going on in the existing implementation (because of the equal
sign).

?
Dan Appel

On Thu, Dec 3, 2015 at 8:57 PM Zef Houssney <zefmail at gmail.com> wrote:

> Interesting thoughts! And thanks for the consideration Chris. Just a
> couple more thoughts and I?ll drop this :)
>
> Chris, I love the way you put this:
>
> Since code is read more often than it is written, the real goal behind
> Swift is to let you write ?more readable code? by eliminating boilerplate
> and other noise.
>
>
> In my view, this proposal is aligned with that goal and it?s as much about
> readability as anything. I find this first example so much more readable at
> a glance, and I consider the duplicate names and equals sign to be in the
> boilerplate/noise category:
>
> if let thing, otherThing, moreThings where thing > 0 { }
>
> if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing > 0 { }
>
>
>
> Kevin, in regard to this:
>
> Furthermore, to anyone not already familiar with the proposed rule, `if
> let foo {` is meaningless
>
>
> I agree with David in that the existing syntax is already at the point
> where your statement is also true. There is nothing in the current syntax
> that indicates that you are unwrapping the optional. It?s only through
> learning or familiarity with other languages that one understands it. The =
> indicates assignment, but the unwrapping is learned and specific to that
> context. The jump to this seems super easy to grok.
>
> Also my point isn?t that it?s doing the same thing technically, but that
> it?s a similar concept ? assigning to a constant with the value derived
> implicitly by the context instead of directly through ?=?.
>
> The idea of another keyword like ?when? also seems plausible to me, though
> it?s a much more drastic change.
>
>
>
>
> On Dec 3, 2015, at 8:13 PM, Sean Heber <sean at fifthace.com> wrote:
>
> What about lifting the whole concept out of "if" or "guard" and making a
> new construct that directly communicates the intent?
>
> For example:
>
> when foo { ... }
>
> Which could be combined with "where" to generate an if-like construct:
>
> when foo where foo.isSomething { ... }
>
> Inside the code block, you can access foo directly and it isn't shadowed -
> so if it was a var, it is mutable, etc.
>
> l8r
> Sean
>
>
> On Dec 3, 2015, at 8:25 PM, David Waite <david at alkaline-solutions.com>
> wrote:
>
> I might argue that if let is already an odd case; people often read it
> equivalent to "if (let x=x)?, but ?let x=x? has completely different
> behavior outside the context of an if let statement (I in fact had to try
> it before I realized it does, in fact, work). Obviously, 'let x=x? on its
> own could not have the same behavior.
>
> In that spirit, I propose an alternative feature:
>
> if foo? { ? }
>
> where the variable is not shadowed by a copy - instead, inside the block
> it behaves as an implicit unwrapped optional, including keeping any
> mutability.
>
> so for example:
>
>  func foo(x:Int?) {
>      if var x = x { // var so it can be assigned
>          x++
>      }
>      print(x)
>  }
>
> foo(1) // => 1, updating the aliased x does not do anything
>
> # working code in Swift 1.2
>  func bar(x:Int?) {
>      var y=x
>      if let x=x {
>          y=x+1
>      }
>      print(y)
>  }
> bar(1) # => Optional(2)
>
> # proposed
> func proposed(x:Int?) {
>      var y = x // since swift 3 won't have var function arguments
>      if y? { // var so it can be assigned
>          y++
>      }
>      print(y)
>  }
>
> proposed(1) // => Optional(2)
>
> -DW
>
> On Dec 3, 2015, at 3:42 PM, Chris Lattner <clattner at apple.com> wrote:
>
>
> ?if let foo {? is a frequently proposed extension to the syntax, but it is
> not one that we?re likely to ever add.
>
> I agree that this is a common pattern, and it would allow you to ?write
> less code?, but that isn?t the goal of Swift.  Since code is read more
> often than it is written, the real goal behind Swift is to let you write
> ?more readable code? by eliminating boilerplate and other noise.
>
> Reducing syntax isn?t itself a goal, particularly if the result
> could/would be confusing for someone who has to read and maintain your code
> later.
>
> -Chris
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e9478aad/attachment-0001.html>

From sean at fifthace.com  Thu Dec  3 23:15:19 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 23:15:19 -0600
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
<DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
Message-ID: <53591A2C-1187-41E6-BB06-8F0327C03238@fifthace.com>

I am obviously biased in favor of a new keyword/construct for this. :) The more I think about it, the more convinced I am that the intent of these scenarios should be conveyed in the code clearly so it is easily seen by future maintainers of that code. It may also help to guide the design of code in the same way that guard seems to alter how I now think about writing a function.

In any event, it is clear that there is a strong desire to solve a pain point, assuming we have correctly identified what pain, exactly, we are trying to solve. :)

l8r
Sean


> On Dec 3, 2015, at 10:57 PM, Zef Houssney <zefmail at gmail.com> wrote:
>
> Interesting thoughts! And thanks for the consideration Chris. Just a couple more thoughts and I?ll drop this :)
>
> Chris, I love the way you put this:
>
>> Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>
> In my view, this proposal is aligned with that goal and it?s as much about readability as anything. I find this first example so much more readable at a glance, and I consider the duplicate names and equals sign to be in the boilerplate/noise category:
>
> if let thing, otherThing, moreThings where thing > 0 { }
> if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing > 0 { }
>
>
> Kevin, in regard to this:
>
>> Furthermore, to anyone not already familiar with the proposed rule, `if let foo {` is meaningless
>
>
> I agree with David in that the existing syntax is already at the point where your statement is also true. There is nothing in the current syntax that indicates that you are unwrapping the optional. It?s only through learning or familiarity with other languages that one understands it. The = indicates assignment, but the unwrapping is learned and specific to that context. The jump to this seems super easy to grok.
>
> Also my point isn?t that it?s doing the same thing technically, but that it?s a similar concept ? assigning to a constant with the value derived implicitly by the context instead of directly through ?=?.
>
> The idea of another keyword like ?when? also seems plausible to me, though it?s a much more drastic change.
>
>
>
>
>> On Dec 3, 2015, at 8:13 PM, Sean Heber <sean at fifthace.com> wrote:
>>
>> What about lifting the whole concept out of "if" or "guard" and making a new construct that directly communicates the intent?
>>
>> For example:
>>
>> when foo { ... }
>>
>> Which could be combined with "where" to generate an if-like construct:
>>
>> when foo where foo.isSomething { ... }
>>
>> Inside the code block, you can access foo directly and it isn't shadowed - so if it was a var, it is mutable, etc.
>>
>> l8r
>> Sean
>>
>>
>>> On Dec 3, 2015, at 8:25 PM, David Waite <david at alkaline-solutions.com> wrote:
>>>
>>> I might argue that if let is already an odd case; people often read it equivalent to "if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, 'let x=x? on its own could not have the same behavior.
>>>
>>> In that spirit, I propose an alternative feature:
>>>
>>> if foo? { ? }
>>>
>>> where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.
>>>
>>> so for example:
>>>
>>>  func foo(x:Int?) {
>>>      if var x = x { // var so it can be assigned
>>>          x++
>>>      }
>>>      print(x)
>>>  }
>>>
>>> foo(1) // => 1, updating the aliased x does not do anything
>>>
>>> # working code in Swift 1.2
>>>  func bar(x:Int?) {
>>>      var y=x
>>>      if let x=x {
>>>          y=x+1
>>>      }
>>>      print(y)
>>>  }
>>> bar(1) # => Optional(2)
>>>
>>> # proposed
>>> func proposed(x:Int?) {
>>>      var y = x // since swift 3 won't have var function arguments
>>>      if y? { // var so it can be assigned
>>>          y++
>>>      }
>>>      print(y)
>>>  }
>>>
>>> proposed(1) // => Optional(2)
>>>
>>> -DW
>>>
>>>> On Dec 3, 2015, at 3:42 PM, Chris Lattner <clattner at apple.com> wrote:
>>>>
>>>>
>>>> ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.
>>>>
>>>> I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>>>>
>>>> Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.
>>>>
>>>> -Chris
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/0875c5d7/attachment-0001.html>

From austinzheng at gmail.com  Thu Dec  3 23:22:11 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Thu, 3 Dec 2015 21:22:11 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
<CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
Message-ID: <CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>

Dear swift-evolution,

I less want to make concrete proposals than start a conversation about
expanded numerical support in Swift. In that spirit, here are some thoughts:

Arbitrary-precision integers (bigints) are a logical first step. Bigints
then enable practical support for rationals. (With bigints, rational
operations need not fail because of integer overflow.) Adding at least
these two numerical types would bring Swift far closer wrt numerical
support wrt languages like Clojure or Ruby.

Many languages make a distinction between fixed precision integers and
bigints (i.e. Haskell's Int vs Integer). I propose the definition of two
related types: ArbitraryPrecisionInteger and Integer.

ArbitraryPrecisionInteger is a struct wrapping a pointer to a byte buffer,
much like how Swift's Array, Set, and Dictionary collection types work
(c.f.
https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html).
It wraps an arbitrarily large integer within a container adhering to value
semantics. Perhaps this can be exposed as part of the stdlib, or a
'private' implementation detail.

Integer is intended to be used by application developers, and most of the
arithmetic/comparison functionality exposed by the stdlib deals with
arguments and return values of type Integer. Integers are enums:

enum Integer {
case Small(Int)
case Big(ArbitraryPrecisionInteger)
}

Like ArbitraryPrecisionInteger, Integer represents an arbitrary-precision
integer. It wraps either a fixed-size (64-bit) signed integer, or a bigint.
Integer's invariant is that integers within the range of an Int are always
stored as an Int. This is enforced by the mathematical operations defined
on arguments of type Integer. This allows for a slow path (consisting of
operations that are conducted on ArbitraryPrecisionIntegers), and a fast
path (consisting of checked operations on Ints, with automatic promotion to
ArbitraryPrecisionInteger as necessary). Fast path operations, in the best
case, need not allocate heap memory or invoke retain/release operations.

Integers can be unconditionally constructed (promoted) from Ints, and can
be conditionally demoted to Ints ( () -> Int? ). (All Ints are Integers,
but not all Integers are Ints.)

A useful compiler support feature might be a "BigIntegerLiteralConvertible"
protocol, which allows literal integers out of the range of Ints to be
assigned to Integer values. Swift can already tell if an integer literal is
out of range (e.g. "let x : Int8 = 123456"), so there is some precedent.
This would be a more elegant solution than requiring bigints to be
initialized via strings (as some other arbitrary precision arithmetic
libraries do).

Rational numbers are represented by the Rational struct which encapsulates
two Integers, the numerator and denominator. Rationals can be conditionally
constructed explicitly from two Integers (as long as the denominator isn't
0), or from a single Integer (all Integers are Rationals, but the opposite
is not true). A good invariant for Rationals might be having them always
represented in the most simplified form - for example, Rational(2, 6)
should be represented internally as 1/3 when constructed.

Future topics to explore include complex numbers, arbitrary-precision
floating-point numbers, and fixed-precision and/or decimal number types.

Given that I'm little more than a dabbler in these topics (most of my
expertise came from trying to reverse-assemble Clojure's numerical
support), feedback from someone with experience and/or expertise wrt
numerical/scientific computing, bignum libraries, numerical towers, etc.
would be hugely appreciated.

Best regards,
Austin


On Thu, Dec 3, 2015 at 6:52 PM, Austin Zheng <austinzheng at gmail.com> wrote:

> Thanks, Chris and Dmitri! I will do some research and write something up
> over the weekend.
>
> Austin
>
> On Thu, Dec 3, 2015 at 2:24 PM, Dmitri Gribenko <gribozavr at gmail.com>
> wrote:
>
>> On Thu, Dec 3, 2015 at 1:14 PM, Austin Zheng <austinzheng at gmail.com>
>> wrote:
>> >
>> > Hi all,
>> >
>> > There are quite a few programming languages that provide support for
>> numeric types apart from the customary floating-point and fixed-width
>> integer types. Prominent examples of additional numeric types include
>> rational numbers, arbitrary-width integer types, and fixed-point numbers.
>> Many of these numeric types are applicable to a wide variety of problem
>> domains.
>>
>> >
>> > Swift seems like it would be a good fit for stdlib implementation of
>> some of these numeric types. Structs and value semantics, literal
>> initialization, and operator overloading would allow such types to be
>> treated as first-class citizens. Is the community amenable to such a
>> proposal, which would entail the data structures themselves, arithmetic
>> operations, and interoperation between different numeric types to form a
>> numerical tower of sorts?
>>
>> Hi Austin,
>>
>> We are interested in improving our numerics support, and we are
>> definitely interested in hearing your ideas in this space.  You don't
>> have to write a full proposal though.  Just an extended email to
>> swift-evolution would be a good start.
>>
>> You can find the current prototype for library support for integers
>> here:
>> https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb
>>
>> Dmitri
>>
>> --
>> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
>> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/c8c3026e/attachment.html>

From sean at fifthace.com  Thu Dec  3 23:35:31 2015
From: sean at fifthace.com (Sean Heber)
Date: Thu, 3 Dec 2015 23:35:31 -0600
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
Message-ID: <2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>

I found a couple of cases of them in my codebase, but they were trivially transformed into ?proper? Swift-style for loops that look better anyway. If it were a vote, I?d vote for eliminating C-style.

l8r
Sean


> On Dec 3, 2015, at 6:52 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> Every time I've tried to use a C-style for loop, I've ended up switching to a while loop because my iteration variable ended up having the wrong type (e.g. having an optional type when the value must be non-optional for the body to execute). The Postmates codebase contains no instances of C-style for loops in Swift.
>
> -Kevin Ballard
>
> On Thu, Dec 3, 2015, at 04:50 PM, Eric Chamberlain wrote:
>> We?ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>
>>
>> --
>> Eric Chamberlain, Lead Architect - iOS
>> ArcTouch - App Development Studio
>>
>> Custom apps for world-class brands and the Fortune 500
>> arctouch.com/work | arctouch.com/blog
>>
>>
>>
>>
>>> On Dec 3, 2015, at 3:46 PM, Andy Matuschak <andy at andymatuschak.org> wrote:
>>>
>>> Just checked; ditto Khan Academy.
>>>
>>>> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com> wrote:
>>>>
>>>> For what it's worth we don't have a single C style for loop in the Lyft
>>>> codebase.
>>>>
>>>> --
>>>> Keith Smiley
>>>>
>>>> On 12/03, Douglas Gregor wrote:
>>>>>
>>>>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>
>>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>>
>>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>>
>>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>
>>>>> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>>>>>
>>>>> - Doug
>>>>>
>>>>>
>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From xcvista at me.com  Thu Dec  3 23:47:32 2015
From: xcvista at me.com (ChanMaxthon)
Date: Fri, 04 Dec 2015 13:47:32 +0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
Message-ID: <750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>

How about this C code when rewritten in Swift:

char *blk_xor(char *dst, const char *src, size_t len)
{
const char *sp = src;
for (char *dp = dst; sp - src < len; sp++, dp++)
*dp ^= *sp;
return dst;
}

Sent from my iPhone

> On Dec 4, 2015, at 13:35, Sean Heber <sean at fifthace.com> wrote:
>
> I found a couple of cases of them in my codebase, but they were trivially transformed into ?proper? Swift-style for loops that look better anyway. If it were a vote, I?d vote for eliminating C-style.
>
> l8r
> Sean
>
>
>> On Dec 3, 2015, at 6:52 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>> Every time I've tried to use a C-style for loop, I've ended up switching to a while loop because my iteration variable ended up having the wrong type (e.g. having an optional type when the value must be non-optional for the body to execute). The Postmates codebase contains no instances of C-style for loops in Swift.
>>
>> -Kevin Ballard
>>
>>> On Thu, Dec 3, 2015, at 04:50 PM, Eric Chamberlain wrote:
>>> We?ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>>
>>>
>>> --
>>> Eric Chamberlain, Lead Architect - iOS
>>> ArcTouch - App Development Studio
>>>
>>> Custom apps for world-class brands and the Fortune 500
>>> arctouch.com/work | arctouch.com/blog
>>>
>>>
>>>
>>>
>>>> On Dec 3, 2015, at 3:46 PM, Andy Matuschak <andy at andymatuschak.org> wrote:
>>>>
>>>> Just checked; ditto Khan Academy.
>>>>
>>>>> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com> wrote:
>>>>>
>>>>> For what it's worth we don't have a single C style for loop in the Lyft
>>>>> codebase.
>>>>>
>>>>> --
>>>>> Keith Smiley
>>>>>
>>>>>> On 12/03, Douglas Gregor wrote:
>>>>>>
>>>>>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>
>>>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>>>
>>>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>>>
>>>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>>
>>>>>> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>>>>>>
>>>>>> - Doug
>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From gribozavr at gmail.com  Thu Dec  3 23:48:32 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Thu, 3 Dec 2015 21:48:32 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
<CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
<CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>
Message-ID: <CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com>

On Thu, Dec 3, 2015 at 9:22 PM, Austin Zheng <austinzheng at gmail.com> wrote:
> Integer is intended to be used by application developers, and most of the
> arithmetic/comparison functionality exposed by the stdlib deals with
> arguments and return values of type Integer.

So one would use Integer, which is capable of representing arbitrary
precision integers, most of the time?  We have considered this in the
past.  The concern is that the branches that this introduces
everywhere and the code bloat wouldn't allow Swift to achieve C-like
performance.

We are considering adding an arbitrary precision integer type, though.

> A useful compiler support feature might be a "BigIntegerLiteralConvertible"
> protocol, which allows literal integers out of the range of Ints to be
> assigned to Integer values. Swift can already tell if an integer literal is
> out of range (e.g. "let x : Int8 = 123456"), so there is some precedent.

Swift's integer literal convertible protocol supports integers up to
2048 bits.  This is sufficient for all practical purposes, I think.

> Rational numbers are represented by the Rational struct which encapsulates
> two Integers, the numerator and denominator. Rationals can be conditionally
> constructed explicitly from two Integers (as long as the denominator isn't
> 0), or from a single Integer (all Integers are Rationals, but the opposite
> is not true).

Yep, this is pretty standard.  How do you propose to model "Integers
are Rationals" in Swift?

> A good invariant for Rationals might be having them always
> represented in the most simplified form - for example, Rational(2, 6) should
> be represented internally as 1/3 when constructed.

This has performance tradeoffs.  What do other libraries and languages do?

> Future topics to explore include complex numbers, arbitrary-precision
> floating-point numbers, and fixed-precision and/or decimal number types.

What about protocols, operations and algorithms?

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From kevin at sb.org  Fri Dec  4 00:02:17 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 03 Dec 2015 22:02:17 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
<750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
Message-ID: <1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>

A straight translation using UnsafePointer without a C-style for loop
would look like

func blk_xor(dst: UnsafeMutablePointer<CChar>, src:
UnsafePointer<CChar>, len: Int) -> UnsafeMutablePointer<CChar> {
for i in 0..<len {
dst[i] ^= src[i]
}
return dst
}

-Kevin Ballard

On Thu, Dec 3, 2015, at 09:47 PM, ChanMaxthon wrote:
> How about this C code when rewritten in Swift:
>
> char *blk_xor(char *dst, const char *src, size_t len)
> {
>   const char *sp = src;
>   for (char *dp = dst; sp - src < len; sp++, dp++)
>     *dp ^= *sp;
>   return dst;
> }
>
> Sent from my iPhone
>
> > On Dec 4, 2015, at 13:35, Sean Heber <sean at fifthace.com> wrote:
> >
> > I found a couple of cases of them in my codebase, but they were trivially transformed into ?proper? Swift-style for loops that look better anyway. If it were a vote, I?d vote for eliminating C-style.
> >
> > l8r
> > Sean
> >
> >
> >> On Dec 3, 2015, at 6:52 PM, Kevin Ballard <kevin at sb.org> wrote:
> >>
> >> Every time I've tried to use a C-style for loop, I've ended up switching to a while loop because my iteration variable ended up having the wrong type (e.g. having an optional type when the value must be non-optional for the body to execute). The Postmates codebase contains no instances of C-style for loops in Swift.
> >>
> >> -Kevin Ballard
> >>
> >>> On Thu, Dec 3, 2015, at 04:50 PM, Eric Chamberlain wrote:
> >>> We?ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
> >>>
> >>>
> >>> --
> >>> Eric Chamberlain, Lead Architect - iOS
> >>> ArcTouch - App Development Studio
> >>>
> >>> Custom apps for world-class brands and the Fortune 500
> >>> arctouch.com/work | arctouch.com/blog
> >>>
> >>>
> >>>
> >>>
> >>>> On Dec 3, 2015, at 3:46 PM, Andy Matuschak <andy at andymatuschak.org> wrote:
> >>>>
> >>>> Just checked; ditto Khan Academy.
> >>>>
> >>>>> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com> wrote:
> >>>>>
> >>>>> For what it's worth we don't have a single C style for loop in the Lyft
> >>>>> codebase.
> >>>>>
> >>>>> --
> >>>>> Keith Smiley
> >>>>>
> >>>>>> On 12/03, Douglas Gregor wrote:
> >>>>>>
> >>>>>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
> >>>>>>>
> >>>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
> >>>>>>>
> >>>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
> >>>>>>>
> >>>>>>> More Swift-like construction is already available with for-in-statements and stride.
> >>>>>>> This would naturally starve the most common point for -- and ++ operators as well.
> >>>>>>
> >>>>>> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
> >>>>>>
> >>>>>> - Doug
> >>>>>
> >>>>>> _______________________________________________
> >>>>>> swift-evolution mailing list
> >>>>>> swift-evolution at swift.org
> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>
> >>>>> _______________________________________________
> >>>>> swift-evolution mailing list
> >>>>> swift-evolution at swift.org
> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>
> >>>> _______________________________________________
> >>>> swift-evolution mailing list
> >>>> swift-evolution at swift.org
> >>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>
> >>> _______________________________________________
> >>> swift-evolution mailing list
> >>> swift-evolution at swift.org
> >>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>
> >>
> >> _______________________________________________
> >> swift-evolution mailing list
> >> swift-evolution at swift.org
> >> https://lists.swift.org/mailman/listinfo/swift-evolution
> >
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution

From bee.ography at gmail.com  Fri Dec  4 00:24:47 2015
From: bee.ography at gmail.com (Bee)
Date: Fri, 4 Dec 2015 13:24:47 +0700
Subject: [swift-evolution] swift for ios?
Message-ID: <CAL-BAQs8pkwmaGfspPggqXiAMaY5oTRTUs9j5LcZvjdKhYwTpA@mail.gmail.com>

Hi all,

I think the next logical step for Swift is Apple creates an iOS Swift IDE.
It doesn't need to be as complex as XCode. Its main purpose is to bring
Swift to the young generations who are mostly more familiar and fluent with
iOS rather than with OSX. At least bring Playground to the iOS.

For reference what the Swift IDE for iOS should be like, try to look at
Codea (Lua) and Pythonista (Python) app in the iOS app store. I love those
both apps. I believe Apple can do much better than those apps. :)

What do you think?

Regards,

--
-Bee-
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/402abffe/attachment.html>

From david at alkaline-solutions.com  Fri Dec  4 00:28:42 2015
From: david at alkaline-solutions.com (David Waite)
Date: Thu, 3 Dec 2015 23:28:42 -0700
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in closures
Message-ID: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>

( Originally proposed here: https://forums.developer.apple.com/thread/13806 )

Often, frameworks will wish to provide a domain specific language for configuring or composition. Web frameworks for instance may define methods like

get(?/?) { request, result in ? }

Testing frameworks (such as Quick/Nimble) may wish to define a terse and expressive syntax for defining behavioral tests:

describe("the 'Documentation' directory") {
it("has everything you need to get started") {
let sections = Directory("Documentation").sections
expect(sections).to(contain("Organized Tests with Quick Examples and Example Groups?))
}
}

While expressive, this has a big problem - describe, it, expect and contain are now defined as either global functions (which cause namespace pollution and mandate global state) or instance methods on a class (which requires the use of class inheritance, and is limited by single class inheritance)

You could have some sort of context object passed into the closure instead:

protocol SpecBuilder {
func describe(description:String, inner:(QuickSpecContext)->())
}

protocol QuickSpecContext {
func it(description:String, inner:(QuickSpecContext)->())
func expect<T>(statement:@autoclosure ()->T, file: StaticString = __FILE__, line: UWord = __LINE__ ) -> Expectation<T>
}

var spec = QuickSpecBuilder(config)
spec.describe("the 'Documentation' directory") {
context in
context.it("has everything you need to get started") {
context in
let sections = Directory("Documentation").sections
context.expect(sections).to(contain("Organized Tests with Quick Examples and Example Groups?))
}
}

But this has significantly more noise. So my proposal is to allow for a closure argument to be used as the current type instance- to be able to redefine ?self? within a block.

var spec = QuickSpecBuilder(config)
spec.describe("the 'Documentation' directory") {
self in
it("has everything you need to get started") {
self in
let sections = Directory("Documentation").sections
expect(sections).to(contain("Organized Tests with Quick Examples and Example Groups?))
}
}

resolution remains the same (lexical scope shadowing the type), this is merely shorthand to allow expressive grammars without requiring class inheritance or global functions. It also remains optional to use - the last two examples are based around the same protocols and should compile to the same code.

I considered alternate syntaxes to express this, mostly alternatives on the bracketing of the closure itself to indicate binding a parameter to self. In the end, I decided:
1. When a block has multiple parameters, you would still need syntax decide which, if any, is bound to self
2. The language complexity in having another syntax for expressing closures with different behavior may not be worth it
3. Code would be confusing for those not knowing the new syntax. ?self in? is (comparatively) straightforward and descriptive


-DW

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/2155c8d2/attachment.html>

From adrian.kashivskyy at me.com  Fri Dec  4 00:55:37 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 07:55:37 +0100
Subject: [swift-evolution] swift for ios?
In-Reply-To: <CAL-BAQs8pkwmaGfspPggqXiAMaY5oTRTUs9j5LcZvjdKhYwTpA@mail.gmail.com>
References: <CAL-BAQs8pkwmaGfspPggqXiAMaY5oTRTUs9j5LcZvjdKhYwTpA@mail.gmail.com>
Message-ID: <ECAA45FD-0D85-48E0-BC10-0468C3C24EE0@me.com>

I think Apple should focus on fixing Xcode first. ?

By the way, I'm not sure swift-evolution is a correct list for this kind of request, since it doesn't concern the language itself.

Pozdrawiam ? Regards,
Adrian Kashivskyy

Wys?ane z iPhone'a

Dnia 04.12.2015 o godz. 07:24 Bee <bee.ography at gmail.com> napisa?(a):

> Hi all,
>
> I think the next logical step for Swift is Apple creates an iOS Swift IDE. It doesn't need to be as complex as XCode. Its main purpose is to bring Swift to the young generations who are mostly more familiar and fluent with iOS rather than with OSX. At least bring Playground to the iOS.
>
> For reference what the Swift IDE for iOS should be like, try to look at Codea (Lua) and Pythonista (Python) app in the iOS app store. I love those both apps. I believe Apple can do much better than those apps. :)
>
> What do you think?
>
> Regards,
>
> --
> -Bee-
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/063e0efc/attachment-0001.html>

From kevin at sb.org  Fri Dec  4 01:07:29 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 3 Dec 2015 23:07:29 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <53591A2C-1187-41E6-BB06-8F0327C03238@fifthace.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
<DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
<53591A2C-1187-41E6-BB06-8F0327C03238@fifthace.com>
Message-ID: <92C9CAD1-2A9B-4CC0-941C-F7850B806C8B@sb.org>

If we change anything based on this, I?d suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of

if let foo = bar {

become the almost-identical

if let foo? = bar {

That said, I?m not convinced we actually have to change anything, but if we do change anything, this seems like the change to make. Of course, it doesn?t actually solve the original poster?s problem of wanting to type less when shadowing an optional value, but I agree completely with Chris Lattner that the goal of Swift is not to be terse but to be readable.

-Kevin Ballard

> On Dec 3, 2015, at 9:15 PM, Sean Heber <sean at fifthace.com> wrote:
>
> I am obviously biased in favor of a new keyword/construct for this. :) The more I think about it, the more convinced I am that the intent of these scenarios should be conveyed in the code clearly so it is easily seen by future maintainers of that code. It may also help to guide the design of code in the same way that guard seems to alter how I now think about writing a function.
>
> In any event, it is clear that there is a strong desire to solve a pain point, assuming we have correctly identified what pain, exactly, we are trying to solve. :)
>
> l8r
> Sean
>
>
> On Dec 3, 2015, at 10:57 PM, Zef Houssney <zefmail at gmail.com <mailto:zefmail at gmail.com>> wrote:
>
>> Interesting thoughts! And thanks for the consideration Chris. Just a couple more thoughts and I?ll drop this :)
>>
>> Chris, I love the way you put this:
>>
>>> Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>>
>> In my view, this proposal is aligned with that goal and it?s as much about readability as anything. I find this first example so much more readable at a glance, and I consider the duplicate names and equals sign to be in the boilerplate/noise category:
>>
>> if let thing, otherThing, moreThings where thing > 0 { }
>> if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing > 0 { }
>>
>>
>> Kevin, in regard to this:
>>
>>> Furthermore, to anyone not already familiar with the proposed rule, `if let foo {` is meaningless
>>
>>
>> I agree with David in that the existing syntax is already at the point where your statement is also true. There is nothing in the current syntax that indicates that you are unwrapping the optional. It?s only through learning or familiarity with other languages that one understands it. The = indicates assignment, but the unwrapping is learned and specific to that context. The jump to this seems super easy to grok.
>>
>> Also my point isn?t that it?s doing the same thing technically, but that it?s a similar concept ? assigning to a constant with the value derived implicitly by the context instead of directly through ?=?.
>>
>> The idea of another keyword like ?when? also seems plausible to me, though it?s a much more drastic change.
>>
>>
>>
>>
>>> On Dec 3, 2015, at 8:13 PM, Sean Heber <sean at fifthace.com <mailto:sean at fifthace.com>> wrote:
>>>
>>> What about lifting the whole concept out of "if" or "guard" and making a new construct that directly communicates the intent?
>>>
>>> For example:
>>>
>>> when foo { ... }
>>>
>>> Which could be combined with "where" to generate an if-like construct:
>>>
>>> when foo where foo.isSomething { ... }
>>>
>>> Inside the code block, you can access foo directly and it isn't shadowed - so if it was a var, it is mutable, etc.
>>>
>>> l8r
>>> Sean
>>>
>>>
>>> On Dec 3, 2015, at 8:25 PM, David Waite <david at alkaline-solutions.com <mailto:david at alkaline-solutions.com>> wrote:
>>>
>>>> I might argue that if let is already an odd case; people often read it equivalent to "if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, 'let x=x? on its own could not have the same behavior.
>>>>
>>>> In that spirit, I propose an alternative feature:
>>>>
>>>> if foo? { ? }
>>>>
>>>> where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.
>>>>
>>>> so for example:
>>>>
>>>>  func foo(x:Int?) {
>>>>      if var x = x { // var so it can be assigned
>>>>          x++
>>>>      }
>>>>      print(x)
>>>>  }
>>>>
>>>> foo(1) // => 1, updating the aliased x does not do anything
>>>>
>>>> # working code in Swift 1.2
>>>>  func bar(x:Int?) {
>>>>      var y=x
>>>>      if let x=x {
>>>>          y=x+1
>>>>      }
>>>>      print(y)
>>>>  }
>>>> bar(1) # => Optional(2)
>>>>
>>>> # proposed
>>>> func proposed(x:Int?) {
>>>>      var y = x // since swift 3 won't have var function arguments
>>>>      if y? { // var so it can be assigned
>>>>          y++
>>>>      }
>>>>      print(y)
>>>>  }
>>>>
>>>> proposed(1) // => Optional(2)
>>>>
>>>> -DW
>>>>
>>>>> On Dec 3, 2015, at 3:42 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>>>
>>>>>
>>>>> ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.
>>>>>
>>>>> I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.
>>>>>
>>>>> Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.
>>>>>
>>>>> -Chris
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/545fb1d3/attachment-0001.html>

From kevin at sb.org  Fri Dec  4 01:21:22 2015
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 3 Dec 2015 23:21:22 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
<CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
<CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>
<CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com>
Message-ID: <7630D974-9311-4D15-B318-631EBF3FEB47@sb.org>

On Dec 3, 2015, at 9:48 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
>> A good invariant for Rationals might be having them always
>> represented in the most simplified form - for example, Rational(2, 6) should
>> be represented internally as 1/3 when constructed.
>
> This has performance tradeoffs.  What do other libraries and languages do?

I know Haskell always reduces Rationals to their reduced form. This does have performance implications, but not doing so has surprising consequences for operations you perform on them. For example, it?s reasonable to expect that Rational(2,6) == Rational(1,3), but implementing that without reduced Rationals pretty much requires reducing them on the fly. The alternative, of saying they?re not equal, would probably surprise most people.

-Kevin Ballard

From tjw at omnigroup.com  Fri Dec  4 01:21:46 2015
From: tjw at omnigroup.com (Timothy Wood)
Date: Thu, 3 Dec 2015 23:21:46 -0800
Subject: [swift-evolution] General take on "special" code in Swift
Message-ID: <76C4E65A-2D2E-4CDD-AC57-141958DBE22D@omnigroup.com>


First off, thanks for all the hard work in putting together an in-depth release and open community infrastructure!

Looking through the Swift sources briefly, I?m noticing various constructs that aren?t documented, idiomatic Swift, or even Swift at all. This isn?t super surprising for various mostly obvious reasons. But, one particular example that caught my attention is in swift/util/gyb.py ("GYB: Generate Your Boilerplate?), and all the .gyb files scattered around.

One of the various Apple Swift tutorial/reference PDFs had the canonical maligning of the C preprocessor (warranted, but yet it is a powerful and useful tool), and yet here is the Swift standard library using a preprocessor of another sort.

For this specific case, I could ask for some magical hygienic macro support, with full debugger support, autocompletion, and puppies (which would be great!), but the more general question is whether the Swift team feels like this dichotomy is OK, or whether it just (a ton of) work that is left to do? Should it be the case that the standard library, Foundation, testing frameworks, and such are almost entirely idiomatic Swift code (even if they are using advanced features)?

Thanks again ? it?s been an exciting day for Swift!

-tim


From david at hartbit.com  Fri Dec  4 01:26:26 2015
From: david at hartbit.com (David Hart)
Date: Fri, 4 Dec 2015 08:26:26 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
Message-ID: <18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>

I also tend to agree but I don't like the ordering in the Python version and would rather see the introduction of the then keyword

> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com> wrote:
>
> I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.
>
> l8r
> Sean
>
>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>>
>> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>>
>> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>>
>> ?
>> Dan Appel
>>
>>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>>
>>> The use of "?" can be confusing when speed reading code with optionals.
>>>
>>> Consider this code as somebody learning swift as their first language.
>>> let result = !condition ? 1 : 2
>>>
>>>
>>> Some alternatives:
>>>
>>> Haskel
>>> if predicate then expr1 else expr2
>>> Python
>>> result = x if a > b else y
>>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>>
>>>
>>> References:
>>> https://devforums.apple.com/message/1020139#1020139
>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0ad1824a/attachment.html>

From david at alkaline-solutions.com  Fri Dec  4 01:40:28 2015
From: david at alkaline-solutions.com (David Waite)
Date: Fri, 4 Dec 2015 00:40:28 -0700
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
Message-ID: <F600E70E-075E-40C8-BB19-661D9C1186FF@alkaline-solutions.com>

Of course one could just drop it as a grammatical language feature and turn it a standard library feature of some form, e.g.:

@warn_unused_result
func when<T>(@autoclosure expr: ()->Bool, @autoclosure value: ()->T, @autoclosure otherwise: ()->T) -> T {
if expr() {
return value()
}
else {
return otherwise()
}
}

var a = when(1 + 1 == 2, value: "works", otherwise: "fails")

print(a) // => ?works"

-DW

> On Dec 4, 2015, at 12:26 AM, David Hart <david at hartbit.com> wrote:
>
> I also tend to agree but I don't like the ordering in the Python version and would rather see the introduction of the then keyword
>
> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com <mailto:sean at fifthace.com>> wrote:
>
>> I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.
>>
>> l8r
>> Sean
>>
>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com <mailto:dan.appel00 at gmail.com>> wrote:
>>
>>> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>>>
>>> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>>>
>>> ?
>>> Dan Appel
>>>
>>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>>
>>> The use of "?" can be confusing when speed reading code with optionals.
>>>
>>> Consider this code as somebody learning swift as their first language.
>>> let result = !condition ? 1 : 2
>>>
>>>
>>> Some alternatives:
>>>
>>> Haskel
>>> if predicate then expr1 else expr2
>>> Python
>>> result = x if a > b else y
>>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>>
>>>
>>> References:
>>> https://devforums.apple.com/message/1020139#1020139 <https://devforums.apple.com/message/1020139#1020139>
>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066 <https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/c2bf2958/attachment-0001.html>

From austinzheng at gmail.com  Fri Dec  4 01:45:41 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Thu, 3 Dec 2015 23:45:41 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <7630D974-9311-4D15-B318-631EBF3FEB47@sb.org>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
<CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
<CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>
<CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com>
<7630D974-9311-4D15-B318-631EBF3FEB47@sb.org>
Message-ID: <CANGnqV2RiaLCg=YLnQtH_dm58x54+9hxxCQ+=vA3c=m+qeF6iw@mail.gmail.com>

Clojure also performs automatic reduction of rational numbers. However, the
source code seems to indicate that reduction is built into the definitions
of the methods that perform arithmetic on rational numbers, and the "Ratio"
class that implements rational number support does not do any reduction
itself.

(c.f.
https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Numbers.java,
ll. 350-364, 704-727, et al)

>From a semantic standpoint, I would be very surprised if e.g. 2/6 and 1/3
were not considered equal, or for that matter if they weren't completely
interchangeable.

- Austin

On Thu, Dec 3, 2015 at 11:21 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Dec 3, 2015, at 9:48 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
> >
> >> A good invariant for Rationals might be having them always
> >> represented in the most simplified form - for example, Rational(2, 6)
> should
> >> be represented internally as 1/3 when constructed.
> >
> > This has performance tradeoffs.  What do other libraries and languages
> do?
>
> I know Haskell always reduces Rationals to their reduced form. This does
> have performance implications, but not doing so has surprising consequences
> for operations you perform on them. For example, it?s reasonable to expect
> that Rational(2,6) == Rational(1,3), but implementing that without reduced
> Rationals pretty much requires reducing them on the fly. The alternative,
> of saying they?re not equal, would probably surprise most people.
>
> -Kevin Ballard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/d4edb0e8/attachment.html>

From david at hartbit.com  Fri Dec  4 02:14:04 2015
From: david at hartbit.com (David Hart)
Date: Fri, 4 Dec 2015 09:14:04 +0100
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
Message-ID: <D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>

The improvements to the Objective-C bridge in Swift 3 are definitely appreciated but are just cosmetics (they only affect naming). What about the fact that NSURL in your example, being an immutable type, would be better represented by a  value type in Swift? Don't misunderstand me, I applaud the fact that corelibs exists, and understand that Foundation has a lot of great ideas, but I would have preferred seeing it exist as a community hobby project instead of an official Swift project and have the community instead concentrate on a core library that embraces value types, generics, protocols, etc...

> On 04 Dec 2015, at 00:14, Tony Parker <anthony.parker at apple.com> wrote:
>
> Hi David,
>
> Fundamentally, we believe that the Foundation library is part of Swift. We also believe that it would be a mistake to throw out the many years of experience that it brings with it. In areas where there are impedance mismatches between the existing API and what feels ?Swifty?, we can improve the API of Foundation to make it as great to use there as it is in Objective-C. The first step of that is our heavy involvement with the Swift 3 naming guidelines here:
>
> https://swift.org/documentation/api-design-guidelines.html
>
> Hope this helps,
> - Tony
>
>> On Dec 3, 2015, at 3:09 PM, David Hart <david at hartbit.com> wrote:
>>
>> Hi Tony,
>>
>> Like Jacob, I would have preferred a completely original corelibs library that uses that clean sheet to be as bold in library design as the standard library is. Why would that direction go against the goal of begin "as standards compliant as possible?? it would just mean that Apple Platform developers would have the option of using the Objective-C bridge to talk to Objective-C Foundation or use the ?swifter? corelibs.
>>
>> David.
>>
>>>> On 03 Dec 2015, at 23:33, Tony Parker <anthony.parker at apple.com> wrote:
>>>>
>>>> Hi Jacob,
>>>>
>>>> On Dec 3, 2015, at 2:23 PM, Jacob Bandes-Storch <jtbandes at gmail.com> wrote:
>>>>
>>>>> On Thu, Dec 3, 2015 at 2:13 PM, Chris Lattner <clattner at apple.com> wrote:
>>>>>
>>>>> As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.
>>>>
>>>> This is great, but is the goal also to exactly duplicate all the idiosyncrasies of the Obj-C Foundation?
>>>>
>>>> Quiz: what's the result of NSURL(string: "http://one/two;three/four")?.URLByAppendingPathComponent("five") ?
>>>>
>>>> If, as I would hope, corelibs-foundation is an opportunity to make simpler APIs that resolve some of these weirdnesses, then should the class names (NSURL, NSFileHandle, etc.) really be the same?
>>>>
>>>>  _______________________________________________
>>>> swift-corelibs-dev mailing list
>>>> swift-corelibs-dev at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev
>>>
>>> I think NSURL is actually a pretty great example of an API that we want to be the same on all platforms. There is quite a bit of logic backing it (along with something like NSURLComponents). Check out some of it here:
>>>
>>> https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c
>>>
>>> (and that CF code is reflected up into NSURLComponents)
>>>
>>> It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.
>>>
>>> So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org. We can take this opportunity to try to make it better for everyone.
>>>
>>> Thanks,
>>> - Tony
>>>
>>>
>>>
>>>  _______________________________________________
>>> swift-corelibs-dev mailing list
>>> swift-corelibs-dev at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ad1017a9/attachment-0001.html>

From david.screve at dlta-studio.com  Fri Dec  4 02:30:52 2015
From: david.screve at dlta-studio.com (=?utf-8?Q?David_Scr=C3=A8ve?=)
Date: Fri, 4 Dec 2015 09:30:52 +0100
Subject: [swift-evolution] abstract keyWord proposal
Message-ID: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>

Hi Everyone,

Nice to see this new swift-evolution process?.I?m not sure to completely understand the whole process of requesting evolutions, but I?m trying
to do?

As I develop sort of framework, I usually have classes that I wanted to partially in the framework and force the user to implement others parts.

For example, I have a WebService class that manage the whole process to perform asynchronous call, error management.
This class has an abstract property that is specific for each WebService call.

Then I would like to make the URL property abstract and, consequently, the whole WebService class abstract : The WebService cannot be directly instantiated.

The goal of this feature would be to extend to method.
This behavior already exists in Java and is really useful.

The workaround is to make an URL property that returns invalid value or make assertion, but the error is only detected at runtime.

My proposal would be to just add a keyword before func, class or var. An abstract property or func should not provide implementation.

Regards,


David


-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4233 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/392cb9a9/attachment.p7s>

From griotspeak at gmail.com  Fri Dec  4 02:43:50 2015
From: griotspeak at gmail.com (T.J. Usiyan)
Date: Fri, 4 Dec 2015 03:43:50 -0500
Subject: [swift-evolution] abstract keyWord proposal
In-Reply-To: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
References: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
Message-ID: <CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>

Hello David,

This sounds like something that can be accomplished with protocols and
default implementations provided in protocol extensions. If you've
watched Protocol-Oriented
Programming in Swift [Session 408]
<https://developer.apple.com/videos/play/wwdc2015-408/>, slides 168 and on,
once he begins talking about Protocol Extensions, is the relevant part. It
looks like the functionality that you've described is already present in
this feature.

TJ

On Fri, Dec 4, 2015 at 3:30 AM, David Scr?ve <david.screve at dlta-studio.com>
wrote:

>         Hi Everyone,
>
>         Nice to see this new swift-evolution process?.I?m not sure to
> completely understand the whole process of requesting evolutions, but I?m
> trying
> to do?
>
>         As I develop sort of framework, I usually have classes that I
> wanted to partially in the framework and force the user to implement others
> parts.
>
>         For example, I have a WebService class that manage the whole
> process to perform asynchronous call, error management.
>         This class has an abstract property that is specific for each
> WebService call.
>
>         Then I would like to make the URL property abstract and,
> consequently, the whole WebService class abstract : The WebService cannot
> be directly instantiated.
>
>         The goal of this feature would be to extend to method.
>         This behavior already exists in Java and is really useful.
>
>         The workaround is to make an URL property that returns invalid
> value or make assertion, but the error is only detected at runtime.
>
>         My proposal would be to just add a keyword before func, class or
> var. An abstract property or func should not provide implementation.
>
>         Regards,
>
>
> David
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/bfe93fe7/attachment.html>

From david.screve at dlta-studio.com  Fri Dec  4 02:56:01 2015
From: david.screve at dlta-studio.com (=?utf-8?Q?David_Scr=C3=A8ve?=)
Date: Fri, 4 Dec 2015 09:56:01 +0100
Subject: [swift-evolution] abstract keyWord proposal
In-Reply-To: <CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>
References: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
<CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>
Message-ID: <2DCFAEF9-850D-4360-A230-136D8329F0CE@dlta-studio.com>

Hello TJ,

Actually not completely?Protocol does not handle properties storage. Only class (and struct) can be made abstract.

Doing this with protocol and class required the use of both and you need to enforce developer to inherit from class and implement protocol.. An abstract class encapsulate both on this in a single entity.

Here is a sample class for WebService :

class WebService {
private var lastModified : NSDate
var url : String?

init() {
lastModified=NSDate()
}

func performCall() {
print(self.url)
self.lastModified=NSDate()
}
}

As written below, I can create a WebService instance?but I would like to forbid this because URL is a property that must be implemented by inherited classes.

I I use a protocol and Protocol extension, I will not be able to have lastModified stored value.

My proposal is to add abstract keyword as below :

abstract class WebService {
private var lastModified : NSDate
abstract var url : String?

init() {
lastModified=NSDate()
}

func performCall() {
print(self.url)
self.lastModified=NSDate()
}
}

Then I will not be able to create a WebService object, and enforced to implement url property in inherited classes.

Regards,

David

> Le 4 d?c. 2015 ? 09:43, T.J. Usiyan <griotspeak at gmail.com> a ?crit :
>
> Hello David,
>
> This sounds like something that can be accomplished with protocols and default implementations provided in protocol extensions. If you've watched Protocol-Oriented Programming in Swift [Session 408] <https://developer.apple.com/videos/play/wwdc2015-408/>, slides 168 and on, once he begins talking about Protocol Extensions, is the relevant part. It looks like the functionality that you've described is already present in this feature.
>
> TJ
>
> On Fri, Dec 4, 2015 at 3:30 AM, David Scr?ve <david.screve at dlta-studio.com <mailto:david.screve at dlta-studio.com>> wrote:
>         Hi Everyone,
>
>         Nice to see this new swift-evolution process?.I?m not sure to completely understand the whole process of requesting evolutions, but I?m trying
> to do?
>
>         As I develop sort of framework, I usually have classes that I wanted to partially in the framework and force the user to implement others parts.
>
>         For example, I have a WebService class that manage the whole process to perform asynchronous call, error management.
>         This class has an abstract property that is specific for each WebService call.
>
>         Then I would like to make the URL property abstract and, consequently, the whole WebService class abstract : The WebService cannot be directly instantiated.
>
>         The goal of this feature would be to extend to method.
>         This behavior already exists in Java and is really useful.
>
>         The workaround is to make an URL property that returns invalid value or make assertion, but the error is only detected at runtime.
>
>         My proposal would be to just add a keyword before func, class or var. An abstract property or func should not provide implementation.
>
>         Regards,
>
>
> David
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/4f5b3614/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4233 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/4f5b3614/attachment-0001.p7s>

From griotspeak at gmail.com  Fri Dec  4 03:11:14 2015
From: griotspeak at gmail.com (T.J. Usiyan)
Date: Fri, 4 Dec 2015 04:11:14 -0500
Subject: [swift-evolution] abstract keyWord proposal
In-Reply-To: <2DCFAEF9-850D-4360-A230-136D8329F0CE@dlta-studio.com>
References: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
<CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>
<2DCFAEF9-850D-4360-A230-136D8329F0CE@dlta-studio.com>
Message-ID: <CAGJeWTpL0F+BPPLG8gf9Pxf_ocasqmdkgVrhog+pn4Sq68NkVw@mail.gmail.com>

Hello,

This is an interesting example. I can't refute it without questioning
decisions/intent rather than code so I'll just say that the `abstract`
quality  you're after still seems like it should be fit into the protocol
family of features.

TJ

On Fri, Dec 4, 2015 at 3:56 AM, David Scr?ve <david.screve at dlta-studio.com>
wrote:

> Hello TJ,
>
> Actually not completely?Protocol does not handle properties storage. Only
> class (and struct) can be made abstract.
>
> Doing this with protocol and class required the use of both and you need
> to enforce developer to inherit from class and implement protocol.. An
> abstract class encapsulate both on this in a single entity.
>
> Here is a sample class for WebService :
>
> class WebService {
>     private var lastModified : NSDate
>     var url : String?
>
>     init() {
>         lastModified=NSDate()
>     }
>
>
>     func performCall() {
>         print(self.url)
>         self.lastModified=NSDate()
>     }
> }
>
> As written below, I can create a WebService instance?but I would like to
> forbid this because URL is a property that must be implemented by inherited
> classes.
>
> I I use a protocol and Protocol extension, I will not be able to have
> lastModified stored value.
>
> My proposal is to add abstract keyword as below :
>
> abstract class WebService {
>     private var lastModified : NSDate
>     abstract var url : String?
>
>     init() {
>         lastModified=NSDate()
>     }
>
>
>     func performCall() {
>         print(self.url)
>         self.lastModified=NSDate()
>     }
> }
>
> Then I will not be able to create a WebService object, and enforced to
> implement url property in inherited classes.
>
> Regards,
>
> David
>
> Le 4 d?c. 2015 ? 09:43, T.J. Usiyan <griotspeak at gmail.com> a ?crit :
>
> Hello David,
>
> This sounds like something that can be accomplished with protocols and
> default implementations provided in protocol extensions. If you've watched Protocol-Oriented
> Programming in Swift [Session 408]
> <https://developer.apple.com/videos/play/wwdc2015-408/>, slides 168 and
> on, once he begins talking about Protocol Extensions, is the relevant part.
> It looks like the functionality that you've described is already present in
> this feature.
>
> TJ
>
> On Fri, Dec 4, 2015 at 3:30 AM, David Scr?ve <david.screve at dlta-studio.com
> > wrote:
>
>>         Hi Everyone,
>>
>>         Nice to see this new swift-evolution process?.I?m not sure to
>> completely understand the whole process of requesting evolutions, but I?m
>> trying
>> to do?
>>
>>         As I develop sort of framework, I usually have classes that I
>> wanted to partially in the framework and force the user to implement others
>> parts.
>>
>>         For example, I have a WebService class that manage the whole
>> process to perform asynchronous call, error management.
>>         This class has an abstract property that is specific for each
>> WebService call.
>>
>>         Then I would like to make the URL property abstract and,
>> consequently, the whole WebService class abstract : The WebService cannot
>> be directly instantiated.
>>
>>         The goal of this feature would be to extend to method.
>>         This behavior already exists in Java and is really useful.
>>
>>         The workaround is to make an URL property that returns invalid
>> value or make assertion, but the error is only detected at runtime.
>>
>>         My proposal would be to just add a keyword before func, class or
>> var. An abstract property or func should not provide implementation.
>>
>>         Regards,
>>
>>
>> David
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/bef3b9e7/attachment.html>

From david.screve at dlta-studio.com  Fri Dec  4 03:23:23 2015
From: david.screve at dlta-studio.com (=?utf-8?Q?David_Scr=C3=A8ve?=)
Date: Fri, 4 Dec 2015 10:23:23 +0100
Subject: [swift-evolution] abstract keyWord proposal
In-Reply-To: <CAGJeWTpL0F+BPPLG8gf9Pxf_ocasqmdkgVrhog+pn4Sq68NkVw@mail.gmail.com>
References: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
<CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>
<2DCFAEF9-850D-4360-A230-136D8329F0CE@dlta-studio.com>
<CAGJeWTpL0F+BPPLG8gf9Pxf_ocasqmdkgVrhog+pn4Sq68NkVw@mail.gmail.com>
Message-ID: <1BB987A8-48AC-42DF-928E-91ECD2568FEC@dlta-studio.com>

Yes,

I agree with you that abstract might be attached to protocol family of feature?but protocol already manage the ?abstract? feature if you don?t consider the value storage issue.

Actually, there 2 ways to add this feature :

1 -  Protocol way : We need to add value storage to protocol
2 -  class way : We need to add abstract for method/properties

The question is : Is adding value storage to protocol is a good thing ?  It might create confusion between classes and protocol, maybe.

But, on the other side, there is not real reason to limit class extension to only method and not to properties. In this case, extending protocol to value container might be an interesting way to respond to this. Anyway, we might keep the abstract keyword.

Regards,

David

> Le 4 d?c. 2015 ? 10:11, T.J. Usiyan <griotspeak at gmail.com> a ?crit :
>
> Hello,
>
> This is an interesting example. I can't refute it without questioning decisions/intent rather than code so I'll just say that the `abstract` quality  you're after still seems like it should be fit into the protocol family of features.
>
> TJ
>
> On Fri, Dec 4, 2015 at 3:56 AM, David Scr?ve <david.screve at dlta-studio.com <mailto:david.screve at dlta-studio.com>> wrote:
> 	Hello TJ,
>
> 	Actually not completely?Protocol does not handle properties storage. Only class (and struct) can be made abstract.
>
> 	Doing this with protocol and class required the use of both and you need to enforce developer to inherit from class and implement protocol.. An abstract class encapsulate both on this in a single entity.
>
> 	Here is a sample class for WebService :
>
> class WebService {
>     private var lastModified : NSDate
>     var url : String?
>
>     init() {
>         lastModified=NSDate()
>     }
>
>     func performCall() {
>         print(self.url)
>         self.lastModified=NSDate()
>     }
> }
>
> As written below, I can create a WebService instance?but I would like to forbid this because URL is a property that must be implemented by inherited classes.
>
> I I use a protocol and Protocol extension, I will not be able to have lastModified stored value.
>
> My proposal is to add abstract keyword as below :
>
> abstract class WebService {
>     private var lastModified : NSDate
>     abstract var url : String?
>
>     init() {
>         lastModified=NSDate()
>     }
>
>     func performCall() {
>         print(self.url)
>         self.lastModified=NSDate()
>     }
> }
>
> Then I will not be able to create a WebService object, and enforced to implement url property in inherited classes.
>
> 	Regards,
>
> David
>
>> Le 4 d?c. 2015 ? 09:43, T.J. Usiyan <griotspeak at gmail.com <mailto:griotspeak at gmail.com>> a ?crit :
>>
>> Hello David,
>>
>> This sounds like something that can be accomplished with protocols and default implementations provided in protocol extensions. If you've watched Protocol-Oriented Programming in Swift [Session 408] <https://developer.apple.com/videos/play/wwdc2015-408/>, slides 168 and on, once he begins talking about Protocol Extensions, is the relevant part. It looks like the functionality that you've described is already present in this feature.
>>
>> TJ
>>
>> On Fri, Dec 4, 2015 at 3:30 AM, David Scr?ve <david.screve at dlta-studio.com <mailto:david.screve at dlta-studio.com>> wrote:
>>         Hi Everyone,
>>
>>         Nice to see this new swift-evolution process?.I?m not sure to completely understand the whole process of requesting evolutions, but I?m trying
>> to do?
>>
>>         As I develop sort of framework, I usually have classes that I wanted to partially in the framework and force the user to implement others parts.
>>
>>         For example, I have a WebService class that manage the whole process to perform asynchronous call, error management.
>>         This class has an abstract property that is specific for each WebService call.
>>
>>         Then I would like to make the URL property abstract and, consequently, the whole WebService class abstract : The WebService cannot be directly instantiated.
>>
>>         The goal of this feature would be to extend to method.
>>         This behavior already exists in Java and is really useful.
>>
>>         The workaround is to make an URL property that returns invalid value or make assertion, but the error is only detected at runtime.
>>
>>         My proposal would be to just add a keyword before func, class or var. An abstract property or func should not provide implementation.
>>
>>         Regards,
>>
>>
>> David
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f46fd7a9/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4233 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f46fd7a9/attachment-0001.p7s>

From xcvista at me.com  Fri Dec  4 04:12:56 2015
From: xcvista at me.com (ChanMaxthon)
Date: Fri, 04 Dec 2015 18:12:56 +0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift
Open	Source Project and Foundation replacements
In-Reply-To: <D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
<D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
Message-ID: <00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>

Then just please leave some stub there so communities can plug their own bridging into Swift gracefully (that is, not as an out-of-tree patch)

My idea:

1) a pure C header file, swift-compat.h describing the interface the community-provided bridging mechanism should implement besides objc/runtime.h, objc/message.h and objc/objc-arc.h, and the associated documentation describing what the community should do, in a even more liberal license like MIT or 3c/BSD
2) The build system checking for a compatible, community-provided libswift-compat.so during compilation and enable the community-provided bridging mechanism if present.
3) Compile-time issues can be solved similarly using libswift-repl-compat.so

When building Swift without a compatible community-provided Foundation reimplementation present everything here will be built, like what we are doing here. When building with such a library set and the corresponding libswift-compat.so present only the Swift standard library will be built, linking to the community-provided Objective-C runtime (which is also used as the Swift runtime through the Objective-C bridge) and take advantage of the community-provided Foundation framework through bridging.

Sent from my iPhone

> On Dec 4, 2015, at 16:14, David Hart <david at hartbit.com> wrote:
>
> The improvements to the Objective-C bridge in Swift 3 are definitely appreciated but are just cosmetics (they only affect naming). What about the fact that NSURL in your example, being an immutable type, would be better represented by a  value type in Swift? Don't misunderstand me, I applaud the fact that corelibs exists, and understand that Foundation has a lot of great ideas, but I would have preferred seeing it exist as a community hobby project instead of an official Swift project and have the community instead concentrate on a core library that embraces value types, generics, protocols, etc...
>
>> On 04 Dec 2015, at 00:14, Tony Parker <anthony.parker at apple.com> wrote:
>>
>> Hi David,
>>
>> Fundamentally, we believe that the Foundation library is part of Swift. We also believe that it would be a mistake to throw out the many years of experience that it brings with it. In areas where there are impedance mismatches between the existing API and what feels ?Swifty?, we can improve the API of Foundation to make it as great to use there as it is in Objective-C. The first step of that is our heavy involvement with the Swift 3 naming guidelines here:
>>
>> https://swift.org/documentation/api-design-guidelines.html
>>
>> Hope this helps,
>> - Tony
>>
>>> On Dec 3, 2015, at 3:09 PM, David Hart <david at hartbit.com> wrote:
>>>
>>> Hi Tony,
>>>
>>> Like Jacob, I would have preferred a completely original corelibs library that uses that clean sheet to be as bold in library design as the standard library is. Why would that direction go against the goal of begin "as standards compliant as possible?? it would just mean that Apple Platform developers would have the option of using the Objective-C bridge to talk to Objective-C Foundation or use the ?swifter? corelibs.
>>>
>>> David.
>>>
>>>>> On 03 Dec 2015, at 23:33, Tony Parker <anthony.parker at apple.com> wrote:
>>>>>
>>>>> Hi Jacob,
>>>>>
>>>>> On Dec 3, 2015, at 2:23 PM, Jacob Bandes-Storch <jtbandes at gmail.com> wrote:
>>>>>
>>>>>> On Thu, Dec 3, 2015 at 2:13 PM, Chris Lattner <clattner at apple.com> wrote:
>>>>>>
>>>>>> As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.
>>>>>
>>>>> This is great, but is the goal also to exactly duplicate all the idiosyncrasies of the Obj-C Foundation?
>>>>>
>>>>> Quiz: what's the result of NSURL(string: "http://one/two;three/four")?.URLByAppendingPathComponent("five") ?
>>>>>
>>>>> If, as I would hope, corelibs-foundation is an opportunity to make simpler APIs that resolve some of these weirdnesses, then should the class names (NSURL, NSFileHandle, etc.) really be the same?
>>>>>
>>>>>  _______________________________________________
>>>>> swift-corelibs-dev mailing list
>>>>> swift-corelibs-dev at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev
>>>>
>>>> I think NSURL is actually a pretty great example of an API that we want to be the same on all platforms. There is quite a bit of logic backing it (along with something like NSURLComponents). Check out some of it here:
>>>>
>>>> https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c
>>>>
>>>> (and that CF code is reflected up into NSURLComponents)
>>>>
>>>> It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.
>>>>
>>>> So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org. We can take this opportunity to try to make it better for everyone.
>>>>
>>>> Thanks,
>>>> - Tony
>>>>
>>>>
>>>>
>>>>  _______________________________________________
>>>> swift-corelibs-dev mailing list
>>>> swift-corelibs-dev at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/442b7357/attachment.html>

From alex.blewitt at gmail.com  Fri Dec  4 04:33:58 2015
From: alex.blewitt at gmail.com (Alex Blewitt)
Date: Fri, 4 Dec 2015 11:33:58 +0100
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
<D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
<00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>
Message-ID: <8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>

A more interesting question would be: is Swift designed to ultimately replace Objective-C? If so, baking in compatibility from the outset of the open source version would probably be going in the wrong direction.

Alex

> On 4 Dec 2015, at 11:12, ChanMaxthon <xcvista at me.com> wrote:
>
> Then just please leave some stub there so communities can plug their own bridging into Swift gracefully (that is, not as an out-of-tree patch)
>
> My idea:
>
> 1) a pure C header file, swift-compat.h describing the interface the community-provided bridging mechanism should implement besides objc/runtime.h, objc/message.h and objc/objc-arc.h, and the associated documentation describing what the community should do, in a even more liberal license like MIT or 3c/BSD
> 2) The build system checking for a compatible, community-provided libswift-compat.so during compilation and enable the community-provided bridging mechanism if present.
> 3) Compile-time issues can be solved similarly using libswift-repl-compat.so
>
> When building Swift without a compatible community-provided Foundation reimplementation present everything here will be built, like what we are doing here. When building with such a library set and the corresponding libswift-compat.so present only the Swift standard library will be built, linking to the community-provided Objective-C runtime (which is also used as the Swift runtime through the Objective-C bridge) and take advantage of the community-provided Foundation framework through bridging.
>
> Sent from my iPhone
>
> On Dec 4, 2015, at 16:14, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
>
>> The improvements to the Objective-C bridge in Swift 3 are definitely appreciated but are just cosmetics (they only affect naming). What about the fact that NSURL in your example, being an immutable type, would be better represented by a  value type in Swift? Don't misunderstand me, I applaud the fact that corelibs exists, and understand that Foundation has a lot of great ideas, but I would have preferred seeing it exist as a community hobby project instead of an official Swift project and have the community instead concentrate on a core library that embraces value types, generics, protocols, etc...
>>
>> On 04 Dec 2015, at 00:14, Tony Parker <anthony.parker at apple.com <mailto:anthony.parker at apple.com>> wrote:
>>
>>> Hi David,
>>>
>>> Fundamentally, we believe that the Foundation library is part of Swift. We also believe that it would be a mistake to throw out the many years of experience that it brings with it. In areas where there are impedance mismatches between the existing API and what feels ?Swifty?, we can improve the API of Foundation to make it as great to use there as it is in Objective-C. The first step of that is our heavy involvement with the Swift 3 naming guidelines here:
>>>
>>> https://swift.org/documentation/api-design-guidelines.html <https://swift.org/documentation/api-design-guidelines.html>
>>>
>>> Hope this helps,
>>> - Tony
>>>
>>>> On Dec 3, 2015, at 3:09 PM, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
>>>>
>>>> Hi Tony,
>>>>
>>>> Like Jacob, I would have preferred a completely original corelibs library that uses that clean sheet to be as bold in library design as the standard library is. Why would that direction go against the goal of begin "as standards compliant as possible?? it would just mean that Apple Platform developers would have the option of using the Objective-C bridge to talk to Objective-C Foundation or use the ?swifter? corelibs.
>>>>
>>>> David.
>>>>
>>>>> On 03 Dec 2015, at 23:33, Tony Parker <anthony.parker at apple.com <mailto:anthony.parker at apple.com>> wrote:
>>>>>
>>>>> Hi Jacob,
>>>>>
>>>>>> On Dec 3, 2015, at 2:23 PM, Jacob Bandes-Storch <jtbandes at gmail.com <mailto:jtbandes at gmail.com>> wrote:
>>>>>>
>>>>>> On Thu, Dec 3, 2015 at 2:13 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>>>>
>>>>>> As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.
>>>>>>
>>>>>> This is great, but is the goal also to exactly duplicate all the idiosyncrasies of the Obj-C Foundation?
>>>>>>
>>>>>> Quiz: what's the result of NSURL(string: "http://one/two;three/four <http://one/two;three/four>")?.URLByAppendingPathComponent("five") ?
>>>>>>
>>>>>> If, as I would hope, corelibs-foundation is an opportunity to make simpler APIs that resolve some of these weirdnesses, then should the class names (NSURL, NSFileHandle, etc.) really be the same?
>>>>>>
>>>>>>  _______________________________________________
>>>>>> swift-corelibs-dev mailing list
>>>>>> swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev <https://lists.swift.org/mailman/listinfo/swift-corelibs-dev>
>>>>>
>>>>> I think NSURL is actually a pretty great example of an API that we want to be the same on all platforms. There is quite a bit of logic backing it (along with something like NSURLComponents). Check out some of it here:
>>>>>
>>>>> https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c <https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c>
>>>>>
>>>>> (and that CF code is reflected up into NSURLComponents)
>>>>>
>>>>> It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.
>>>>>
>>>>> So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org <http://bugs.swift.org/>. We can take this opportunity to try to make it better for everyone.
>>>>>
>>>>> Thanks,
>>>>> - Tony
>>>>>
>>>>>
>>>>>
>>>>>  _______________________________________________
>>>>> swift-corelibs-dev mailing list
>>>>> swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev <https://lists.swift.org/mailman/listinfo/swift-corelibs-dev>
>>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2ad78014/attachment-0001.html>

From bee.ography at gmail.com  Fri Dec  4 04:46:40 2015
From: bee.ography at gmail.com (Bee)
Date: Fri, 4 Dec 2015 17:46:40 +0700
Subject: [swift-evolution] swift for ios?
In-Reply-To: <ECAA45FD-0D85-48E0-BC10-0468C3C24EE0@me.com>
References: <CAL-BAQs8pkwmaGfspPggqXiAMaY5oTRTUs9j5LcZvjdKhYwTpA@mail.gmail.com>
<ECAA45FD-0D85-48E0-BC10-0468C3C24EE0@me.com>
Message-ID: <CAL-BAQu+ybOGuMYH6qnyOtFxnZtPKYYeCu3yCvFKkyy2iAbuiQ@mail.gmail.com>

On Fri, Dec 4, 2015 at 1:55 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com>
wrote:

> I think Apple should focus on fixing Xcode first. ?
>

Apple is a huge and very rich company. They could afford to create a new
team to work on Playground for iOS project. :)


> By the way, I'm not sure swift-evolution is a correct list for this kind
> of request, since it doesn't concern the language itself.
>

Me neither. But I couldn't find a better list for this kind of suggestion
than this one. Yes, I've check the available list for swift on:
https://swift.org/community/#mailing-lists

Regards,

--
-Bee-



> Pozdrawiam ? Regards,
> Adrian Kashivskyy
>
> Wys?ane z iPhone'a
>
> Dnia 04.12.2015 o godz. 07:24 Bee <bee.ography at gmail.com> napisa?(a):
>
> Hi all,
>
> I think the next logical step for Swift is Apple creates an iOS Swift IDE.
> It doesn't need to be as complex as XCode. Its main purpose is to bring
> Swift to the young generations who are mostly more familiar and fluent with
> iOS rather than with OSX. At least bring Playground to the iOS.
>
> For reference what the Swift IDE for iOS should be like, try to look at
> Codea (Lua) and Pythonista (Python) app in the iOS app store. I love those
> both apps. I believe Apple can do much better than those apps. :)
>
> What do you think?
>
> Regards,
>
> --
> -Bee-
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a020e39b/attachment.html>

From xcvista at me.com  Fri Dec  4 04:54:28 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 18:54:28 +0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
<D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
<00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>
<8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>
Message-ID: <50C9A65D-DDDB-462D-9151-BD672DE556AD@me.com>

Let?s take a look at C# which Microsoft designed to replace C++ MFC. The compatibility is never removed although C# itself is pretty complete already. During early days (2002) lots of components in C# are stubs calling back to MFC but nevertheless this presented a more or less complete library set to the user and allowed the language to gain traction - so many traction that now people demand it to be ported to multiple platforms.

Removing Objective-C compatibility in Swift (which does not even have a complete set of libraries yet) in this stage would undermine its usability and the completeness of the libraries, and when the project finally matured a bad reputation of ?incomplete support? would already be out there, hampering its use.

> On Dec 4, 2015, at 18:33, Alex Blewitt <alex.blewitt at gmail.com> wrote:
>
> A more interesting question would be: is Swift designed to ultimately replace Objective-C? If so, baking in compatibility from the outset of the open source version would probably be going in the wrong direction.
>
> Alex
>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d9f6be27/attachment.p7s>

From gdapeng at icloud.com  Fri Dec  4 05:04:45 2015
From: gdapeng at icloud.com (Dapeng Gao)
Date: Fri, 04 Dec 2015 19:04:45 +0800
Subject: [swift-evolution] Generic `typealias`s
Message-ID: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>

It would be handy if Swift can support generic `typealias`s, which would probably look like this:

typealias Handler<Element> = [Element] -> Void

One common way to achieve this is to define a generic `struct` and use a nested `typealias`:

struct HandlerWrapper<Element> {
typealias Hander = [Element] -> Void
}

HandlerWrapper<SomeType>.Hander
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/86430753/attachment.html>

From s.pepyakin at gmail.com  Fri Dec  4 05:05:44 2015
From: s.pepyakin at gmail.com (Sergey Shulepov)
Date: Fri, 4 Dec 2015 14:05:44 +0300
Subject: [swift-evolution] Control Flow Expressions
Message-ID: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>

Hello.

It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
so instead of writing:

var message: String
if x % 2 == 0 {
message = "x is even"
} else {
message = "x is odd"
}

you can write:

let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }

I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.
Thanks!

From xcvista at me.com  Fri Dec  4 05:07:27 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 19:07:27 +0800
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
Message-ID: <F3457551-65D5-4A8D-A9F3-241F26D67678@me.com>

I believe switch-as-an-expression can be implemented as a dictionary lookup, and if-as-an-expression is the ternary operator ?:

> On Dec 4, 2015, at 19:05, Sergey Shulepov <s.pepyakin at gmail.com> wrote:
>
> Hello.
>
> It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
> so instead of writing:
>
> var message: String
> if x % 2 == 0 {
> message = "x is even"
> } else {
> message = "x is odd"
> }
>
> you can write:
>
> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>
> I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.
> Thanks!
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/129ab465/attachment-0001.p7s>

From adrian.zubarev at devandartist.com  Fri Dec  4 05:22:24 2015
From: adrian.zubarev at devandartist.com (Adrian Zubarev)
Date: Fri, 4 Dec 2015 12:22:24 +0100
Subject: [swift-evolution] Proposal: Access control for protocols
Message-ID: <etPan.56617770.354c52ce.8c1@mscience.local>

I hope markdown is supported in these mails. :)

A few month ago I build a singleton generator with the help of protocols (just for fun). As you all know a true singleton will hide its init(), but right know there is no Access control for protocols. This might be a good feature for other code abstraction too.

Any feedback is welcome.

Here is my little implementation.

public protocol SingletonType { /* private */ init() } // wait for this feature to create a true singleton

private var singletonInstances = [String: SingletonType]()

public extension SingletonType {

typealias SingletonInstance = Self
typealias SingletonMetatype = Self.Type

public static var getSingleton: SingletonInstance { return setSingleton { $0 } }

public static var setSingleton: SingletonMetatype { return self }

public static func setSingleton(setter: (_: SingletonInstance) -> SingletonInstance) -> SingletonInstance {

guard let instance = singletonInstances["\(self)"] as? Self else {

return setInstance(self.init(), withSetter: setter, overridable: true)
}
return setInstance(instance, withSetter: setter, overridable: false)
}

private static func setInstance(var instance: Self, withSetter setter: (_: Self) -> Self, overridable: Bool) -> Self {

// I will have to fix `var instance` in Swift 3.0 :/

instance = restoreInstanceIfNeeded(instance1: instance, instance2: setter(instance), overridable: overridable)

singletonInstances["\(self)"] = instance

return instance
}

private static func restoreInstanceIfNeeded(instance1 i1: Self, instance2 i2: Self, overridable: Bool) -> Self {

guard i1.dynamicType is AnyClass else { return i2 }

return ((i1 as! AnyObject) !== (i2 as! AnyObject)) && !overridable ? i1 : i2
}
}

infix operator ? { associativity none }

func ? <Instance: SingletonType>(type: Instance.Type, newInstance: Instance) -> Instance {

return type.setSingleton { (_) -> Instance in newInstance }
}


??
Regards Adrian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/4ea76c78/attachment.html>

From s.pepyakin at gmail.com  Fri Dec  4 05:39:00 2015
From: s.pepyakin at gmail.com (Sergey Shulepov)
Date: Fri, 4 Dec 2015 14:39:00 +0300
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <F3457551-65D5-4A8D-A9F3-241F26D67678@me.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<F3457551-65D5-4A8D-A9F3-241F26D67678@me.com>
Message-ID: <0EF11B02-2420-4111-96C2-5E483F07956B@gmail.com>

Agree on the if-as-an-expression part, that is possible, but it can be cumbersome if branches contain more than few trivial expressions.
Whenever such situations occur you often have to break your expressions to separate methods just to split things up.

As for switch-as-an-expression, I'm not sure I got it right, can you elaborate on this?

> On 04 Dec 2015, at 14:07, Maxthon Chan <xcvista at me.com> wrote:
>
> I believe switch-as-an-expression can be implemented as a dictionary lookup, and if-as-an-expression is the ternary operator ?:
>
>> On Dec 4, 2015, at 19:05, Sergey Shulepov <s.pepyakin at gmail.com> wrote:
>>
>> Hello.
>>
>> It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
>> so instead of writing:
>>
>> var message: String
>> if x % 2 == 0 {
>> message = "x is even"
>> } else {
>> message = "x is odd"
>> }
>>
>> you can write:
>>
>> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>>
>> I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.
>> Thanks!
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From brent at architechies.com  Fri Dec  4 05:50:39 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 03:50:39 -0800
Subject: [swift-evolution] SE-0005: Ambiguous NS prefix removals
Message-ID: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>

SE-0005 in the repository (?Better Translation of Objective-C APIs into Swift?, https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md) discusses plans to remove the NS prefix from many Foundation APIs, but admits that you haven?t yet settled on a way to handle conflicts with the standard library:

> The removal of the "NS" prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation's versions will shadow the standard library's versions. We are investigating several ways to address this problem, including:
>
> 	? Retain the NS prefix on such classes.
>
> 	? Introduce some notion of submodules into Swift, so that these classes would exist in a submodule for reference-semantic types (e.g., one would refer to Foundation.ReferenceTypes.Array or similar).

Since the main difference between e.g. String and NSString is that the latter has reference semantics, why not alter the name to reflect that?

NSString -> StringRef
NSArray -> ArrayRef
NSDictionary -> DictionaryRef

The resulting type names have a bit of a Core Foundation-y flavor to them, but that?s not necessarily a bad thing?it quietly encourages use of the Swift types just as NSString vs. CFStringRef quietly encourages use of the Foundation type.

Normally this transformation would not apply to types with no corresponding standard library type:

NSCalendar -> Calendar
NSBundle -> Bundle

However, subclasses of a type with ?Ref? in the name would also have ?Ref" in the subclass name:

NSMutableString -> MutableStringRef (because its superclass is StringRef)
NSMutableArray -> MutableArrayRef (because its superclass is ArrayRef)
NSMutableDictionary -> MutableDictionaryRef (because its superclass is DictionaryRef)

If you don?t like ?Ref?, ?Object? is wordier but clearer:

StringObject, MutableStringObject
ArrayObject, MutableArrayObject
DictionaryObject, MutableDictionaryObject

And as long as we?re doing this, it might make sense to add the ?Ref? suffix for a few other types which might naturally have value-typed standard library equivalents someday, even if they don?t right now:

URLRef (the URL type would have something like NSURLComponents?s mutation APIs)
DateComponentsRef (this is begging to be a struct in Swift)
DateRef (perhaps less important, since it?s immutable and doesn?t really have many natural properties to expose anyway)
NumberRef (a standard library equivalent might be a protocol that all numeric types conform to)

On the other hand, you might just want to cross that bridge when you get to it with a source code migrator in Swift 4 or whatever.

(By the way, I love the rest of this proposal. I?ve always wanted Swift to clean up and reformat API names more when it imports them.)

--
Brent Royal-Gordon
Architechies


From cheyo at masters3d.com  Fri Dec  4 06:14:36 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Fri, 4 Dec 2015 06:14:36 -0600
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
Message-ID: <CAAcV4sZ=HEu-GO9=U3-7ASZ0tkvQu_uhM6VcAG552emT=nJRug@mail.gmail.com>

I like it. Related.

https://lists.swift.org/pipermail/swift-evolution/2015-December/000098.html

The switch would be interesting if it could be done in one line.


On Friday, December 4, 2015, Sergey Shulepov <s.pepyakin at gmail.com> wrote:

> Hello.
>
> It would be cool if control flow statements like "switch", "if" can be
> used as expressions, such as in languages like Scala, Rust and Kotlin,
> so instead of writing:
>
> var message: String
> if x % 2 == 0 {
>  message = "x is even"
> } else {
>  message = "x is odd"
> }
>
> you can write:
>
> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>
> I'm not into any kind of compiler development, and don't know is it
> feasible to introduce such change at the moment, but at least, I would like
> to hear why not.
> Thanks!
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/9b3a3a62/attachment.html>

From me at tal.by  Fri Dec  4 07:36:33 2015
From: me at tal.by (Tal Atlas)
Date: Fri, 04 Dec 2015 13:36:33 +0000
Subject: [swift-evolution] abstract keyWord proposal
In-Reply-To: <1BB987A8-48AC-42DF-928E-91ECD2568FEC@dlta-studio.com>
References: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
<CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>
<2DCFAEF9-850D-4360-A230-136D8329F0CE@dlta-studio.com>
<CAGJeWTpL0F+BPPLG8gf9Pxf_ocasqmdkgVrhog+pn4Sq68NkVw@mail.gmail.com>
<1BB987A8-48AC-42DF-928E-91ECD2568FEC@dlta-studio.com>
Message-ID: <CA+ddMk3okznf6a6+2-p3J6eiL38_A2t8RchbRSPxOruMqRkBtQ@mail.gmail.com>

I don't think there'd be much confusion with allowing protocol extensions
to contain stored types but I could easily see that being very difficult to
implement.
On Fri, Dec 4, 2015 at 4:24 AM David Scr?ve <david.screve at dlta-studio.com>
wrote:

> Yes,
>
> I agree with you that abstract might be attached to protocol family of
> feature?but protocol already manage the ?abstract? feature if you don?t
> consider the value storage issue.
>
> Actually, there 2 ways to add this feature :
>
> 1 -  Protocol way : We need to add value storage to protocol
> 2 -  class way : We need to add abstract for method/properties
>
> The question is : Is adding value storage to protocol is a good thing ?
> It might create confusion between classes and protocol, maybe.
>
> But, on the other side, there is not real reason to limit class extension
> to only method and not to properties. In this case, extending protocol to
> value container might be an interesting way to respond to this. Anyway, we
> might keep the abstract keyword.
>
> Regards,
>
> David
>
> Le 4 d?c. 2015 ? 10:11, T.J. Usiyan <griotspeak at gmail.com> a ?crit :
>
> Hello,
>
> This is an interesting example. I can't refute it without questioning
> decisions/intent rather than code so I'll just say that the `abstract`
> quality  you're after still seems like it should be fit into the protocol
> family of features.
>
> TJ
>
> On Fri, Dec 4, 2015 at 3:56 AM, David Scr?ve <david.screve at dlta-studio.com
> > wrote:
>
>> Hello TJ,
>>
>> Actually not completely?Protocol does not handle properties storage. Only
>> class (and struct) can be made abstract.
>>
>> Doing this with protocol and class required the use of both and you need
>> to enforce developer to inherit from class and implement protocol.. An
>> abstract class encapsulate both on this in a single entity.
>>
>> Here is a sample class for WebService :
>>
>> class WebService {
>>     private var lastModified : NSDate
>>     var url : String?
>>
>>     init() {
>>         lastModified=NSDate()
>>     }
>>
>>     func performCall() {
>>         print(self.url)
>>         self.lastModified=NSDate()
>>     }
>> }
>>
>> As written below, I can create a WebService instance?but I would like to
>> forbid this because URL is a property that must be implemented by inherited
>> classes.
>>
>> I I use a protocol and Protocol extension, I will not be able to have
>> lastModified stored value.
>>
>> My proposal is to add abstract keyword as below :
>>
>> abstract class WebService {
>>     private var lastModified : NSDate
>>     abstract var url : String?
>>
>>     init() {
>>         lastModified=NSDate()
>>     }
>>
>>     func performCall() {
>>         print(self.url)
>>         self.lastModified=NSDate()
>>     }
>> }
>>
>> Then I will not be able to create a WebService object, and enforced to
>> implement url property in inherited classes.
>>
>> Regards,
>>
>> David
>>
>> Le 4 d?c. 2015 ? 09:43, T.J. Usiyan <griotspeak at gmail.com> a ?crit :
>>
>> Hello David,
>>
>> This sounds like something that can be accomplished with protocols and
>> default implementations provided in protocol extensions. If you've watched Protocol-Oriented
>> Programming in Swift [Session 408]
>> <https://developer.apple.com/videos/play/wwdc2015-408/>, slides 168 and
>> on, once he begins talking about Protocol Extensions, is the relevant part.
>> It looks like the functionality that you've described is already present in
>> this feature.
>>
>> TJ
>>
>> On Fri, Dec 4, 2015 at 3:30 AM, David Scr?ve <
>> david.screve at dlta-studio.com> wrote:
>>
>>>         Hi Everyone,
>>>
>>>         Nice to see this new swift-evolution process?.I?m not sure to
>>> completely understand the whole process of requesting evolutions, but I?m
>>> trying
>>> to do?
>>>
>>>         As I develop sort of framework, I usually have classes that I
>>> wanted to partially in the framework and force the user to implement others
>>> parts.
>>>
>>>         For example, I have a WebService class that manage the whole
>>> process to perform asynchronous call, error management.
>>>         This class has an abstract property that is specific for each
>>> WebService call.
>>>
>>>         Then I would like to make the URL property abstract and,
>>> consequently, the whole WebService class abstract : The WebService cannot
>>> be directly instantiated.
>>>
>>>         The goal of this feature would be to extend to method.
>>>         This behavior already exists in Java and is really useful.
>>>
>>>         The workaround is to make an URL property that returns invalid
>>> value or make assertion, but the error is only detected at runtime.
>>>
>>>         My proposal would be to just add a keyword before func, class or
>>> var. An abstract property or func should not provide implementation.
>>>
>>>         Regards,
>>>
>>>
>>> David
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/53714029/attachment-0001.html>

From adrian.kashivskyy at me.com  Fri Dec  4 07:39:28 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 14:39:28 +0100
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <50C9A65D-DDDB-462D-9151-BD672DE556AD@me.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
<D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
<00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>
<8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>
<50C9A65D-DDDB-462D-9151-BD672DE556AD@me.com>
Message-ID: <F82D2642-BFB1-4604-9DC7-3EE4CC75D254@me.com>

> Removing Objective-C compatibility in Swift (which does not even have a complete set of libraries yet) in this stage would undermine its usability and the completeness of the libraries, and when the project finally matured a bad reputation of ?incomplete support? would already be out there, hampering its use.

Could you point out five Objective-C Linux libraries (apart from GNU Foundation) that you'd like to use in your Swift projects on Linux? I suspect you can't and that's why I strongly disagree. You only need Objective-C on Apple platforms ? and that's not going away.

Maintaining Objective-C interoperability for non-Apple platforms is a very niche aim and could potentially lead to longer development and evolvement process. That's a reasonable tradeoff.

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Maxthon Chan <xcvista at me.com> w dniu 04.12.2015, o godz. 11:54:
>
> Let?s take a look at C# which Microsoft designed to replace C++ MFC. The compatibility is never removed although C# itself is pretty complete already. During early days (2002) lots of components in C# are stubs calling back to MFC but nevertheless this presented a more or less complete library set to the user and allowed the language to gain traction - so many traction that now people demand it to be ported to multiple platforms.
>
> Removing Objective-C compatibility in Swift (which does not even have a complete set of libraries yet) in this stage would undermine its usability and the completeness of the libraries, and when the project finally matured a bad reputation of ?incomplete support? would already be out there, hampering its use.
>
>> On Dec 4, 2015, at 18:33, Alex Blewitt <alex.blewitt at gmail.com> wrote:
>>
>> A more interesting question would be: is Swift designed to ultimately replace Objective-C? If so, baking in compatibility from the outset of the open source version would probably be going in the wrong direction.
>>
>> Alex
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/59a39de6/attachment.html>

From david at hartbit.com  Fri Dec  4 07:40:39 2015
From: david at hartbit.com (David Hart)
Date: Fri, 4 Dec 2015 14:40:39 +0100
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
Message-ID: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>

In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:

@interface MyClass : NSObject

@property (nonatomic) ForeignClass* foreignObject;
@property (nonatomic) int64_t foreignKey;

@end

@implementation MyClass

- (void)setForeignKey:(int64_t)foreignKey {
_foreignKey = foreignKey;
_foreignObject = nil;
}

- (ForeignClass*)foreignObject {
if (!_foreignObject) {
_foreignObject = [Database expensiveSelect:_foreignKey];
}
return _foreignObject;
}

@end

Unfortunately, the lazy keyword in Swift, which was supposed to make the lazy initialization pattern more concsive does not work in this case:

class MyClass {
var foreignKey: Int64 {
didSet {
self.foreignObject = nil
}
}

lazy var foreignObject: ForeignClass? = {
return Database.expensiveSelect(self.foreignKey)
}()
}

I'm forced to rewrite it this way:

class MyClass {
var foreignKey: Int64 {
didSet {
self.foreignObject = nil
}
}

private var _foreignObject: ForeignClass? = nil
var foreignObject: ForeignClass? {
if _foreignObject == nil {
_foreignObject = Database.expensiveSelect(self.foreignKey)
}
return _foreignObject
}
}

When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
I want your opinion on three alternatives:

1- Do nothing, and use the slightly uglier Swift example when using a cache.
2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
3- Add a cache modifier that re-calcualtes when nil.

From adrian.zubarev at devandartist.com  Fri Dec  4 07:51:25 2015
From: adrian.zubarev at devandartist.com (Adrian Zubarev)
Date: Fri, 4 Dec 2015 14:51:25 +0100
Subject: [swift-evolution] Proposal: CustomConvertible protocol
Message-ID: <etPan.56619a5d.3cf2ae61.8c1@mscience.local>

We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.

Swift introduced a few Convertible protocols, but it still needs some more If you ask me.

Something like this:

public protocol CustomConvertible {

typealias CustomType

public init(value: Self.CustomType) // or in a better way I can't come up with
}
But it should work in a way that we could create more different types like enums and ErrorType.

protocol AConvertible: CustomConvertible { /* some stuff here*/ }
protocol BConvertible: CustomConvertible { /* some stuff here*/ }

struct A {
var foo: Int = 0
}

struct B {
var boo: String = "Hello World"
}

struct C: AConvertible, BConvertible {

typealias CustomAType = A
typealias CustomBType = B

var magical: SomeType

init(value: CustomAType) {
// implement it
}

init(value: CustomBType) {
// implement it
}
}

//===========================

let firstC: C = A() // this is what I'm missing in Swift
let secondC: C = B() // this would be a great syntax sugar
What do you think?



??
Regards Adrian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/877dfd93/attachment.html>

From xcvista at me.com  Fri Dec  4 08:11:45 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 22:11:45 +0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <F82D2642-BFB1-4604-9DC7-3EE4CC75D254@me.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
<D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
<00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>
<8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>
<50C9A65D-DDDB-462D-9151-BD672DE556AD@me.com>
<F82D2642-BFB1-4604-9DC7-3EE4CC75D254@me.com>
Message-ID: <2B7AB7DC-9187-4766-B103-556E9DA17312@me.com>

The thing is, I can, in fact, point out a few libraries I would like to use in Swift and as of now you cannot provide it:

GNUstep GUI (AppKit) and UIKit - anything that have GUI in it will need either of those libraries, and GNUstep?s version works perfectly under Linux as well as Windows.
GNUstep GSWeb (WebObjects) and GDL2 (Enterprise Objects Framework) - Web development stack, ain?t this your initial intention of allowing Swift to be run on Linux?
GNUstep SimpleWebKit (lightweight Web browser framework, depend on AppKit)
GNUstep Base for Windows (Foundation, but it works under Windows while yours currently don?t) - better cross platform capability from the get-go.

And a few other libraries that are nice to have:

CocoaAsyncSocket
Objective-C LINQ
CGIKit (a lightweight replacement for WebObjects) - another Web stack

Also by maintaining Objective-C compatibility means you can free yourself from the burden of maintaining any runtime libraries except the Swift standard library itself, as it would allow you to offload Foundation and all other supporting libraries to other, existing, Objective-C-based projects, like GNUstep.

> On Dec 4, 2015, at 21:39, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
>> Removing Objective-C compatibility in Swift (which does not even have a complete set of libraries yet) in this stage would undermine its usability and the completeness of the libraries, and when the project finally matured a bad reputation of ?incomplete support? would already be out there, hampering its use.
>
> Could you point out five Objective-C Linux libraries (apart from GNU Foundation) that you'd like to use in your Swift projects on Linux? I suspect you can't and that's why I strongly disagree. You only need Objective-C on Apple platforms ? and that's not going away.
>
> Maintaining Objective-C interoperability for non-Apple platforms is a very niche aim and could potentially lead to longer development and evolvement process. That's a reasonable tradeoff.
>
> Pozdrawiam ? Regards,
> Adrian Kashivskyy
>
>> Wiadomo?? napisana przez Maxthon Chan <xcvista at me.com <mailto:xcvista at me.com>> w dniu 04.12.2015, o godz. 11:54:
>>
>> Let?s take a look at C# which Microsoft designed to replace C++ MFC. The compatibility is never removed although C# itself is pretty complete already. During early days (2002) lots of components in C# are stubs calling back to MFC but nevertheless this presented a more or less complete library set to the user and allowed the language to gain traction - so many traction that now people demand it to be ported to multiple platforms.
>>
>> Removing Objective-C compatibility in Swift (which does not even have a complete set of libraries yet) in this stage would undermine its usability and the completeness of the libraries, and when the project finally matured a bad reputation of ?incomplete support? would already be out there, hampering its use.
>>
>>> On Dec 4, 2015, at 18:33, Alex Blewitt <alex.blewitt at gmail.com <mailto:alex.blewitt at gmail.com>> wrote:
>>>
>>> A more interesting question would be: is Swift designed to ultimately replace Objective-C? If so, baking in compatibility from the outset of the open source version would probably be going in the wrong direction.
>>>
>>> Alex
>>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2bac4de1/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2bac4de1/attachment-0001.p7s>

From vinivendra at gmail.com  Fri Dec  4 08:13:12 2015
From: vinivendra at gmail.com (Vinicius Vendramini)
Date: Fri, 4 Dec 2015 09:13:12 -0500
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <CANGnqV2RiaLCg=YLnQtH_dm58x54+9hxxCQ+=vA3c=m+qeF6iw@mail.gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
<CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
<CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>
<CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com>
<7630D974-9311-4D15-B318-631EBF3FEB47@sb.org>
<CANGnqV2RiaLCg=YLnQtH_dm58x54+9hxxCQ+=vA3c=m+qeF6iw@mail.gmail.com>
Message-ID: <028CF26F-131D-48DD-9B70-39A507E1E352@gmail.com>

If Swift?s Ints may go up to 2048 bits, I?d agree that they probably cover most cases. That?s not to say a big int would be useless, just that I think it should be separate, meant to be used by those who actually need it rather than interfering with normal Int logic, which is likely to be used more often.

> On Dec 4, 2015, at 2:45 AM, Austin Zheng <austinzheng at gmail.com> wrote:
>
> Clojure also performs automatic reduction of rational numbers. However, the source code seems to indicate that reduction is built into the definitions of the methods that perform arithmetic on rational numbers, and the "Ratio" class that implements rational number support does not do any reduction itself.
>
> (c.f. https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Numbers.java <https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Numbers.java>, ll. 350-364, 704-727, et al)
>
> From a semantic standpoint, I would be very surprised if e.g. 2/6 and 1/3 were not considered equal, or for that matter if they weren't completely interchangeable.
>
> - Austin
>
> On Thu, Dec 3, 2015 at 11:21 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
> On Dec 3, 2015, at 9:48 PM, Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>> wrote:
> >
> >> A good invariant for Rationals might be having them always
> >> represented in the most simplified form - for example, Rational(2, 6) should
> >> be represented internally as 1/3 when constructed.
> >
> > This has performance tradeoffs.  What do other libraries and languages do?
>
> I know Haskell always reduces Rationals to their reduced form. This does have performance implications, but not doing so has surprising consequences for operations you perform on them. For example, it?s reasonable to expect that Rational(2,6) == Rational(1,3), but implementing that without reduced Rationals pretty much requires reducing them on the fly. The alternative, of saying they?re not equal, would probably surprise most people.
>
> -Kevin Ballard
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b930887b/attachment.html>

From stepan.hruda at gmail.com  Fri Dec  4 08:15:57 2015
From: stepan.hruda at gmail.com (Stepan Hruda)
Date: Fri, 04 Dec 2015 06:15:57 -0800 (PST)
Subject: [swift-evolution] Proposal: CustomConvertible protocol
In-Reply-To: <etPan.56619a5d.3cf2ae61.8c1@mscience.local>
References: <etPan.56619a5d.3cf2ae61.8c1@mscience.local>
Message-ID: <1449238556751.bf17d8bb@Nodemailer>

This is not how *LiteralConvertible protocols work, though. You can only initialize variables with specific literal values recognized by the parser, it never magically casts a type to a different type for you. Similar implicit casts in my opinion confuse whoever reads the code afterwards.




```


class SomeConvertible: BooleanLiteralConvertible {

? ? typealias BooleanLiteralType = Bool

? ? let boolean: Bool




? ? internal required init(booleanLiteral value: SomeConvertible.BooleanLiteralType) {

? ? ? ? self.boolean = value

? ? }

}




func getBoolean() -> Bool {

? ? return false

}




let validConvertible: SomeConvertible = false

// Line below doesn?t compile

let invalidConvertible: SomeConvertible = getBoolean()



```

On Fri, Dec 4, 2015 at 8:51 AM, Adrian Zubarev
<adrian.zubarev at devandartist.com> wrote:

> We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.
> Swift introduced a few Convertible protocols, but it still needs some more If you ask me.
> Something like this:
> public protocol CustomConvertible {
>
>     typealias CustomType
>
>     public init(value: Self.CustomType) // or in a better way I can't come up with
> }
> But it should work in a way that we could create more different types like enums and ErrorType.
> protocol AConvertible: CustomConvertible { /* some stuff here*/ }
> protocol BConvertible: CustomConvertible { /* some stuff here*/ }
> struct A {
>     var foo: Int = 0
> }
> struct B {
>     var boo: String = "Hello World"
> }
> struct C: AConvertible, BConvertible {
>
>     typealias CustomAType = A
>     typealias CustomBType = B
>
>     var magical: SomeType
>
>     init(value: CustomAType) {
>         // implement it
>     }
>
>     init(value: CustomBType) {
>         // implement it
>     }
> }
> //===========================
> let firstC: C = A() // this is what I'm missing in Swift
> let secondC: C = B() // this would be a great syntax sugar
> What do you think?
> ??
> Regards Adrian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0fbd63a3/attachment.html>

From vinivendra at gmail.com  Fri Dec  4 08:26:48 2015
From: vinivendra at gmail.com (Vinicius Vendramini)
Date: Fri, 4 Dec 2015 09:26:48 -0500
Subject: [swift-evolution] abstract keyWord proposal
In-Reply-To: <CA+ddMk3okznf6a6+2-p3J6eiL38_A2t8RchbRSPxOruMqRkBtQ@mail.gmail.com>
References: <D8F693D4-3153-4B2A-B920-98847E949E3A@dlta-studio.com>
<CAGJeWTpYti=YOBDb3iSwHSpwFTsiapJdj_=aSSLz+EYB4_b3dQ@mail.gmail.com>
<2DCFAEF9-850D-4360-A230-136D8329F0CE@dlta-studio.com>
<CAGJeWTpL0F+BPPLG8gf9Pxf_ocasqmdkgVrhog+pn4Sq68NkVw@mail.gmail.com>
<1BB987A8-48AC-42DF-928E-91ECD2568FEC@dlta-studio.com>
<CA+ddMk3okznf6a6+2-p3J6eiL38_A2t8RchbRSPxOruMqRkBtQ@mail.gmail.com>
Message-ID: <93136795-4B72-4159-8B3B-8C25B96FEB82@gmail.com>


> On Dec 4, 2015, at 8:36 AM, Tal Atlas <me at tal.by> wrote:
>
> I don't think there'd be much confusion with allowing protocol extensions to contain stored types but I could easily see that being very difficult to implement.

I agree, I believe allowing stored types either in protocols or in classes might be very difficult to implement. I don?t even think this is allowed in Objective-C, probably for the same reason.


From adrian.zubarev at devandartist.com  Fri Dec  4 08:27:59 2015
From: adrian.zubarev at devandartist.com (Adrian Zubarev)
Date: Fri, 4 Dec 2015 15:27:59 +0100
Subject: [swift-evolution] Fw: Re:  Proposal: CustomConvertible protocol
Message-ID: <etPan.5661a2ef.747f369d.8c1@mscience.local>

I know that, but I couldn?t describe it better. I mean implicit casts are already there and do look the same:

class A {}
class B: A {}

let someA: A = B() // this works fine

protocol C {}

class D: C {}

let someC: C = D() // this works fine too
Sure it depends on the context, but the implicit cast functionality could be extended on my opinion.

I build a little prototype to be able to automatically cast math expression. It looks something like this:

let someDouble = Double(UInt(0) + Int(1)) // + is overloaded

// sometimes the compiler complains so I need to write this

let someDouble = Double(UInt(0) + Int(1) as Expression)

// it would look better if we had implicit conversion enabled trough constructors
let someDouble: Double = UInt(0) + Int(1)

// or
let someDouble: Double = UInt(0) + Int(1) as Expression




??
Regards Adrian

Am 4. Dezember 2015 bei 15:15:59, Stepan Hruda (stepan.hruda at gmail.com) schrieb:

This is not how *LiteralConvertible protocols work, though. You can only initialize variables with specific literal values recognized by the parser, it never magically casts a type to a different type for you. Similar implicit casts in my opinion confuse whoever reads the code afterwards.

```
class SomeConvertible: BooleanLiteralConvertible {
? ? typealias BooleanLiteralType = Bool
? ? let boolean: Bool

? ? internal required init(booleanLiteral value: SomeConvertible.BooleanLiteralType) {
? ? ? ? self.boolean = value
? ? }
}

func getBoolean() -> Bool {
? ? return false
}

let validConvertible: SomeConvertible = false
// Line below doesn?t compile
let invalidConvertible: SomeConvertible = getBoolean()
```




On Fri, Dec 4, 2015 at 8:51 AM, Adrian Zubarev <adrian.zubarev at devandartist.com> wrote:

We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.

Swift introduced a few Convertible protocols, but it still needs some more If you ask me.

Something like this:

public protocol CustomConvertible {

typealias CustomType

public init(value: Self.CustomType) // or in a better way I can't come up with
}

But it should work in a way that we could create more different types like enums and ErrorType.

protocol AConvertible: CustomConvertible { /* some stuff here*/ }
protocol BConvertible: CustomConvertible { /* some stuff here*/ }

struct A {
var foo: Int = 0
}

struct B {
var boo: String = "Hello World"
}

struct C: AConvertible, BConvertible {

typealias CustomAType = A
typealias CustomBType = B

var magical: SomeType

init(value: CustomAType) {
// implement it
}

init(value: CustomBType) {
// implement it
}
}

//===========================

let firstC: C = A() // this is what I'm missing in Swift
let secondC: C = B() // this would be a great syntax sugar

What do you think?



??
Regards Adrian


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/630928a7/attachment-0001.html>

From a.michail at me.com  Fri Dec  4 09:20:45 2015
From: a.michail at me.com (Amir Michail)
Date: Fri, 04 Dec 2015 10:20:45 -0500
Subject: [swift-evolution] mandatory "?" suffix for identifiers associated
with optional types
Message-ID: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>

So for example the following (probable) bug would result in a compile error:

let f = x < 5 // where x is optional and could be nil

If that was really what was intended, you would need to write:

let f = x? < 5

Similarly, the rule would also apply for functions that return an optional type:

let f = x()? < 5

A major advantage of this approach is it would encourage programmers to unwrap optionals early to avoid writing ??? and ??!" frequently in their code.

Note that conditional chaining would just make use of the existing ??? suffix. There is no need to add another ??? after that.

let f = x?.g?.h
let f = x()?.g?.h

As for implicitly unwrapped optionals, a ??? suffix would only be used when you want to treat a value as an optional (e.g., when comparing it to nil). For example, for x of type Int?, one could write:

let y = (x? == nil) ? 0 : x


From cheyo at masters3d.com  Fri Dec  4 09:41:32 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Fri, 4 Dec 2015 09:41:32 -0600
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
Message-ID: <CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>

This a little confusing, I don't think adding yet another question mark
helps. The ?? ( nil coalescing operator) already included in swift handles
checking for nil values. If anything, the ternary operator just makes
matters worse in this example.  If else would be better imo.

https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html


On Friday, December 4, 2015, Amir Michail <a.michail at me.com> wrote:

> So for example the following (probable) bug would result in a compile
> error:
>
> let f = x < 5 // where x is optional and could be nil
>
> If that was really what was intended, you would need to write:
>
> let f = x? < 5
>
> Similarly, the rule would also apply for functions that return an optional
> type:
>
> let f = x()? < 5
>
> A major advantage of this approach is it would encourage programmers to
> unwrap optionals early to avoid writing ??? and ??!" frequently in their
> code.
>
> Note that conditional chaining would just make use of the existing ???
> suffix. There is no need to add another ??? after that.
>
> let f = x?.g?.h
> let f = x()?.g?.h
>
> As for implicitly unwrapped optionals, a ??? suffix would only be used
> when you want to treat a value as an optional (e.g., when comparing it to
> nil). For example, for x of type Int?, one could write:
>
> let y = (x? == nil) ? 0 : x
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ef0cd973/attachment.html>

From a.michail at me.com  Fri Dec  4 09:44:38 2015
From: a.michail at me.com (Amir Michail)
Date: Fri, 04 Dec 2015 10:44:38 -0500
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
Message-ID: <67703D49-546F-4E49-9868-87DC8A166296@me.com>


> On Dec 4, 2015, at 10:41 AM, J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>
> This a little confusing, I don't think adding yet another question mark helps. The ?? ( nil coalescing operator) already included in swift handles checking for nil values. If anything, the ternary operator just makes matters worse in this example.  If else would be better imo.
>
> https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000133.html>
>
>

I don?t want to remember if a variable is optional. I want to see it in the variable name.

> On Friday, December 4, 2015, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
> So for example the following (probable) bug would result in a compile error:
>
> let f = x < 5 // where x is optional and could be nil
>
> If that was really what was intended, you would need to write:
>
> let f = x? < 5
>
> Similarly, the rule would also apply for functions that return an optional type:
>
> let f = x()? < 5
>
> A major advantage of this approach is it would encourage programmers to unwrap optionals early to avoid writing ??? and ??!" frequently in their code.
>
> Note that conditional chaining would just make use of the existing ??? suffix. There is no need to add another ??? after that.
>
> let f = x?.g?.h
> let f = x()?.g?.h
>
> As for implicitly unwrapped optionals, a ??? suffix would only be used when you want to treat a value as an optional (e.g., when comparing it to nil). For example, for x of type Int?, one could write:
>
> let y = (x? == nil) ? 0 : x
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/efc382fe/attachment.html>

From sean at fifthace.com  Fri Dec  4 09:54:26 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 09:54:26 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <F600E70E-075E-40C8-BB19-661D9C1186FF@alkaline-solutions.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<F600E70E-075E-40C8-BB19-661D9C1186FF@alkaline-solutions.com>
Message-ID: <9BFE2EED-28DF-4084-932A-522077968026@fifthace.com>

Could alternatively could take a page from Smalltalk:

extension Bool {
func ifTrue<T>(@autoclosure isTrue: () -> T, @autoclosure otherwise isFalse: () -> T) -> T {
if self {
return isTrue()
} else {
return isFalse()
}
}
}

:)

l8r
Sean


> On Dec 4, 2015, at 1:40 AM, David Waite <david at alkaline-solutions.com> wrote:
>
> Of course one could just drop it as a grammatical language feature and turn it a standard library feature of some form, e.g.:
>
> @warn_unused_result
> func when<T>(@autoclosure expr: ()->Bool, @autoclosure value: ()->T, @autoclosure otherwise: ()->T) -> T {
>   if expr() {
>     return value()
>   }
>   else {
>     return otherwise()
>   }
> }
>
> var a = when(1 + 1 == 2, value: "works", otherwise: "fails")
>
> print(a) // => ?works"
>
> -DW
>
>> On Dec 4, 2015, at 12:26 AM, David Hart <david at hartbit.com> wrote:
>>
>> I also tend to agree but I don't like the ordering in the Python version and would rather see the introduction of the then keyword
>>
>> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com> wrote:
>>
>>> I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.
>>>
>>> l8r
>>> Sean
>>>
>>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>>>
>>>> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>>>>
>>>> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>>>>
>>>> ?
>>>> Dan Appel
>>>>
>>>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>>>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>>>
>>>> The use of "?" can be confusing when speed reading code with optionals.
>>>>
>>>> Consider this code as somebody learning swift as their first language.
>>>> let result = !condition ? 1 : 2
>>>>
>>>>
>>>> Some alternatives:
>>>>
>>>> Haskel
>>>> if predicate then expr1 else expr2
>>>> Python
>>>> result = x if a > b else y
>>>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>>>
>>>>
>>>> References:
>>>> https://devforums.apple.com/message/1020139#1020139
>>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From david at alkaline-solutions.com  Fri Dec  4 09:56:51 2015
From: david at alkaline-solutions.com (David Waite)
Date: Fri, 4 Dec 2015 08:56:51 -0700
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <67703D49-546F-4E49-9868-87DC8A166296@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
Message-ID: <87EA274A-D267-4C3E-9D30-218EF7DE054D@alkaline-solutions.com>

Ruby recently ran into a similar problem from the other direction - they wanted to support ?. syntax, but ??? was already legal in identifier names (and used) to represent result values which are meant to be considered ?truthy?. In the end, they went with a different ?&." syntax because
1. This meant ??? was both a naming convention and an operation
2. Too many question marks made the code psychologically confusing
3. They already had to change the syntax (to ?.??) to make code unambiguous

An naming system or pattern indicating something optional isn?t a bad idea - but it probably shouldn?t use ??? for the same reason. A ??? is already used heavily to indicate actions against optionals, and every time you see that identifier you will have to think about whether you are just referencing it by name, or performing some operation on it.

I think you however are pushing for a mandatory naming system for optionals - to make it clear in your examples below that ?x? needs to be treated as an optional, not as the type contained within. This makes coming up with an acceptable system significantly harder.

-DW

> On Dec 4, 2015, at 8:44 AM, Amir Michail <a.michail at me.com> wrote:
>
> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>
>> On Friday, December 4, 2015, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>> So for example the following (probable) bug would result in a compile error:
>>
>> let f = x < 5 // where x is optional and could be nil
>>
>> If that was really what was intended, you would need to write:
>>
>> let f = x? < 5
>>
>> Similarly, the rule would also apply for functions that return an optional type:
>>
>> let f = x()? < 5
>>
>> A major advantage of this approach is it would encourage programmers to unwrap optionals early to avoid writing ??? and ??!" frequently in their code.
>>
>> Note that conditional chaining would just make use of the existing ??? suffix. There is no need to add another ??? after that.
>>
>> let f = x?.g?.h
>> let f = x()?.g?.h
>>
>> As for implicitly unwrapped optionals, a ??? suffix would only be used when you want to treat a value as an optional (e.g., when comparing it to nil). For example, for x of type Int?, one could write:
>>
>> let y = (x? == nil) ? 0 : x
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/af8f54ea/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4139 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/af8f54ea/attachment-0001.p7s>

From alex.blewitt at gmail.com  Fri Dec  4 09:57:52 2015
From: alex.blewitt at gmail.com (Alex Blewitt)
Date: Fri, 4 Dec 2015 16:57:52 +0100
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <67703D49-546F-4E49-9868-87DC8A166296@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
Message-ID: <902C8BE2-9C17-4C32-AD96-5821779203AE@gmail.com>


> On 4 Dec 2015, at 16:44, Amir Michail <a.michail at me.com> wrote:
>
> I don?t want to remember if a variable is optional. I want to see it in the variable name.

Optionality is associated with the type, not the identifier. In addition, how would you deal with type aliases to optional constructs?

typealias MaybeString = String?
var maybe:MaybeString

This doesn?t ?look? like an optional value (so would it deserve a ? at the end) but if you have MaybeString? you now have an Optional<Optional<String>>. Should you have ?? there now?

Alex
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/48445dda/attachment.html>

From sean at fifthace.com  Fri Dec  4 10:01:57 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 10:01:57 -0600
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <87EA274A-D267-4C3E-9D30-218EF7DE054D@alkaline-solutions.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
<87EA274A-D267-4C3E-9D30-218EF7DE054D@alkaline-solutions.com>
Message-ID: <32007497-D08D-4E8E-B10A-82EA77C5ECF1@fifthace.com>

Couldn?t this issue of remembering which variables are optional be solved in the IDE by using a different color for optionals or something like that?

l8r
Sean


> On Dec 4, 2015, at 9:56 AM, David Waite <david at alkaline-solutions.com> wrote:
>
> Ruby recently ran into a similar problem from the other direction - they wanted to support ?. syntax, but ??? was already legal in identifier names (and used) to represent result values which are meant to be considered ?truthy?. In the end, they went with a different ?&." syntax because
> 1. This meant ??? was both a naming convention and an operation
> 2. Too many question marks made the code psychologically confusing
> 3. They already had to change the syntax (to ?.??) to make code unambiguous
>
> An naming system or pattern indicating something optional isn?t a bad idea - but it probably shouldn?t use ??? for the same reason. A ??? is already used heavily to indicate actions against optionals, and every time you see that identifier you will have to think about whether you are just referencing it by name, or performing some operation on it.
>
> I think you however are pushing for a mandatory naming system for optionals - to make it clear in your examples below that ?x? needs to be treated as an optional, not as the type contained within. This makes coming up with an acceptable system significantly harder.
>
> -DW
>
>> On Dec 4, 2015, at 8:44 AM, Amir Michail <a.michail at me.com> wrote:
>>
>> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>>
>>> On Friday, December 4, 2015, Amir Michail <a.michail at me.com> wrote:
>>> So for example the following (probable) bug would result in a compile error:
>>>
>>> let f = x < 5 // where x is optional and could be nil
>>>
>>> If that was really what was intended, you would need to write:
>>>
>>> let f = x? < 5
>>>
>>> Similarly, the rule would also apply for functions that return an optional type:
>>>
>>> let f = x()? < 5
>>>
>>> A major advantage of this approach is it would encourage programmers to unwrap optionals early to avoid writing ??? and ??!" frequently in their code.
>>>
>>> Note that conditional chaining would just make use of the existing ??? suffix. There is no need to add another ??? after that.
>>>
>>> let f = x?.g?.h
>>> let f = x()?.g?.h
>>>
>>> As for implicitly unwrapped optionals, a ??? suffix would only be used when you want to treat a value as an optional (e.g., when comparing it to nil). For example, for x of type Int?, one could write:
>>>
>>> let y = (x? == nil) ? 0 : x
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From jeremy.j.pereira at googlemail.com  Fri Dec  4 10:09:24 2015
From: jeremy.j.pereira at googlemail.com (Jeremy Pereira)
Date: Fri, 4 Dec 2015 16:09:24 +0000
Subject: [swift-evolution] Proposal: CustomConvertible protocol
In-Reply-To: <etPan.5661a2ef.747f369d.8c1@mscience.local>
References: <etPan.5661a2ef.747f369d.8c1@mscience.local>
Message-ID: <8C02CEA7-110C-4F9F-A46F-185DAE5076C9@googlemail.com>


> On 4 Dec 2015, at 14:27, Adrian Zubarev <adrian.zubarev at devandartist.com> wrote:
>
> I know that, but I couldn?t describe it better. I mean implicit casts are already there and do look the same:
>
> class A {}
> class B: A {}
>
> let someA: A = B() // this works fine
>
> protocol C {}
>
> class D: C {}
>
> let someC: C = D() // this works fine too

Neither of these are casts. someA is actually  a reference to the B. someC is a reference to a D (I?m not sure how the mechanism worked for structs conforming to protocols, but there?s still no instance conversion)


>
> Sure it depends on the context, but the implicit cast functionality could be extended on my opinion.
>
> I build a little prototype to be able to automatically cast math expression. It looks something like this:
>
> let someDouble = Double(UInt(0) + Int(1)) // + is overloaded
>
> // sometimes the compiler complains so I need to write this
>
> let someDouble = Double(UInt(0) + Int(1) as Expression)
>
> // it would look better if we had implicit conversion enabled trough constructors
> let someDouble: Double = UInt(0) + Int(1)
>
> // or
> let someDouble: Double = UInt(0) + Int(1) as Expression
>
>

This used to come up on the Apple lists. A deliberate design decision was taken early on to require explicit conversion for arithmetic types on the grounds that implicit casts are a common source of error. I don?t think any proposal to add them back in is going to get very far.


>
>
>
>
> ?
> Regards Adrian
>
> Am 4. Dezember 2015 bei 15:15:59, Stepan Hruda (stepan.hruda at gmail.com) schrieb:
>
>> This is not how *LiteralConvertible protocols work, though. You can only initialize variables with specific literal values recognized by the parser, it never magically casts a type to a different type for you. Similar implicit casts in my opinion confuse whoever reads the code afterwards.
>>
>> ```
>> class SomeConvertible: BooleanLiteralConvertible {
>>     typealias BooleanLiteralType = Bool
>>     let boolean: Bool
>>
>>     internal required init(booleanLiteral value: SomeConvertible.BooleanLiteralType) {
>>         self.boolean = value
>>     }
>> }
>>
>> func getBoolean() -> Bool {
>>     return false
>> }
>>
>> let validConvertible: SomeConvertible = false
>> // Line below doesn?t compile
>> let invalidConvertible: SomeConvertible = getBoolean()
>> ```
>>
>>
>>
>>
>> On Fri, Dec 4, 2015 at 8:51 AM, Adrian Zubarev <adrian.zubarev at devandartist.com> wrote:
>>
>> We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.
>>
>> Swift introduced a few Convertible protocols, but it still needs some more If you ask me.
>>
>> Something like this:
>>
>> public protocol CustomConvertible {
>>
>>     typealias CustomType
>>
>>     public init(value: Self.CustomType) // or in a better way I can't come up with
>> }
>>
>>
>> But it should work in a way that we could create more different types like enums and ErrorType.
>>
>> protocol AConvertible: CustomConvertible { /* some stuff here*/ }
>> protocol BConvertible: CustomConvertible { /* some stuff here*/ }
>>
>> struct A {
>>     var foo: Int = 0
>> }
>>
>> struct B {
>>     var boo: String = "Hello World"
>> }
>>
>> struct C: AConvertible, BConvertible {
>>
>>     typealias CustomAType = A
>>     typealias CustomBType = B
>>
>>     var magical: SomeType
>>
>>     init(value: CustomAType) {
>>         // implement it
>>     }
>>
>>     init(value: CustomBType) {
>>         // implement it
>>     }
>> }
>>
>> //===========================
>>
>> let firstC: C = A() // this is what I'm missing in Swift
>> let secondC: C = B() // this would be a great syntax sugar
>>
>>
>> What do you think?
>>
>>
>>
>> ?
>> Regards Adrian
>>
>>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From a.michail at me.com  Fri Dec  4 10:09:39 2015
From: a.michail at me.com (Amir Michail)
Date: Fri, 04 Dec 2015 11:09:39 -0500
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <32007497-D08D-4E8E-B10A-82EA77C5ECF1@fifthace.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
<87EA274A-D267-4C3E-9D30-218EF7DE054D@alkaline-solutions.com>
<32007497-D08D-4E8E-B10A-82EA77C5ECF1@fifthace.com>
Message-ID: <D7346036-25C8-4641-9E2B-1427E50D8BAB@me.com>


> On Dec 4, 2015, at 11:01 AM, Sean Heber <sean at fifthace.com> wrote:
>
> Couldn?t this issue of remembering which variables are optional be solved in the IDE by using a different color for optionals or something like that?

It?s better in the language because it forces the programmer to think more about what they are doing and the compiler could generate more errors for possible bugs.

Also, the syntax highlighting you propose would not be supported in all contexts (e.g., email, mailing lists, github, etc.).

>
> l8r
> Sean
>
>
>> On Dec 4, 2015, at 9:56 AM, David Waite <david at alkaline-solutions.com> wrote:
>>
>> Ruby recently ran into a similar problem from the other direction - they wanted to support ?. syntax, but ??? was already legal in identifier names (and used) to represent result values which are meant to be considered ?truthy?. In the end, they went with a different ?&." syntax because
>> 1. This meant ??? was both a naming convention and an operation
>> 2. Too many question marks made the code psychologically confusing
>> 3. They already had to change the syntax (to ?.??) to make code unambiguous
>>
>> An naming system or pattern indicating something optional isn?t a bad idea - but it probably shouldn?t use ??? for the same reason. A ??? is already used heavily to indicate actions against optionals, and every time you see that identifier you will have to think about whether you are just referencing it by name, or performing some operation on it.
>>
>> I think you however are pushing for a mandatory naming system for optionals - to make it clear in your examples below that ?x? needs to be treated as an optional, not as the type contained within. This makes coming up with an acceptable system significantly harder.
>>
>> -DW
>>
>>> On Dec 4, 2015, at 8:44 AM, Amir Michail <a.michail at me.com> wrote:
>>>
>>> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>>>
>>>> On Friday, December 4, 2015, Amir Michail <a.michail at me.com> wrote:
>>>> So for example the following (probable) bug would result in a compile error:
>>>>
>>>> let f = x < 5 // where x is optional and could be nil
>>>>
>>>> If that was really what was intended, you would need to write:
>>>>
>>>> let f = x? < 5
>>>>
>>>> Similarly, the rule would also apply for functions that return an optional type:
>>>>
>>>> let f = x()? < 5
>>>>
>>>> A major advantage of this approach is it would encourage programmers to unwrap optionals early to avoid writing ??? and ??!" frequently in their code.
>>>>
>>>> Note that conditional chaining would just make use of the existing ??? suffix. There is no need to add another ??? after that.
>>>>
>>>> let f = x?.g?.h
>>>> let f = x()?.g?.h
>>>>
>>>> As for implicitly unwrapped optionals, a ??? suffix would only be used when you want to treat a value as an optional (e.g., when comparing it to nil). For example, for x of type Int?, one could write:
>>>>
>>>> let y = (x? == nil) ? 0 : x
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From a.michail at me.com  Fri Dec  4 10:17:18 2015
From: a.michail at me.com (Amir Michail)
Date: Fri, 04 Dec 2015 11:17:18 -0500
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <902C8BE2-9C17-4C32-AD96-5821779203AE@gmail.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
<902C8BE2-9C17-4C32-AD96-5821779203AE@gmail.com>
Message-ID: <E0DCFE91-73E2-45C7-BF15-A83AB417ED0A@me.com>


> On Dec 4, 2015, at 10:57 AM, Alex Blewitt <alex.blewitt at gmail.com> wrote:
>
>
>> On 4 Dec 2015, at 16:44, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>
>> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>
> Optionality is associated with the type, not the identifier. In addition, how would you deal with type aliases to optional constructs?
>
> typealias MaybeString = String?
> var maybe:MaybeString
>
> This doesn?t ?look? like an optional value (so would it deserve a ? at the end) but if you have MaybeString? you now have an Optional<Optional<String>>. Should you have ?? there now?
>
> Alex

You would have:

typealias MaybeString? = String?
var maybe?:MaybeString?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/43474a8c/attachment-0001.html>

From ben_cocoa_dev_list at yahoo.co.uk  Fri Dec  4 10:31:59 2015
From: ben_cocoa_dev_list at yahoo.co.uk (Ben)
Date: Fri, 4 Dec 2015 16:31:59 +0000
Subject: [swift-evolution] Proposal: Protocol methods should accept default
arguments
Message-ID: <777E6A79-E489-46B0-A3ED-135EED198666@yahoo.co.uk>

Hi list,

I propose that methods defined in protocols should accept default arguments. This could help remove the need for method families where only one parameter is essential, but others are often used.

For example:

protocol Datastore {
func executeQuery(query: String)
func executeQuery(query: String, usingParameters: [Any])
func executeQuery(query: String, usingParameters: [Any], logType: LogType)
func executeQuery(query: String, usingParameters: [Any], logType: LogType, completionHandler:ClosureOfSomeSort)
}

Where typically the implementing object funnels the first three methods through to the final, more verbose method.

This could be shortened to:

protocol Database {
func executeQuery(query: String, usingParameters: [Any] = [], logType: LogType  = .NotLogged  completionHandler:ClosureOfSomeSort? = nil)
}

Advantages:
- Only one method to implement
- Less to document, less cluttered interface
- Prevent objects adopting the protocol from using different default values
- Prevent objects from implementing similar methods in the family differently - fewer code paths to inspect, less confusion over behaviour since no argument values are hidden

This fits in well with the parameters section of the Swift API design page: https://swift.org/documentation/api-design-guidelines.html#parameters <https://swift.org/documentation/api-design-guidelines.html#parameters>


What do you think?

Regards,

Ben Barnett
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/56e6c6bf/attachment.html>

From xcvista at me.com  Fri Dec  4 04:50:28 2015
From: xcvista at me.com (Maxthon Chan)
Date: Fri, 04 Dec 2015 18:50:28 +0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Swift Open
Source Project and Foundation replacements
In-Reply-To: <8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>
References: <89F1B454-0DB0-4A6F-85E7-BC688040EA9D@me.com>
<F0DE8028-3B24-46C1-8682-0D7F1507E9C4@apple.com>
<CADcs6kMVnR3J+E5rhsHJUkz9JccgQ5kH+KBqVTxxZYN+ObmbAw@mail.gmail.com>
<48AD6BCF-3BBA-4C4F-BB46-3320107CB0CA@apple.com>
<05F94FE4-F064-45D0-ADEF-95B44910DCD2@hartbit.com>
<74AF294C-B899-4377-AC0E-0991CEEAEA74@apple.com>
<D7FA0905-D237-45CB-B10E-5D656D315BD3@hartbit.com>
<00AB30B1-5932-44B5-AF88-58D27CB2D192@me.com>
<8AC5B808-F618-42E1-A8AF-72A80865ED2A@gmail.com>
Message-ID: <AAEE0780-EC74-4BE8-9C5A-04E0436A0DAC@me.com>

Let?s take a look at C# which Microsoft designed to replace C++ MFC. The compatibility is never removed although C# itself is pretty complete already. During early days (2002) lots of components in C# are stubs calling back to MFC but nevertheless this presented a more or less complete library set to the user and allowed the language to gain traction - so many traction that now people demand it to be ported to multiple platforms.

Removing Objective-C compatibility in Swift (which does not even have a complete set of libraries yet) in this stage would undermine its usability and the completeness of the libraries, and when the project finally matured a bad reputation of ?incomplete support? would already be out there, hampering its use.

> On Dec 4, 2015, at 18:33, Alex Blewitt <alex.blewitt at gmail.com> wrote:
>
> A more interesting question would be: is Swift designed to ultimately replace Objective-C? If so, baking in compatibility from the outset of the open source version would probably be going in the wrong direction.
>
> Alex
>
>> On 4 Dec 2015, at 11:12, ChanMaxthon <xcvista at me.com <mailto:xcvista at me.com>> wrote:
>>
>> Then just please leave some stub there so communities can plug their own bridging into Swift gracefully (that is, not as an out-of-tree patch)
>>
>> My idea:
>>
>> 1) a pure C header file, swift-compat.h describing the interface the community-provided bridging mechanism should implement besides objc/runtime.h, objc/message.h and objc/objc-arc.h, and the associated documentation describing what the community should do, in a even more liberal license like MIT or 3c/BSD
>> 2) The build system checking for a compatible, community-provided libswift-compat.so during compilation and enable the community-provided bridging mechanism if present.
>> 3) Compile-time issues can be solved similarly using libswift-repl-compat.so
>>
>> When building Swift without a compatible community-provided Foundation reimplementation present everything here will be built, like what we are doing here. When building with such a library set and the corresponding libswift-compat.so present only the Swift standard library will be built, linking to the community-provided Objective-C runtime (which is also used as the Swift runtime through the Objective-C bridge) and take advantage of the community-provided Foundation framework through bridging.
>>
>> Sent from my iPhone
>>
>> On Dec 4, 2015, at 16:14, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
>>
>>> The improvements to the Objective-C bridge in Swift 3 are definitely appreciated but are just cosmetics (they only affect naming). What about the fact that NSURL in your example, being an immutable type, would be better represented by a  value type in Swift? Don't misunderstand me, I applaud the fact that corelibs exists, and understand that Foundation has a lot of great ideas, but I would have preferred seeing it exist as a community hobby project instead of an official Swift project and have the community instead concentrate on a core library that embraces value types, generics, protocols, etc...
>>>
>>> On 04 Dec 2015, at 00:14, Tony Parker <anthony.parker at apple.com <mailto:anthony.parker at apple.com>> wrote:
>>>
>>>> Hi David,
>>>>
>>>> Fundamentally, we believe that the Foundation library is part of Swift. We also believe that it would be a mistake to throw out the many years of experience that it brings with it. In areas where there are impedance mismatches between the existing API and what feels ?Swifty?, we can improve the API of Foundation to make it as great to use there as it is in Objective-C. The first step of that is our heavy involvement with the Swift 3 naming guidelines here:
>>>>
>>>> https://swift.org/documentation/api-design-guidelines.html <https://swift.org/documentation/api-design-guidelines.html>
>>>>
>>>> Hope this helps,
>>>> - Tony
>>>>
>>>>> On Dec 3, 2015, at 3:09 PM, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
>>>>>
>>>>> Hi Tony,
>>>>>
>>>>> Like Jacob, I would have preferred a completely original corelibs library that uses that clean sheet to be as bold in library design as the standard library is. Why would that direction go against the goal of begin "as standards compliant as possible?? it would just mean that Apple Platform developers would have the option of using the Objective-C bridge to talk to Objective-C Foundation or use the ?swifter? corelibs.
>>>>>
>>>>> David.
>>>>>
>>>>>> On 03 Dec 2015, at 23:33, Tony Parker <anthony.parker at apple.com <mailto:anthony.parker at apple.com>> wrote:
>>>>>>
>>>>>> Hi Jacob,
>>>>>>
>>>>>>> On Dec 3, 2015, at 2:23 PM, Jacob Bandes-Storch <jtbandes at gmail.com <mailto:jtbandes at gmail.com>> wrote:
>>>>>>>
>>>>>>> On Thu, Dec 3, 2015 at 2:13 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>>>>>
>>>>>>> As others have surmised, the goal for the Swift Foundation project is to provide a pure-swift implementation (which reuses widely-available C libraries) of important Foundation APIs that do *not* depend on the Objective-C runtime.  Reusing GNUstep, Cocotron, or even Apple?s existing Foundation implementation didn?t allow us to achieve those goals, so we didn?t go with those approaches.
>>>>>>>
>>>>>>> This is great, but is the goal also to exactly duplicate all the idiosyncrasies of the Obj-C Foundation?
>>>>>>>
>>>>>>> Quiz: what's the result of NSURL(string: "http://one/two;three/four <http://one/two;three/four>")?.URLByAppendingPathComponent("five") ?
>>>>>>>
>>>>>>> If, as I would hope, corelibs-foundation is an opportunity to make simpler APIs that resolve some of these weirdnesses, then should the class names (NSURL, NSFileHandle, etc.) really be the same?
>>>>>>>
>>>>>>>  _______________________________________________
>>>>>>> swift-corelibs-dev mailing list
>>>>>>> swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev <https://lists.swift.org/mailman/listinfo/swift-corelibs-dev>
>>>>>>
>>>>>> I think NSURL is actually a pretty great example of an API that we want to be the same on all platforms. There is quite a bit of logic backing it (along with something like NSURLComponents). Check out some of it here:
>>>>>>
>>>>>> https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c <https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/URL.subproj/CFURLComponents_URIParser.c>
>>>>>>
>>>>>> (and that CF code is reflected up into NSURLComponents)
>>>>>>
>>>>>> It?s tricky stuff, and the goal is to get it as standards compliant as possible. If we use this implementation for all Swift clients then we can get a consistent answer everywhere - and even better, fix bugs everywhere at the same time.
>>>>>>
>>>>>> So if you find some of the interface confusing (or wrong), then file a bug for us at bugs.swift.org <http://bugs.swift.org/>. We can take this opportunity to try to make it better for everyone.
>>>>>>
>>>>>> Thanks,
>>>>>> - Tony
>>>>>>
>>>>>>
>>>>>>
>>>>>>  _______________________________________________
>>>>>> swift-corelibs-dev mailing list
>>>>>> swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev <https://lists.swift.org/mailman/listinfo/swift-corelibs-dev>
>>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/528a5fd6/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/528a5fd6/attachment-0001.p7s>

From felix.gabel at me.com  Fri Dec  4 10:37:32 2015
From: felix.gabel at me.com (Felix Gabel)
Date: Fri, 04 Dec 2015 17:37:32 +0100
Subject: [swift-evolution] Proposal: Protocol methods should accept
default arguments
In-Reply-To: <777E6A79-E489-46B0-A3ED-135EED198666@yahoo.co.uk>
References: <777E6A79-E489-46B0-A3ED-135EED198666@yahoo.co.uk>
Message-ID: <18A5AD3C-3780-4725-9D98-FA3B85354912@me.com>

Default parameters are in my opinion an implementation detail and should be always handled by the conforming type. What can be done here is only declare the 4th method in the protocol and create a protocol extension with default forwarding.

> On 04 Dec 2015, at 17:31, Ben <ben_cocoa_dev_list at yahoo.co.uk> wrote:
>
> Hi list,
>
> I propose that methods defined in protocols should accept default arguments. This could help remove the need for method families where only one parameter is essential, but others are often used.
>
> For example:
>
> protocol Datastore {
>   func executeQuery(query: String)
>   func executeQuery(query: String, usingParameters: [Any])
>   func executeQuery(query: String, usingParameters: [Any], logType: LogType)
>   func executeQuery(query: String, usingParameters: [Any], logType: LogType, completionHandler:ClosureOfSomeSort)
> }
>
> Where typically the implementing object funnels the first three methods through to the final, more verbose method.
>
> This could be shortened to:
>
> protocol Database {
>   func executeQuery(query: String, usingParameters: [Any] = [], logType: LogType  = .NotLogged  completionHandler:ClosureOfSomeSort? = nil)
> }
>
> Advantages:
> - Only one method to implement
> - Less to document, less cluttered interface
> - Prevent objects adopting the protocol from using different default values
> - Prevent objects from implementing similar methods in the family differently - fewer code paths to inspect, less confusion over behaviour since no argument values are hidden
>
> This fits in well with the parameters section of the Swift API design page: https://swift.org/documentation/api-design-guidelines.html#parameters
>
>
> What do you think?
>
> Regards,
>
> Ben Barnett
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d4641d2a/attachment.html>

From sean at fifthace.com  Fri Dec  4 10:41:43 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 10:41:43 -0600
Subject: [swift-evolution] Proposal: Protocol methods should accept
default arguments
In-Reply-To: <777E6A79-E489-46B0-A3ED-135EED198666@yahoo.co.uk>
References: <777E6A79-E489-46B0-A3ED-135EED198666@yahoo.co.uk>
Message-ID: <52198CEC-524C-4E50-B9CA-47C582D75CF2@fifthace.com>

I ran into a situation like this in my own code and thought the same before I realized that the protocol only needs the single function that takes all of the parameters (with no need for defaults) and convenience variants can provide default values by implementing them in a protocol extension.

l8r
Sean


> On Dec 4, 2015, at 10:31 AM, Ben <ben_cocoa_dev_list at yahoo.co.uk> wrote:
>
> Hi list,
>
> I propose that methods defined in protocols should accept default arguments. This could help remove the need for method families where only one parameter is essential, but others are often used.
>
> For example:
>
> protocol Datastore {
>   func executeQuery(query: String)
>   func executeQuery(query: String, usingParameters: [Any])
>   func executeQuery(query: String, usingParameters: [Any], logType: LogType)
>   func executeQuery(query: String, usingParameters: [Any], logType: LogType, completionHandler:ClosureOfSomeSort)
> }
>
> Where typically the implementing object funnels the first three methods through to the final, more verbose method.
>
> This could be shortened to:
>
> protocol Database {
>   func executeQuery(query: String, usingParameters: [Any] = [], logType: LogType  = .NotLogged  completionHandler:ClosureOfSomeSort? = nil)
> }
>
> Advantages:
> - Only one method to implement
> - Less to document, less cluttered interface
> - Prevent objects adopting the protocol from using different default values
> - Prevent objects from implementing similar methods in the family differently - fewer code paths to inspect, less confusion over behaviour since no argument values are hidden
>
> This fits in well with the parameters section of the Swift API design page: https://swift.org/documentation/api-design-guidelines.html#parameters
>
>
> What do you think?
>
> Regards,
>
> Ben Barnett
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From migi at apple.com  Fri Dec  4 10:57:04 2015
From: migi at apple.com (Alex Migicovsky)
Date: Fri, 04 Dec 2015 08:57:04 -0800
Subject: [swift-evolution] API Guidelines for Asynchronous	Completion
Handlers?
In-Reply-To: <9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
Message-ID: <66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>


> On Dec 3, 2015, at 2:15 PM, Douglas Gregor <dgregor at apple.com> wrote:
>
>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com <mailto:daniel.j.stenmark at gmail.com>> wrote:
>>
>> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>>
>> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
>> - Double Block (one for success, one for failure)
>> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/ <http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/>)
>>
>> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?
>
> This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.

Hi Dan!

I think guidelines in this area would be great.

Here are the tradeoffs I think we have for each approach:

1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.

2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code.

Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.

Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.

/*
Single block.
Trailing closure syntax works well.
*/
request.fetch { result, error in
// More indented code since we need to use guard or if let.
guard let result = result else {
// Need to force unwrap `error`.
handleFetchError(error!)
return
}

use(result)
}

/*
Double block.
Trailing closure syntax is awkward here.
*/
request.fetch(withCompletionHandler: { result in
use(result)
}, errorHandler: { error in
// Don?t need to force unwrap `error`.
handleFetchError(error)
})

3) Enums with associated values are conceptually nice, but unless we have a Result<> or an Either<> in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.

Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?

Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.

- Alex


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e429cbf6/attachment-0001.html>

From adrian.kashivskyy at me.com  Fri Dec  4 11:17:23 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 18:17:23 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <9BFE2EED-28DF-4084-932A-522077968026@fifthace.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<F600E70E-075E-40C8-BB19-661D9C1186FF@alkaline-solutions.com>
<9BFE2EED-28DF-4084-932A-522077968026@fifthace.com>
Message-ID: <04881AE6-1F3E-4A30-902A-BE0DEAD84DCA@me.com>

-1 on Bool extension, this should exist as a free function. Reason?

(1 + 1 == 2).ifTrue("foo", otherwise: "bar")

This: 1. doesn't look well; 2. is not clear and understandable; 3. doesn't allow condition to be a closure.


Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Sean Heber <sean at fifthace.com> w dniu 04.12.2015, o godz. 16:54:
>
> Could alternatively could take a page from Smalltalk:
>
>   extension Bool {
>      func ifTrue<T>(@autoclosure isTrue: () -> T, @autoclosure otherwise isFalse: () -> T) -> T {
>         if self {
>            return isTrue()
>         } else {
>            return isFalse()
>         }
>      }
>   }
>
> :)
>
> l8r
> Sean
>
>
>> On Dec 4, 2015, at 1:40 AM, David Waite <david at alkaline-solutions.com> wrote:
>>
>> Of course one could just drop it as a grammatical language feature and turn it a standard library feature of some form, e.g.:
>>
>> @warn_unused_result
>> func when<T>(@autoclosure expr: ()->Bool, @autoclosure value: ()->T, @autoclosure otherwise: ()->T) -> T {
>>  if expr() {
>>    return value()
>>  }
>>  else {
>>    return otherwise()
>>  }
>> }
>>
>> var a = when(1 + 1 == 2, value: "works", otherwise: "fails")
>>
>> print(a) // => ?works"
>>
>> -DW
>>
>>> On Dec 4, 2015, at 12:26 AM, David Hart <david at hartbit.com> wrote:
>>>
>>> I also tend to agree but I don't like the ordering in the Python version and would rather see the introduction of the then keyword
>>>
>>> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com> wrote:
>>>
>>>> I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.
>>>>
>>>> l8r
>>>> Sean
>>>>
>>>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>>>>
>>>>> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>>>>>
>>>>> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>>>>>
>>>>> ?
>>>>> Dan Appel
>>>>>
>>>>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>>>>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>>>>
>>>>> The use of "?" can be confusing when speed reading code with optionals.
>>>>>
>>>>> Consider this code as somebody learning swift as their first language.
>>>>> let result = !condition ? 1 : 2
>>>>>
>>>>>
>>>>> Some alternatives:
>>>>>
>>>>> Haskel
>>>>> if predicate then expr1 else expr2
>>>>> Python
>>>>> result = x if a > b else y
>>>>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>>>>
>>>>>
>>>>> References:
>>>>> https://devforums.apple.com/message/1020139#1020139
>>>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/1fc6baf1/attachment.html>

From sean at fifthace.com  Fri Dec  4 11:21:51 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 11:21:51 -0600
Subject: [swift-evolution] API Guidelines for Asynchronous	Completion
Handlers?
In-Reply-To: <66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
<66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>
Message-ID: <31B10C00-43F7-4BEF-970E-9AD85D18C976@fifthace.com>

What if there was a possibility for a deferred throw?

For example, imagine the fetch function was something like this:

func fetch(withCompletionHandler: (Result) -> ()) defer throws {}

And to call it, you?d wrap it in a try with a new kind of catch:

do {
try request.fetch() { result in ? }
} defer catch (? pattern) {
}

So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.

The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:

func fetch(withCompletionHandler: (Result) -> ()) defer throws {
var context = FetchContext()
context.completionHandler = withCompletionHandler
context.errorHandler = { reason in throw RequestError(reason) }
self.pending.append(context)
context.start()
}

Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.

l8r
Sean


> On Dec 4, 2015, at 10:57 AM, Alex Migicovsky <migi at apple.com> wrote:
>
>>
>> On Dec 3, 2015, at 2:15 PM, Douglas Gregor <dgregor at apple.com> wrote:
>>
>>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>>>
>>> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>>>
>>> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
>>> - Double Block (one for success, one for failure)
>>> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)
>>>
>>> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?
>>
>> This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.
>
> Hi Dan!
>
> I think guidelines in this area would be great.
>
> Here are the tradeoffs I think we have for each approach:
>
> 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.
>
> 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code.
>
> Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.
>
> Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.
>
>      /*
>           Single block.
>           Trailing closure syntax works well.
>      */
>      request.fetch { result, error in
>           // More indented code since we need to use guard or if let.
>           guard let result = result else {
>                // Need to force unwrap `error`.
>                handleFetchError(error!)
>                return
>           }
>
>           use(result)
>      }
>
>      /*
>           Double block.
>           Trailing closure syntax is awkward here.
>      */
>      request.fetch(withCompletionHandler: { result in
>           use(result)
>      }, errorHandler: { error in
>           // Don?t need to force unwrap `error`.
>           handleFetchError(error)
>      })
>
> 3) Enums with associated values are conceptually nice, but unless we have a Result<> or an Either<> in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.
>
> Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?
>
> Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.
>
> - Alex
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From david at owensd.io  Fri Dec  4 11:27:10 2015
From: david at owensd.io (David Owens II)
Date: Fri, 4 Dec 2015 09:27:10 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
Message-ID: <2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>

There?s no need for the ?then" keyword if you just allow if-expressions as well.

```
let result = if condition { 1 } else { 2 }
```

Or more verbosely:

```
let result =
if condition {
return 1
}
else {
return 2
}
```

The same could be for switch statements as well.

```
let result = switch item {
case foo: 1
case bar: 2
}
```

The above assume implicit returns on single-line statements on the condition/case branches.

-David

> On Dec 3, 2015, at 11:26 PM, David Hart <david at hartbit.com> wrote:
>
> I also tend to agree but I don't like the ordering in the Python version and would rather see the introduction of the then keyword
>
> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com <mailto:sean at fifthace.com>> wrote:
>
>> I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.
>>
>> l8r
>> Sean
>>
>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com <mailto:dan.appel00 at gmail.com>> wrote:
>>
>>> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>>>
>>> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>>>
>>> ?
>>> Dan Appel
>>>
>>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>>
>>> The use of "?" can be confusing when speed reading code with optionals.
>>>
>>> Consider this code as somebody learning swift as their first language.
>>> let result = !condition ? 1 : 2
>>>
>>>
>>> Some alternatives:
>>>
>>> Haskel
>>> if predicate then expr1 else expr2
>>> Python
>>> result = x if a > b else y
>>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>>
>>>
>>> References:
>>> https://devforums.apple.com/message/1020139#1020139 <https://devforums.apple.com/message/1020139#1020139>
>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066 <https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e4d7cf1c/attachment-0001.html>

From adrian.kashivskyy at me.com  Fri Dec  4 11:27:28 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 18:27:28 +0100
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <E0DCFE91-73E2-45C7-BF15-A83AB417ED0A@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
<902C8BE2-9C17-4C32-AD96-5821779203AE@gmail.com>
<E0DCFE91-73E2-45C7-BF15-A83AB417ED0A@me.com>
Message-ID: <3D66276D-9943-4D6B-B273-5B2BA24487FF@me.com>

I agree with Alex,

> Optionality is associated with the type, not the identifier.

Optionals are designed to provide null safety inside a program, not promote using nullables wherever possible. If you use optionals so extensively that you feel the need for special IDE support, maybe you should consider rethinking your API.

By the way,

> So for example the following (probable) bug would result in a compile error:
> let f = x < 5 // where x is optional and could be nil

I believe nil being less than anything else is an expected behavior which has been introduced by design.

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Amir Michail <a.michail at me.com> w dniu 04.12.2015, o godz. 17:17:
>
>>
>> On Dec 4, 2015, at 10:57 AM, Alex Blewitt <alex.blewitt at gmail.com <mailto:alex.blewitt at gmail.com>> wrote:
>>
>>
>>> On 4 Dec 2015, at 16:44, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>>
>>> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>>
>> Optionality is associated with the type, not the identifier. In addition, how would you deal with type aliases to optional constructs?
>>
>> typealias MaybeString = String?
>> var maybe:MaybeString
>>
>> This doesn?t ?look? like an optional value (so would it deserve a ? at the end) but if you have MaybeString? you now have an Optional<Optional<String>>. Should you have ?? there now?
>>
>> Alex
>
> You would have:
>
> typealias MaybeString? = String?
> var maybe?:MaybeString?
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/be8e8c99/attachment.html>

From a.michail at me.com  Fri Dec  4 11:30:48 2015
From: a.michail at me.com (Amir Michail)
Date: Fri, 04 Dec 2015 12:30:48 -0500
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <3D66276D-9943-4D6B-B273-5B2BA24487FF@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
<902C8BE2-9C17-4C32-AD96-5821779203AE@gmail.com>
<E0DCFE91-73E2-45C7-BF15-A83AB417ED0A@me.com>
<3D66276D-9943-4D6B-B273-5B2BA24487FF@me.com>
Message-ID: <7ED9D8AA-1191-4801-B529-6CE6998E5C4E@me.com>


> On Dec 4, 2015, at 12:27 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
> I agree with Alex,
>
>> Optionality is associated with the type, not the identifier.
>
> Optionals are designed to provide null safety inside a program, not promote using nullables wherever possible. If you use optionals so extensively that you feel the need for special IDE support, maybe you should consider rethinking your API.
>
> By the way,
>
>> So for example the following (probable) bug would result in a compile error:
>> let f = x < 5 // where x is optional and could be nil
>
> I believe nil being less than anything else is an expected behavior which has been introduced by design.
>

It still leads to bugs that are hard to find though.

In any case, I proposed using this code for such a comparison: let f = x? < 5

> Pozdrawiam ? Regards,
> Adrian Kashivskyy
>
>> Wiadomo?? napisana przez Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> w dniu 04.12.2015, o godz. 17:17:
>>
>>>
>>> On Dec 4, 2015, at 10:57 AM, Alex Blewitt <alex.blewitt at gmail.com <mailto:alex.blewitt at gmail.com>> wrote:
>>>
>>>
>>>> On 4 Dec 2015, at 16:44, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>>>
>>>> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>>>
>>> Optionality is associated with the type, not the identifier. In addition, how would you deal with type aliases to optional constructs?
>>>
>>> typealias MaybeString = String?
>>> var maybe:MaybeString
>>>
>>> This doesn?t ?look? like an optional value (so would it deserve a ? at the end) but if you have MaybeString? you now have an Optional<Optional<String>>. Should you have ?? there now?
>>>
>>> Alex
>>
>> You would have:
>>
>> typealias MaybeString? = String?
>> var maybe?:MaybeString?
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f2fdf9de/attachment-0001.html>

From david at hartbit.com  Fri Dec  4 11:33:55 2015
From: david at hartbit.com (David Hart)
Date: Fri, 4 Dec 2015 18:33:55 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
Message-ID: <BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>

Best proposition since, but still more verbose than the ternary operator.

> On 04 Dec 2015, at 18:27, David Owens II <david at owensd.io> wrote:
>
> There?s no need for the ?then" keyword if you just allow if-expressions as well.
>
> ```
> let result = if condition { 1 } else { 2 }
> ```
>
> Or more verbosely:
>
> ```
> let result =
>     if condition {
>         return 1
>     }
>     else {
>         return 2
>     }
> ```
>
> The same could be for switch statements as well.
>
> ```
> let result = switch item {
>     case foo: 1
>     case bar: 2
> }
> ```
>
> The above assume implicit returns on single-line statements on the condition/case branches.
>
> -David
>
>> On Dec 3, 2015, at 11:26 PM, David Hart <david at hartbit.com> wrote:
>>
>> I also tend to agree but I don't like the ordering in the Python version and would rather see the introduction of the then keyword
>>
>>> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com> wrote:
>>>
>>> I agree that using ? for ternary feels.. uncomfortable in Swift. I wouldn't mind seeing Python-style or just eliminating it entirely in favor of simplicity.
>>>
>>> l8r
>>> Sean
>>>
>>>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>>>>
>>>> I agree that ternary can make code unreadable, especially so with the ???. I personally like the Haskel option the most, but it introduces a new keyword ?then?, which isn?t great either. Python?s "y if x else z" is therefore, in my opinion, the best alternative.
>>>>
>>>> Also, I found it interesting how split the Rust community was about removing the ternary operator.
>>>>
>>>> ?
>>>> Dan Appel
>>>>
>>>>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>>>>> Would you consider replacing the C style ?: ternary operator to something that does not use the question mark and colon ?
>>>>>
>>>>> The use of "?" can be confusing when speed reading code with optionals.
>>>>>
>>>>> Consider this code as somebody learning swift as their first language.
>>>>> let result = !condition ? 1 : 2
>>>>>
>>>>>
>>>>> Some alternatives:
>>>>>
>>>>> Haskel
>>>>> if predicate then expr1 else expr2
>>>>> Python
>>>>> result = x if a > b else y
>>>>> The advantage of not using the question mark is that the language will be more consistency on the use of "?" to mean only optionals.
>>>>>
>>>>>
>>>>> References:
>>>>> https://devforums.apple.com/message/1020139#1020139
>>>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/780dbf0c/attachment.html>

From jgroff at apple.com  Fri Dec  4 11:36:32 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 09:36:32 -0800
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in
closures
In-Reply-To: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
References: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
Message-ID: <20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>


> On Dec 3, 2015, at 10:28 PM, David Waite <david at alkaline-solutions.com> wrote:
>
> ( Originally proposed here: https://forums.developer.apple.com/thread/13806 <https://forums.developer.apple.com/thread/13806> )
>
> Often, frameworks will wish to provide a domain specific language for configuring or composition. Web frameworks for instance may define methods like
>
> get(?/?) { request, result in ? }
>
> Testing frameworks (such as Quick/Nimble) may wish to define a terse and expressive syntax for defining behavioral tests:
>
> describe("the 'Documentation' directory") {
>       it("has everything you need to get started") {
>             let sections = Directory("Documentation").sections
>             expect(sections).to(contain("Organized Tests with Quick Examples and Example Groups?))
>       }
> }
>
> While expressive, this has a big problem - describe, it, expect and contain are now defined as either global functions (which cause namespace pollution and mandate global state) or instance methods on a class (which requires the use of class inheritance, and is limited by single class inheritance)
>
> You could have some sort of context object passed into the closure instead:
>
> protocol SpecBuilder {
>       func describe(description:String, inner:(QuickSpecContext)->())
> }
>
> protocol QuickSpecContext {
>       func it(description:String, inner:(QuickSpecContext)->())
>       func expect<T>(statement:@autoclosure ()->T, file: StaticString = __FILE__, line: UWord = __LINE__ ) -> Expectation<T>
> }
>
> var spec = QuickSpecBuilder(config)
> spec.describe("the 'Documentation' directory") {
>       context in
>       context.it <http://context.it/>("has everything you need to get started") {
>             context in
>             let sections = Directory("Documentation").sections
>             context.expect(sections).to(contain("Organized Tests with Quick Examples and Example Groups?))
>       }
> }
>
> But this has significantly more noise. So my proposal is to allow for a closure argument to be used as the current type instance- to be able to redefine ?self? within a block.
>
> var spec = QuickSpecBuilder(config)
> spec.describe("the 'Documentation' directory") {
>       self in
>       it("has everything you need to get started") {
>             self in
>             let sections = Directory("Documentation").sections
>             expect(sections).to(contain("Organized Tests with Quick Examples and Example Groups?))
>       }
> }
>
> resolution remains the same (lexical scope shadowing the type), this is merely shorthand to allow expressive grammars without requiring class inheritance or global functions. It also remains optional to use - the last two examples are based around the same protocols and should compile to the same code.
>
> I considered alternate syntaxes to express this, mostly alternatives on the bracketing of the closure itself to indicate binding a parameter to self. In the end, I decided:
> 1. When a block has multiple parameters, you would still need syntax decide which, if any, is bound to self
> 2. The language complexity in having another syntax for expressing closures with different behavior may not be worth it
> 3. Code would be confusing for those not knowing the new syntax. ?self in? is (comparatively) straightforward and descriptive

Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:

{
import func QuickSpecBuilder.expect

expect(sections).to(....)
}

Being able to elide self is already somewhat controversial, and a number of people find it makes code harder to read. I worry that allowing closures to change 'self' has the potential to be even more confusing. In Javascript, it's my understanding the ability to arbitrarily rebind 'this' is seen as a design flaw rather than a feature people regularly take advantage of.

-Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/843b5d38/attachment-0001.html>

From rjmccall at apple.com  Fri Dec  4 11:42:28 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 09:42:28 -0800
Subject: [swift-evolution] Proposal: CustomConvertible protocol
In-Reply-To: <etPan.56619a5d.3cf2ae61.8c1@mscience.local>
References: <etPan.56619a5d.3cf2ae61.8c1@mscience.local>
Message-ID: <3C363FCE-50C0-4244-B479-97371AF068D0@apple.com>

> On Dec 4, 2015, at 5:51 AM, Adrian Zubarev <adrian.zubarev at devandartist.com> wrote:
> We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.
>
> Swift introduced a few Convertible protocols, but it still needs some more If you ask me.
>
> Something like this:
>
> public protocol CustomConvertible {
>
>     typealias CustomType
>
>     public init(value: Self.CustomType) // or in a better way I can't come up with
> }
> But it should work in a way that we could create more different types like enums and ErrorType.
>
> protocol AConvertible: CustomConvertible { /* some stuff here*/ }
> protocol BConvertible: CustomConvertible { /* some stuff here*/ }
>
> struct A {
>     var foo: Int = 0
> }
>
> struct B {
>     var boo: String = "Hello World"
> }
>
> struct C: AConvertible, BConvertible {
>
>     typealias CustomAType = A
>     typealias CustomBType = B
>
>     var magical: SomeType
>
>     init(value: CustomAType) {
>         // implement it
>     }
>
>     init(value: CustomBType) {
>         // implement it
>     }
> }
>
> //===========================
>
> let firstC: C = A() // this is what I'm missing in Swift
> let secondC: C = B() // this would be a great syntax sugar
> What do you think?
>
This is effectively a request for user-defined conversion operators.  We actually did support those at one point in the history of Swift, but we removed them because they both introduced a lot of confusion and errors into common user idioms and were very problematic for the type-checker.  It?s easy to look at obviously-contextually-typed examples like this and say that the type-checker should just make it work, but in the context of a general System F-sub type system, it is a massive source of added complexity.

In other words, at present, this is not an extension we feel we can deliver a satisfactory experience for, and to be taken seriously, any proposal is going need to demonstrate a lot of familiarity with type systems.

John.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2cd5dab6/attachment.html>

From adrian.kashivskyy at me.com  Fri Dec  4 11:43:17 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 18:43:17 +0100
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <7ED9D8AA-1191-4801-B529-6CE6998E5C4E@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
<CAAcV4sYy8aH4S_6gbYR_yM-EZjG6WGvfcYXEXZCzbQveAoGZYA@mail.gmail.com>
<67703D49-546F-4E49-9868-87DC8A166296@me.com>
<902C8BE2-9C17-4C32-AD96-5821779203AE@gmail.com>
<E0DCFE91-73E2-45C7-BF15-A83AB417ED0A@me.com>
<3D66276D-9943-4D6B-B273-5B2BA24487FF@me.com>
<7ED9D8AA-1191-4801-B529-6CE6998E5C4E@me.com>
Message-ID: <2A39FC55-59DE-4348-90B4-F0D2A49E1D88@me.com>

I agree it may lead to unexpected bugs, but "let f = x? < 5" is not a great alternative, either. We should consider rethinking the behavior of comparison function itself, rather than introduce a new language feature like an operator.

I suggest changing the comparison function's return value to an optional Bool? and consider the following implementation

> func < <T: Comparable>(lhs: T?, rhs: T?) -> Bool? {
> 	if let lhs = lhs, rhs = rhs {
> 		return lhs < rhs
> 	} else {
> 		return nil
> 	}
> }


That way,

> // true
> Optional(1) < Optional(2)
>
> // nil
> Optional(1) < nil
>
> // nil
> nil < Optional(2)


Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Amir Michail <a.michail at me.com> w dniu 04.12.2015, o godz. 18:30:
>
>>
>> On Dec 4, 2015, at 12:27 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>
>> I agree with Alex,
>>
>>> Optionality is associated with the type, not the identifier.
>>
>> Optionals are designed to provide null safety inside a program, not promote using nullables wherever possible. If you use optionals so extensively that you feel the need for special IDE support, maybe you should consider rethinking your API.
>>
>> By the way,
>>
>>> So for example the following (probable) bug would result in a compile error:
>>> let f = x < 5 // where x is optional and could be nil
>>
>> I believe nil being less than anything else is an expected behavior which has been introduced by design.
>>
>
> It still leads to bugs that are hard to find though.
>
> In any case, I proposed using this code for such a comparison: let f = x? < 5
>
>> Pozdrawiam ? Regards,
>> Adrian Kashivskyy
>>
>>> Wiadomo?? napisana przez Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> w dniu 04.12.2015, o godz. 17:17:
>>>
>>>>
>>>> On Dec 4, 2015, at 10:57 AM, Alex Blewitt <alex.blewitt at gmail.com <mailto:alex.blewitt at gmail.com>> wrote:
>>>>
>>>>
>>>>> On 4 Dec 2015, at 16:44, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>>>>
>>>>> I don?t want to remember if a variable is optional. I want to see it in the variable name.
>>>>
>>>> Optionality is associated with the type, not the identifier. In addition, how would you deal with type aliases to optional constructs?
>>>>
>>>> typealias MaybeString = String?
>>>> var maybe:MaybeString
>>>>
>>>> This doesn?t ?look? like an optional value (so would it deserve a ? at the end) but if you have MaybeString? you now have an Optional<Optional<String>>. Should you have ?? there now?
>>>>
>>>> Alex
>>>
>>> You would have:
>>>
>>> typealias MaybeString? = String?
>>> var maybe?:MaybeString?
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/3da0f958/attachment-0001.html>

From jgroff at apple.com  Fri Dec  4 11:43:20 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 09:43:20 -0800
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <F3457551-65D5-4A8D-A9F3-241F26D67678@me.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<F3457551-65D5-4A8D-A9F3-241F26D67678@me.com>
Message-ID: <E30081C1-CCE9-4ADF-B0D2-23E26654A294@apple.com>


> On Dec 4, 2015, at 3:07 AM, Maxthon Chan <xcvista at me.com> wrote:
>
> I believe switch-as-an-expression can be implemented as a dictionary lookup, and if-as-an-expression is the ternary operator ?:

A dictionary lookup works in some cases, but is likely to be slower without optimizer heroics. Furthermore, you can't bind pattern variables or get exhaustiveness checking out of a dictionary.

-Joe

From rjmccall at apple.com  Fri Dec  4 11:47:09 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 09:47:09 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <92C9CAD1-2A9B-4CC0-941C-F7850B806C8B@sb.org>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
<DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
<53591A2C-1187-41E6-BB06-8F0327C03238@fifthace.com>
<92C9CAD1-2A9B-4CC0-941C-F7850B806C8B@sb.org>
Message-ID: <D9C67AEB-E65D-48A7-BAFA-576E6051F0D3@apple.com>


> On Dec 3, 2015, at 11:07 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> If we change anything based on this, I?d suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of
>
>     if let foo = bar {
>
> become the almost-identical
>
>     if let foo? = bar {

This is something we carefully considered after introducing the ? pattern, and in fact it was even implemented for a time.  The lesson we took from that experience was that optional-binding is really, really important, and it really is worthwhile to recognize that importance by giving it special syntactic support.

John.

From adrian.kashivskyy at me.com  Fri Dec  4 12:18:08 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Fri, 04 Dec 2015 19:18:08 +0100
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
Message-ID: <899D2E72-7140-4627-8D42-F11D199F152C@me.com>

Anyone has any thoughts on this? I didn't expect this topic to die without any response...

Pozdrawiam ? Regards,
Adrian Kashivskyy

> Wiadomo?? napisana przez Adrian Kashivskyy <adrian.kashivskyy at me.com> w dniu 04.12.2015, o godz. 01:43:
>
> I'm sure you heard this request like a billion times already, but I'd like to be official and make a proper proposal for that. So having said that, I hereby propose adding support for typed `throws` annotations.
>
> If a function can throw, it is often known what type of error it may throw. Consider this piece of code:
>
>> enum NetworkError: ErrorType {
>> 	case RequestTimeout
>> 	case UnreachableHost
>> }
>>
>> enum SearchError: ErrorType {
>> 	case InvalidQuery
>> }
>>
>> func search(query: String) throws {}
>>
>> func m() {
>> 	do {
>> 		try search("foo")
>> 	} catch SearchError.InvalidQuery {
>> 		print("your query is invalid")
>> 	} catch is NetworkError {
>> 		print("please check your internet connection")
>> 	} catch {
>> 		print("an unknown error occurred") // ???
>> 	}
>> }
>
>
> In order for `do-catch` to be exhaustive, the vague `catch` block is required by the compiler, and inside of it, one has literally no idea what kind of error they deal with. This is useless or even dangerous for error handling, because the last `catch` often looks like this:
>
>> catch {
>> 	// don't know what that is, let's ignore that
>> }
>
> The situation above can be resolved by introducing typed error handling, so that the `search` function may be refactored to:
>
>> func search(query: String) throws SearchError, NetworkError {}
>
> Then, the requirement for last, opaque `catch` block can be completely removed as the compiler will make sure that only errors of the allowed types be thrown from `search`.
>
> I will be happy to hear your comments on this.
>
> ?????
>
> As a bonus, I prepared a short FAQ for my proposal:
>
> Q: What if my function throws multiple error types?
>
> Use comma-separated list of error types.
>
>> func f() throws SomeError, OtherError {}
>
> Q: What if I `try` a function which throws something completely different?
>
> Then you have three possibilities:
>
> 1. You resolve the error in scope of the function, inside a `catch` block.
> 2. You convert it into a compatible type and `throw` it.
> 3. You annotate your `func` to be throwing that particular error as well.
>
> Q: What about `rethrows`?
>
> `rethrows` should become generic and throw anything that the closure arguments can throw.
>
>> func f(g: () throws SomeError -> Void, h: () throws OtherError -> Void) rethrows {}
>>
>> // behaves like
>>
>> func f(g: () throws SomeError -> Void, h: () throws OtherError -> Void) throws SomeError, OtherError {}
>
> Q: What if I want to use the old behavior?
>
> Just annotate as `throws ErrorType` and you can throw anything from there.
>
>> func f() throws ErrorType {}
>
>
> Q: Is the failure path really as important as the success path?
>
> Yes, it is.
>
> Pozdrawiam ? Regards,
> Adrian Kashivskyy
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2fd38e95/attachment.html>

From vinivendra at gmail.com  Fri Dec  4 12:20:45 2015
From: vinivendra at gmail.com (Vinicius Vendramini)
Date: Fri, 4 Dec 2015 13:20:45 -0500
Subject: [swift-evolution] API Guidelines for Asynchronous	Completion
Handlers?
In-Reply-To: <31B10C00-43F7-4BEF-970E-9AD85D18C976@fifthace.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
<66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>
<31B10C00-43F7-4BEF-970E-9AD85D18C976@fifthace.com>
Message-ID: <228F1420-FE70-40A7-924C-0A23156192A3@gmail.com>

I really like the idea of using try/catches, it seems like a more swifty approach. However, I'd prefer to do it in a way that doesn't add a new syntax.

Also, I agree with Alex, the second options seems the best of those alternatives (if it were done without trailing closures.)

> On Dec 4, 2015, at 12:21 PM, Sean Heber <sean at fifthace.com> wrote:
>
> What if there was a possibility for a deferred throw?
>
> For example, imagine the fetch function was something like this:
>
> func fetch(withCompletionHandler: (Result) -> ()) defer throws {}
>
> And to call it, you?d wrap it in a try with a new kind of catch:
>
> do {
>  try request.fetch() { result in ? }
> } defer catch (? pattern) {
> }
>
> So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.
>
> The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:
>
> func fetch(withCompletionHandler: (Result) -> ()) defer throws {
>  var context = FetchContext()
>  context.completionHandler = withCompletionHandler
>  context.errorHandler = { reason in throw RequestError(reason) }
>  self.pending.append(context)
>  context.start()
> }
>
> Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.
>
> l8r
> Sean
>
>
>>> On Dec 4, 2015, at 10:57 AM, Alex Migicovsky <migi at apple.com> wrote:
>>>
>>>
>>>> On Dec 3, 2015, at 2:15 PM, Douglas Gregor <dgregor at apple.com> wrote:
>>>>
>>>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>>>>
>>>> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>>>>
>>>> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
>>>> - Double Block (one for success, one for failure)
>>>> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)
>>>>
>>>> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?
>>>
>>> This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.
>>
>> Hi Dan!
>>
>> I think guidelines in this area would be great.
>>
>> Here are the tradeoffs I think we have for each approach:
>>
>> 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.
>>
>> 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code.
>>
>> Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.
>>
>> Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.
>>
>>     /*
>>          Single block.
>>          Trailing closure syntax works well.
>>     */
>>     request.fetch { result, error in
>>          // More indented code since we need to use guard or if let.
>>          guard let result = result else {
>>               // Need to force unwrap `error`.
>>               handleFetchError(error!)
>>               return
>>          }
>>
>>          use(result)
>>     }
>>
>>     /*
>>          Double block.
>>          Trailing closure syntax is awkward here.
>>     */
>>     request.fetch(withCompletionHandler: { result in
>>          use(result)
>>     }, errorHandler: { error in
>>          // Don?t need to force unwrap `error`.
>>          handleFetchError(error)
>>     })
>>
>> 3) Enums with associated values are conceptually nice, but unless we have a Result<> or an Either<> in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.
>>
>> Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?
>>
>> Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.
>>
>> - Alex
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From rayfix at gmail.com  Fri Dec  4 12:45:45 2015
From: rayfix at gmail.com (Ray Fix)
Date: Fri, 4 Dec 2015 10:45:45 -0800
Subject: [swift-evolution] Pluggable hash algorithm for containers
In-Reply-To: <CA+Y5xYc_M3S+hPERVd4kHvjZARgD=2srgN4a0wJ4OAAhqQw42Q@mail.gmail.com>
References: <8F9F94DC-3991-457C-A145-FD3CC887D535@gmail.com>
<CA+Y5xYc_M3S+hPERVd4kHvjZARgD=2srgN4a0wJ4OAAhqQw42Q@mail.gmail.com>
Message-ID: <5BC786CB-CF5F-4685-947A-52029480C875@gmail.com>


> On Dec 3, 2015, at 8:29 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> A prototype is here (written before Howard's talk, so it probably uses
> different terms):
>
> https://github.com/apple/swift/blob/master/validation-test/stdlib/HashingPrototype.swift
>

Thank your for the excellent pointer, Dmitri.  I will look into that as I get setup to build, test, and make actual changes.

> However, I couldn't make it interoperate with NSObject.hash in both
> directions: you should be able to override 'var hash' and get an
> implementation of Hashable based on that, and vice versa.  It could be
> solvable with protocol extensions now, I haven't looked at that
> prototype for more than a year -- help and patches appreciated.
>

As you know, a hashing algorithm just needs to consume raw bytes.  The HasherType protocol could use protocol extensions to provide a clean API to standard types like Int and Float, Double, String, Bool, UInt32, Sequences, etc.

extension CGPoint : NewHashable {
func combineInto(hasher: Hasher) {
x.combineInto(hasher)
y.combineInto(hasher)
}

What would be even better is if there was some interspection with a default implementation so the user code could look like this:

extension CGPoint : NewHashable {}

but that is dependent on another language feature.

The default implementation of hash is to call combineInto(Hasher) with a legacy hasher and immediately squeeze.  Might even want this to be statically dispatched (an extension with no protocol definition).

extension NewHashable {
var hash: Int {
var h = LegacyHasher()
self.combineInto(h)
return h.squeezeHashValue()
}
}

Any thoughts?

Ray


From cheyo at masters3d.com  Fri Dec  4 12:50:11 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Fri, 4 Dec 2015 12:50:11 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
Message-ID: <CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>

The motive is to desist the use of the question mark outside of the swift
optional context.
I like the rust style if-expression as an alternative.
Imo consistency and readability is a little more important than brevity.


On Friday, December 4, 2015, David Hart <david at hartbit.com> wrote:

> Best proposition since, but still more verbose than the ternary operator.
>
> On 04 Dec 2015, at 18:27, David Owens II <david at owensd.io
> <javascript:_e(%7B%7D,'cvml','david at owensd.io');>> wrote:
>
> There?s no need for the ?then" keyword if you just allow if-expressions as
> well.
>
> ```
> let result = if condition { 1 } else { 2 }
> ```
>
> Or more verbosely:
>
> ```
> let result =
>     if condition {
>         return 1
>     }
>     else {
>         return 2
>     }
> ```
>
> The same could be for switch statements as well.
>
> ```
> let result = switch item {
>     case foo: 1
>     case bar: 2
> }
> ```
>
> The above assume implicit returns on single-line statements on the
> condition/case branches.
>
> -David
>
> On Dec 3, 2015, at 11:26 PM, David Hart <david at hartbit.com
> <javascript:_e(%7B%7D,'cvml','david at hartbit.com');>> wrote:
>
> I also tend to agree but I don't like the ordering in the Python version
> and would rather see the introduction of the then keyword
>
> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com
> <javascript:_e(%7B%7D,'cvml','sean at fifthace.com');>> wrote:
>
> I agree that using ? for ternary feels.. uncomfortable in Swift. I
> wouldn't mind seeing Python-style or just eliminating it entirely in favor
> of simplicity.
>
> l8r
> Sean
>
> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com
> <javascript:_e(%7B%7D,'cvml','dan.appel00 at gmail.com');>> wrote:
>
> I agree that ternary can make code unreadable, especially so with the ???.
> I personally like the Haskel option the most, but it introduces a new
> keyword ?then?, which isn?t great either. Python?s "y if x else z" is
> therefore, in my opinion, the best alternative.
>
> Also, I found it interesting how split the Rust community was about
> removing the ternary operator.
>
> ?
> Dan Appel
>
> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com
> <javascript:_e(%7B%7D,'cvml','cheyo at masters3d.com');>> wrote:
>
>> Would you consider replacing the C style ?: ternary operator to something
>> that does not use the question mark and colon ?
>>
>> The use of "?" can be confusing when speed reading code with optionals.
>>
>> Consider this code as somebody learning swift as their first language.
>>
>> let result = !condition ? 1 : 2
>>
>> Some alternatives:
>>
>> Haskel
>>
>> if predicate then expr1 else expr2
>>
>> Python
>>
>> result = x if a > b else y
>>
>> The advantage of not using the question mark is that the language will be
>> more consistency on the use of "?" to mean only optionals.
>>
>>
>> References:
>> https://devforums.apple.com/message/1020139#1020139
>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> <javascript:_e(%7B%7D,'cvml','swift-evolution at swift.org');>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> <javascript:_e(%7B%7D,'cvml','swift-evolution at swift.org');>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> <javascript:_e(%7B%7D,'cvml','swift-evolution at swift.org');>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> <javascript:_e(%7B%7D,'cvml','swift-evolution at swift.org');>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/5d190911/attachment-0001.html>

From byatt.chris at gmail.com  Fri Dec  4 12:49:36 2015
From: byatt.chris at gmail.com (Chris Byatt)
Date: Fri, 04 Dec 2015 18:49:36 +0000
Subject: [swift-evolution] Allow Selectors to be used as Closures
Message-ID: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>

It feels a lot more Swift-like to me to allow a Selector argument to have
the option of being a closure.

For example, instead of:

UIBarButtonItem(title: "Press", style: .Done, target: self, action:
"functionToCall")

func functionToCall() {
// Do something}

We should be able to do:

UIBarButtonItem(title: "Press", style: .Done, target: self, action: {
// Do Something})

For simple tasks it would be a lot neater, and indeed faster to code this
way.

Thanks,

Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/44c8c0bf/attachment.html>

From erica at ericasadun.com  Fri Dec  4 12:56:54 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Fri, 4 Dec 2015 11:56:54 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
<750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
<1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>
Message-ID: <6A63268A-BF21-491A-A974-3BD11A7B0AEB@ericasadun.com>

I honestly have no idea where to go next with this. Here's my starting point: https://gist.github.com/erica/cf064a34f8891fb7a4a8

Advice welcome.

-- E, inexperienced at this stuff


> On Dec 3, 2015, at 11:02 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> A straight translation using UnsafePointer without a C-style for loop
> would look like
>
> func blk_xor(dst: UnsafeMutablePointer<CChar>, src:
> UnsafePointer<CChar>, len: Int) -> UnsafeMutablePointer<CChar> {
>    for i in 0..<len {
>        dst[i] ^= src[i]
>    }
>    return dst
> }
>
> -Kevin Ballard
>
> On Thu, Dec 3, 2015, at 09:47 PM, ChanMaxthon wrote:
>> How about this C code when rewritten in Swift:
>>
>> char *blk_xor(char *dst, const char *src, size_t len)
>> {
>>  const char *sp = src;
>>  for (char *dp = dst; sp - src < len; sp++, dp++)
>>    *dp ^= *sp;
>>  return dst;
>> }
>>
>> Sent from my iPhone
>>
>>> On Dec 4, 2015, at 13:35, Sean Heber <sean at fifthace.com> wrote:
>>>
>>> I found a couple of cases of them in my codebase, but they were trivially transformed into ?proper? Swift-style for loops that look better anyway. If it were a vote, I?d vote for eliminating C-style.
>>>
>>> l8r
>>> Sean
>>>
>>>
>>>> On Dec 3, 2015, at 6:52 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>> Every time I've tried to use a C-style for loop, I've ended up switching to a while loop because my iteration variable ended up having the wrong type (e.g. having an optional type when the value must be non-optional for the body to execute). The Postmates codebase contains no instances of C-style for loops in Swift.
>>>>
>>>> -Kevin Ballard
>>>>
>>>>> On Thu, Dec 3, 2015, at 04:50 PM, Eric Chamberlain wrote:
>>>>> We?ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>>>>
>>>>>
>>>>> --
>>>>> Eric Chamberlain, Lead Architect - iOS
>>>>> ArcTouch - App Development Studio
>>>>>
>>>>> Custom apps for world-class brands and the Fortune 500
>>>>> arctouch.com/work | arctouch.com/blog
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>> On Dec 3, 2015, at 3:46 PM, Andy Matuschak <andy at andymatuschak.org> wrote:
>>>>>>
>>>>>> Just checked; ditto Khan Academy.
>>>>>>
>>>>>>> On Dec 3, 2015, at 3:43 PM, Keith Smiley <keithbsmiley at gmail.com> wrote:
>>>>>>>
>>>>>>> For what it's worth we don't have a single C style for loop in the Lyft
>>>>>>> codebase.
>>>>>>>
>>>>>>> --
>>>>>>> Keith Smiley
>>>>>>>
>>>>>>>> On 12/03, Douglas Gregor wrote:
>>>>>>>>
>>>>>>>>> On Dec 3, 2015, at 3:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>>>
>>>>>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>>>>>
>>>>>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>>>>>
>>>>>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>>>>
>>>>>>>> My intuition *completely* agrees that Swift no longer needs C-style for loops. We have richer, better-structured looping and functional algorithms. That said, one bit of data I?d like to see is how often C-style for loops are actually used in Swift. It?s something a quick crawl through Swift sources on GitHub could establish. If the feature feels anachronistic and is rarely used, it?s a good candidate for removal.
>>>>>>>>
>>>>>>>> - Doug
>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From gribozavr at gmail.com  Fri Dec  4 13:00:17 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Fri, 4 Dec 2015 11:00:17 -0800
Subject: [swift-evolution] Pluggable hash algorithm for containers
In-Reply-To: <5BC786CB-CF5F-4685-947A-52029480C875@gmail.com>
References: <8F9F94DC-3991-457C-A145-FD3CC887D535@gmail.com>
<CA+Y5xYc_M3S+hPERVd4kHvjZARgD=2srgN4a0wJ4OAAhqQw42Q@mail.gmail.com>
<5BC786CB-CF5F-4685-947A-52029480C875@gmail.com>
Message-ID: <CA+Y5xYfXgXhx_t6ov9VpOEjvWAvpDm1TiXv84EU1nbXa90RUfw@mail.gmail.com>

On Fri, Dec 4, 2015 at 10:45 AM, Ray Fix <rayfix at gmail.com> wrote:
>
>> On Dec 3, 2015, at 8:29 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>>
>> A prototype is here (written before Howard's talk, so it probably uses
>> different terms):
>>
>> https://github.com/apple/swift/blob/master/validation-test/stdlib/HashingPrototype.swift
>>
>
> Thank your for the excellent pointer, Dmitri.  I will look into that as I get setup to build, test, and make actual changes.
>
>> However, I couldn't make it interoperate with NSObject.hash in both
>> directions: you should be able to override 'var hash' and get an
>> implementation of Hashable based on that, and vice versa.  It could be
>> solvable with protocol extensions now, I haven't looked at that
>> prototype for more than a year -- help and patches appreciated.
>>
>
> As you know, a hashing algorithm just needs to consume raw bytes.  The HasherType protocol could use protocol extensions to provide a clean API to standard types like Int and Float, Double, String, Bool, UInt32, Sequences, etc.
>
> extension CGPoint : NewHashable {
>   func combineInto(hasher: Hasher) {
>     x.combineInto(hasher)
>     y.combineInto(hasher)
>   }

I definitely agree.

> What would be even better is if there was some interspection with a default implementation so the user code could look like this:
>
> extension CGPoint : NewHashable {}
>
> but that is dependent on another language feature.

Right, there are a lot of interesting things we could do if we had
more introspection language features.

> The default implementation of hash is to call combineInto(Hasher) with a legacy hasher and immediately squeeze.  Might even want this to be statically dispatched (an extension with no protocol definition).
>
> extension NewHashable {
>     var hash: Int {
>          var h = LegacyHasher()
>          self.combineInto(h)
>          return h.squeezeHashValue()
>     }
> }
>
> Any thoughts?

The interop issue is the following.  Consider a subclass of NSObject,
possibly defined in Objective-C, that does not conform to NewHashable:
we want to use its 'hash' implementation.  If someone subclasses
NSObject in Swift and implements NewHashable, we should use its API
instead.  If someone further subclasses that Swift class in
Objective-C, they should be able to add more properties, and override
'var hash', since that's the only API available in Objective-C.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From ben_cocoa_dev_list at yahoo.co.uk  Fri Dec  4 13:06:36 2015
From: ben_cocoa_dev_list at yahoo.co.uk (Ben)
Date: Fri, 4 Dec 2015 19:06:36 +0000
Subject: [swift-evolution] Proposal: Protocol methods should accept
default arguments
In-Reply-To: <18A5AD3C-3780-4725-9D98-FA3B85354912@me.com>
References: <777E6A79-E489-46B0-A3ED-135EED198666@yahoo.co.uk>
<18A5AD3C-3780-4725-9D98-FA3B85354912@me.com>
Message-ID: <D85CA605-3999-4159-AD15-272453CAB5A2@yahoo.co.uk>

Thank you Felix and Sean for the advice. I am happy to cautiously withdraw my suggestion, since this is a mostly acceptable workaround. The only hiccup appears to be with where inline documentation should be placed to have it appear in Xcode (in the extension, not the original protocol). I will think further and perhaps file a radar for Xcode later.

Incidentally, having explored the mailing lists further it seems that stuff like my original post should start in the swift-users list then works it's way over here. Would that be correct? I don't want to be extra noise in the wrong place.

- Ben




> On 4 Dec 2015, at 16:37, Felix Gabel <felix.gabel at me.com> wrote:
>
> Default parameters are in my opinion an implementation detail and should be always handled by the conforming type. What can be done here is only declare the 4th method in the protocol and create a protocol extension with default forwarding.
>
> On 04 Dec 2015, at 17:31, Ben <ben_cocoa_dev_list at yahoo.co.uk <mailto:ben_cocoa_dev_list at yahoo.co.uk>> wrote:
>
>> Hi list,
>>
>> I propose that methods defined in protocols should accept default arguments. This could help remove the need for method families where only one parameter is essential, but others are often used.
>>
>> For example:
>>
>> protocol Datastore {
>>   func executeQuery(query: String)
>>   func executeQuery(query: String, usingParameters: [Any])
>>   func executeQuery(query: String, usingParameters: [Any], logType: LogType)
>>   func executeQuery(query: String, usingParameters: [Any], logType: LogType, completionHandler:ClosureOfSomeSort)
>> }
>>
>> Where typically the implementing object funnels the first three methods through to the final, more verbose method.
>>
>> This could be shortened to:
>>
>> protocol Database {
>>   func executeQuery(query: String, usingParameters: [Any] = [], logType: LogType  = .NotLogged  completionHandler:ClosureOfSomeSort? = nil)
>> }
>>
>> Advantages:
>> - Only one method to implement
>> - Less to document, less cluttered interface
>> - Prevent objects adopting the protocol from using different default values
>> - Prevent objects from implementing similar methods in the family differently - fewer code paths to inspect, less confusion over behaviour since no argument values are hidden
>>
>> This fits in well with the parameters section of the Swift API design page: https://swift.org/documentation/api-design-guidelines.html#parameters <https://swift.org/documentation/api-design-guidelines.html#parameters>
>>
>>
>> What do you think?
>>
>> Regards,
>>
>> Ben Barnett
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/69e02c29/attachment-0001.html>

From jgroff at apple.com  Fri Dec  4 13:07:49 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 11:07:49 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <6A63268A-BF21-491A-A974-3BD11A7B0AEB@ericasadun.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
<750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
<1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>
<6A63268A-BF21-491A-A974-3BD11A7B0AEB@ericasadun.com>
Message-ID: <94F08C46-27BC-44C5-ACFC-7A5F59DE0672@apple.com>


> On Dec 4, 2015, at 10:56 AM, Erica Sadun <erica at ericasadun.com> wrote:
>
> I honestly have no idea where to go next with this. Here's my starting point: https://gist.github.com/erica/cf064a34f8891fb7a4a8
>
> Advice welcome.
>
> -- E, inexperienced at this stuff

Looks like you're on the right track. Check out the Swift evolution process if you haven't already: https://swift.org/contributing/#participating-in-the-swift-evolution-process Next step would be to fork swift-evolution and make a pull request, I believe.

-Joe

From rjmccall at apple.com  Fri Dec  4 13:08:26 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 11:08:26 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <899D2E72-7140-4627-8D42-F11D199F152C@me.com>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
Message-ID: <AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>

> On Dec 4, 2015, at 10:18 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
> Anyone has any thoughts on this? I didn't expect this topic to die without any response?

Patience. :)  We?ve been getting a lot of proposals, and it hasn?t even been a full day yet.

I do think that there?s a place for typed throws.  There are some very narrow use cases, usually where error handling is being employed as a sort of alternate control scheme rather than a mechanism for reporting ?errors? per se, where it?s nice to both:

- inform callers that the function only ?fails? in the prescribed ways

- statically enforce that general errors aren?t accidentally getting mixed in

You might imagine using it in a recursive-descent parser, for example, although even there I?m not convinced.

However, I?m still reluctant to fully embrace the feature, because I think it?s far too tempting to try to use it for actual error handling, and that?s a job that it?s really, really poorly-suited for.

Let?s get one thing out of the way first.  There are some operations that make sense to be able to do on a generic error ? crucially, formatting it for display in various ways ? and right now the ErrorType protocol doesn?t expose API for that.  That?s something we perhaps need to work on.

Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  Even putting evolution aside, the list of failures is almost certainly impractical to exhaustively pattern-match over, and doing so couples you very tightly to the implementation of the library and everything it uses.  Furthermore, in practice nearly every ?exhaustively enumerable? error type I?ve ever seen has at least one (and often two or three) generic, catch-all cases used to encode arbitrary extra kinds of error, either dynamically-typed (e.g. carrying an ErrorType) or completely untyped (e.g. carrying a String); and not only does this make it impossible to exhaustively enumerate the actual kinds of failure, but it actually makes it more difficult to detect specific failures, by making it more likely that the error you?re actually trying to detect and special-case will be stored at the end of a rather complicated path of wrapping errors.

And this isn?t even just about third-party libraries, because if there?s any lesson from the last fifty years of experience that's broadly applicable across programming languages, it?s that you really do need to think about how your program breaks down into components, and understand how those components work with each other essentially as if they were separable libraries, or else you will always, always run into a wall as you find that the complexity of your comprehension has failed to scale with the complexity of your code.

So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.

John.

From anthony.parker at apple.com  Fri Dec  4 13:12:37 2015
From: anthony.parker at apple.com (Tony Parker)
Date: Fri, 04 Dec 2015 11:12:37 -0800
Subject: [swift-evolution] SE-0005: Ambiguous NS prefix removals
In-Reply-To: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>
References: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>
Message-ID: <23C22A72-E3D5-4762-B473-9FD5822D43D4@apple.com>

Hi Brent,

> On Dec 4, 2015, at 3:50 AM, Brent Royal-Gordon <brent at architechies.com> wrote:
>
> SE-0005 in the repository (?Better Translation of Objective-C APIs into Swift?, https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md) discusses plans to remove the NS prefix from many Foundation APIs, but admits that you haven?t yet settled on a way to handle conflicts with the standard library:
>
>> The removal of the "NS" prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation's versions will shadow the standard library's versions. We are investigating several ways to address this problem, including:
>>
>> 	? Retain the NS prefix on such classes.
>>
>> 	? Introduce some notion of submodules into Swift, so that these classes would exist in a submodule for reference-semantic types (e.g., one would refer to Foundation.ReferenceTypes.Array or similar).
>
> Since the main difference between e.g. String and NSString is that the latter has reference semantics, why not alter the name to reflect that?
>
> 	NSString -> StringRef
> 	NSArray -> ArrayRef
> 	NSDictionary -> DictionaryRef
>
> The resulting type names have a bit of a Core Foundation-y flavor to them, but that?s not necessarily a bad thing?it quietly encourages use of the Swift types just as NSString vs. CFStringRef quietly encourages use of the Foundation type.
>
> Normally this transformation would not apply to types with no corresponding standard library type:
>
> 	NSCalendar -> Calendar
> 	NSBundle -> Bundle
>
> However, subclasses of a type with ?Ref? in the name would also have ?Ref" in the subclass name:
>
> 	NSMutableString -> MutableStringRef (because its superclass is StringRef)
> 	NSMutableArray -> MutableArrayRef (because its superclass is ArrayRef)
> 	NSMutableDictionary -> MutableDictionaryRef (because its superclass is DictionaryRef)
>
> If you don?t like ?Ref?, ?Object? is wordier but clearer:
>
> 	StringObject, MutableStringObject
> 	ArrayObject, MutableArrayObject
> 	DictionaryObject, MutableDictionaryObject
>
> And as long as we?re doing this, it might make sense to add the ?Ref? suffix for a few other types which might naturally have value-typed standard library equivalents someday, even if they don?t right now:
>
> 	URLRef (the URL type would have something like NSURLComponents?s mutation APIs)
> 	DateComponentsRef (this is begging to be a struct in Swift)
> 	DateRef (perhaps less important, since it?s immutable and doesn?t really have many natural properties to expose anyway)
> 	NumberRef (a standard library equivalent might be a protocol that all numeric types conform to)
>
> On the other hand, you might just want to cross that bridge when you get to it with a source code migrator in Swift 4 or whatever.
>

We?ve been thinking about exactly what to call this submodule, but haven?t landed on a preferred name yet. For the class names themselves, I don?t think we want to suffix some classes with ?Ref? or ?Object? but not others, because it would lead to either boilerplate names or inconsistency. The idea of the submodule was to avoid the inconsistency but still have something which obviously separates these classes.

e.g.

NSString -> submodule.String
NSBundle -> Bundle
NSMutableString -> submodule.MutableString
NSArray -> submodule.Array

etc.

- Tony

> (By the way, I love the rest of this proposal. I?ve always wanted Swift to clean up and reformat API names more when it imports them.)
>
> --
> Brent Royal-Gordon
> Architechies
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From daniel.j.stenmark at gmail.com  Fri Dec  4 13:13:17 2015
From: daniel.j.stenmark at gmail.com (Dan Stenmark)
Date: Fri, 4 Dec 2015 11:13:17 -0800
Subject: [swift-evolution] API Guidelines for Asynchronous	Completion
Handlers?
In-Reply-To: <228F1420-FE70-40A7-924C-0A23156192A3@gmail.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
<66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>
<31B10C00-43F7-4BEF-970E-9AD85D18C976@fifthace.com>
<228F1420-FE70-40A7-924C-0A23156192A3@gmail.com>
Message-ID: <F015C10F-5F94-49BF-B7C9-E1EA787869D6@gmail.com>

Hey Alex!

I completely agree that the double-block approach is advantageous for its reduced unwrapping, but the only issue I have is that, when applied in production, it typically leads to duplicate code.

request.fetch(withCompletionHandler: { result in
activityIndicator.stopAnimating()
button.enabled = true
tableView.hidden = false

use(result)

print( ?Foo!? )

}, errorHandler: { error in
activityIndicator.stopAnimating()
button.enabled = true
tableView.hidden = false

// Don?t need to force unwrap `error`.
handleFetchError(error)

print( ?Foo!? )

})

The same issue is present in the aforementioned deferred throw concept.  There?re certainly ways to mitigate the problem, but no practical way of eliminating it altogether.  I?m personally leaning towards an evolution of the Enum-based approach for this very reason, but if a solution can be figured out to remove such code duplication, I?d happily adopt double-blocks.

Dan

> On Dec 4, 2015, at 10:20 AM, Vinicius Vendramini <vinivendra at gmail.com> wrote:
>
> I really like the idea of using try/catches, it seems like a more swifty approach. However, I'd prefer to do it in a way that doesn't add a new syntax.
>
> Also, I agree with Alex, the second options seems the best of those alternatives (if it were done without trailing closures.)
>
>> On Dec 4, 2015, at 12:21 PM, Sean Heber <sean at fifthace.com> wrote:
>>
>> What if there was a possibility for a deferred throw?
>>
>> For example, imagine the fetch function was something like this:
>>
>> func fetch(withCompletionHandler: (Result) -> ()) defer throws {}
>>
>> And to call it, you?d wrap it in a try with a new kind of catch:
>>
>> do {
>> try request.fetch() { result in ? }
>> } defer catch (? pattern) {
>> }
>>
>> So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.
>>
>> The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:
>>
>> func fetch(withCompletionHandler: (Result) -> ()) defer throws {
>> var context = FetchContext()
>> context.completionHandler = withCompletionHandler
>> context.errorHandler = { reason in throw RequestError(reason) }
>> self.pending.append(context)
>> context.start()
>> }
>>
>> Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.
>>
>> l8r
>> Sean
>>
>>
>>>> On Dec 4, 2015, at 10:57 AM, Alex Migicovsky <migi at apple.com> wrote:
>>>>
>>>>
>>>>> On Dec 3, 2015, at 2:15 PM, Douglas Gregor <dgregor at apple.com> wrote:
>>>>>
>>>>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>>>>>
>>>>> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>>>>>
>>>>> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
>>>>> - Double Block (one for success, one for failure)
>>>>> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)
>>>>>
>>>>> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?
>>>>
>>>> This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.
>>>
>>> Hi Dan!
>>>
>>> I think guidelines in this area would be great.
>>>
>>> Here are the tradeoffs I think we have for each approach:
>>>
>>> 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.
>>>
>>> 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code.
>>>
>>> Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.
>>>
>>> Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.
>>>
>>>    /*
>>>         Single block.
>>>         Trailing closure syntax works well.
>>>    */
>>>    request.fetch { result, error in
>>>         // More indented code since we need to use guard or if let.
>>>         guard let result = result else {
>>>              // Need to force unwrap `error`.
>>>              handleFetchError(error!)
>>>              return
>>>         }
>>>
>>>         use(result)
>>>    }
>>>
>>>    /*
>>>         Double block.
>>>         Trailing closure syntax is awkward here.
>>>    */
>>>    request.fetch(withCompletionHandler: { result in
>>>         use(result)
>>>    }, errorHandler: { error in
>>>         // Don?t need to force unwrap `error`.
>>>         handleFetchError(error)
>>>    })
>>>
>>> 3) Enums with associated values are conceptually nice, but unless we have a Result<> or an Either<> in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.
>>>
>>> Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?
>>>
>>> Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.
>>>
>>> - Alex
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/82fb6e65/attachment-0001.html>

From crk at fastmail.com  Fri Dec  4 13:16:43 2015
From: crk at fastmail.com (Cole Kurkowski)
Date: Fri, 4 Dec 2015 13:16:43 -0600
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
References: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
Message-ID: <ECE26AFE-B51D-48E2-908F-BBEEFD426A58@fastmail.com>

To me this actually feels more like something that might fit better as an additional type of optional, rather than a language feature.

Setting this optional to nil could work normally, and any attempt to access the value when nil would cause the reload to occur. The initialization semantics might be a tad ugly though.

var myLazyOpt = ReloadingOptional<ForeignClass>({
return Database.expensiveSelect(self.foreignKey)
})

You could probably implement something like this yourself, though I'm not sure how elegant that would be without full language support.

Thanks for your time,
Cole Kurkowski
> On Dec 4, 2015, at 07:40, David Hart <david at hartbit.com> wrote:
>
> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
>
> @interface MyClass : NSObject
>
> @property (nonatomic) ForeignClass* foreignObject;
> @property (nonatomic) int64_t foreignKey;
>
> @end
>
> @implementation MyClass
>
> - (void)setForeignKey:(int64_t)foreignKey {
>   _foreignKey = foreignKey;
>   _foreignObject = nil;
> }
>
> - (ForeignClass*)foreignObject {
>   if (!_foreignObject) {
>       _foreignObject = [Database expensiveSelect:_foreignKey];
>   }
>   return _foreignObject;
> }
>
> @end
>
> Unfortunately, the lazy keyword in Swift, which was supposed to make the lazy initialization pattern more concsive does not work in this case:
>
> class MyClass {
>   var foreignKey: Int64 {
>       didSet {
>           self.foreignObject = nil
>       }
>   }
>
>   lazy var foreignObject: ForeignClass? = {
>       return Database.expensiveSelect(self.foreignKey)
>   }()
> }
>
> I'm forced to rewrite it this way:
>
> class MyClass {
>   var foreignKey: Int64 {
>       didSet {
>           self.foreignObject = nil
>       }
>   }
>
>   private var _foreignObject: ForeignClass? = nil
>   var foreignObject: ForeignClass? {
>       if _foreignObject == nil {
>           _foreignObject = Database.expensiveSelect(self.foreignKey)
>       }
>       return _foreignObject
>   }
> }
>
> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
> I want your opinion on three alternatives:
>
> 1- Do nothing, and use the slightly uglier Swift example when using a cache.
> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
> 3- Add a cache modifier that re-calcualtes when nil.
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From sean at fifthace.com  Fri Dec  4 13:19:17 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 13:19:17 -0600
Subject: [swift-evolution] API Guidelines for Asynchronous	Completion
Handlers?
In-Reply-To: <F015C10F-5F94-49BF-B7C9-E1EA787869D6@gmail.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
<66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>
<31B10C00-43F7-4BEF-970E-9AD85D18C976@fifthace.com>
<228F1420-FE70-40A7-924C-0A23156192A3@gmail.com>
<F015C10F-5F94-49BF-B7C9-E1EA787869D6@gmail.com>
Message-ID: <C96096A9-E9F7-4566-A412-0E9E3B724DC9@fifthace.com>

I think that the code duplication issue is more of an API design side effect. If the API was designed with a 3rd block for when it is ?done? regardless of error, then you could put that shared code there - but I would imagine that?d be out of the scope of Swift itself. What I often do in these situations is just make a local function that does the shared stuff and then call it from both blocks:

func finished() {
activityIndicator.stopAnimating()
button.enabled = true
tableView.hidden = false
}

request.fetch(withCompletionHandler: { result in
finished()
use(result)
}, errorHandler: { error in
finished()
handleFetchError(error)
})

l8r
Sean


> On Dec 4, 2015, at 1:13 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>
> Hey Alex!
>
> I completely agree that the double-block approach is advantageous for its reduced unwrapping, but the only issue I have is that, when applied in production, it typically leads to duplicate code.
>
> request.fetch(withCompletionHandler: { result in
>           activityIndicator.stopAnimating()
>           button.enabled = true
>           tableView.hidden = false
>
>           use(result)
>
>           print( ?Foo!? )
>
>      }, errorHandler: { error in
>           activityIndicator.stopAnimating()
>           button.enabled = true
>           tableView.hidden = false
>
>           // Don?t need to force unwrap `error`.
>           handleFetchError(error)
>
>           print( ?Foo!? )
>
>      })
>
> The same issue is present in the aforementioned deferred throw concept.  There?re certainly ways to mitigate the problem, but no practical way of eliminating it altogether.  I?m personally leaning towards an evolution of the Enum-based approach for this very reason, but if a solution can be figured out to remove such code duplication, I?d happily adopt double-blocks.
>
> Dan
>
>> On Dec 4, 2015, at 10:20 AM, Vinicius Vendramini <vinivendra at gmail.com> wrote:
>>
>> I really like the idea of using try/catches, it seems like a more swifty approach. However, I'd prefer to do it in a way that doesn't add a new syntax.
>>
>> Also, I agree with Alex, the second options seems the best of those alternatives (if it were done without trailing closures.)
>>
>>> On Dec 4, 2015, at 12:21 PM, Sean Heber <sean at fifthace.com> wrote:
>>>
>>> What if there was a possibility for a deferred throw?
>>>
>>> For example, imagine the fetch function was something like this:
>>>
>>> func fetch(withCompletionHandler: (Result) -> ()) defer throws {}
>>>
>>> And to call it, you?d wrap it in a try with a new kind of catch:
>>>
>>> do {
>>> try request.fetch() { result in ? }
>>> } defer catch (? pattern) {
>>> }
>>>
>>> So what the language would do then is treat all of the ?defer catch? blocks as closures and pass them along with calls to ?defer throws? functions in the same context. When they throw, they would then run those blocks as if you had passed them along manually in the double block style.
>>>
>>> The context to throw back to would need to be capture-able by the function body for fetch() so that if it encounters an error some time later it would know where to throw it to. Perhaps the easiest way would be to create a closure that throws like so:
>>>
>>> func fetch(withCompletionHandler: (Result) -> ()) defer throws {
>>> var context = FetchContext()
>>> context.completionHandler = withCompletionHandler
>>> context.errorHandler = { reason in throw RequestError(reason) }
>>> self.pending.append(context)
>>> context.start()
>>> }
>>>
>>> Under the hood the ?throw? captured in the closure would also be carrying along the context needed to route that error back to the expected defer catch block.
>>>
>>> l8r
>>> Sean
>>>
>>>
>>>>> On Dec 4, 2015, at 10:57 AM, Alex Migicovsky <migi at apple.com> wrote:
>>>>>
>>>>>
>>>>>> On Dec 3, 2015, at 2:15 PM, Douglas Gregor <dgregor at apple.com> wrote:
>>>>>>
>>>>>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>>>>>>
>>>>>> There?s a some of debate in the community regarding best practice for asynchronous completion callbacks.  These practices include:
>>>>>>
>>>>>> - Single Block w/ Mutually Exclusive Result and Error Objects (the current standard convention in Cocoa, though originally designed with Objective-C in mind)
>>>>>> - Double Block (one for success, one for failure)
>>>>>> - Swift Enum w/ Associated Objects (as described here: http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/)
>>>>>>
>>>>>> Even prior to Swift, Apple?s code guidelines never explicitly addressed this topic.  Going forward into the brave new world of Swift, are there going to be new preferred API design guidelines for this?
>>>>>
>>>>> This is a great point, and there are a number of other issues related to callbacks/closure arguments that would benefit from guidelines. For example, I've seen the ?Double Block? case where the second block ends up being a trailing closure, which makes for non-intuitive uses.
>>>>
>>>> Hi Dan!
>>>>
>>>> I think guidelines in this area would be great.
>>>>
>>>> Here are the tradeoffs I think we have for each approach:
>>>>
>>>> 1) The single block approach means you?d code against an optional result and an optional error, making it easy to write invalid code (see example in #2). With the single block you can use trailing closure syntax coherently. I think most ObjC APIs use this approach since it works well in ObjC.
>>>>
>>>> 2) As Doug mentioned, the double block can be inconvenient / awkward but it does produce more correct code.
>>>>
>>>> Doug: maybe we can limit using trailing closures from being used if the 2nd to last parameter is also a closure? That would eliminate some confusion at the call site.
>>>>
>>>> Some ObjC APIs use this approach. One positive aspect of the double-block approach is that it always produces code that?s less indented than the single block approach. e.g.
>>>>
>>>>    /*
>>>>         Single block.
>>>>         Trailing closure syntax works well.
>>>>    */
>>>>    request.fetch { result, error in
>>>>         // More indented code since we need to use guard or if let.
>>>>         guard let result = result else {
>>>>              // Need to force unwrap `error`.
>>>>              handleFetchError(error!)
>>>>              return
>>>>         }
>>>>
>>>>         use(result)
>>>>    }
>>>>
>>>>    /*
>>>>         Double block.
>>>>         Trailing closure syntax is awkward here.
>>>>    */
>>>>    request.fetch(withCompletionHandler: { result in
>>>>         use(result)
>>>>    }, errorHandler: { error in
>>>>         // Don?t need to force unwrap `error`.
>>>>         handleFetchError(error)
>>>>    })
>>>>
>>>> 3) Enums with associated values are conceptually nice, but unless we have a Result<> or an Either<> in the Standard Library I think most people will write one-off enums for each set of methods that return a specific kind of result + error. That adds an unnecessary conceptual burden since you need to know the type of of the value that?s passed to each callback. Also, we don?t have any primarily ObjC APIs that use this approach yet. It would also suffer from the same indentation problem as #1 but without the ?invalid code? problem. If we go this route I think we?d want to map the async error ObjC APIs to use this approach similar to what we do with non-async error handling.
>>>>
>>>> Looking at the tradeoffs I think I prefer #2 if we could limit the ability to use a trailing closure for the last parameter. I?d want to look at more code with the change though. We should also consider whether we should map the single block APIs in ObjC into double block APIs. What do you think?
>>>>
>>>> Also, with any of these approaches there?s also the question of whether we pass ErrorType, NSError, or the specific error type.
>>>>
>>>> - Alex
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From crk at fastmail.com  Fri Dec  4 13:25:47 2015
From: crk at fastmail.com (Cole Kurkowski)
Date: Fri, 4 Dec 2015 13:25:47 -0600
Subject: [swift-evolution] Allow Selectors to be used as Closures
In-Reply-To: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>
References: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>
Message-ID: <7D3509DA-DA2F-4977-80F6-EF59D9683ADD@fastmail.com>

I agree that a closure is a much better solution to the target-action pattern in Swift, especially since you could pass a declared method with ?self.functionToCall? which is basically a type safe version of the current paradigm. All of that said, I believe the reason it doesn?t work this way right now is compatibility with objective-c and Cocoa. I?d love to see this changed, as it?s one of the least Swifty things I have to use on a regular basis. I?m just not sure exactly how large of an effort it would be to make it compatible.

Thanks for your time,
Cole Kurkowski
> On Dec 4, 2015, at 12:49, Chris Byatt <byatt.chris at gmail.com> wrote:
>
> It feels a lot more Swift-like to me to allow a Selector argument to have the option of being a closure.
>
> For example, instead of:
>
> UIBarButtonItem(title: "Press", style: .Done, target: self, action: "functionToCall")
>
> func functionToCall() {
>     // Do something
> }
> We should be able to do:
>
> UIBarButtonItem(title: "Press", style: .Done, target: self, action: {
>     // Do Something
> })
> For simple tasks it would be a lot neater, and indeed faster to code this way.
>
> Thanks,
>
> Chris
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6453b9fb/attachment-0001.html>

From david_smith at apple.com  Fri Dec  4 13:26:51 2015
From: david_smith at apple.com (David Smith)
Date: Fri, 04 Dec 2015 11:26:51 -0800
Subject: [swift-evolution] Allow Selectors to be used as Closures
In-Reply-To: <7D3509DA-DA2F-4977-80F6-EF59D9683ADD@fastmail.com>
References: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>
<7D3509DA-DA2F-4977-80F6-EF59D9683ADD@fastmail.com>
Message-ID: <F9E5E2D6-610C-4FC2-BCBF-EE39530139FC@apple.com>

The other concern with patterns like this is that they tend to lead to reference cycles due to unintentional closure capture.

David

> On Dec 4, 2015, at 11:25 AM, Cole Kurkowski <crk at fastmail.com> wrote:
>
> I agree that a closure is a much better solution to the target-action pattern in Swift, especially since you could pass a declared method with ?self.functionToCall? which is basically a type safe version of the current paradigm. All of that said, I believe the reason it doesn?t work this way right now is compatibility with objective-c and Cocoa. I?d love to see this changed, as it?s one of the least Swifty things I have to use on a regular basis. I?m just not sure exactly how large of an effort it would be to make it compatible.
>
> Thanks for your time,
> Cole Kurkowski
>> On Dec 4, 2015, at 12:49, Chris Byatt <byatt.chris at gmail.com <mailto:byatt.chris at gmail.com>> wrote:
>>
>> It feels a lot more Swift-like to me to allow a Selector argument to have the option of being a closure.
>>
>> For example, instead of:
>>
>> UIBarButtonItem(title: "Press", style: .Done, target: self, action: "functionToCall")
>>
>> func functionToCall() {
>>     // Do something
>> }
>> We should be able to do:
>>
>> UIBarButtonItem(title: "Press", style: .Done, target: self, action: {
>>     // Do Something
>> })
>> For simple tasks it would be a lot neater, and indeed faster to code this way.
>>
>> Thanks,
>>
>> Chris
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/502de486/attachment.html>

From matthew at anandabits.com  Fri Dec  4 13:35:05 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Fri, 4 Dec 2015 13:35:05 -0600
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
Message-ID: <1FC42E7B-83CA-43F0-902D-C400E788A04D@anandabits.com>

> Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.
>
> So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.

I am a big proponent of typed throws.  IMO error results are every bit as important a part of an API contract as success results.  Sometimes erasing type information is the right API contract and sometimes it is not.  I don?t think requiring type information to be erased is the right way to go.  It should be a choice the language allows library authors to make for themselves.

I have worked in many languages over the last 20 years and one complaint I have nearly always had is that documentation of error cases is quite poor.  This problem has been significant enough that I think it warrants a language solution.  Typed errors provide compiler-enforced documentation about what errors can arise from a call.  The value of this compiler-enforced documentation should not be underestimated.

If the language evolves to support typed errors I believe we would learn how and when it is best to provide specific error types and when to employ type erasure / generic errors.  The range of options would encourage thoughtful library authors to consider their approach carefully and likely lead to solutions that facilitate better error handling in code that uses the library.

One idea that I think merits consideration is the approach Rust uses to translate lower level errors representing implementation details into higher level errors represented in the API contract at module boundaries.  A well-designed language feature along these lines would go a long way towards addressing the complexity of ?previously unanticipated errors?, would provide compiler enforced documentation, and would allow library authors to present a well-defined contract for error conditions as well as success conditions.

I hope this at least begins to answer the question of what programmers might hope to achieve with additional typing information on errors.

Matthew

From david at owensd.io  Fri Dec  4 13:36:39 2015
From: david at owensd.io (David Owens II)
Date: Fri, 4 Dec 2015 11:36:39 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
Message-ID: <B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>

For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.

var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8

do {
try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.InvalidSelection {
print("Invalid Selection.")
} catch VendingMachineError.OutOfStock {
print("Out of Stock.")
} catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
} catch { fatalError("this is always needed??) }

> So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.

Possibly? but I think the counter argument is that introducing a new error type that can happen **should** be a breaking change. So the `catch` with no pattern becomes a pattern that is ?yeah, some error may happen at a later date, but since we have no idea what it is, it may be benign or it may be catastrophic. So, should it be handled with a `fatalError()` or should it be equivalent to a no-op?

To me, the question really becomes: does a non-typed error-like system really make sense in Swift? Or in other words, if interop with ObjC was not required, would `throw` exist as it does today?

It would seem that something has to give: either something like a `Result`/`Error` type should be used instead with some nicer syntax to handle it, or `throws` should really become typed. Leaving it as-is, seems to be the worst of both worlds.

-David


> On Dec 4, 2015, at 11:08 AM, John McCall <rjmccall at apple.com> wrote:
>
>> On Dec 4, 2015, at 10:18 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>> Anyone has any thoughts on this? I didn't expect this topic to die without any response?
>
> Patience. :)  We?ve been getting a lot of proposals, and it hasn?t even been a full day yet.
>
> I do think that there?s a place for typed throws.  There are some very narrow use cases, usually where error handling is being employed as a sort of alternate control scheme rather than a mechanism for reporting ?errors? per se, where it?s nice to both:
>
>  - inform callers that the function only ?fails? in the prescribed ways
>
>  - statically enforce that general errors aren?t accidentally getting mixed in
>
> You might imagine using it in a recursive-descent parser, for example, although even there I?m not convinced.
>
> However, I?m still reluctant to fully embrace the feature, because I think it?s far too tempting to try to use it for actual error handling, and that?s a job that it?s really, really poorly-suited for.
>
> Let?s get one thing out of the way first.  There are some operations that make sense to be able to do on a generic error ? crucially, formatting it for display in various ways ? and right now the ErrorType protocol doesn?t expose API for that.  That?s something we perhaps need to work on.
>
> Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  Even putting evolution aside, the list of failures is almost certainly impractical to exhaustively pattern-match over, and doing so couples you very tightly to the implementation of the library and everything it uses.  Furthermore, in practice nearly every ?exhaustively enumerable? error type I?ve ever seen has at least one (and often two or three) generic, catch-all cases used to encode arbitrary extra kinds of error, either dynamically-typed (e.g. carrying an ErrorType) or completely untyped (e.g. carrying a String); and not only does this make it impossible to exhaustively enumerate the actual kinds of failure, but it actually makes it more difficult to detect specific failures, by making it more likely that the error you?re actually trying to detect and special-case will be stored at the end of a rather complicated path of wrapping errors.
>
> And this isn?t even just about third-party libraries, because if there?s any lesson from the last fifty years of experience that's broadly applicable across programming languages, it?s that you really do need to think about how your program breaks down into components, and understand how those components work with each other essentially as if they were separable libraries, or else you will always, always run into a wall as you find that the complexity of your comprehension has failed to scale with the complexity of your code.
>
> So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.
>
> John.
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From cheyo at masters3d.com  Fri Dec  4 13:43:40 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Fri, 4 Dec 2015 13:43:40 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
Message-ID: <CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>

I'd like some feedback from the core team to see if eliminating the ternary
operator and replacing it with if-else is even proposal worthy.

Some interesting code in the standard library that uses the ternary
operator quite a bit.

https://gist.github.com/masters3d/7b0c6f3653368afe4357



On Fri, Dec 4, 2015 at 12:50 PM, J. Cheyo Jimenez <cheyo at masters3d.com>
wrote:

> The motive is to desist the use of the question mark outside of the swift
> optional context.
> I like the rust style if-expression as an alternative.
> Imo consistency and readability is a little more important than brevity.
>
>
> On Friday, December 4, 2015, David Hart <david at hartbit.com> wrote:
>
>> Best proposition since, but still more verbose than the ternary operator.
>>
>> On 04 Dec 2015, at 18:27, David Owens II <david at owensd.io> wrote:
>>
>> There?s no need for the ?then" keyword if you just allow if-expressions
>> as well.
>>
>> ```
>> let result = if condition { 1 } else { 2 }
>> ```
>>
>> Or more verbosely:
>>
>> ```
>> let result =
>>     if condition {
>>         return 1
>>     }
>>     else {
>>         return 2
>>     }
>> ```
>>
>> The same could be for switch statements as well.
>>
>> ```
>> let result = switch item {
>>     case foo: 1
>>     case bar: 2
>> }
>> ```
>>
>> The above assume implicit returns on single-line statements on the
>> condition/case branches.
>>
>> -David
>>
>> On Dec 3, 2015, at 11:26 PM, David Hart <david at hartbit.com> wrote:
>>
>> I also tend to agree but I don't like the ordering in the Python version
>> and would rather see the introduction of the then keyword
>>
>> On 04 Dec 2015, at 06:08, Sean Heber <sean at fifthace.com> wrote:
>>
>> I agree that using ? for ternary feels.. uncomfortable in Swift. I
>> wouldn't mind seeing Python-style or just eliminating it entirely in favor
>> of simplicity.
>>
>> l8r
>> Sean
>>
>> On Dec 3, 2015, at 10:48 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>>
>> I agree that ternary can make code unreadable, especially so with the
>> ???. I personally like the Haskel option the most, but it introduces a new
>> keyword ?then?, which isn?t great either. Python?s "y if x else z" is
>> therefore, in my opinion, the best alternative.
>>
>> Also, I found it interesting how split the Rust community was about
>> removing the ternary operator.
>>
>> ?
>> Dan Appel
>>
>> On Thu, Dec 3, 2015 at 7:58 PM J. Cheyo Jimenez <cheyo at masters3d.com>
>> wrote:
>>
>>> Would you consider replacing the C style ?: ternary operator to
>>> something that does not use the question mark and colon ?
>>>
>>> The use of "?" can be confusing when speed reading code with optionals.
>>>
>>> Consider this code as somebody learning swift as their first language.
>>>
>>> let result = !condition ? 1 : 2
>>>
>>> Some alternatives:
>>>
>>> Haskel
>>>
>>> if predicate then expr1 else expr2
>>>
>>> Python
>>>
>>> result = x if a > b else y
>>>
>>> The advantage of not using the question mark is that the language will
>>> be more consistency on the use of "?" to mean only optionals.
>>>
>>>
>>> References:
>>> https://devforums.apple.com/message/1020139#1020139
>>> https://github.com/rust-lang/rust/issues/1698#issuecomment-3705066
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/023b991e/attachment.html>

From emaloney at gilt.com  Fri Dec  4 13:48:16 2015
From: emaloney at gilt.com (Evan Maloney)
Date: Fri, 4 Dec 2015 14:48:16 -0500
Subject: [swift-evolution] Ability to set access control independently for
getter & setter of a property
Message-ID: <DD4E8FFD-A5D6-47F8-9F2E-E9D1FB518D8E@gilt.com>

Currently, Swift supports a single level of access controls for properties. If a read/write property is declared as public, both the getter and the setter of that property will be publicly visible.

However, it is often the case that you need a stored property that is publicly read-only but internally or privately writeable. The current way to achieve this is by doing something like:

public var authenticationValidUntil: NSDate? {
return _authenticationValidUntil
}
private var _authenticationValidUntil: NSDate?

This seems like a lot of boilerplate to achieve a common goal. Objective-C supported a similar concept by being able to declare a property as read-only in a .h file while being able to override this as a read-write property in the .m file.

I propose being able to declare separate access controls for a property's getter and setter, wherein the setter could have more restrictive access controls than the getter.

For example:

var authenticationValidUntil: NSDate? { public get, private set }

This would result in a public getter, while the implementer could still set the value of the property.

Curious to get your thoughts on this.

Regards,

E. Maloney
Gilt Groupe

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/c23555c7/attachment.html>

From jordan_rose at apple.com  Fri Dec  4 13:50:09 2015
From: jordan_rose at apple.com (Jordan Rose)
Date: Fri, 04 Dec 2015 11:50:09 -0800
Subject: [swift-evolution] Ability to set access control independently
for getter & setter of a property
In-Reply-To: <DD4E8FFD-A5D6-47F8-9F2E-E9D1FB518D8E@gilt.com>
References: <DD4E8FFD-A5D6-47F8-9F2E-E9D1FB518D8E@gilt.com>
Message-ID: <6EAB3989-B757-4B58-AF96-1AA60AA1F97B@apple.com>

We have this, actually! It's spelled "private(set)" on the property.

We probably will need a way to put attributes on stored property accessors, though. @objc for custom getter or setter names is an interesting one already.

Jordan


> On Dec 4, 2015, at 11:48 , Evan Maloney <emaloney at gilt.com> wrote:
>
> Currently, Swift supports a single level of access controls for properties. If a read/write property is declared as public, both the getter and the setter of that property will be publicly visible.
>
> However, it is often the case that you need a stored property that is publicly read-only but internally or privately writeable. The current way to achieve this is by doing something like:
>
>     public var authenticationValidUntil: NSDate? {
>         return _authenticationValidUntil
>     }
>     private var _authenticationValidUntil: NSDate?
>
> This seems like a lot of boilerplate to achieve a common goal. Objective-C supported a similar concept by being able to declare a property as read-only in a .h file while being able to override this as a read-write property in the .m file.
>
> I propose being able to declare separate access controls for a property's getter and setter, wherein the setter could have more restrictive access controls than the getter.
>
> For example:
>
>     var authenticationValidUntil: NSDate? { public get, private set }
>
> This would result in a public getter, while the implementer could still set the value of the property.
>
> Curious to get your thoughts on this.
>
> Regards,
>
> E. Maloney
> Gilt Groupe
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a85f0dd5/attachment-0001.html>

From stephen.celis at gmail.com  Fri Dec  4 13:52:54 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Fri, 4 Dec 2015 14:52:54 -0500
Subject: [swift-evolution] API Guidelines for Asynchronous Completion
Handlers?
In-Reply-To: <C96096A9-E9F7-4566-A412-0E9E3B724DC9@fifthace.com>
References: <91BD3DAA-C47B-437A-B2EB-35C99586F033@gmail.com>
<9B0FCF96-4D77-438B-895B-8A4A86FD2536@apple.com>
<66126E8B-7A71-423C-9B25-F26CFFE129C5@apple.com>
<31B10C00-43F7-4BEF-970E-9AD85D18C976@fifthace.com>
<228F1420-FE70-40A7-924C-0A23156192A3@gmail.com>
<F015C10F-5F94-49BF-B7C9-E1EA787869D6@gmail.com>
<C96096A9-E9F7-4566-A412-0E9E3B724DC9@fifthace.com>
Message-ID: <CAN9tzpDy6-_gy=GV_6oR7_Nr3P6Mrk7pdEjFwS9xtDjmoJN_Uw@mail.gmail.com>

There's a concurrency proposal that discusses various options here:
https://github.com/apple/swift/blob/master/docs/proposals/Concurrency.rst

I like the idea of using try-catch for asynchronous error handling, but
don't think that defers needs to annotate throws. With a language-level
async/await model we'd get deferred catching for free:

class Request {
async func fetch() throws -> Response {}
}

try {
let response = try await request.fetch()
} catch {
// handle error
}

The "try await ?" is a bit wordy, though.

On Fri, Dec 4, 2015 at 2:19 PM, Sean Heber <sean at fifthace.com> wrote:

> I think that the code duplication issue is more of an API design side
> effect. If the API was designed with a 3rd block for when it is ?done?
> regardless of error, then you could put that shared code there - but I
> would imagine that?d be out of the scope of Swift itself. What I often do
> in these situations is just make a local function that does the shared
> stuff and then call it from both blocks:
>
> func finished() {
>           activityIndicator.stopAnimating()
>           button.enabled = true
>           tableView.hidden = false
> }
>
> request.fetch(withCompletionHandler: { result in
>           finished()
>           use(result)
>      }, errorHandler: { error in
>           finished()
>           handleFetchError(error)
>      })
>
> l8r
> Sean
>
>
> > On Dec 4, 2015, at 1:13 PM, Dan Stenmark <daniel.j.stenmark at gmail.com>
> wrote:
> >
> > Hey Alex!
> >
> > I completely agree that the double-block approach is advantageous for
> its reduced unwrapping, but the only issue I have is that, when applied in
> production, it typically leads to duplicate code.
> >
> > request.fetch(withCompletionHandler: { result in
> >           activityIndicator.stopAnimating()
> >           button.enabled = true
> >           tableView.hidden = false
> >
> >           use(result)
> >
> >           print( ?Foo!? )
> >
> >      }, errorHandler: { error in
> >           activityIndicator.stopAnimating()
> >           button.enabled = true
> >           tableView.hidden = false
> >
> >           // Don?t need to force unwrap `error`.
> >           handleFetchError(error)
> >
> >           print( ?Foo!? )
> >
> >      })
> >
> > The same issue is present in the aforementioned deferred throw concept.
> There?re certainly ways to mitigate the problem, but no practical way of
> eliminating it altogether.  I?m personally leaning towards an evolution of
> the Enum-based approach for this very reason, but if a solution can be
> figured out to remove such code duplication, I?d happily adopt
> double-blocks.
> >
> > Dan
> >
> >> On Dec 4, 2015, at 10:20 AM, Vinicius Vendramini <vinivendra at gmail.com>
> wrote:
> >>
> >> I really like the idea of using try/catches, it seems like a more
> swifty approach. However, I'd prefer to do it in a way that doesn't add a
> new syntax.
> >>
> >> Also, I agree with Alex, the second options seems the best of those
> alternatives (if it were done without trailing closures.)
> >>
> >>> On Dec 4, 2015, at 12:21 PM, Sean Heber <sean at fifthace.com> wrote:
> >>>
> >>> What if there was a possibility for a deferred throw?
> >>>
> >>> For example, imagine the fetch function was something like this:
> >>>
> >>> func fetch(withCompletionHandler: (Result) -> ()) defer throws {}
> >>>
> >>> And to call it, you?d wrap it in a try with a new kind of catch:
> >>>
> >>> do {
> >>> try request.fetch() { result in ? }
> >>> } defer catch (? pattern) {
> >>> }
> >>>
> >>> So what the language would do then is treat all of the ?defer catch?
> blocks as closures and pass them along with calls to ?defer throws?
> functions in the same context. When they throw, they would then run those
> blocks as if you had passed them along manually in the double block style.
> >>>
> >>> The context to throw back to would need to be capture-able by the
> function body for fetch() so that if it encounters an error some time later
> it would know where to throw it to. Perhaps the easiest way would be to
> create a closure that throws like so:
> >>>
> >>> func fetch(withCompletionHandler: (Result) -> ()) defer throws {
> >>> var context = FetchContext()
> >>> context.completionHandler = withCompletionHandler
> >>> context.errorHandler = { reason in throw RequestError(reason) }
> >>> self.pending.append(context)
> >>> context.start()
> >>> }
> >>>
> >>> Under the hood the ?throw? captured in the closure would also be
> carrying along the context needed to route that error back to the expected
> defer catch block.
> >>>
> >>> l8r
> >>> Sean
> >>>
> >>>
> >>>>> On Dec 4, 2015, at 10:57 AM, Alex Migicovsky <migi at apple.com> wrote:
> >>>>>
> >>>>>
> >>>>>> On Dec 3, 2015, at 2:15 PM, Douglas Gregor <dgregor at apple.com>
> wrote:
> >>>>>>
> >>>>>> On Dec 3, 2015, at 12:32 PM, Dan Stenmark <
> daniel.j.stenmark at gmail.com> wrote:
> >>>>>>
> >>>>>> There?s a some of debate in the community regarding best practice
> for asynchronous completion callbacks.  These practices include:
> >>>>>>
> >>>>>> - Single Block w/ Mutually Exclusive Result and Error Objects (the
> current standard convention in Cocoa, though originally designed with
> Objective-C in mind)
> >>>>>> - Double Block (one for success, one for failure)
> >>>>>> - Swift Enum w/ Associated Objects (as described here:
> http://www.developerdave.co.uk/2015/09/better-completion-handlers-in-swift/
> )
> >>>>>>
> >>>>>> Even prior to Swift, Apple?s code guidelines never explicitly
> addressed this topic.  Going forward into the brave new world of Swift, are
> there going to be new preferred API design guidelines for this?
> >>>>>
> >>>>> This is a great point, and there are a number of other issues
> related to callbacks/closure arguments that would benefit from guidelines.
> For example, I've seen the ?Double Block? case where the second block ends
> up being a trailing closure, which makes for non-intuitive uses.
> >>>>
> >>>> Hi Dan!
> >>>>
> >>>> I think guidelines in this area would be great.
> >>>>
> >>>> Here are the tradeoffs I think we have for each approach:
> >>>>
> >>>> 1) The single block approach means you?d code against an optional
> result and an optional error, making it easy to write invalid code (see
> example in #2). With the single block you can use trailing closure syntax
> coherently. I think most ObjC APIs use this approach since it works well in
> ObjC.
> >>>>
> >>>> 2) As Doug mentioned, the double block can be inconvenient / awkward
> but it does produce more correct code.
> >>>>
> >>>> Doug: maybe we can limit using trailing closures from being used if
> the 2nd to last parameter is also a closure? That would eliminate some
> confusion at the call site.
> >>>>
> >>>> Some ObjC APIs use this approach. One positive aspect of the
> double-block approach is that it always produces code that?s less indented
> than the single block approach. e.g.
> >>>>
> >>>>    /*
> >>>>         Single block.
> >>>>         Trailing closure syntax works well.
> >>>>    */
> >>>>    request.fetch { result, error in
> >>>>         // More indented code since we need to use guard or if let.
> >>>>         guard let result = result else {
> >>>>              // Need to force unwrap `error`.
> >>>>              handleFetchError(error!)
> >>>>              return
> >>>>         }
> >>>>
> >>>>         use(result)
> >>>>    }
> >>>>
> >>>>    /*
> >>>>         Double block.
> >>>>         Trailing closure syntax is awkward here.
> >>>>    */
> >>>>    request.fetch(withCompletionHandler: { result in
> >>>>         use(result)
> >>>>    }, errorHandler: { error in
> >>>>         // Don?t need to force unwrap `error`.
> >>>>         handleFetchError(error)
> >>>>    })
> >>>>
> >>>> 3) Enums with associated values are conceptually nice, but unless we
> have a Result<> or an Either<> in the Standard Library I think most people
> will write one-off enums for each set of methods that return a specific
> kind of result + error. That adds an unnecessary conceptual burden since
> you need to know the type of of the value that?s passed to each callback.
> Also, we don?t have any primarily ObjC APIs that use this approach yet. It
> would also suffer from the same indentation problem as #1 but without the
> ?invalid code? problem. If we go this route I think we?d want to map the
> async error ObjC APIs to use this approach similar to what we do with
> non-async error handling.
> >>>>
> >>>> Looking at the tradeoffs I think I prefer #2 if we could limit the
> ability to use a trailing closure for the last parameter. I?d want to look
> at more code with the change though. We should also consider whether we
> should map the single block APIs in ObjC into double block APIs. What do
> you think?
> >>>>
> >>>> Also, with any of these approaches there?s also the question of
> whether we pass ErrorType, NSError, or the specific error type.
> >>>>
> >>>> - Alex
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> swift-evolution mailing list
> >>>> swift-evolution at swift.org
> >>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>
> >>> _______________________________________________
> >>> swift-evolution mailing list
> >>> swift-evolution at swift.org
> >>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >> _______________________________________________
> >> swift-evolution mailing list
> >> swift-evolution at swift.org
> >> https://lists.swift.org/mailman/listinfo/swift-evolution
> >
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e589cb4e/attachment.html>

From rjmccall at apple.com  Fri Dec  4 13:54:53 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 11:54:53 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
<B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>
Message-ID: <E43D5828-DEA0-4A44-B795-B4C4D3834FAE@apple.com>

> On Dec 4, 2015, at 11:36 AM, David Owens II <david at owensd.io> wrote:
> For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.
>
>    var vendingMachine = VendingMachine()
>    vendingMachine.coinsDeposited = 8
>
>    do {
>        try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
>    } catch VendingMachineError.InvalidSelection {
>        print("Invalid Selection.")
>    } catch VendingMachineError.OutOfStock {
>        print("Out of Stock.")
>    } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
>        print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
>    } catch { fatalError("this is always needed??) }

But this is printing.  Of course you should be able to generically display an error, but you don?t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.

>> So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.
>
> Possibly? but I think the counter argument is that introducing a new error type that can happen **should** be a breaking change.

This is abstract reasoning without any real consideration for what it?s going to do to actual code.  My argument here is that it?s very easy to fall into a trap where you think this information is useful, but in practice it just leads to a lot of redundancy and boilerplate which, overall, actually means you?re handling errors *worse* than you were before.

> So the `catch` with no pattern becomes a pattern that is ?yeah, some error may happen at a later date, but since we have no idea what it is, it may be benign or it may be catastrophic. So, should it be handled with a `fatalError()` or should it be equivalent to a no-op?
>
> To me, the question really becomes: does a non-typed error-like system really make sense in Swift? Or in other words, if interop with ObjC was not required, would `throw` exist as it does today?

Yes.  It is absolutely the case that libraries are not going to commit to a generating a small, fixed set of failures.  Please feel free to try to find an exhaustive error enum that isn?t littered with vague catch-alls.  Library authors often don?t want to commit to their current set of failures precisely *because* they feel that their current errors are too loosely typed, and they?re holding out hope that some day they?ll come along and make them more specific.

It?s nice to say things like library authors should be encouraged to think more carefully about what errors they generate, and I don?t disagree, but it is not reasonable language design to demand and expect that programmers suddenly start putting vastly more effort into this sort of thing.  Honestly, I am curious what environment people are thinking of when they say that it?s been successful elsewhere, because whenever I see something like Result<T, SomeErrorType>, I take a look at SomeErrorType and almost always find that it is extremely loosely specified.

John.

> It would seem that something has to give: either something like a `Result`/`Error` type should be used instead with some nicer syntax to handle it, or `throws` should really become typed. Leaving it as-is, seems to be the worst of both worlds.
>
> -David
>
>
>> On Dec 4, 2015, at 11:08 AM, John McCall <rjmccall at apple.com> wrote:
>>
>>> On Dec 4, 2015, at 10:18 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>>> Anyone has any thoughts on this? I didn't expect this topic to die without any response?
>>
>> Patience. :)  We?ve been getting a lot of proposals, and it hasn?t even been a full day yet.
>>
>> I do think that there?s a place for typed throws.  There are some very narrow use cases, usually where error handling is being employed as a sort of alternate control scheme rather than a mechanism for reporting ?errors? per se, where it?s nice to both:
>>
>> - inform callers that the function only ?fails? in the prescribed ways
>>
>> - statically enforce that general errors aren?t accidentally getting mixed in
>>
>> You might imagine using it in a recursive-descent parser, for example, although even there I?m not convinced.
>>
>> However, I?m still reluctant to fully embrace the feature, because I think it?s far too tempting to try to use it for actual error handling, and that?s a job that it?s really, really poorly-suited for.
>>
>> Let?s get one thing out of the way first.  There are some operations that make sense to be able to do on a generic error ? crucially, formatting it for display in various ways ? and right now the ErrorType protocol doesn?t expose API for that.  That?s something we perhaps need to work on.
>>
>> Beyond that, however, it has always been unclear to me what exactly programmers expect to do with this additional typing information on errors, besides pedantically copying it all over the place and feeling pleased.  Libraries can fail in a lot of different ways.  It?s inevitable that that set will grow in ways that neither the library?s authors nor its users are necessarily anticipating.  Even putting evolution aside, the list of failures is almost certainly impractical to exhaustively pattern-match over, and doing so couples you very tightly to the implementation of the library and everything it uses.  Furthermore, in practice nearly every ?exhaustively enumerable? error type I?ve ever seen has at least one (and often two or three) generic, catch-all cases used to encode arbitrary extra kinds of error, either dynamically-typed (e.g. carrying an ErrorType) or completely untyped (e.g. carrying a String); and not only does this make it impossible to exhaustively enumerate the actual kinds of failure, but it actually makes it more difficult to detect specific failures, by making it more likely that the error you?re actually trying to detect and special-case will be stored at the end of a rather complicated path of wrapping errors.
>>
>> And this isn?t even just about third-party libraries, because if there?s any lesson from the last fifty years of experience that's broadly applicable across programming languages, it?s that you really do need to think about how your program breaks down into components, and understand how those components work with each other essentially as if they were separable libraries, or else you will always, always run into a wall as you find that the complexity of your comprehension has failed to scale with the complexity of your code.
>>
>> So I continue to feel that the pattern of ?recognize a few special cases and then be prepared to deal with other failures generically? is basically the right approach for ordinary error-handling in Swift, and I think it?s pretty well-served by the current design.
>>
>> John.
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From emaloney at gilt.com  Fri Dec  4 13:57:12 2015
From: emaloney at gilt.com (Evan Maloney)
Date: Fri, 4 Dec 2015 14:57:12 -0500
Subject: [swift-evolution] Ability to set access control independently
for getter & setter of a property
In-Reply-To: <6EAB3989-B757-4B58-AF96-1AA60AA1F97B@apple.com>
References: <DD4E8FFD-A5D6-47F8-9F2E-E9D1FB518D8E@gilt.com>
<6EAB3989-B757-4B58-AF96-1AA60AA1F97B@apple.com>
Message-ID: <1436C965-67CD-42F4-ABC4-AEE9D2065429@gilt.com>

Very cool! I hadn't seen that in use anywhere; glad I sent my e-mail or I wouldn't know it exists. :)

Thanks, Jordan!



> On Dec 4, 2015, at 2:50 PM, Jordan Rose <jordan_rose at apple.com> wrote:
>
> We have this, actually! It's spelled "private(set)" on the property.
>
> We probably will need a way to put attributes on stored property accessors, though. @objc for custom getter or setter names is an interesting one already.
>
> Jordan
>
>
>> On Dec 4, 2015, at 11:48 , Evan Maloney <emaloney at gilt.com <mailto:emaloney at gilt.com>> wrote:
>>
>> Currently, Swift supports a single level of access controls for properties. If a read/write property is declared as public, both the getter and the setter of that property will be publicly visible.
>>
>> However, it is often the case that you need a stored property that is publicly read-only but internally or privately writeable. The current way to achieve this is by doing something like:
>>
>>     public var authenticationValidUntil: NSDate? {
>>         return _authenticationValidUntil
>>     }
>>     private var _authenticationValidUntil: NSDate?
>>
>> This seems like a lot of boilerplate to achieve a common goal. Objective-C supported a similar concept by being able to declare a property as read-only in a .h file while being able to override this as a read-write property in the .m file.
>>
>> I propose being able to declare separate access controls for a property's getter and setter, wherein the setter could have more restrictive access controls than the getter.
>>
>> For example:
>>
>>     var authenticationValidUntil: NSDate? { public get, private set }
>>
>> This would result in a public getter, while the implementer could still set the value of the property.
>>
>> Curious to get your thoughts on this.
>>
>> Regards,
>>
>> E. Maloney
>> Gilt Groupe
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8b2e23c0/attachment.html>

From jj at johanjensen.dk  Fri Dec  4 14:07:20 2015
From: jj at johanjensen.dk (Johan Jensen)
Date: Fri, 4 Dec 2015 21:07:20 +0100
Subject: [swift-evolution] Ability to set access control independently
for getter & setter of a property
In-Reply-To: <1436C965-67CD-42F4-ABC4-AEE9D2065429@gilt.com>
References: <DD4E8FFD-A5D6-47F8-9F2E-E9D1FB518D8E@gilt.com>
<6EAB3989-B757-4B58-AF96-1AA60AA1F97B@apple.com>
<1436C965-67CD-42F4-ABC4-AEE9D2065429@gilt.com>
Message-ID: <CAB8TY2OA=aj1sNjhQrjTQ9227E327+q5YUJLSF3whdgCsO8R4w@mail.gmail.com>

For reference, it can also be found in The Swift Programming Language Guide
under Access Control ? Constants, Variables, Properties, and
Subscripts ? Getters
and Setters
<https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID18>
.

> You can give a setter a *lower* access level than its corresponding
getter, to restrict the read-write scope of that variable, property, or
subscript. You assign a lower access level by writing private(set) or
internal(set) before the var or subscript introducer.

?Johan

On Fri, Dec 4, 2015 at 8:57 PM, Evan Maloney <emaloney at gilt.com> wrote:

> Very cool! I hadn't seen that in use anywhere; glad I sent my e-mail or I
> wouldn't know it exists. :)
>
> Thanks, Jordan!
>
>
>
> On Dec 4, 2015, at 2:50 PM, Jordan Rose <jordan_rose at apple.com> wrote:
>
> We have this, actually! It's spelled "private(set)" on the property.
>
> We probably will need a way to put attributes on stored property
> accessors, though. @objc for custom getter or setter names is an
> interesting one already.
>
> Jordan
>
>
> On Dec 4, 2015, at 11:48 , Evan Maloney <emaloney at gilt.com> wrote:
>
> Currently, Swift supports a single level of access controls for
> properties. If a read/write property is declared as public, both the getter
> and the setter of that property will be publicly visible.
>
> However, it is often the case that you need a stored property that is
> publicly read-only but internally or privately writeable. The current way
> to achieve this is by doing something like:
>
>     public var authenticationValidUntil: NSDate? {
>         return _authenticationValidUntil
>     }
>     private var _authenticationValidUntil: NSDate?
>
> This seems like a lot of boilerplate to achieve a common goal. Objective-C
> supported a similar concept by being able to declare a property as
> read-only in a .h file while being able to override this as a read-write
> property in the .m file.
>
> I propose being able to declare separate access controls for a property's
> getter and setter, wherein the setter could have more restrictive access
> controls than the getter.
>
> For example:
>
>     var authenticationValidUntil: NSDate? { public get, private set }
>
> This would result in a public getter, while the implementer could still
> set the value of the property.
>
> Curious to get your thoughts on this.
>
> Regards,
>
> E. Maloney
> Gilt Groupe
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/c141222a/attachment.html>

From brent at architechies.com  Fri Dec  4 14:09:37 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 12:09:37 -0800
Subject: [swift-evolution] SE-0005: Ambiguous NS prefix removals
In-Reply-To: <23C22A72-E3D5-4762-B473-9FD5822D43D4@apple.com>
References: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>
<23C22A72-E3D5-4762-B473-9FD5822D43D4@apple.com>
Message-ID: <606A3B1E-DDB4-45F1-89AC-22D9B0DA1780@architechies.com>

> We?ve been thinking about exactly what to call this submodule, but haven?t landed on a preferred name yet. For the class names themselves, I don?t think we want to suffix some classes with ?Ref? or ?Object? but not others, because it would lead to either boilerplate names or inconsistency. The idea of the submodule was to avoid the inconsistency but still have something which obviously separates these classes.

But I?m not sure using a submodule really solves either of these problems.

BOILERPLATE: How are you going to address types inside the module? Either you?ll have to always include the prefix?in which case the prefix is boilerplate, but it?s in the wrong place on the type name to read correctly (?reference array? instead of ?array reference?) and requires an extra character due to the ?.??or there will be some way to make Swift favor the reference types over the value types, in which case you won?t even be able to read ?Array? or ?String? in a piece of code without wondering which semantics you?re talking about.

INCONSISTENCY: Not every type in Foundation will be moved into this submodule; some will stay behind in the top-level Foundation module. Doesn?t that mean the submodule approach is inconsistent too?

So is putting these types into a submodule actually fixing these problems, or is it just sticking a dot after them?

Actually, as long as we?re here, here?s a weird idea I just came up with. Why not nest the reference types inside the types they bridge to?

NSString -> String.Reference
NSMutableString -> String.MutableReference
NSArray<T> -> Array<T>.Reference
NSMutableArray<T> -> Array<T>.MutableReference

This would require you to get a handle on nesting types within generic types, but personally, that?s always been a pain point for me in Swift?s design. With the right type resolution rules, it might also allow you to say something like this and let Swift figure out what you mean:

let foo = ?foo bar baz? as .Reference	// implicitly means String.Reference

And if this was driven by a protocol with a typealias for the reference type, you could even make this public so users who have their own matching value/reference types can have them autoboxed:

// Think of this as a cleaned up version of _ObjectiveCBridgeable.
public protocol Referable {
typealias Reference: class
static func referenceType() -> Reference.Type			// or make it possible to get this from the protocol witness

var reference: Reference { get }
init?(reference: Reference)							// for an as! conversion, this is force-unwrapped by the caller
}

--
Brent Royal-Gordon
Architechies


From jgroff at apple.com  Fri Dec  4 14:18:56 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 12:18:56 -0800
Subject: [swift-evolution] Allow Selectors to be used as Closures
In-Reply-To: <F9E5E2D6-610C-4FC2-BCBF-EE39530139FC@apple.com>
References: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>
<7D3509DA-DA2F-4977-80F6-EF59D9683ADD@fastmail.com>
<F9E5E2D6-610C-4FC2-BCBF-EE39530139FC@apple.com>
Message-ID: <295BC5A8-A114-48C5-BC0D-A5FB6E19FCA9@apple.com>

On Dec 4, 2015, at 11:26 AM, David Smith <david_smith at apple.com> wrote:
>
> The other concern with patterns like this is that they tend to lead to reference cycles due to unintentional closure capture.

We could do something with selectors similar to what we do with C function pointers and limit them to taking closures that take no context. We could do this by having a '@convention(objc_selector)' or something like that that represents a context-free (Self: class) -> Args -> Return function type as a selector pointer; invoking it emits objc_msgSend.

-Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/cc0d5e5c/attachment.html>

From nvazquez1297 at gmail.com  Fri Dec  4 14:34:43 2015
From: nvazquez1297 at gmail.com (Nikolai Vazquez)
Date: Fri, 04 Dec 2015 20:34:43 +0000
Subject: [swift-evolution] SE-0005: Ambiguous NS prefix removals
In-Reply-To: <606A3B1E-DDB4-45F1-89AC-22D9B0DA1780@architechies.com>
References: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>
<23C22A72-E3D5-4762-B473-9FD5822D43D4@apple.com>
<606A3B1E-DDB4-45F1-89AC-22D9B0DA1780@architechies.com>
Message-ID: <CANhuES3CpEVBVkReQXN7iEzd-zXSH-p5Y7OZy04q_TE3GzoPsg@mail.gmail.com>

Hey Brent,

I really like the idea you proposed with having a Reference nested type. I
prefer a name like Object but that's just me.

>From my experience, nested types don't conflict with typealiases for
protocol conformance so you could do something similar to:

extension Array: Referable {
class Reference<Element> { ... }
var reference: Reference<Element> { ... }
}

I do agree with Tony however that types like NSBundle that have no Swift
counterpart could be renamed to simply Bundle.

One thing I'm wondering about is abuse of the Referable protocol. It could
lead to developers feeling the need to conform to it when it comes to
creating new value types. However, it shouldn't be an issue.

On Fri, Dec 4, 2015, 3:09 PM Brent Royal-Gordon <brent at architechies.com>
wrote:

> > We’ve been thinking about exactly what to call this submodule, but
> haven’t landed on a preferred name yet. For the class names themselves, I
> don’t think we want to suffix some classes with ‘Ref’ or ‘Object’ but not
> others, because it would lead to either boilerplate names or inconsistency.
> The idea of the submodule was to avoid the inconsistency but still have
> something which obviously separates these classes.
>
> But I’m not sure using a submodule really solves either of these problems.
>
> BOILERPLATE: How are you going to address types inside the module? Either
> you’ll have to always include the prefix—in which case the prefix is
> boilerplate, but it’s in the wrong place on the type name to read correctly
> (“reference array” instead of “array reference”) and requires an extra
> character due to the “.”—or there will be some way to make Swift favor the
> reference types over the value types, in which case you won’t even be able
> to read “Array” or “String” in a piece of code without wondering which
> semantics you’re talking about.
>
> INCONSISTENCY: Not every type in Foundation will be moved into this
> submodule; some will stay behind in the top-level Foundation module.
> Doesn’t that mean the submodule approach is inconsistent too?
>
> So is putting these types into a submodule actually fixing these problems,
> or is it just sticking a dot after them?
>
> Actually, as long as we’re here, here’s a weird idea I just came up with.
> Why not nest the reference types inside the types they bridge to?
>
>         NSString -> String.Reference
>         NSMutableString -> String.MutableReference
>         NSArray<T> -> Array<T>.Reference
>         NSMutableArray<T> -> Array<T>.MutableReference
>
> This would require you to get a handle on nesting types within generic
> types, but personally, that’s always been a pain point for me in Swift’s
> design. With the right type resolution rules, it might also allow you to
> say something like this and let Swift figure out what you mean:
>
>         let foo = “foo bar baz” as .Reference   // implicitly means
> String.Reference
>
> And if this was driven by a protocol with a typealias for the reference
> type, you could even make this public so users who have their own matching
> value/reference types can have them autoboxed:
>
>         // Think of this as a cleaned up version of _ObjectiveCBridgeable.
>         public protocol Referable {
>                 typealias Reference: class
>                 static func referenceType() -> Reference.Type
>      // or make it possible to get this from the protocol witness
>
>                 var reference: Reference { get }
>                 init?(reference: Reference)
>                      // for an as! conversion, this is force-unwrapped by
> the caller
>         }
>
> --
> Brent Royal-Gordon
> Architechies
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ed6eacb2/attachment.html>

From anthony.parker at apple.com  Fri Dec  4 14:45:10 2015
From: anthony.parker at apple.com (Tony Parker)
Date: Fri, 04 Dec 2015 12:45:10 -0800
Subject: [swift-evolution] SE-0005: Ambiguous NS prefix removals
In-Reply-To: <606A3B1E-DDB4-45F1-89AC-22D9B0DA1780@architechies.com>
References: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>
<23C22A72-E3D5-4762-B473-9FD5822D43D4@apple.com>
<606A3B1E-DDB4-45F1-89AC-22D9B0DA1780@architechies.com>
Message-ID: <57419815-29D3-40A3-AF75-5CA850676EF5@apple.com>


> On Dec 4, 2015, at 12:09 PM, Brent Royal-Gordon <brent at architechies.com> wrote:
>
>> We’ve been thinking about exactly what to call this submodule, but haven’t landed on a preferred name yet. For the class names themselves, I don’t think we want to suffix some classes with ‘Ref’ or ‘Object’ but not others, because it would lead to either boilerplate names or inconsistency. The idea of the submodule was to avoid the inconsistency but still have something which obviously separates these classes.
>
> But I’m not sure using a submodule really solves either of these problems.
>
> BOILERPLATE: How are you going to address types inside the module? Either you’ll have to always include the prefix—in which case the prefix is boilerplate, but it’s in the wrong place on the type name to read correctly (“reference array” instead of “array reference”) and requires an extra character due to the “.”—or there will be some way to make Swift favor the reference types over the value types, in which case you won’t even be able to read “Array” or “String” in a piece of code without wondering which semantics you’re talking about.
>

You’re right that there is going to be some boilerplate here. Inside the Foundation module we’re willing to accept the readability hit of using submodule.Array when we mean “NSArray.” Using NSArray outside of Foundation itself should be relatively rare compared to using the standard library Array, so it should not be very prevalent there.

The idea we’ve been thinking about is to add something (in the module map, or in the class interface itself) here which makes the submodule specification required. We don’t have that capability today, so we need a compiler change of some kind to make this work if it is the direction we go. That means that Array always means Array.

> INCONSISTENCY: Not every type in Foundation will be moved into this submodule; some will stay behind in the top-level Foundation module. Doesn’t that mean the submodule approach is inconsistent too?
>

It would just be for types which have a value type equivalent in Swift that we would rather be used in most situations. This is why NSString Obj-C API is imported into Swift API as String, for example.

> So is putting these types into a submodule actually fixing these problems, or is it just sticking a dot after them?
>
> Actually, as long as we’re here, here’s a weird idea I just came up with. Why not nest the reference types inside the types they bridge to?
>
> 	NSString -> String.Reference
> 	NSMutableString -> String.MutableReference
> 	NSArray<T> -> Array<T>.Reference
> 	NSMutableArray<T> -> Array<T>.MutableReference
>
> This would require you to get a handle on nesting types within generic types, but personally, that’s always been a pain point for me in Swift’s design. With the right type resolution rules, it might also allow you to say something like this and let Swift figure out what you mean:
>
> 	let foo = “foo bar baz” as .Reference	// implicitly means String.Reference
>
> And if this was driven by a protocol with a typealias for the reference type, you could even make this public so users who have their own matching value/reference types can have them autoboxed:
>
> 	// Think of this as a cleaned up version of _ObjectiveCBridgeable.
> 	public protocol Referable {
> 		typealias Reference: class
> 		static func referenceType() -> Reference.Type			// or make it possible to get this from the protocol witness
>
> 		var reference: Reference { get }
> 		init?(reference: Reference)							// for an as! conversion, this is force-unwrapped by the caller
> 	}
>
> --
> Brent Royal-Gordon
> Architechies
>

This is an interesting idea; although I think it goes beyond what we had in mind for just the renaming. Even without the casting idea you propose, the names are not too different from calling the submodule ‘Reference’, which is something we considered:

NSString -> Reference.String
NSMutableString -> Reference.MutableString
NSArray -> Reference.Array

etc. The problem with this in my mind is that ‘Reference’ is not a good enough word to describe the difference between Foundation.NSString and Swift.String.

- Tony


From david at owensd.io  Fri Dec  4 14:54:56 2015
From: david at owensd.io (David Owens II)
Date: Fri, 4 Dec 2015 12:54:56 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <E43D5828-DEA0-4A44-B795-B4C4D3834FAE@apple.com>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
<B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>
<E43D5828-DEA0-4A44-B795-B4C4D3834FAE@apple.com>
Message-ID: <3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>


> On Dec 4, 2015, at 11:54 AM, John McCall <rjmccall at apple.com> wrote:
>
>> On Dec 4, 2015, at 11:36 AM, David Owens II <david at owensd.io> wrote:
>> For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.
>>
>>   var vendingMachine = VendingMachine()
>>   vendingMachine.coinsDeposited = 8
>>
>>   do {
>>       try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
>>   } catch VendingMachineError.InvalidSelection {
>>       print("Invalid Selection.")
>>   } catch VendingMachineError.OutOfStock {
>>       print("Out of Stock.")
>>   } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
>>       print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
>>   } catch { fatalError("this is always needed…”) }
>
> But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.

This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.

The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.

That’s my concern.

Instead, if we could annotate throws, we could move this into a compile-time validation.

enum VendingMachineError: ErrorType {
case InvalidSelection
case InsufficientFunds(coinsNeeded: Int)
case OutOfStock
}

func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws VendingMachineError {
let snackName = favoriteSnacks[person] ?? "Candy Bar"
try vendingMachine.vend(itemNamed: snackName)
}

This allows the compiler to validate the only error information leaving this call site is a `VendingMachineError` and it allows all callers to ensure that they are indeed handling the all of the errors for `VendingMachineError`.

To me, that is a very practical and pragmatic problem and is fundamentally no different than the treatment of exhaustive switch cases needed when dealing with other enum values.

Instead, if I turned the `buyFavoriteSnack` into this:

enum Error<ErrorType> {
case Ok,
case Error(ErrorType)
}

func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) -> Error<VendingMachineError>

I then get to leverage the compiler to check that I’m indeed handling all of the VendingMachineErrors.

Yes, I do realize that multiple error types would complicate that, but honestly, I’d rather than the limitation that only a single error type can be propagated up the callstack than to have the ability to have no typed error information at all.

Of course, I can do this myself, but the language is going to win so I still have to deal with how `throws` is treated within the language as a whole.

-David

From dgregor at apple.com  Fri Dec  4 14:56:55 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Fri, 4 Dec 2015 12:56:55 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <94F08C46-27BC-44C5-ACFC-7A5F59DE0672@apple.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
<750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
<1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>
<6A63268A-BF21-491A-A974-3BD11A7B0AEB@ericasadun.com>
<94F08C46-27BC-44C5-ACFC-7A5F59DE0672@apple.com>
Message-ID: <0A63C683-8F47-4D8B-9D1A-3D14F6FA1649@apple.com>


> On Dec 4, 2015, at 11:07 AM, Joe Groff <jgroff at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 10:56 AM, Erica Sadun <erica at ericasadun.com> wrote:
>>
>> I honestly have no idea where to go next with this. Here's my starting point: https://gist.github.com/erica/cf064a34f8891fb7a4a8
>>
>> Advice welcome.
>>
>> -- E, inexperienced at this stuff
>
> Looks like you're on the right track. Check out the Swift evolution process if you haven't already: https://swift.org/contributing/#participating-in-the-swift-evolution-process Next step would be to fork swift-evolution and make a pull request, I believe.


Just to close the loop on this… the review of Erica’s proposal is now scheduled for December 7-10, 2015, and is on the review schedule here:

https://github.com/apple/swift-evolution/blob/master/schedule.md

The evolution process we’re following is described at

https://github.com/apple/swift-evolution/blob/master/process.md

- Doug


From sungon at gmail.com  Fri Dec  4 15:00:20 2015
From: sungon at gmail.com (Nikolay Petrov)
Date: Fri, 4 Dec 2015 15:00:20 -0600
Subject: [swift-evolution] Proposal: Optional unwrap resulting in exception.
Message-ID: <CAMsnS2v7+FBZdzRZHtqO7HBDnuevHORwFtZ_DW5QocYZnLVYLw@mail.gmail.com>

Currently, force unwraping .None/nil optional results in a runtime error. I
suggest to put operator/method which will allow the optional unwrap to
result in exception. For example:

enum OptionalError: ErrorType {
case NoValue(String)
}

extension Optional {
func unwrap(@autoclosure reason: () -> String = "No value found")
throws -> Wrapped {
if let val = self {
return val
} else {
throw OptionalError.NoValue(reason())
}
}
}

Alternatively we could put a postfix operator like !!.

--
Best Regards,
Nikolay Petrov
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/befa5b67/attachment.html>

From andy at andymatuschak.org  Fri Dec  4 15:09:18 2015
From: andy at andymatuschak.org (Andy Matuschak)
Date: Fri, 4 Dec 2015 13:09:18 -0800
Subject: [swift-evolution] Process question: breaking proposals for API
changes to stdlib?
Message-ID: <380DE8CE-E29D-4D85-BDF5-2B4CAA7AD023@andymatuschak.org>

Hello, all! Process question here: if I'd like to propose an API change in stdlib, should I do that here? Open a pull request?

From p at greendale.se  Fri Dec  4 15:18:48 2015
From: p at greendale.se (Per Melin)
Date: Fri, 4 Dec 2015 22:18:48 +0100
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
Message-ID: <CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>

On Fri, Dec 4, 2015 at 1:03 AM, Amir Michail <a.michail at me.com> wrote:

>
> I really don’t like having to put the ! suffix in boolean contexts:
>

To be explicit:

let a: Bool! = false

if a == false { }  // Works as expected

if !a { }  // Works as expected

if a { }   // "error: optional type 'Bool!' cannot be used as a
boolean; test for '!= nil' instead"

Xcode "fixes" the last line like this:

if (a != nil) { }



> "if displayFlag! { ... }" instead of "if displayFlag { … }" etc.
>
> If you also want a way to compare with nil, then maybe have this for
> implicitly unwrapped optionals:
>
> if displayFlag? == nil { … }
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/863392a7/attachment.html>

From plxswift at icloud.com  Fri Dec  4 15:19:31 2015
From: plxswift at icloud.com (plx)
Date: Fri, 04 Dec 2015 15:19:31 -0600
Subject: [swift-evolution] Proposal: Automatic Wrapper Synthesis / "deriving"
Message-ID: <12DD7FBE-CA6D-4667-A854-9F0FE492A883@icloud.com>

# A `wrapper` / `deriving` Construct

I'm sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.

The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.

## Design Sketch

It ought to be possible to write something like this:

// an example:
struct SectionIndex
wrapping Int
as index
satisfying precondition { $0 >= 0 }
deriving Equatable, Comparable, Hashable {
// declaration can continue in here
}

...which, when compiled, would be "expanded" along these lines:

struct SectionIndex {

// would have been `wrappedValue` w/out the `as index` clause
let index: Int

init(_ index: Int) {
precondition(index >= 0)
// ^ would have been assert(index >= 0)
//   had we used `satisfying { $0 >= 0 }`,
//   and omitted entirely had we omitted a `satisfying` clause
self.index = index
}

}

extension SectionIndex : Equatable {
}

// synthesized unless explicitly written-out
func ==(lhs: SectionIndex, rhs: SectionIndex) -> Bool {
return lhs.index == rhs.index
}

// same for Comparable, Hashable, all done in the obvious way

// there’s a lot of utility in synthesizing something like this,
//  I can expand on it if necessary:
extension SectionIndex: ValueWrapperType {
typealias WrappedType = Int
}

...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols' typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.

I think this enough to sketch the way the feature would look and how it would work.

I’m curious at this point to hear if there’s anything already on the roadmap and/or other community thoughts.

## Postscript

I'm aware that some of this can be done today via protocol extensions, but at least at present that technique has some serious drawbacks; I point it out only b/c it's possible Swift will wind up with enough improvements to protocol extensions to make a dedicated wrapper-synthesis, language-level feature unnecessary.

Additionally, although the sketch above *could* be implemented today via an external code-generation tool, the looming presence of a "standard" package manager makes it seem better to have this construct baked into the official tooling if possible.

From david at hartbit.com  Fri Dec  4 15:19:58 2015
From: david at hartbit.com (David Hart)
Date: Fri, 4 Dec 2015 22:19:58 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for accessing
instance properties and functions
Message-ID: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>

I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?

Just as example, my proposition makes the following piece of code illegal:

```
struct FooBar {
var foo: String = "foobar"

func bar() {
print(foo) // compiler error
print(self.foo) // compiler happy
}

func bar2() {
bar() // compiler error
self.bar() // compiler happy
}
}
```

From david_smith at apple.com  Fri Dec  4 15:21:37 2015
From: david_smith at apple.com (David Smith)
Date: Fri, 04 Dec 2015 13:21:37 -0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
Message-ID: <2B43B46B-76AC-4D73-9B77-EBC08DD2F595@apple.com>

Currently, ‘self.’ is required when used in closure capture contexts, which has the nice property of making it really clear when things are being captured (and therefore retained).

David

> On Dec 4, 2015, at 1:19 PM, David Hart <david at hartbit.com> wrote:
>
> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>
> Just as example, my proposition makes the following piece of code illegal:
>
> ```
> struct FooBar {
>    var foo: String = "foobar"
>
>    func bar() {
>        print(foo) // compiler error
>        print(self.foo) // compiler happy
>    }
>
>    func bar2() {
>        bar() // compiler error
>        self.bar() // compiler happy
>    }
> }
> ```
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From erica at ericasadun.com  Fri Dec  4 15:24:09 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Fri, 4 Dec 2015 14:24:09 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
Message-ID: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>

PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example:

let task = NSTask()
task.launchPath = "/usr/bin/mdfind"
task.arguments = ["kMDItemDisplayName == *.playground"]
task.standardOutput = pipe

Here's another:

let questionLabel = UILabel()
questionLabel.textAlignment = .Center
questionLabel.font =  UIFont(name:"DnealianManuscript", size: 72)
questionLabel.text = currentQuestion.questionText
questionLabel.numberOfLines = 0

You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:
This code feels unnecessarily redundant
This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.
The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.
Further, if you have many instances to set up there's no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.

PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:

let task = NSTask()>>{
launchPath = "/usr/bin/mdfind"
arguments = ["kMDItemDisplayName == *.playground"]
standardOutput = pipe
}

In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.

ADVANTAGES AND DISADVANTAGES:

The advantages I see are as follows:
additional setup becomes integrated into initialization
code is streamlined, a general Swift ideal
the indented scope provides a visual emphasis of the single task being addressed
allows easier top-level initialization for global values, especially for Swift playgrounds.

The disadvantages I imagine would include:
the need for a new operator to disambiguate trailing closures from setup
compiler tweaking so `self`-references within the closure work without constant copies for value types

Thoughts?


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6cacca68/attachment.html>

From jgroff at apple.com  Fri Dec  4 15:27:05 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 13:27:05 -0800
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
Message-ID: <090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>


> On Dec 4, 2015, at 1:24 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
> PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example:
>
> let task = NSTask()
> task.launchPath = "/usr/bin/mdfind"
> task.arguments = ["kMDItemDisplayName == *.playground"]
> task.standardOutput = pipe
>
> Here's another:
>
> let questionLabel = UILabel()
> questionLabel.textAlignment = .Center
> questionLabel.font =  UIFont(name:"DnealianManuscript", size: 72)
> questionLabel.text = currentQuestion.questionText
> questionLabel.numberOfLines = 0
>
> You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:
> This code feels unnecessarily redundant
> This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.
> The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.
> Further, if you have many instances to set up there's no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.
>
> PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:
>
> let task = NSTask()>>{
>     launchPath = "/usr/bin/mdfind"
>     arguments = ["kMDItemDisplayName == *.playground"]
>     standardOutput = pipe
> }
>
> In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.

In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same 'self'. In Dart they use '..' for this:

let task = NSTask()
..launchPath = "..."
..arguments = [...]
..standardOutput = pipe

The nice thing about that is that it's a bit more generally applicable than just initialization.

-Joe

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0ec325b3/attachment-0001.html>

From salutis at me.com  Fri Dec  4 15:33:18 2015
From: salutis at me.com (Rudolf Adamkovic)
Date: Fri, 04 Dec 2015 22:33:18 +0100
Subject: [swift-evolution] SE-0005: Ambiguous NS prefix removals
In-Reply-To: <57419815-29D3-40A3-AF75-5CA850676EF5@apple.com>
References: <4CF80C7B-8A7E-4FA3-88E4-AD0A34BC055D@architechies.com>
<23C22A72-E3D5-4762-B473-9FD5822D43D4@apple.com>
<606A3B1E-DDB4-45F1-89AC-22D9B0DA1780@architechies.com>
<57419815-29D3-40A3-AF75-5CA850676EF5@apple.com>
Message-ID: <049E93DC-CCF0-44B9-BAD2-D8AA46A0F95B@me.com>

> The problem with this in my mind is that ‘Reference’ is not a good enough word to describe the difference between Foundation.NSString and Swift.String.
>
> - Tony

What about Legacy instead of Reference?

P.S. Hopefully, UI and other prefixes will be removed "soonish" too.

R+

Sent from my iPhone

> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From sean at fifthace.com  Fri Dec  4 15:35:02 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 15:35:02 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
Message-ID: <54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>


> On Dec 4, 2015, at 3:27 PM, Joe Groff <jgroff at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 1:24 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>
>> PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example:
>>
>> let task = NSTask()
>> task.launchPath = "/usr/bin/mdfind"
>> task.arguments = ["kMDItemDisplayName == *.playground"]
>> task.standardOutput = pipe
>>
>> Here's another:
>>
>> let questionLabel = UILabel()
>> questionLabel.textAlignment = .Center
>> questionLabel.font =  UIFont(name:"DnealianManuscript", size: 72)
>> questionLabel.text = currentQuestion.questionText
>> questionLabel.numberOfLines = 0
>>
>> You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:
>> This code feels unnecessarily redundant
>> This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.
>> The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.
>> Further, if you have many instances to set up there's no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.
>>
>> PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:
>>
>> let task = NSTask()>>{
>>     launchPath = "/usr/bin/mdfind"
>>     arguments = ["kMDItemDisplayName == *.playground"]
>>     standardOutput = pipe
>> }
>>
>> In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.
>
> In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same 'self'. In Dart they use '..' for this:
>
> let task = NSTask()
>   ..launchPath = "..."
>   ..arguments = [...]
>   ..standardOutput = pipe
>
> The nice thing about that is that it's a bit more generally applicable than just initialization.
>
> -Joe

I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P

with let task = NSTask() {
launchPath = "/usr/bin/mdfind"
arguments = ["kMDItemDisplayName == *.playground"]
standardOutput = pipe
}

Also valid:

with someVariable {
func1()
func2(“etc")
}

Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).

l8r
Sean


From matthew at anandabits.com  Fri Dec  4 15:41:24 2015
From: matthew at anandabits.com (Anandabits)
Date: Fri, 4 Dec 2015 15:41:24 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
Message-ID: <6BFB1B46-1B4D-4B58-8D12-5E577150C69B@anandabits.com>

let task = NSTask()>>{
>     launchPath = "/usr/bin/mdfind"
>     arguments = ["kMDItemDisplayName == *.playground"]
>     standardOutput = pipe
> }
>

I think something like this would be extremely useful, however I think the proposal as it is written is a bit more limited than I would like to see as it only applies to mutable properties.

I don't have a concrete idea of exactly what I would prefer, but it would take the form of a general solution that would allow an initializer to accept initial values for some or all public stored properties from the caller.  The simplest case might look a lot like the compiler generated memberwise initializer for structs.  Slightly more complex cases might allow the caller to omit some properties if a default is specified by the type or by the initializer.  Going a step further, some initializers for a type may need to initialize some of the stored priorities directly and thus not allow those specific properties to be specified by the caller.

The goal is to allow flexible initialization for callers without sacrificing immutability and without requiring a ton of initializer overloads.

If others like this basic idea I will try to make it more concrete and write a proposal.

Matthew
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/abc958ae/attachment.html>

From erica at ericasadun.com  Fri Dec  4 15:43:02 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Fri, 4 Dec 2015 14:43:02 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
Message-ID: <FBE0B6D5-9FD9-433D-94B9-D8569A4BC2E7@ericasadun.com>

I really like both approaches, although I prefer the elegance of Sean's.

-- E


> On Dec 4, 2015, at 2:35 PM, Sean Heber <sean at fifthace.com> wrote:
>
>>
>> On Dec 4, 2015, at 3:27 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>
>>
>>> On Dec 4, 2015, at 1:24 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>
>>> PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example:
>>>
>>> let task = NSTask()
>>> task.launchPath = "/usr/bin/mdfind"
>>> task.arguments = ["kMDItemDisplayName == *.playground"]
>>> task.standardOutput = pipe
>>>
>>> Here's another:
>>>
>>> let questionLabel = UILabel()
>>> questionLabel.textAlignment = .Center
>>> questionLabel.font =  UIFont(name:"DnealianManuscript", size: 72)
>>> questionLabel.text = currentQuestion.questionText
>>> questionLabel.numberOfLines = 0
>>>
>>> You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:
>>> This code feels unnecessarily redundant
>>> This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.
>>> The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.
>>> Further, if you have many instances to set up there's no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.
>>>
>>> PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:
>>>
>>> let task = NSTask()>>{
>>>    launchPath = "/usr/bin/mdfind"
>>>    arguments = ["kMDItemDisplayName == *.playground"]
>>>    standardOutput = pipe
>>> }
>>>
>>> In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.
>>
>> In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same 'self'. In Dart they use '..' for this:
>>
>> let task = NSTask()
>>  ..launchPath = "..."
>>  ..arguments = [...]
>>  ..standardOutput = pipe
>>
>> The nice thing about that is that it's a bit more generally applicable than just initialization.
>>
>> -Joe
>
> I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
>
> with let task = NSTask() {
>    launchPath = "/usr/bin/mdfind"
>    arguments = ["kMDItemDisplayName == *.playground"]
>    standardOutput = pipe
> }
>
> Also valid:
>
> with someVariable {
>    func1()
>    func2(“etc")
> }
>
> Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).
>
> l8r
> Sean

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/40d78aea/attachment-0001.html>

From david at alkaline-solutions.com  Fri Dec  4 15:44:30 2015
From: david at alkaline-solutions.com (David Waite)
Date: Fri, 4 Dec 2015 14:44:30 -0700
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in
closures
In-Reply-To: <20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
References: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
<20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
Message-ID: <463290DA-0491-494F-9182-72684B00C068@alkaline-solutions.com>


> On Dec 4, 2015, at 10:36 AM, Joe Groff <jgroff at apple.com> wrote:
>
> Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:
>
> {
>   import func QuickSpecBuilder.expect
>
>   expect(sections).to(....)
> }

All of the matching methods (such as equal, contains, raiseError, raiseException) are also module functions, so you would likely just pull them all in. The Hamcrest Java project is very similar to Nimble, and they have a utility class generator (static methods calling other class static methods) specifically for reducing the number of static imports you have to put at the top of your test files.

The most common use of DSLs is to give an expressive grammar to builder patterns. The Ruby on Rails router has perhaps had more man hours put into it than any other DSL on the platform, and its primary purpose is to build
- a dispatch table to match and parse parameters out of incoming URLs, and stuff them into methods on controller instances
- a method (actually methods) for the reverse behavior of taking parameters and building the appropriate path, e.g. user_path(current_user)

These are often hierarchal via closures. The use of closures both allows specific context to be made available based on the outer configuration, and for the actual use of a function to be deferred until it is needed.

Another example would be a DSL providing inversion of control. This might define methods to resolve objects by name, with the closures defining the construction behavior. The closure would get as a parameter the context of the DSL lookup, to allow it to lazily retrieve its own dependencies. However, this can’t be the global reference to the DSL object, because you want to fail on circular dependencies. Instead, you get a state object representing the particular request which was made of the system.

Yet another example is Quick itself - the ‘it’ and ‘expect’ functions are inheriting the ‘describe’ to aid in better error reporting, as well as any per-test invocation behavior (such as clearing out an in-memory database). This state can be passed in as an object, captured in lexical scope by the nested closure, or (in these cases) set and modified globally as needed. My concern is in people using global state to get the expressiveness they desire for their APIs.

With Nimble in particular, expect has state which currently (because it is a global function) has to be globally defined. This state also can’t be thread local, as your actual tests might involve multiple threads or callbacks.

>
> Being able to elide self is already somewhat controversial, and a number of people find it makes code harder to read. I worry that allowing closures to change 'self' has the potential to be even more confusing. In Javascript, it's my understanding the ability to arbitrarily rebind 'this' is seen as a design flaw rather than a feature people regularly take advantage of.
>

Ruby has it as well, and while it perhaps a bit more ‘magic’ than some would desire, you will not find Ruby developers lamenting its existence. Javascript’s inconsistent historical behaviors greatly contribute to the perception that rebinding is a design flaw.

However, the behavior I’m describing is different than either Ruby or Javascript:
- both Ruby and Javascript are late bound, which allows the JIT implementations to adapt to whatever type instance is given. Swift is not a late bound language, so it must know the types it is working with beforehand
- Ruby and Javascript allow the caller to set self/this. The choice to consider one of the parameters to have ‘self’ behavior in my proposal is entirely in the hands of the person writing the block of code being called, by choosing to name one of the passed in parameters ‘self'
- Due to late binding, it may be very difficult to determine what type your self/this is bound to in Ruby/Javascript. This is explicit in the signature of the closure in my proposal.
- Ruby and Javascript have no visual indicator that a block of code may be called with some other object as self/this. This is explicit in my proposal by naming one of the parameters in your closure ‘self'
- Finally, as a side-effect you can choose to bind a parameter to self independent of the API designer if you feel that makes your code more readable. Admittedly, I removed my example as the code was simplistic enough that $0 was more concise

That said, as proposed this is an expressiveness feature. I proposed it because I found I was uncomfortable with the number of global functions and amount of global state I was seeing in Swift modules - but could not come up with a way to make said code more robust/safe without negatively affecting expressiveness.

-DW
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6d9610b7/attachment.html>

From matthew at anandabits.com  Fri Dec  4 15:45:12 2015
From: matthew at anandabits.com (Anandabits)
Date: Fri, 4 Dec 2015 15:45:12 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
Message-ID: <99D033BE-7C12-4538-B329-5D8C5E9F6A25@anandabits.com>

> I would also be in favor of something more generally applicable rather than making initialization more special.

Initialization is inherently special - it is the only opportunity to provide an value for immutable stored properties.  IMO that means an adequate solution *must* at least consider initialization in depth and must be able to facilitate initializing immutable stored properties (which method cascade would not be able to do).

Matthew

From crk at fastmail.com  Fri Dec  4 15:45:26 2015
From: crk at fastmail.com (crk at fastmail.com)
Date: Fri, 4 Dec 2015 15:45:26 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <FBE0B6D5-9FD9-433D-94B9-D8569A4BC2E7@ericasadun.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
<FBE0B6D5-9FD9-433D-94B9-D8569A4BC2E7@ericasadun.com>
Message-ID: <5dcbe526-ab03-41de-891c-55c496bf6af5@Spark>

Agreed, the
with variable {
statements
}
Format seems quite elegant and descriptive

Thanks for your time,
Cole Kurkowski

On Dec 4, 2015, 15:43 -0600, Erica Sadun<erica at ericasadun.com>, wrote:
> I really like both approaches, although I prefer the elegance of Sean's.
>
> -- E
>
>
> > On Dec 4, 2015, at 2:35 PM, Sean Heber<sean at fifthace.com(mailto:sean at fifthace.com)>wrote:
> > >
> > > On Dec 4, 2015, at 3:27 PM, Joe Groff<jgroff at apple.com(mailto:jgroff at apple.com)>wrote:
> > >
> > >
> > > > On Dec 4, 2015, at 1:24 PM, Erica Sadun<erica at ericasadun.com(mailto:erica at ericasadun.com)<mailto:erica at ericasadun.com>>wrote:
> > > >
> > > > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.Here's one example:
> > > >
> > > > let task = NSTask()
> > > > task.launchPath = "/usr/bin/mdfind"
> > > > task.arguments = ["kMDItemDisplayName == *.playground"]
> > > > task.standardOutput = pipe
> > > >
> > > > Here's another:
> > > >
> > > > let questionLabel = UILabel()
> > > > questionLabel.textAlignment = .Center
> > > > questionLabel.font =UIFont(name:"DnealianManuscript", size: 72)
> > > > questionLabel.text = currentQuestion.questionText
> > > > questionLabel.numberOfLines = 0
> > > >
> > > > You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:
> > > > This code feels unnecessarily redundant
> > > > This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.
> > > > The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.
> > > > Further, if you have many instances to set up there's no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.
> > > >
> > > > PROPOSED SOLUTION: What do you think about creating setup closuresthat modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:
> > > >
> > > > let task = NSTask()>>{
> > > > launchPath = "/usr/bin/mdfind"
> > > > arguments = ["kMDItemDisplayName == *.playground"]
> > > > standardOutput = pipe
> > > > }
> > > >
> > > > In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.
> > >
> > > In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same 'self'. In Dart they use '..' for this:
> > >
> > > let task = NSTask()
> > > ..launchPath = "..."
> > > ..arguments = [...]
> > > ..standardOutput = pipe
> > >
> > > The nice thing about that is that it's a bit more generally applicable than just initialization.
> > >
> > > -Joe
> >
> > I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
> >
> > with let task = NSTask() {
> > launchPath = "/usr/bin/mdfind"
> > arguments = ["kMDItemDisplayName == *.playground"]
> > standardOutput = pipe
> > }
> >
> > Also valid:
> >
> > with someVariable {
> > func1()
> > func2(“etc")
> > }
> >
> > Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).
> >
> > l8r
> > Sean
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/563287e6/attachment-0001.html>

From michel.fortin at michelf.ca  Fri Dec  4 15:51:42 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Fri, 4 Dec 2015 16:51:42 -0500
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
Message-ID: <33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>

Le 4 déc. 2015 à 16:35, Sean Heber <sean at fifthace.com> a écrit :

> I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
>
> with let task = NSTask() {
>   launchPath = "/usr/bin/mdfind"
>   arguments = ["kMDItemDisplayName == *.playground"]
>   standardOutput = pipe
> }
>
> Also valid:
>
> with someVariable {
>   func1()
>   func2(“etc")
> }
>
> Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).

The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:

let launchPath = "a.out"
let description = "blah blah"
with let task = NSTask() {
launchPath = launchPath // eh, what?
arguments = [launchPath, description] // is that task.description?
}

I think it's important that things referring to the "task" in the above example be syntactically distinguishable.

It can also lead to code breakage:

let path = "a.out"
with let task = NSTask() {
launchPath = path
}

That would work fine one day, but what if in the next OS release NSTask gets a new "path" property? That code breaks silently once you recompile with the newer SDK.


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From salutis at me.com  Fri Dec  4 15:51:48 2015
From: salutis at me.com (Rudolf Adamkovic)
Date: Fri, 04 Dec 2015 22:51:48 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
Message-ID: <8DE83A4A-14B6-472C-A320-8F336875E830@me.com>

+1

1) I actually encountered at least two bugs in my app introduced by this implicit "self" behavior. It can be dangerous and hard to track down.

2) Also when, say fine-tuning UIKit animations, I find myself wasting enormous amount of time adding and removing "self".

R+

Sent from my iPhone

> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com> wrote:
>
> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>
> Just as example, my proposition makes the following piece of code illegal:
>
> ```
> struct FooBar {
>    var foo: String = "foobar"
>
>    func bar() {
>        print(foo) // compiler error
>        print(self.foo) // compiler happy
>    }
>
>    func bar2() {
>        bar() // compiler error
>        self.bar() // compiler happy
>    }
> }
> ```
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From erica at ericasadun.com  Fri Dec  4 15:58:24 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Fri, 4 Dec 2015 14:58:24 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
<33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>
Message-ID: <ABC83921-C048-44B6-BB01-7129B8FB0A29@ericasadun.com>

I suspect this is an easy compiler catch requiring a forced self for disambiguation the same way as in init

-- E

> On Dec 4, 2015, at 2:51 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> Le 4 déc. 2015 à 16:35, Sean Heber <sean at fifthace.com> a écrit :
>
>> I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
>>
>> with let task = NSTask() {
>>  launchPath = "/usr/bin/mdfind"
>>  arguments = ["kMDItemDisplayName == *.playground"]
>>  standardOutput = pipe
>> }
>>
>> Also valid:
>>
>> with someVariable {
>>  func1()
>>  func2(“etc")
>> }
>>
>> Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).
>
> The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:
>
> 	let launchPath = "a.out"
> 	let description = "blah blah"
> 	with let task = NSTask() {
> 		launchPath = launchPath // eh, what?
> 		arguments = [launchPath, description] // is that task.description?
> 	}
>
> I think it's important that things referring to the "task" in the above example be syntactically distinguishable.
>
> It can also lead to code breakage:
>
> 	let path = "a.out"
> 	with let task = NSTask() {
> 		launchPath = path
> 	}
>
> That would work fine one day, but what if in the next OS release NSTask gets a new "path" property? That code breaks silently once you recompile with the newer SDK.
>
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From rayfix at gmail.com  Fri Dec  4 15:59:07 2015
From: rayfix at gmail.com (Ray Fix)
Date: Fri, 4 Dec 2015 13:59:07 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <94F08C46-27BC-44C5-ACFC-7A5F59DE0672@apple.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
<750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
<1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>
<6A63268A-BF21-491A-A974-3BD11A7B0AEB@ericasadun.com>
<94F08C46-27BC-44C5-ACFC-7A5F59DE0672@apple.com>
Message-ID: <85C3C754-B93B-4F27-80C5-B41E3A159303@gmail.com>

Hi Erica,

One argument that I don’t see being made in your proposal is that the while statement provides an equivalent, more verbose form of C-style for loops.

var i = 0
while (i < 10) {
print(i)
i += 1
}

I understand that one of the major goals of Swift is to be a language great to learn about computing.  Removing C-style loops doesn’t really diminished from this goal because the same thing can be taught with while.

Good luck,

Ray Fix

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2d8ede2e/attachment.html>

From sean at fifthace.com  Fri Dec  4 15:59:56 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 15:59:56 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
<33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>
Message-ID: <07F5EC38-760F-46EF-89D7-8A5748735B0F@fifthace.com>

Yeah, that thought occurred to me as I was writing it out. One possibility would be to limit what can go inside that block - perhaps all statements must be functions called on the value you are using in the with block? Or perhaps simply prefix them with a period? (Maybe looks too much like enum?)

with let task = NSTask() {
.launchPath = path
.arguments = []
.standardOutput = pipe
}

etc.

l8r
Sean

> On Dec 4, 2015, at 3:51 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> Le 4 déc. 2015 à 16:35, Sean Heber <sean at fifthace.com> a écrit :
>
>> I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
>>
>> with let task = NSTask() {
>>  launchPath = "/usr/bin/mdfind"
>>  arguments = ["kMDItemDisplayName == *.playground"]
>>  standardOutput = pipe
>> }
>>
>> Also valid:
>>
>> with someVariable {
>>  func1()
>>  func2(“etc")
>> }
>>
>> Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).
>
> The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:
>
> 	let launchPath = "a.out"
> 	let description = "blah blah"
> 	with let task = NSTask() {
> 		launchPath = launchPath // eh, what?
> 		arguments = [launchPath, description] // is that task.description?
> 	}
>
> I think it's important that things referring to the "task" in the above example be syntactically distinguishable.
>
> It can also lead to code breakage:
>
> 	let path = "a.out"
> 	with let task = NSTask() {
> 		launchPath = path
> 	}
>
> That would work fine one day, but what if in the next OS release NSTask gets a new "path" property? That code breaks silently once you recompile with the newer SDK.
>
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From dgregor at apple.com  Fri Dec  4 16:01:55 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Fri, 4 Dec 2015 14:01:55 -0800
Subject: [swift-evolution] Process question: breaking proposals for
API	changes to stdlib?
In-Reply-To: <380DE8CE-E29D-4D85-BDF5-2B4CAA7AD023@andymatuschak.org>
References: <380DE8CE-E29D-4D85-BDF5-2B4CAA7AD023@andymatuschak.org>
Message-ID: <EDFAFCDE-A1EB-4490-81AD-F8BE94D45590@apple.com>


> On Dec 4, 2015, at 1:09 PM, Andy Matuschak <andy at andymatuschak.org> wrote:
>
> Hello, all! Process question here: if I'd like to propose an API change in stdlib, should I do that here? Open a pull request?

The first step is to post your idea here!

The actual process is described long-windedly over at

https://github.com/apple/swift-evolution/blob/master/process.md

but the important part is:

How to propose a change

Socialize the idea: propose a rough sketch of the idea on the swift-evolution mailing list <https://swift.org/community/#swift-evolution>, the problems it solves, what the solution looks like, etc., to gauge interest from the community.
Develop the proposal: expand the rough sketch into a complete proposal, using the proposal template <https://github.com/apple/swift-evolution/blob/master/0000-template.md>, and continue to refine the proposal on the evolution mailing list. Prototyping an implementation and its uses along with the proposal is encouraged, because it helps ensure both technical feasibility of the proposal as well as validating that the proposal solves the problems it is meant to solve.
Request a review: initiate a pull request to the swift-evolution repository <https://github.com/apple/swift-evolution> to indicate to the core team that you would like the proposal to be reviewed. When the proposal is sufficiently detailed and clear, and addresses feedback from earlier discussions of the idea, the pull request will be accepted. The proposal will be assigned a proposal number as well as a core team member to manage the review.
Address feedback: in general, and especially during the review period <https://github.com/apple/swift-evolution/blob/master/schedule.md#review>, be responsive to questions and feedback about the proposal.

- Doug


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6c3fd914/attachment-0001.html>

From jalkut at red-sweater.com  Fri Dec  4 16:05:51 2015
From: jalkut at red-sweater.com (jalkut at red-sweater.com)
Date: Fri, 4 Dec 2015 17:05:51 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
Message-ID: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>

In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?

My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.

The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:

"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."

To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.

I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.

In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.

Thoughts?

Daniel


From daniel.j.stenmark at gmail.com  Fri Dec  4 16:06:17 2015
From: daniel.j.stenmark at gmail.com (Dan Stenmark)
Date: Fri, 4 Dec 2015 14:06:17 -0800
Subject: [swift-evolution] Proposal: Bridging for Swift Structs in
Objective-C
Message-ID: <99C67754-3AE5-4F28-9466-24700135B845@gmail.com>

Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.

@objc struct Letter {
var address : String?

init(withAddress address : String? ) {
self.address = address
}
}

At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.

Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’

With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.

@objc(US) struct Letter {
var address : String?

init(withAddress address : String? ) {
self.address = address
}
}

-------

USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’

Nested types would also be represented via this proposal:

@objc(US) class PostalService {
struct Letter {
var address : String?

init(withAddress address : String? ) {
self.address = address
}
}
}

-------

USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’
USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’

Dan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2c2e488b/attachment.html>

From erica at ericasadun.com  Fri Dec  4 16:12:40 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Fri, 4 Dec 2015 15:12:40 -0700
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
Message-ID: <AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>

Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.

True fact: On all of gist.github.com, there are only 22 gist results for "fallthrough language:swift".
Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
case .Enum1, .Enum2:
expressed as
case .Enum1: fallthrough
case .Enum2:

And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.




> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
>
> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>
> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>
> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>
> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>
> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>
> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>
> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>
> Thoughts?
>
> Daniel
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/588f3fe1/attachment.html>

From sean at fifthace.com  Fri Dec  4 16:14:02 2015
From: sean at fifthace.com (Sean Heber)
Date: Fri, 4 Dec 2015 16:14:02 -0600
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
Message-ID: <6AFB46F3-A288-4B8B-A541-8B08A7BBF0FA@fifthace.com>

I’ve always shied away from fallthrough no matter what language I’m using. Perhaps there are situations where it is required, but in spirit I agree it maybe should be removed.

I’d amend this to also prevent “break” from applying to switch statements so that they can break out of loops if you’ve nested a switch inside of a loop. I ran into this situation and spent entirely too long confused about why it didn’t break out like I thought it should have:

for thing in collection {
switch thing {
case .Special: break
default { … }
}
}

The reason I expected this to work is that I don’t need to use a “break” in Swift cases so it stood to reason this would mean the “break” statement would only apply to the loop. I was wrong. :P

l8r
Sean


> On Dec 4, 2015, at 4:05 PM, jalkut at red-sweater.com wrote:
>
> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>
> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>
> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>
> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>
> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>
> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>
> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>
> Thoughts?
>
> Daniel
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From greg at omnigroup.com  Fri Dec  4 16:16:24 2015
From: greg at omnigroup.com (Greg Titus)
Date: Fri, 4 Dec 2015 14:16:24 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
Message-ID: <8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>

Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.

> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>
> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
> case .Enum1, .Enum2:
> expressed as
> case .Enum1: fallthrough
> case .Enum2:
>
> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>
>
>
>
>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>
>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>
>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>
>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>
>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>
>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>
>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>
>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>
>> Thoughts?
>>
>> Daniel
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/554bca66/attachment.html>

From kevin at sb.org  Fri Dec  4 16:20:28 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 14:20:28 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <6AFB46F3-A288-4B8B-A541-8B08A7BBF0FA@fifthace.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<6AFB46F3-A288-4B8B-A541-8B08A7BBF0FA@fifthace.com>
Message-ID: <1449267628.2863797.458457033.2179D39A@webmail.messagingengine.com>

I don't use `fallthrough` very often, but when I do, it's extremely
useful. Removing it would make some of my code significantly harder to
read. In fact, I actually wish `fallthrough` was more powerful, allowing
me to fall into cases that bound identifiers if every bound identifier
was already bound with the same type in the current case, though I
understand why the language doesn't allow it (it's significant
complexity for a relatively minor gain).

Similarly, the ability to use `break` in switch statements, while not
something I use very often outside of using it for empty cases, is still
invaluable when I do occasionally need it. And since you can already
break out of loops by using a label, I don't see why we should remove
it. An example of doing that is

loop: for thing in collection {
switch thing {
case .Special: break loop
default: ...
}
}

-Kevin Ballard

On Fri, Dec 4, 2015, at 02:14 PM, Sean Heber wrote:
> I’ve always shied away from fallthrough no matter what language I’m
> using. Perhaps there are situations where it is required, but in spirit I
> agree it maybe should be removed.
>
> I’d amend this to also prevent “break” from applying to switch statements
> so that they can break out of loops if you’ve nested a switch inside of a
> loop. I ran into this situation and spent entirely too long confused
> about why it didn’t break out like I thought it should have:
>
> for thing in collection {
>   switch thing {
>   case .Special: break
>   default { … }
>   }
> }
>
> The reason I expected this to work is that I don’t need to use a “break”
> in Swift cases so it stood to reason this would mean the “break”
> statement would only apply to the loop. I was wrong. :P
>
> l8r
> Sean
>
>
> > On Dec 4, 2015, at 4:05 PM, jalkut at red-sweater.com wrote:
> >
> > In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
> >
> > My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
> >
> > The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
> >
> > "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
> >
> > To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
> >
> > I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
> >
> > In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
> >
> > Thoughts?
> >
> > Daniel
> >
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From rayfix at gmail.com  Fri Dec  4 16:20:44 2015
From: rayfix at gmail.com (Ray Fix)
Date: Fri, 4 Dec 2015 14:20:44 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
Message-ID: <1870FFFE-70C5-471D-8E3B-372966F90795@gmail.com>


> On Dec 4, 2015, at 2:16 PM, Greg Titus <greg at omnigroup.com> wrote:
>
> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.

Yes.  You beat me to it but I agree.  I think having fallthrough could be an important performance optimization as refactoring would either result in the overhead of a function call or replicated code.   I would also prefer to keep it in the toolbox.

Ray Fix
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6cef076a/attachment.html>

From michel.fortin at michelf.ca  Fri Dec  4 16:22:45 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Fri, 4 Dec 2015 17:22:45 -0500
Subject: [swift-evolution] Type-safe selectors
Message-ID: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>

Currently in Swift you can get a closure by referring to a method:

let x = NSString.hasPrefix
// x is of type NSString -> String -> Bool

Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you'd just have to refer to the method, and you know there's no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:

notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil)

This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.
https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md

But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:

@convention(selector) AnyObject -> NSNotification -> Void

Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You

Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:

@objc func callSelector(selector: @convention(selector) NSString -> String -> Bool) -> Bool {
let str = NSString(string: "hello")
return selector(str)("hell")
}

let x = NSString.hasPrefix
// x is of type @convention(selector) NSString -> String -> Bool
callSelector(x)

So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.

- - -

This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:

1. I wanted to preserve D's type-safety while still being able to use selectors, and
2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.

For reference, here is the meager documentation for that feature:
https://michelf.ca/projects/d-objc/syntax/#selector-literals
And for the selector-name mangling:
https://michelf.ca/projects/d-objc/syntax/#generated-selectors


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From rayfix at gmail.com  Fri Dec  4 16:25:33 2015
From: rayfix at gmail.com (Ray Fix)
Date: Fri, 4 Dec 2015 14:25:33 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <1870FFFE-70C5-471D-8E3B-372966F90795@gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1870FFFE-70C5-471D-8E3B-372966F90795@gmail.com>
Message-ID: <659095B1-42D2-4F28-B498-329BEBC7934C@gmail.com>


> On Dec 4, 2015, at 2:20 PM, Ray Fix <rayfix at gmail.com> wrote:
>
>
>> On Dec 4, 2015, at 2:16 PM, Greg Titus <greg at omnigroup.com <mailto:greg at omnigroup.com>> wrote:
>>
>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>
> Yes.  You beat me to it but I agree.  I think having fallthrough could be an important performance optimization as refactoring would either result in the overhead of a function call or replicated code.   I would also prefer to keep it in the toolbox.
>

I should have mentioned that 99% of the time the overhead of a function call doesn’t matter, but when it does… it is great to have.

Ray Fix


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8a4fcf9f/attachment-0001.html>

From alex at alexwlchan.net  Fri Dec  4 16:26:24 2015
From: alex at alexwlchan.net (Alex Chan)
Date: Fri, 04 Dec 2015 22:26:24 +0000
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <85C3C754-B93B-4F27-80C5-B41E3A159303@gmail.com>
References: <D39BA312-67AA-4A50-8C4C-0634F89EE809@ericasadun.com>
<75CAED33-7A35-4BCD-9E83-952E961EDA18@apple.com>
<20151203234343.GB723@bryant.sfhq.lyft.internal>
<C1103871-84B2-4A7A-89DA-D38D254E5351@andymatuschak.org>
<317D1285-35F5-434F-AEEB-9F20862A0B86@arctouch.com>
<1449190365.2821157.457577745.74F54430@webmail.messagingengine.com>
<2E3D66B6-99BE-4E3F-AD66-CC9A6DB00D90@fifthace.com>
<750D25AE-56CA-4FF7-917E-0CE3D3F2B252@me.com>
<1449208937.1392214.457745537.3AF82688@webmail.messagingengine.com>
<6A63268A-BF21-491A-A974-3BD11A7B0AEB@ericasadun.com>
<94F08C46-27BC-44C5-ACFC-7A5F59DE0672@apple.com>
<85C3C754-B93B-4F27-80C5-B41E3A159303@gmail.com>
Message-ID: <1449267984.805408.458456625.09EFBA8C@webmail.messagingengine.com>

Hi Erica,

I was a bit surprised that safety wasn't among the disadvantages of for
loops.

For loops make it easy to mess up the bounds of an array.  You can miss
items at either end, or inadvertently read beyond the end.  For example:

for var i = 0; i <= bar.count; i++ {
print("The \(i)th element in bar is \(bar[i]).")
    }

There are similar mistakes where you can miss an element of an array at
either end.  I'm struggling to imagine how you could make the same
mistakes with for-in loops.

Perhaps only a minor benefit, but I still think it adds to the case in
favour.

— Alex



PS If I try to run the snippet above in a Playground in Xcode 7.1.1, the
compiler error is fairly unhelpful:

> Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0).

From rjmccall at apple.com  Fri Dec  4 16:26:49 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 14:26:49 -0800
Subject: [swift-evolution] Proposal: Automatic Wrapper Synthesis /
"deriving"
In-Reply-To: <12DD7FBE-CA6D-4667-A854-9F0FE492A883@icloud.com>
References: <12DD7FBE-CA6D-4667-A854-9F0FE492A883@icloud.com>
Message-ID: <B591D5C1-3E01-4724-B1D7-67F9AE3A2EA5@apple.com>

> On Dec 4, 2015, at 1:19 PM, plx <plxswift at icloud.com> wrote:
> # A `wrapper` / `deriving` Construct
>
> I'm sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.
>
> The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.
>
> ## Design Sketch
>
> It ought to be possible to write something like this:
>
>    // an example:
>    struct SectionIndex
>      wrapping Int
>      as index
>      satisfying precondition { $0 >= 0 }
>      deriving Equatable, Comparable, Hashable {
>      // declaration can continue in here
>    }
>
> ...which, when compiled, would be "expanded" along these lines:
>
>    struct SectionIndex {
>
>      // would have been `wrappedValue` w/out the `as index` clause
>      let index: Int
>
>      init(_ index: Int) {
>        precondition(index >= 0)
>        // ^ would have been assert(index >= 0)
>        //   had we used `satisfying { $0 >= 0 }`,
>        //   and omitted entirely had we omitted a `satisfying` clause
>        self.index = index
>      }
>
>    }
>
>    extension SectionIndex : Equatable {
>    }
>
>    // synthesized unless explicitly written-out
>    func ==(lhs: SectionIndex, rhs: SectionIndex) -> Bool {
>      return lhs.index == rhs.index
>    }
>
>    // same for Comparable, Hashable, all done in the obvious way
>
>    // there’s a lot of utility in synthesizing something like this,
>    //  I can expand on it if necessary:
>    extension SectionIndex: ValueWrapperType {
>      typealias WrappedType = Int
>    }
>
> ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols' typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.
>
> I think this enough to sketch the way the feature would look and how it would work.

I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.

I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.

For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).

John.

From jgroff at apple.com  Fri Dec  4 16:26:56 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 14:26:56 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
Message-ID: <2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>


> On Dec 4, 2015, at 2:22 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> Currently in Swift you can get a closure by referring to a method:
>
> 	let x = NSString.hasPrefix
> 	// x is of type NSString -> String -> Bool
>
> Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you'd just have to refer to the method, and you know there's no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:
>
> 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil)
>
> This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.
> https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md
>
> But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:
>
> 	@convention(selector) AnyObject -> NSNotification -> Void
>
> Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You

This is a great approach, and it's mostly exactly what I've had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.

>
> Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:
>
> 	@objc func callSelector(selector: @convention(selector) NSString -> String -> Bool) -> Bool {
> 		let str = NSString(string: "hello")
> 		return selector(str)("hell")
> 	}
>
> 	let x = NSString.hasPrefix
> 	// x is of type @convention(selector) NSString -> String -> Bool
> 	callSelector(x)
>
> So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.

I would say that 'let x = NSString.hasPrefix' should still give you a @convention(swift) function value by default; that's what we do with method references in general, but you could ask for a @convention(selector) reference explicitly:

let x: @convention(selector) X -> Y -> Z = X.hasPrefix

-Joe

> - - -
>
> This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:
>
> 1. I wanted to preserve D's type-safety while still being able to use selectors, and
> 2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.
>
> For reference, here is the meager documentation for that feature:
> https://michelf.ca/projects/d-objc/syntax/#selector-literals
> And for the selector-name mangling:
> https://michelf.ca/projects/d-objc/syntax/#generated-selectors
>
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From jgroff at apple.com  Fri Dec  4 16:31:59 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 14:31:59 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
Message-ID: <3A6FBE86-45CB-4D85-9255-1CF3138282A6@apple.com>


> On Dec 4, 2015, at 2:26 PM, Joe Groff <jgroff at apple.com> wrote:
>
>>
>> On Dec 4, 2015, at 2:22 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>>
>> Currently in Swift you can get a closure by referring to a method:
>>
>> 	let x = NSString.hasPrefix
>> 	// x is of type NSString -> String -> Bool
>>
>> Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you'd just have to refer to the method, and you know there's no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:
>>
>> 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil)
>>
>> This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.
>> https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md
>>
>> But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:
>>
>> 	@convention(selector) AnyObject -> NSNotification -> Void
>>
>> Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You
>
> This is a great approach, and it's mostly exactly what I've had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.
>
>>
>> Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:
>>
>> 	@objc func callSelector(selector: @convention(selector) NSString -> String -> Bool) -> Bool {
>> 		let str = NSString(string: "hello")
>> 		return selector(str)("hell")
>> 	}
>>
>> 	let x = NSString.hasPrefix
>> 	// x is of type @convention(selector) NSString -> String -> Bool
>> 	callSelector(x)
>>
>> So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.
>
> I would say that 'let x = NSString.hasPrefix' should still give you a @convention(swift) function value by default; that's what we do with method references in general, but you could ask for a @convention(selector) reference explicitly:
>
> let x: @convention(selector) X -> Y -> Z = X.hasPrefix

One wrinkle you need to consider is the different ARC behavior of method families. @convention(selector) would have to be restricted to referencing methods that don't belong to an usual method family or have unusual ownership rules, or else we'd need multiple @convention(init_selector), (copy_selector), (alloc_selector) etc. conventions.

-Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/82063808/attachment-0001.html>

From erica at ericasadun.com  Fri Dec  4 16:33:27 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Fri, 4 Dec 2015 15:33:27 -0700
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <659095B1-42D2-4F28-B498-329BEBC7934C@gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1870FFFE-70C5-471D-8E3B-372966F90795@gmail.com>
<659095B1-42D2-4F28-B498-329BEBC7934C@gmail.com>
Message-ID: <1EC3FF58-5DCC-47FC-9B31-9DF1E2593354@ericasadun.com>

I courteously remove my objections.

-- E


> On Dec 4, 2015, at 3:25 PM, Ray Fix <rayfix at gmail.com> wrote:
>
>
>> On Dec 4, 2015, at 2:20 PM, Ray Fix <rayfix at gmail.com <mailto:rayfix at gmail.com>> wrote:
>>
>>
>>> On Dec 4, 2015, at 2:16 PM, Greg Titus <greg at omnigroup.com <mailto:greg at omnigroup.com>> wrote:
>>>
>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>
>> Yes.  You beat me to it but I agree.  I think having fallthrough could be an important performance optimization as refactoring would either result in the overhead of a function call or replicated code.   I would also prefer to keep it in the toolbox.
>>
>
> I should have mentioned that 99% of the time the overhead of a function call doesn’t matter, but when it does… it is great to have.
>
> Ray Fix
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/5929967c/attachment.html>

From rjmccall at apple.com  Fri Dec  4 16:33:36 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 14:33:36 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <3A6FBE86-45CB-4D85-9255-1CF3138282A6@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<3A6FBE86-45CB-4D85-9255-1CF3138282A6@apple.com>
Message-ID: <6A12497D-5FF5-4B06-98CD-325B10A8E6C7@apple.com>

> On Dec 4, 2015, at 2:31 PM, Joe Groff <jgroff at apple.com> wrote:
>> On Dec 4, 2015, at 2:26 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>
>>>
>>> On Dec 4, 2015, at 2:22 PM, Michel Fortin <michel.fortin at michelf.ca <mailto:michel.fortin at michelf.ca>> wrote:
>>>
>>> Currently in Swift you can get a closure by referring to a method:
>>>
>>> 	let x = NSString.hasPrefix
>>> 	// x is of type NSString -> String -> Bool
>>>
>>> Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you'd just have to refer to the method, and you know there's no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:
>>>
>>> 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil)
>>>
>>> This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.
>>> https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md <https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md>
>>>
>>> But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:
>>>
>>> 	@convention(selector) AnyObject -> NSNotification -> Void
>>>
>>> Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You
>>
>> This is a great approach, and it's mostly exactly what I've had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.
>>
>>>
>>> Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:
>>>
>>> 	@objc func callSelector(selector: @convention(selector) NSString -> String -> Bool) -> Bool {
>>> 		let str = NSString(string: "hello")
>>> 		return selector(str)("hell")
>>> 	}
>>>
>>> 	let x = NSString.hasPrefix
>>> 	// x is of type @convention(selector) NSString -> String -> Bool
>>> 	callSelector(x)
>>>
>>> So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.
>>
>> I would say that 'let x = NSString.hasPrefix' should still give you a @convention(swift) function value by default; that's what we do with method references in general, but you could ask for a @convention(selector) reference explicitly:
>>
>> let x: @convention(selector) X -> Y -> Z = X.hasPrefix
>
> One wrinkle you need to consider is the different ARC behavior of method families. @convention(selector) would have to be restricted to referencing methods that don't belong to an usual method family or have unusual ownership rules, or else we'd need multiple @convention(init_selector), (copy_selector), (alloc_selector) etc. conventions.

Or, alternatively, encode that information in the type, which would be necessary for full ObjC fidelity anyway, since ObjC ARC allows you to override conventions with attributes.

The flip side is that, of course, that’s quite a bit more complicated.

John.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a1f6873c/attachment.html>

From kevin at sb.org  Fri Dec  4 16:33:47 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 14:33:47 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
Message-ID: <1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>

It's  not actually Duff's Device. Duff's Device relies on the fact that
C switch statements don't actually introduce a new scope, and so it
overlaps a switch with a do-while loop. This lets it only test the
number of bytes once, to jump into the middle of the loop, and then it
switches over to a while loop that decrements a counter every 8
instructions. Basically, it's a trick for manual loop unrolling that
deals with non-multiple-of-8 counts efficiently.

Steve's code is also an example of manual loop unrolling that deals with
non-multiple-of-8 counts, but it has calculate the number of bytes on
every iteration instead of once. It's a good example of one of the uses
of `fallthrough`, it's just not Duff's Device. It's impossible to use
Duff's Device in Swift.

-Kevin Ballard

On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
> Streza’s source code is an example of Duff’s Device, which is a big
> place where switch fallthrough is arguably the cleanest way to do
> things and the reason why I’d personally prefer to keep it as part of
> the language.
>
>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>
>> Oh let it die, let it die. Any time I use fallthrough I find myself
>> re-factoring to stop using it.
>>
>> *True fact*: On all of gist.github.com[1], there are only 22 gist
>> results for "fallthrough language:swift". Half of those are people
>> just testing out the feature. Most of the remaining ones are just
>> complex cases: *case .Enum1, .Enum2:* expressed as *case .Enum1:
>> fallthrough* *case .Enum2:*
>>
>> And then there's streza:
>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty
>> sure that ponies were harmed in the production of whatever that last
>> bit is.
>>
>>
>>
>>
>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
>>>
>>> In the spirit of some other proposals that remove C or C++ style
>>> artifacts, what do folks think about the possibility of removing the
>>> "fallthrough" keyword from the language?
>>>
>>> My understanding is this keyword is only used for the archaic
>>> seeming purpose of perpetuating C-style fallthrough from one switch
>>> statement to the subsequent one. The documentation hedges the use of
>>> this keyword in forbidding terms that make it clear its use is not
>>> encouraged. The presence of the keyword, while an improvement over
>>> C’s implicit fallthrough, is a mark of inelegance on an otherwise
>>> well-designed, opinionated implementation of swtich statements.
>>>
>>> The ugliness of fallthrough’s C-style behavior even demands a caveat
>>> in the documentation:
>>>
>>> "The fallthrough keyword does not check the case conditions for the
>>> switch case that it causes execution to fall into. The fallthrough
>>> keyword simply causes code execution to move directly to the
>>> statements inside the next case (or default case) block, as in C’s
>>> standard switch statement behavior."
>>>
>>> To my mind, the caveat explains just what is wrong with fallthrough,
>>> both in C or Swift: coded that is clearly labeled with deliberate
>>> conditions can nonetheless be reached.
>>>
>>> I quipped about this on Twitter, and the most common pushback I got
>>> seemed to be from people who either did not know about Swift’s
>>> support for comma-separated case statements, or harbored an
>>> aesthetic preference for clustering such cases together with
>>> fallthrough statements.
>>>
>>> In my opinion, unless somebody can think of a strong defense for
>>> supporting intentional fallthrough in Swift, removing the keyword
>>> would be a move in the direction of minimizing the language’s
>>> complexity while also discouraging poor coding style in switch
>>> statements.
>>>
>>> Thoughts?
>>>
>>> Daniel
>>>
>>> _______________________________________________
>>> swift-evolution mailing list swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution



Links:

1. http://gist.github.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b34cc62d/attachment-0001.html>

From colin.cornaby at mac.com  Fri Dec  4 16:33:56 2015
From: colin.cornaby at mac.com (Colin Cornaby)
Date: Fri, 04 Dec 2015 22:33:56 +0000 (GMT)
Subject: [swift-evolution] C-style For Loops
Message-ID: <d30ab130-3f93-45de-9a10-e64c70aa03d3@me.com>

I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...

It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.

We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.

But if it's actively hurting some other part of the language we could probably be talked into it.

On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com> wrote:

Does Swift still needs C-style for loops with conditions and incrementers?



More Swift-like construction is already available with for-in-statements and stride.
This would naturally starve the most common point for -- and ++ operators as well.

-- E

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/129946cd/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Screen Shot 2015-12-03 at 4.30.15 PM.png
Type: image/png
Size: 27490 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/129946cd/attachment-0001.png>

From salutis at me.com  Fri Dec  4 16:34:38 2015
From: salutis at me.com (=?utf-8?Q?Rudolf_Adamkovi=C4=8D?=)
Date: Fri, 04 Dec 2015 23:34:38 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
Message-ID: <2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>

To be a little more specific, here’s a real-world example:

1. Say there’s a method in my class that contains a local variable called “title”.
2. After a while, I decide to remove a part of this method, including the “title” variable.
3. Everything compiles and seems to work just fine.
4. However, I forgot to remove one more line that used the “title” variable.
5. Because we’re in a UIViewController subclass, I'm unknowingly modifying view controller’s title.

R+

> On 4 Dec 2015, at 22:51, Rudolf Adamkovic <salutis at me.com> wrote:
>
> +1
>
> 1) I actually encountered at least two bugs in my app introduced by this implicit "self" behavior. It can be dangerous and hard to track down.
>
> 2) Also when, say fine-tuning UIKit animations, I find myself wasting enormous amount of time adding and removing "self".
>
> R+
>
> Sent from my iPhone
>
>> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com> wrote:
>>
>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>
>> Just as example, my proposition makes the following piece of code illegal:
>>
>> ```
>> struct FooBar {
>>   var foo: String = "foobar"
>>
>>   func bar() {
>>       print(foo) // compiler error
>>       print(self.foo) // compiler happy
>>   }
>>
>>   func bar2() {
>>       bar() // compiler error
>>       self.bar() // compiler happy
>>   }
>> }
>> ```
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From stephen.celis at gmail.com  Fri Dec  4 16:35:12 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Fri, 4 Dec 2015 17:35:12 -0500
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in
closures
In-Reply-To: <463290DA-0491-494F-9182-72684B00C068@alkaline-solutions.com>
References: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
<20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
<463290DA-0491-494F-9182-72684B00C068@alkaline-solutions.com>
Message-ID: <CAN9tzpD=1N-11tC0L2DO16FipeTedWdu5euuK-EVkd-3-vVRng@mail.gmail.com>

On Fri, Dec 4, 2015 at 4:44 PM, David Waite <david at alkaline-solutions.com>
wrote:

>
> All of the matching methods (such as equal, contains, raiseError,
> raiseException) are also module functions, so you would likely just pull
> them all in. The Hamcrest Java project is very similar to Nimble, and they
> have a utility class generator (static methods calling other class static
> methods) specifically for reducing the number of static imports you have to
> put at the top of your test files.
>

They don't need to be, though. Protocol extensions offer an improved way of
handling this. I put together a proof-of-concept PR a short while ago:

https://github.com/Quick/Nimble/pull/218


> Ruby has it as well, and while it perhaps a bit more ‘magic’ than some
> would desire, you will not find Ruby developers lamenting its existence.
> Javascript’s inconsistent historical behaviors greatly contribute to the
> perception that rebinding is a design flaw.
>

The Ruby community in the past has been somewhat divided on the use of
instance_eval/exec vs. yielding block arguments for clarity, though there
are many popular DSL-like libraries that take advantage of
instance_eval/exec and are expressive and easy to read at the cost of
opaqueness.


> However, the behavior I’m describing is different than either Ruby or
> Javascript:
> - both Ruby and Javascript are late bound, which allows the JIT
> implementations to adapt to whatever type instance is given. Swift is not a
> late bound language, so it must know the types it is working with beforehand
> ...
>

Perhaps a bracketed annotation could assign an unbound type to a closure:

let builder: [MyType] () -> Void = { ... }
builder.bind(instance)() // or builder[instance](), or some other syntax

I agree that such a mechanism would allow for very expressive, type-safe
APIs. IDEs could take the guesswork out of "what is 'self'?". At the same
time, I understand apprehensions and aversions to both the complexity and
ambiguities associated with such a feature, and they may go against Swift's
principles at the moment.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/881363e1/attachment.html>

From griotspeak at gmail.com  Fri Dec  4 16:35:32 2015
From: griotspeak at gmail.com (T.J. Usiyan)
Date: Fri, 4 Dec 2015 23:35:32 +0100
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
Message-ID: <CAGJeWTqiE_RWbprxBOx8TXybCscTBaHYzk51cCtWdtf_DVzG=g@mail.gmail.com>

I concur and I think that there is should be more to this idea. I, at
least, would want partial specialization as part of this.  Consider Either
and Result:

`enum Either {
case .Left
case .Right
}

typealias Result<SuccessValue> = Either<NSError, SuccessValue>`

How (can I?) specify just one of the types or, possibly, constrain the left
side so as to avoid the need to provide a concrete type "NSError" there?

This next bit is probably another proposal. Assuming that that gets sorted
out, it would be useful to alias methods, properties, cases, etc for the
new name. `<Some keyword> case Result.Success = case Either.Left`

TJ

On Fri, Dec 4, 2015 at 12:04 PM, Dapeng Gao <gdapeng at icloud.com> wrote:

> It would be handy if Swift can support generic `typealias`s, which would
> probably look like this:
>
> typealias Handler<Element> = [Element] -> Void
>
> One common way to achieve this is to define a generic `struct` and use a
> nested `typealias`:
>
> struct HandlerWrapper<Element> {
>     typealias Hander = [Element] -> Void
> }
>
> HandlerWrapper<SomeType>.Hander
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/facbbe0e/attachment.html>

From jgroff at apple.com  Fri Dec  4 16:37:43 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 14:37:43 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <d30ab130-3f93-45de-9a10-e64c70aa03d3@me.com>
References: <d30ab130-3f93-45de-9a10-e64c70aa03d3@me.com>
Message-ID: <1392D64D-1048-44E3-B7AA-3A0B008012ED@apple.com>

You might ease the pain by approximating C-style 'for' by a higher-order function:

func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
// left as an exercise
}

var i = 0
cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
print(i)
}

-Joe

> On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>
> I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...
>
> It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.
>
> We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.
>
> But if it's actively hurting some other part of the language we could probably be talked into it.
>
> On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
>> Does Swift still needs C-style for loops with conditions and incrementers?
>>
>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>
>> More Swift-like construction is already available with for-in-statements and stride.
>> This would naturally starve the most common point for -- and ++ operators as well.
>>
>> -- E
>>
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/5603a92b/attachment-0001.html>

From oisin.kidney at gmail.com  Fri Dec  4 16:38:44 2015
From: oisin.kidney at gmail.com (=?utf-8?Q?Donnacha_Ois=C3=ADn_Kidney?=)
Date: Fri, 4 Dec 2015 22:38:44 +0000
Subject: [swift-evolution] Lazy flatMap for Optionals
Message-ID: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>

Currently, several of the methods on SequenceType in the standard library have lazy variants. flatMap, though, (seems) to have a version missing: while there’s a lazy version for nested sequences, there’s no lazy version for sequences of Optionals. Is there maybe a reason for this that I haven’t thought of? At any rate, here’s what I had in mind:

public struct FlatMapOptionalGenerator<G: GeneratorType, Element>: GeneratorType {
private let f: G.Element -> Element?
private var g: G
public mutating func next() -> Element? {
while let x = g.next() {
if let y = f(x) {
return y
}
}
return nil
}
}

public struct FlatMapOptionalSequence<S: LazySequenceType, Element>: LazySequenceType {
private let f: S.Generator.Element -> Element?
private let s: S
public func generate() -> FlatMapOptionalGenerator<S.Generator, Element> {
return FlatMapOptionalGenerator(f: f, g: s.generate())
}
}

extension LazySequenceType {
public func flatMap<T>(transform: Generator.Element -> T?) -> FlatMapOptionalSequence<Self, T> {
return FlatMapOptionalSequence(f: transform, s: self)
}
}

Does this seem like a good idea?

Oisin.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/80612439/attachment.html>

From brent at architechies.com  Fri Dec  4 16:40:10 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 14:40:10 -0800
Subject: [swift-evolution] Failable arithmetic
Message-ID: <81F08B04-0675-442A-A35B-C3DDFBA35E4F@architechies.com>

Currently, Swift has three ways to handle potential overflows and other errors in arithmetic:

// 1: Crashes
Int.max + 1

// 2: Returns the wrong answer (Int.min in this case)
Int.max &+ 1

// 3: Returns a tuple with the value of &+ and a boolean indicating whether it overflowed
Int.addWithOverflow(Int.max, 1)

The problem is, if you want to handle overflows in some simple way, none of these are very good. 1 terminates your app, 2 gives the wrong answer, and 3 is very awkward to use. If you’re, for instance, working with numbers input by the user or downloaded from the Internet, you don’t want 1 or 2, and 3 is a major pain. You’re not looking to figure out exactly what went wrong; you just want to show the user “Arithmetic error” or something, rather than crashing or giving a wildly incorrect answer.

Therefore, I propose that we add failable arithmetic operators (e.g. +?). These return nil on overflow and the result on non-overflow.

1 +? 1			// => Optional(1)
Int.max +? 1		// => nil

1 -? 1			// => Optional(0)
Int.min -? 1		// => nil

1 /? 1			// => Optional(1)
1 /? 0			// => nil

One important consideration is that you ought to be able to chain such operations together into expressions like "m *? x +? c”. The simplest way to do this would be to make these operators take optional arguments; then the implementations would all look something like this:

func +? <Integer: IntegerArithmeticType>(lhs: Integer?, rhs: Integer?) -> Integer? {
guard let lhs = lhs, rhs = rhs else {
return nil
}

let (result, overflowed) = Integer.addWithOverflow(lhs, rhs)
if overflowed {
return nil
}
else {
return result
}
}

However, that might encourage people to misuse these operators to simply perform arithmetic on optional integers even when they don’t want nil-on-overflow. There may be some clever way to get these operators to allow chaining from other failable operators, but prevent the use of other nil-returning expressions; I’m not sure how that would be done, but I wouldn’t mind if Swift forced that sort of hygiene on this feature.

An alternative approach might be to write throwing variants of these operators which require the use of “try". These would have a few advantages: they would naturally short-circuit, they wouldn’t form an attractive nuisance for people trying to do arithmetic with optional integers, and the errors they throw could provide additional detail. However, unlike the association of Optional with ?, there’s no obvious way to associate these operators with the idea of trying and throwing. For this example, I’ve used “+!” purely for lack of a better idea:

do {
print(try 1 +! 2 +! Int.max)
}
catch let error as IntegerArithmeticError {	// or perhaps IntegerArithmeticError<Int>
print(error)		// AdditionOverflow, or perhaps even AdditionOverflow(3, 9223372036854775807)
}

Of course, if you really did just want an optional, you could always use “try?” with this.

--
Brent Royal-Gordon
Architechies


From stephen.celis at gmail.com  Fri Dec  4 16:41:11 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Fri, 4 Dec 2015 17:41:11 -0500
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
Message-ID: <CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>

Are there warnings/diagnostics that could call out when local variables
shadow properties? I generally like that `self` is optional and prefer
limiting its use to explicitly call out potential retain cycles. Xcode also
makes it easy to introspect variable scope, though Xcode is less of a
requirement these days...

On Fri, Dec 4, 2015 at 5:34 PM, Rudolf Adamkovič <salutis at me.com> wrote:

> To be a little more specific, here’s a real-world example:
>
> 1. Say there’s a method in my class that contains a local variable called
> “title”.
> 2. After a while, I decide to remove a part of this method, including the
> “title” variable.
> 3. Everything compiles and seems to work just fine.
> 4. However, I forgot to remove one more line that used the “title”
> variable.
> 5. Because we’re in a UIViewController subclass, I'm unknowingly modifying
> view controller’s title.
>
> R+
>
> > On 4 Dec 2015, at 22:51, Rudolf Adamkovic <salutis at me.com> wrote:
> >
> > +1
> >
> > 1) I actually encountered at least two bugs in my app introduced by this
> implicit "self" behavior. It can be dangerous and hard to track down.
> >
> > 2) Also when, say fine-tuning UIKit animations, I find myself wasting
> enormous amount of time adding and removing "self".
> >
> > R+
> >
> > Sent from my iPhone
> >
> >> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com> wrote:
> >>
> >> I don't understand the reasoning behind removing the need to access
> instance properties and functions using self. Swift has always seemed to
> prefer readability to brevity and the feature makes the distinction between
> local and instance variables/functions crystal clear. Any good reason I
> shouldn't go on with the proposition?
> >>
> >> Just as example, my proposition makes the following piece of code
> illegal:
> >>
> >> ```
> >> struct FooBar {
> >>   var foo: String = "foobar"
> >>
> >>   func bar() {
> >>       print(foo) // compiler error
> >>       print(self.foo) // compiler happy
> >>   }
> >>
> >>   func bar2() {
> >>       bar() // compiler error
> >>       self.bar() // compiler happy
> >>   }
> >> }
> >> ```
> >> _______________________________________________
> >> swift-evolution mailing list
> >> swift-evolution at swift.org
> >> https://lists.swift.org/mailman/listinfo/swift-evolution
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/53518aba/attachment-0001.html>

From rjmccall at apple.com  Fri Dec  4 16:42:26 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 14:42:26 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
Message-ID: <02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>

> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:
> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.

To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.

But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.

John.

>
> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>
> -Kevin Ballard
>
> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>
>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>
>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>
>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>> case .Enum1, .Enum2:
>>> expressed as
>>> case .Enum1: fallthrough
>>> case .Enum2:
>>>
>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>
>>>
>>>
>>>
>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>
>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>
>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>
>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>
>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>
>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>
>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>
>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>
>>>> Thoughts?
>>>>
>>>> Daniel
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8ccfb740/attachment.html>

From kevin at sb.org  Fri Dec  4 16:51:47 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 14:51:47 -0800
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in
closures
In-Reply-To: <20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
References: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
<20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
Message-ID: <1449269507.2870902.458470841.617B34D2@webmail.messagingengine.com>

On Fri, Dec 4, 2015, at 09:36 AM, Joe Groff wrote:
> Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:
>
> {  import func QuickSpecBuilder.expect
>
> expect(sections).to(....) }
>
> Being able to elide self is already somewhat controversial, and a
> number of people find it makes code harder to read. I worry that
> allowing closures to change 'self' has the potential to be even more
> confusing. In Javascript, it's my understanding the ability to
> arbitrarily rebind 'this' is seen as a design flaw rather than a
> feature people regularly take advantage of.

I like this idea. I'm very much against rebinding `self` because it
seems like an excellent source for confusion. Not only that, but the
actual underlying desire here isn't to remove `self` at all, but just to
introduce new functions into function resolution within a scope. And
this is precisely what adding imports in arbitrary scopes does (the only
downside being you need a line of code to add them, but that's not a big
deal). I know Rust allows this and it's pretty handy. I'd love to have
this feature even when not using a DSL.

-Kevin Ballard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/506870b4/attachment.html>

From jj at johanjensen.dk  Fri Dec  4 16:52:38 2015
From: jj at johanjensen.dk (Johan Jensen)
Date: Fri, 4 Dec 2015 23:52:38 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <1392D64D-1048-44E3-B7AA-3A0B008012ED@apple.com>
References: <d30ab130-3f93-45de-9a10-e64c70aa03d3@me.com>
<1392D64D-1048-44E3-B7AA-3A0B008012ED@apple.com>
Message-ID: <CAB8TY2MvkBr_vmzh-FWp8KaCjKHxPcObfa9efWRn1HgX7QbB7Q@mail.gmail.com>

With the removal of post/pre-increment/decrement you might as well
translate C-style for-loops to something akin to

for var i in 0..<10 {
...
}

If more advanced C-style for-loops are needed, I am sure most developers
can use a while-loop (as mentioned by Ray Fix) until they get accustomed to
Swift’s syntax.

On Fri, Dec 4, 2015 at 11:37 PM, Joe Groff <jgroff at apple.com> wrote:

> You might ease the pain by approximating C-style 'for' by a higher-order
> function:
>
> func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test:
> () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
>   // left as an exercise
> }
>
> var i = 0
> cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
>   print(i)
> }
>
> -Joe
>
> On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>
> I was talking with people in the office about this proposal today, in
> since there has been such a long discussion already I'll just reply to the
> top of the tree just to get our take in before the review...
>
> It's understood that Swift has better, more readable ways to do for loops,
> but C style for loops reduce friction for getting our C or C++ developers
> on board with Swift. Unless there is a gain elsewhere to be made in their
> removal, it would be nice to keep them. As we transition to Swift we can
> educate developers on better ways to iterate, but it would be nice to have
> one less thing in the way of getting people writing Swift code.
>
> We work on a lot of algorithmic code which would be well suited for Swift.
> And again, I understand that C style for loops are redundant. But it's just
> one less speed bump in understanding for some of our developers or for
> porting pure C or C++ code without having to do as much re-validation of
> algorithms for accidental changes.
>
> But if it's actively hurting some other part of the language we could
> probably be talked into it.
>
> On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
> Does Swift still needs C-style for loops with conditions and incrementers?
>
> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>
> More Swift-like construction is already available with *for-in*-statements
> and *stride*.
> This would naturally starve the most common point for -- and ++ operators
> as well.
>
> -- E
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a787ad7a/attachment-0001.html>

From david at alkaline-solutions.com  Fri Dec  4 16:55:52 2015
From: david at alkaline-solutions.com (David Waite)
Date: Fri, 4 Dec 2015 15:55:52 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
<33A2204D-9FE6-4C80-9836-C05BABD9912F@michelf.ca>
Message-ID: <3AB3B7A2-720A-4179-B4DF-32042DB3064F@alkaline-solutions.com>

This seems related to my proposal to be able to bind self to a closure parameter.

Instead of:

with let task = NSTask() {…}

you could just make ‘with' a standard function:

func with<T>(argument:T, apply:(T) throws->()) rethrows -> T {
try apply(argument)
return argument
}

let task =  with(NSTask()) {
$0.launchPath = …
}

Then, with my proposal:

let task =  with(NSTask()) {
self in
launchPath = …
arguments = …
standardOutput = ...
}

-DW

> On Dec 4, 2015, at 2:51 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> Le 4 déc. 2015 à 16:35, Sean Heber <sean at fifthace.com> a écrit :
>
>> I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
>>
>> with let task = NSTask() {
>>  launchPath = "/usr/bin/mdfind"
>>  arguments = ["kMDItemDisplayName == *.playground"]
>>  standardOutput = pipe
>> }
>>
>> Also valid:
>>
>> with someVariable {
>>  func1()
>>  func2(“etc")
>> }
>>
>> Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).
>
> The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:
>
> 	let launchPath = "a.out"
> 	let description = "blah blah"
> 	with let task = NSTask() {
> 		launchPath = launchPath // eh, what?
> 		arguments = [launchPath, description] // is that task.description?
> 	}
>
> I think it's important that things referring to the "task" in the above example be syntactically distinguishable.
>
> It can also lead to code breakage:
>
> 	let path = "a.out"
> 	with let task = NSTask() {
> 		launchPath = path
> 	}
>
> That would work fine one day, but what if in the next OS release NSTask gets a new "path" property? That code breaks silently once you recompile with the newer SDK.
>
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From kevin at sb.org  Fri Dec  4 16:57:19 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 14:57:19 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
Message-ID: <1449269839.2871826.458481977.04EE506B@webmail.messagingengine.com>

On Fri, Dec 4, 2015, at 02:42 PM, John McCall wrote:
>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote: It's
>> not actually Duff's Device. Duff's Device relies on the fact that C
>> switch statements don't actually introduce a new scope, and so it
>> overlaps a switch with a do-while loop. This lets it only test the
>> number of bytes once, to jump into the middle of the loop, and then
>> it switches over to a while loop that decrements a counter every 8
>> instructions. Basically, it's a trick for manual loop unrolling that
>> deals with non-multiple-of-8 counts efficiently.
>
> To be pedantic, C switch statements do introduce a new scope.  What
> Duff’s Device exploits is that switch is allowed to jump into
> (almost) arbitrary scopes, and cases can appear anywhere recursively
> inside a switch.

Oh you're right, what I meant to say was that case statements don't
introduce a new scope. The do-while loop is contained entirely within
the scope of the switch itself, and the case statements act like goto
labels so it can jump into the scope of the do-while.

-Kevin Ballard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b0d796bb/attachment.html>

From david at hartbit.com  Fri Dec  4 16:59:07 2015
From: david at hartbit.com (David Hart)
Date: Fri, 4 Dec 2015 23:59:07 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
<CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
Message-ID: <073C2DB6-1F52-441A-899F-9BA39A99CD01@hartbit.com>

Stephen, as previously stated by Rudolf, his real-world example would not trigger such a warning because the title local variable no longer exists and therefore no longer shadows the instance property.

To continue the discussion, here is a more detailed but rough proposal closer to the required template to advance discussions. I hope you don’t mind Rudolf, but I used your example to illustrate the proposal:

Introduction

Swift used to force using ‘.self’ when accessing instance properties and functions, but since dropped this requirement, only to keep it for closure captures. It now feels inconsistent, and we have lost the automatic documentation of instance properties vs local variables and instance functions vs local functions or closures. This proposal offers to re-instate the original behaviour.

Motivation

The previous behaviour which this proposal hopes to re-instate provided several advantages:

* When reading code, it makes it obvious which are instance properties and which are local variables, as well as which are instance functions and which are local functions/closures. Moreover, a sloppy programmer can make it hard to read his code if he does not constantly use self. or not.
* Avoids bugs where the author meant to use one a local variable but instead is unknowingly using an instance property (and the other way round).

One example of a bug avoided by the original proposal (provided by Rudolf Adamkovic):

class MyViewController : UIViewController {
@IBOutlet var button: UIButton!
var name: String = “David"

func updateButton() {
// var title = “Hello \(name)”
button.setTitle(title, forState: .Normal) // forgot to comment this line but the compiler does not complain and title is now referencing UIViewController’s title by mistake
button.setTitleColor(UIColor.blackColor(), forState: .Normal)
}
}

The API Design Guidelines <https://swift.org/documentation/api-design-guidelines.html> are meant for writing APIs but I still think they represent fundamentals of Swift. The two first points are:

• Clarity at the point of use is your most important goal. Code is read far more than it is written.
• Clarity is more important than brevity. Although Swift code can be compact, it is a non-goal to enable the smallest possible code with the fewest characters. Brevity in Swift code, where it occurs, is a side-effect of the strong type system and features that naturally reduce boilerplate.

And I believe that the proposition is directly in line with those objectives.

Proposed solution

Re-instante the previous behaviour where ‘self.’ was required to access instance properties and functions.

Detailed design

It would not require changes to the grammar, and I think (not a compiler engineer) that it would require minimal amount of work.

Impact on existing code

A lot of code written since the original change would be impacted by this proposal, but it seems like it can be easily fixed by both the migrator tool and Auto Fixes.

Alternatives considered

The alternative is to keep the current behaviour, but it has the aforementioned disadvantages

> On 04 Dec 2015, at 22:51, Rudolf Adamkovic <salutis at me.com> wrote:
>
> +1
>
> 1) I actually encountered at least two bugs in my app introduced by this implicit "self" behavior. It can be dangerous and hard to track down.
>
> 2) Also when, say fine-tuning UIKit animations, I find myself wasting enormous amount of time adding and removing "self".
>
> R+
>
> Sent from my iPhone
>
>> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com> wrote:
>>
>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>
>> Just as example, my proposition makes the following piece of code illegal:
>>
>> ```
>> struct FooBar {
>>   var foo: String = "foobar"
>>
>>   func bar() {
>>       print(foo) // compiler error
>>       print(self.foo) // compiler happy
>>   }
>>
>>   func bar2() {
>>       bar() // compiler error
>>       self.bar() // compiler happy
>>   }
>> }
>> ```
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


> On 04 Dec 2015, at 23:41, Stephen Celis <stephen.celis at gmail.com> wrote:
>
> Are there warnings/diagnostics that could call out when local variables shadow properties? I generally like that `self` is optional and prefer limiting its use to explicitly call out potential retain cycles. Xcode also makes it easy to introspect variable scope, though Xcode is less of a requirement these days...
>
> On Fri, Dec 4, 2015 at 5:34 PM, Rudolf Adamkovič <salutis at me.com <mailto:salutis at me.com>> wrote:
> To be a little more specific, here’s a real-world example:
>
> 1. Say there’s a method in my class that contains a local variable called “title”.
> 2. After a while, I decide to remove a part of this method, including the “title” variable.
> 3. Everything compiles and seems to work just fine.
> 4. However, I forgot to remove one more line that used the “title” variable.
> 5. Because we’re in a UIViewController subclass, I'm unknowingly modifying view controller’s title.
>
> R+
>
> > On 4 Dec 2015, at 22:51, Rudolf Adamkovic <salutis at me.com <mailto:salutis at me.com>> wrote:
> >
> > +1
> >
> > 1) I actually encountered at least two bugs in my app introduced by this implicit "self" behavior. It can be dangerous and hard to track down.
> >
> > 2) Also when, say fine-tuning UIKit animations, I find myself wasting enormous amount of time adding and removing "self".
> >
> > R+
> >
> > Sent from my iPhone
> >
> >> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
> >>
> >> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
> >>
> >> Just as example, my proposition makes the following piece of code illegal:
> >>
> >> ```
> >> struct FooBar {
> >>   var foo: String = "foobar"
> >>
> >>   func bar() {
> >>       print(foo) // compiler error
> >>       print(self.foo) // compiler happy
> >>   }
> >>
> >>   func bar2() {
> >>       bar() // compiler error
> >>       self.bar() // compiler happy
> >>   }
> >> }
> >> ```
> >> _______________________________________________
> >> swift-evolution mailing list
> >> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> > https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8d4f1eb5/attachment-0001.html>

From michel.fortin at michelf.ca  Fri Dec  4 17:00:05 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Fri, 4 Dec 2015 18:00:05 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <3A6FBE86-45CB-4D85-9255-1CF3138282A6@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<3A6FBE86-45CB-4D85-9255-1CF3138282A6@apple.com>
Message-ID: <D308D5C9-ED30-4E27-9F5E-14999CF8F832@michelf.ca>

Le 4 déc. 2015 à 17:31, Joe Groff <jgroff at apple.com> a écrit :

> One wrinkle you need to consider is the different ARC behavior of method families. @convention(selector) would have to be restricted to referencing methods that don't belong to an usual method family or have unusual ownership rules, or else we'd need multiple @convention(init_selector), (copy_selector), (alloc_selector) etc. conventions.

Very true. Still, people currently pass selectors around without really bothering about this. It seems to me that restricting @convention(selector) to represent methods having standard behaviour (standard being autoreleased-return with non-consuming arguments) would cover about 99.9% of the use cases.

--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From michel.fortin at michelf.ca  Fri Dec  4 17:01:50 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Fri, 4 Dec 2015 18:01:50 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
Message-ID: <7AA700B8-2324-465E-AD90-03A85B027F44@michelf.ca>

Le 4 déc. 2015 à 17:26, Joe Groff <jgroff at apple.com> a écrit :

> This is a great approach, and it's mostly exactly what I've had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.

Something like this?

view.target = target
view.action = { (target) in beep() }

Not bad, but wouldn't that be somewhat fragile? Given you must make sure the target is retained, I'm not sure it really make things simpler. And you need to make sure it's not nil either: this just won't work:

view.action = { beep() }

It looks like an error-prone idiom to me.


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From kevin at sb.org  Fri Dec  4 17:02:03 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 15:02:03 -0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
<CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
Message-ID: <1449270123.2872744.458483625.00FB0378@webmail.messagingengine.com>

Very strong -1.

The ability to elide `self` in most contexts is really nice. Especially
when combined with the fact that SourceKitService lets Xcode syntax-
colorize properties/methods nicely so the color of the identifier tells
me whether it's a method/property on self or something else. I realize
that not everybody will be using Xcode (particularly people on other
platforms), but in time we should hopefully see other editors gain
support for SourceKit to provide more intelligent handling of Swift
code as well.

Similarly, I rely on the ability to shadow things (including properties
of self) a _lot_. And it's not just me; it's very common for e.g.
initializers to use property names as the parameter names, such as:

init(x: Int, y: Int) {    self.x = x    self.y = y }

-Kevin Ballard

On Fri, Dec 4, 2015, at 02:41 PM, Stephen Celis wrote:
> Are there warnings/diagnostics that could call out when local
> variables shadow properties? I generally like that `self` is optional
> and prefer limiting its use to explicitly call out potential retain
> cycles. Xcode also makes it easy to introspect variable scope, though
> Xcode is less of a requirement these days...
>
> On Fri, Dec 4, 2015 at 5:34 PM, Rudolf Adamkovič
> <salutis at me.com> wrote:
>> To be a little more specific, here’s a real-world example:
>>
>>
1. Say there’s a method in my class that contains a local variable
called “title”.
>>
2. After a while, I decide to remove a part of this method, including
the “title” variable.
>>
3. Everything compiles and seems to work just fine.
>>
4. However, I forgot to remove one more line that used the
“title” variable.
>>
5. Because we’re in a UIViewController subclass, I'm unknowingly
modifying view controller’s title.
>>
>>
R+
>>
>>
> On 4 Dec 2015, at 22:51, Rudolf Adamkovic <salutis at me.com> wrote:
>>
>
>>
> +1
>>
>
>>
> 1) I actually encountered at least two bugs in my app introduced by
>    this implicit "self" behavior. It can be dangerous and hard to
>    track down.
>>
>
>>
> 2) Also when, say fine-tuning UIKit animations, I find myself wasting
>    enormous amount of time adding and removing "self".
>>
>
>>
> R+
>>
>
>>
> Sent from my iPhone
>>
>
>>
>> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com> wrote:
>>
>>
>>
>> I don't understand the reasoning behind removing the need to access
>> instance properties and functions using self. Swift has always seemed
>> to prefer readability to brevity and the feature makes the
>> distinction between local and instance variables/functions crystal
>> clear. Any good reason I shouldn't go on with the proposition?
>>
>>
>>
>> Just as example, my proposition makes the following piece of code
>> illegal:
>>
>>
>>
>> ```
>>
>> struct FooBar {
>>
>>var foo: String = "foobar"
>>
>>
>>
>>func bar() {
>>
>>print(foo) // compiler error
>>
>>print(self.foo) // compiler happy
>>
>>}
>>
>>
>>
>>func bar2() {
>>
>>bar() // compiler error
>>
>>self.bar() // compiler happy
>>
>>}
>>
>> }
>>
>> ```
>>
>> _______________________________________________
>>
>> swift-evolution mailing list
>>
>> swift-evolution at swift.org
>>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
> _______________________________________________
>>
> swift-evolution mailing list
>>
> swift-evolution at swift.org
>>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
_______________________________________________
>>
swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ec70e4eb/attachment.html>

From daniel.muhra at gmail.com  Fri Dec  4 17:07:44 2015
From: daniel.muhra at gmail.com (Daniel Muhra)
Date: Sat, 5 Dec 2015 00:07:44 +0100
Subject: [swift-evolution] Type information containing multiple additional
protocols
Message-ID: <A9BD5D7C-E99C-44F7-A7BB-A501C8788083@gmail.com>

Currently it doesn’t seem possible to define a property or variable of a specific class that also implements one or more protocols.
Take as an example the following definition from Objective C:

NSManagedObject<NSCoding, Task>* someObject;

To my knowledge, currently it is only possible to define multiple protocols only:

var object : protocol<NSCoding, Task>

However, given the first example, sometimes it is not possible to restrict to protocols only. This becomes especially cumbersome, if you would need to cast down to such a construct within a single method and perform several steps which would require all those type information:

func doSomething(object: AnyObject) {
if let managedObject = object as? NSManagedObject {
// Do core data related stuff
}

if let task = object as? Task {
// Do task related stuff
}
}

In this case you now have managedObject and task though you operate on the same object. Also it is not (easily) possible to interleave actions of those two.

My first idea here would be to introduce an Objective C like style of type naming. This also has the benefit, that it is perfectly clear, whether a type name refers to a class or a protocol (without first having to check it).
The downside, of course, is that protocol type variables would become something like Any<MyProtocol>

Any other ideas are welcome, but the initial problem still stands and should be addressed.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/fb927de9/attachment-0001.html>

From david at hartbit.com  Fri Dec  4 17:08:30 2015
From: david at hartbit.com (David Hart)
Date: Sat, 5 Dec 2015 00:08:30 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <1449270123.2872744.458483625.00FB0378@webmail.messagingengine.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
<CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
<1449270123.2872744.458483625.00FB0378@webmail.messagingengine.com>
Message-ID: <06FC0FC0-62AA-4B07-B738-F3012F884637@hartbit.com>

> Very strong -1.

I have the impression that this topic can be quite divisive.

> The ability to elide `self` in most contexts is really nice. Especially when combined with the fact that SourceKitService lets Xcode syntax-colorize properties/methods nicely so the color of the identifier tells me whether it's a method/property on self or something else. I realize that not everybody will be using Xcode (particularly people on other platforms), but in time we should hopefully see other editors gain support for SourceKit to provide more intelligent handling of Swift code as well.

For me, Swift should be clear even without the help of syntax highlighting. Syntax highlighting should come only as a bonus. On a personal note, I’m colourblind and have great difficulties telling colours apart.

> Similarly, I rely on the ability to shadow things (including properties of self) a _lot_. And it's not just me; it's very common for e.g. initializers to use property names as the parameter names, such as:
>
> init(x: Int, y: Int) {
>     self.x = x
>     self.y = y
> }

I agree with you on this, as I often use such idioms. That’s why the shadowing warning is not a good solution IMHO.

David.

> On Fri, Dec 4, 2015, at 02:41 PM, Stephen Celis wrote:
>> Are there warnings/diagnostics that could call out when local variables shadow properties? I generally like that `self` is optional and prefer limiting its use to explicitly call out potential retain cycles. Xcode also makes it easy to introspect variable scope, though Xcode is less of a requirement these days...
>>
>> On Fri, Dec 4, 2015 at 5:34 PM, Rudolf Adamkovič <salutis at me.com <mailto:salutis at me.com>> wrote:
>> To be a little more specific, here’s a real-world example:
>>
>> 1. Say there’s a method in my class that contains a local variable called “title”.
>> 2. After a while, I decide to remove a part of this method, including the “title” variable.
>> 3. Everything compiles and seems to work just fine.
>> 4. However, I forgot to remove one more line that used the “title” variable.
>> 5. Because we’re in a UIViewController subclass, I'm unknowingly modifying view controller’s title.
>>
>> R+
>>
>> > On 4 Dec 2015, at 22:51, Rudolf Adamkovic <salutis at me.com <mailto:salutis at me.com>> wrote:
>> >
>> > +1
>> >
>> > 1) I actually encountered at least two bugs in my app introduced by this implicit "self" behavior. It can be dangerous and hard to track down.
>> >
>> > 2) Also when, say fine-tuning UIKit animations, I find myself wasting enormous amount of time adding and removing "self".
>> >
>> > R+
>> >
>> > Sent from my iPhone
>> >
>> >> On 04 Dec 2015, at 22:19, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
>> >>
>> >> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>> >>
>> >> Just as example, my proposition makes the following piece of code illegal:
>> >>
>> >> ```
>> >> struct FooBar {
>> >>   var foo: String = "foobar"
>> >>
>> >>   func bar() {
>> >>       print(foo) // compiler error
>> >>       print(self.foo) // compiler happy
>> >>   }
>> >>
>> >>   func bar2() {
>> >>       bar() // compiler error
>> >>       self.bar() // compiler happy
>> >>   }
>> >> }
>> >> ```
>> >> _______________________________________________
>> >> swift-evolution mailing list
>> >> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> >> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>> > _______________________________________________
>> > swift-evolution mailing list
>> > swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> > https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0c43d13d/attachment.html>

From dgregor at apple.com  Fri Dec  4 17:12:29 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Fri, 4 Dec 2015 15:12:29 -0800
Subject: [swift-evolution] swift for ios?
In-Reply-To: <CAL-BAQs8pkwmaGfspPggqXiAMaY5oTRTUs9j5LcZvjdKhYwTpA@mail.gmail.com>
References: <CAL-BAQs8pkwmaGfspPggqXiAMaY5oTRTUs9j5LcZvjdKhYwTpA@mail.gmail.com>
Message-ID: <11C9FF8D-0E03-4DAC-B829-378554C27657@apple.com>


> On Dec 3, 2015, at 10:24 PM, Bee <bee.ography at gmail.com> wrote:
>
> Hi all,
>
> I think the next logical step for Swift is Apple creates an iOS Swift IDE. It doesn't need to be as complex as XCode. Its main purpose is to bring Swift to the young generations who are mostly more familiar and fluent with iOS rather than with OSX. At least bring Playground to the iOS.
>
> For reference what the Swift IDE for iOS should be like, try to look at Codea (Lua) and Pythonista (Python) app in the iOS app store. I love those both apps. I believe Apple can do much better than those apps. :)

This is outside of the scope of the Swift evolution process.

- Doug



From andy at andymatuschak.org  Fri Dec  4 17:15:24 2015
From: andy at andymatuschak.org (Andy Matuschak)
Date: Fri, 4 Dec 2015 15:15:24 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
Message-ID: <F4E87A36-0846-4F6C-A8CA-E237EA65FD18@andymatuschak.org>

On a few occasions, fallthrough has been the most expressive path for a non-performance-related reason: rather, because it’s not possible to destructure a value and also have multiple predicates in a case, e.g.

switch downloadStatus {
case let .Downloading(progress) where progress == 0.0:
fallthrough
case .NotStarted:
// do things implying we have no data
default:
// do things implying we have some data
}

Of course, we might resolve this by changing the destructuring semantics.

> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com wrote:
>
> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>
> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>
> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>
> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>
> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>
> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>
> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>
> Thoughts?
>
> Daniel
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/66f1fb80/attachment-0001.html>

From me at tal.by  Fri Dec  4 17:16:19 2015
From: me at tal.by (Tal Atlas)
Date: Fri, 04 Dec 2015 23:16:19 +0000
Subject: [swift-evolution] Proposal: helpers for initializing properties of
same name as parameters
Message-ID: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>

There’s lots of boilerplate of initializing structs with stored properties
and initializer parameters. I’d like to create a syntax for alleviating
that in the 90% case.

```swift
struct Foo {
let bar: String
let baz: Int

init(self.bar: String = "default", counter self.baz: Int) {
}
}
```

This would be identical to:
```swift
struct Foo {
let bar: String
let baz: Int

init(bar: String = "default", counter baz: Int) {
self.bar = bar
self.baz = baz
}
}
```
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d43820f5/attachment.html>

From jgroff at apple.com  Fri Dec  4 17:16:48 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 15:16:48 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <7AA700B8-2324-465E-AD90-03A85B027F44@michelf.ca>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<7AA700B8-2324-465E-AD90-03A85B027F44@michelf.ca>
Message-ID: <F176AF04-9C9E-43D7-A3DD-2ECE41B64A1F@apple.com>


> On Dec 4, 2015, at 3:01 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> Le 4 déc. 2015 à 17:26, Joe Groff <jgroff at apple.com> a écrit :
>
>> This is a great approach, and it's mostly exactly what I've had in mind for this. Another nice thing about @convention(selector) is that the compiler could also context-free closures, like with @convention(c), by compiling them down to categories with mangled methods.
>
> Something like this?
>
> 	view.target = target
> 	view.action = { (target) in beep() }
>
> Not bad, but wouldn't that be somewhat fragile? Given you must make sure the target is retained, I'm not sure it really make things simpler. And you need to make sure it's not nil either: this just won't work:
>
> 	view.action = { beep() }
>
> It looks like an error-prone idiom to me.

That shouldn't be a problem, since the function would be emitted with the same guaranteed-self convention ObjC methods normally have.

-Joe

From stephen.celis at gmail.com  Fri Dec  4 17:20:20 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Fri, 4 Dec 2015 18:20:20 -0500
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <073C2DB6-1F52-441A-899F-9BA39A99CD01@hartbit.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
<CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
<073C2DB6-1F52-441A-899F-9BA39A99CD01@hartbit.com>
Message-ID: <CAN9tzpAgL+QT8siJJAY39=syT4WP3ZGfqLqPWHJP94tn8-=mkQ@mail.gmail.com>

On Fri, Dec 4, 2015 at 5:59 PM, David Hart <david at hartbit.com> wrote:

> Stephen, as previously stated by Rudolf, his real-world example would not
> trigger such a warning because the title local variable no longer exists
> and therefore no longer shadows the instance property.
>

Wouldn't the warning trigger prior to refactoring and therefore be more
apparent during such a removal?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ac2db6d4/attachment.html>

From colin.cornaby at mac.com  Fri Dec  4 17:21:31 2015
From: colin.cornaby at mac.com (Colin Cornaby)
Date: Fri, 04 Dec 2015 23:21:31 +0000 (GMT)
Subject: [swift-evolution] C-style For Loops
Message-ID: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>

This is a nice solution that translates nicely without creating too much concern about changing the nature of an algorithm in a complex system. 👍

Should at least get a nice "fix it" in Xcode though. On survey, we do have developers using the C style syntax, but we're early in the process of transitioning.

On Dec 04, 2015, at 02:52 PM, Johan Jensen <jj at johanjensen.dk> wrote:

With the removal of post/pre-increment/decrement you might as well translate C-style for-loops to something akin to

for var i in 0..<10 {
    ...
}

If more advanced C-style for-loops are needed, I am sure most developers can use a while-loop (as mentioned by Ray Fix) until they get accustomed to Swift’s syntax.

On Fri, Dec 4, 2015 at 11:37 PM, Joe Groff <jgroff at apple.com> wrote:
You might ease the pain by approximating C-style 'for' by a higher-order function:

func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
  // left as an exercise
}

var i = 0
cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
  print(i)
}

-Joe

On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:

I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...

It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.

We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.

But if it's actively hurting some other part of the language we could probably be talked into it.

On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com> wrote:

Does Swift still needs C-style for loops with conditions and incrementers?

<Screen Shot 2015-12-03 at 4.30.15 PM.png>

More Swift-like construction is already available with for-in-statements and stride.
This would naturally starve the most common point for -- and ++ operators as well.

-- E



_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution



_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/917597da/attachment.html>

From david at hartbit.com  Fri Dec  4 17:22:59 2015
From: david at hartbit.com (David Hart)
Date: Sat, 5 Dec 2015 00:22:59 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <CAN9tzpAgL+QT8siJJAY39=syT4WP3ZGfqLqPWHJP94tn8-=mkQ@mail.gmail.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
<CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
<073C2DB6-1F52-441A-899F-9BA39A99CD01@hartbit.com>
<CAN9tzpAgL+QT8siJJAY39=syT4WP3ZGfqLqPWHJP94tn8-=mkQ@mail.gmail.com>
Message-ID: <D8D51D5F-4376-450C-968C-62FD82D6870B@hartbit.com>

It would, so it’s better than nothing, but it would disappear as soon as the un-intentional bug appears. But, as Kevin stated, there are too many good used of shadowing to suffer a warning.

> On 05 Dec 2015, at 00:20, Stephen Celis <stephen.celis at gmail.com> wrote:
>
> On Fri, Dec 4, 2015 at 5:59 PM, David Hart <david at hartbit.com <mailto:david at hartbit.com>> wrote:
> Stephen, as previously stated by Rudolf, his real-world example would not trigger such a warning because the title local variable no longer exists and therefore no longer shadows the instance property.
>
> Wouldn't the warning trigger prior to refactoring and therefore be more apparent during such a removal?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7099343a/attachment-0001.html>

From stephen.celis at gmail.com  Fri Dec  4 17:23:12 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Fri, 4 Dec 2015 18:23:12 -0500
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <06FC0FC0-62AA-4B07-B738-F3012F884637@hartbit.com>
References: <54BBD066-764C-4521-95A7-3F7D235721C3@hartbit.com>
<8DE83A4A-14B6-472C-A320-8F336875E830@me.com>
<2916C538-F58B-4018-8397-0CBA9B4CF5E5@me.com>
<CAN9tzpDtcqQqXKPZ_P95NtUg3oPDNbqfVS+8T7JugsX0zdrz6A@mail.gmail.com>
<1449270123.2872744.458483625.00FB0378@webmail.messagingengine.com>
<06FC0FC0-62AA-4B07-B738-F3012F884637@hartbit.com>
Message-ID: <CAN9tzpDtHKK5mZWxrjE81DMJzk+72KX-aFnPutVoVFqk37J6Ug@mail.gmail.com>

On Fri, Dec 4, 2015 at 6:08 PM, David Hart <david at hartbit.com> wrote:

> Similarly, I rely on the ability to shadow things (including properties of
> self) a _lot_. And it's not just me; it's very common for e.g. initializers
> to use property names as the parameter names, such as:
>
>
> init(x: Int, y: Int) {
>     self.x = x
>     self.y = y
> }
>
>
> I agree with you on this, as I often use such idioms. That’s why the
> shadowing warning is not a good solution IMHO.
>

This is a fair point, though initialization seems to be the most common
exception and could be omitted from the rule.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/657e8d96/attachment.html>

From clattner at apple.com  Fri Dec  4 17:25:44 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 15:25:44 -0800
Subject: [swift-evolution] General take on "special" code in Swift
In-Reply-To: <76C4E65A-2D2E-4CDD-AC57-141958DBE22D@omnigroup.com>
References: <76C4E65A-2D2E-4CDD-AC57-141958DBE22D@omnigroup.com>
Message-ID: <A0FF5B16-25DA-4E61-B584-C30240112B81@apple.com>


> On Dec 3, 2015, at 11:21 PM, Timothy Wood <tjw at omnigroup.com> wrote:
>
>
> First off, thanks for all the hard work in putting together an in-depth release and open community infrastructure!
>
> Looking through the Swift sources briefly, I’m noticing various constructs that aren’t documented, idiomatic Swift, or even Swift at all. This isn’t super surprising for various mostly obvious reasons. But, one particular example that caught my attention is in swift/util/gyb.py ("GYB: Generate Your Boilerplate”), and all the .gyb files scattered around.
>
> One of the various Apple Swift tutorial/reference PDFs had the canonical maligning of the C preprocessor (warranted, but yet it is a powerful and useful tool), and yet here is the Swift standard library using a preprocessor of another sort.
>
> For this specific case, I could ask for some magical hygienic macro support, with full debugger support, autocompletion, and puppies (which would be great!), but the more general question is whether the Swift team feels like this dichotomy is OK, or whether it just (a ton of) work that is left to do? Should it be the case that the standard library, Foundation, testing frameworks, and such are almost entirely idiomatic Swift code (even if they are using advanced features)?

This is a better question for swift-dev than swift-evolution, but…

IMO, “gyb” is a pragmatic but unfortunate tool.  It fills the same space as the underscored protocols in the standard library: it allows us to ship a product that is useful, but they are both far from ideal.  The _ protocols were generally forced by some limitations in the generics system and other parts of the compiler.  GYB is needed by those, but also by the fact that we don’t have a hygienic macro system (we certainly won’t have a macro system in Swift 3, but could consider it after that).

The good news is that the need for these things is being reduced as Swift improves.

-Chris

From andy at andymatuschak.org  Fri Dec  4 17:26:58 2015
From: andy at andymatuschak.org (Andy Matuschak)
Date: Fri, 4 Dec 2015 15:26:58 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
Message-ID: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>

Hello, all! This SequenceType-implemented flatMap recently caused some confusion on my team:

func flatMap<T>(@noescape transform: (Self.Generator.Element) throws -> T?) rethrows -> [T]

I’m a big fan of this operator in various functional libraries, but I admit I was a bit surprised to see the “flatMap” terminology appear in the Swift stdlib in the first place—its naming is certainly a notch obscure!

From the reactions of teammates in code reviews involving these methods, there was a significant difference in comprehensibility between the Element -> [T] variant and the Element -> T? variant. The former was easily explained by “it’s a map, followed by a flatten,” whereas the same explanation failed in the latter case.

I expect that the inspiration came from Scala, where the equivalent definition has a transformer essentially of type  Element -> GeneratorType<T>; separately, their optionals are implicitly convertible to (their equivalent of) GeneratorType. So, in the end, in Scala, you can effectively flatMap with an Element -> T? transformer.

But Optional doesn’t implement GeneratorType, and I’d (weakly) argue that it shouldn’t. And if we think about flatMap in the context of a monadic bind (I do, anyway!), it’s especially surprising that the transformer is operating in a different monadic context (Optional) than the receiver (SequenceType). Unless we made Optional adopt SequenceType, in which case we could consider the bind to be happening in that context.

In conclusion, I argue that this overload is confusing both to folks unfamiliar with FP (because it doesn’t feel like Optionals can be flattened) and to folks familiar with FP (because it implies binding across monadic contexts).

~

In terms of what to do instead: I do think that this is a useful method, and I’d like to keep this functionality easily accessible! Two ideas:

1. We expose a separate operator like:

extension SequenceType where Generator.Element: OptionalType {
func filterNils() -> [Generator.Element.Wrapped]
}

// To deal with limitations on protocol extension type restriction:
protocol OptionalType {
typealias Wrapped
func flatMap<Result>(@noescape f: Wrapped -> Result?) -> Result?
}
extension Optional: OptionalType {}

Clients would do myArray.map(optionalReturningTransform).filterNils(). There would be some performance impact from the intermediate array.

2. We give the foo variant a more specific name, e.g. mappedArrayFilteringNils etc. Naming this is tricky (which probably implies it should be decomposed?).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0b5b792e/attachment.html>

From kevin at sb.org  Fri Dec  4 17:27:22 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 15:27:22 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
Message-ID: <1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>

The @convention(selector) as proposed is a neat idea, but it will
completely break target/action. This is because the
@convention(selector) is a strongly-typed function signature, but
target/action relies on the fact that it can provide 2 parameters to the
method and this will work with any method that matches one of the 3
forms (2 forms on OS X):

- (void)action
- (void)action:(id)sender
- (void)action:(id)sender forEvent:(UIEvent *)event

But these 3 forms translate into the 3 distinct types:

@convention(selector) T -> () -> Void
@convention(selector) T -> AnyObject -> Void
@convention(selector) T -> AnyObject -> UIEvent -> Void

But the only way to handle this in a reasonable fashion is to allow
these 3 types to implicitly coerce to each other, which seems like a bad
idea and removes a lot of the benefit of trying to strongly type them.
There's also the confusion around the receiver type T here; a selector
can't possibly encode the receiver type, because the whole point of
selectors is the caller doesn't care what the receiver is, it only cares
how the receiver behaves. You could make the receiver be AnyObject, but
now you can create a selector from one type and call it with another
type.

Furthermore, how would you even handle this for methods that take
selectors of arbitrary types, e.g. respondsToSelector() or various obj-c
runtime methods? Allowing implicit conversion to a single common form
like `@convention(selector) () -> Void` is no better than keeping the
current Selector (and is in fact worse because it implies strong typing
where there is none), and keeping the current Selector in addition to
@convention(selector) is not a great solution either (it leaves the
language as more complex, without really providing the strong typing
that @convention(selector) looks like it's trying to do).

I also worry that allowing something like @convention(selector) would be
confusing, because it would look like the following two code snippets
should be identical:

foo.performSelector(Foo.handleBar)

and

let sel = Foo.handleBar
foo.performSelector(sel)

But this can't work because it requires the ability to convert from
@convention(swift) T -> U into @convention(selector) T -> U, which can't
work because not all closures will have associated selectors. You'd need
to introduce something else, like @convention(objc_swift) T -> U, that
includes a selector and implicitly converts to both @convention(swift)
and @convention(objc), but this is quickly becoming needlessly complex.
And it still doesn't solve the type-safety issues above.

---

My simpler proposal here would be to simply embrace the fact that
selectors are weakly-typed, to say that any API that wants type safety
should be changed to just take a closure (or to have an overload that
does), and then to just have a bit of Swift syntax that gives you the
selector for any method. I'm not sure offhand what the syntax should be,
but I filed a couple of radars a long time ago that also asked for a
syntax to get at the willSet/didSet property observers and the
underlying storage for lazy properties, and suggested that these could
all use the same bit of syntax. I don't know what the syntax should be,
but general meaning of the syntax would be to access pieces of
information about members (where "members" means properties and
methods). As an example of what I'm talking about, if we decided that
the syntax should be to use `` to access things like "foo.storage" as a
value the way you can use it for keywords-as-identifiers, then you could
say things like

notificationCenter.addObserver(foo, selector:
Foo.`observeBar.selector`, name: /* ... */)
self.`lazyBar.storage` = nil
self.`baz.didSet`(oldValue: qux)

Note that I'm not actually suggesting this is the right syntax to use
(while I like that it re-uses existing syntax, it's also pretty weird),
but the concept is sound.

-Kevin Ballard

On Fri, Dec 4, 2015, at 02:26 PM, Joe Groff wrote:
>
> > On Dec 4, 2015, at 2:22 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
> >
> > Currently in Swift you can get a closure by referring to a method:
> >
> > 	let x = NSString.hasPrefix
> > 	// x is of type NSString -> String -> Bool
> >
> > Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you'd just have to refer to the method, and you know there's no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:
> >
> > 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil)
> >
> > This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.
> > https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md
> >
> > But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:
> >
> > 	@convention(selector) AnyObject -> NSNotification -> Void
> >
> > Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You
>
> This is a great approach, and it's mostly exactly what I've had in mind
> for this. Another nice thing about @convention(selector) is that the
> compiler could also context-free closures, like with @convention(c), by
> compiling them down to categories with mangled methods.
>
> >
> > Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:
> >
> > 	@objc func callSelector(selector: @convention(selector) NSString -> String -> Bool) -> Bool {
> > 		let str = NSString(string: "hello")
> > 		return selector(str)("hell")
> > 	}
> >
> > 	let x = NSString.hasPrefix
> > 	// x is of type @convention(selector) NSString -> String -> Bool
> > 	callSelector(x)
> >
> > So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.
>
> I would say that 'let x = NSString.hasPrefix' should still give you a
> @convention(swift) function value by default; that's what we do with
> method references in general, but you could ask for a
> @convention(selector) reference explicitly:
>
> let x: @convention(selector) X -> Y -> Z = X.hasPrefix
>
> -Joe
>
> > - - -
> >
> > This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:
> >
> > 1. I wanted to preserve D's type-safety while still being able to use selectors, and
> > 2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.
> >
> > For reference, here is the meager documentation for that feature:
> > https://michelf.ca/projects/d-objc/syntax/#selector-literals
> > And for the selector-name mangling:
> > https://michelf.ca/projects/d-objc/syntax/#generated-selectors
> >
> >
> > --
> > Michel Fortin
> > michel.fortin at michelf.ca
> > https://michelf.ca
> >
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From colin.cornaby at mac.com  Fri Dec  4 17:29:41 2015
From: colin.cornaby at mac.com (Colin Cornaby)
Date: Fri, 04 Dec 2015 23:29:41 +0000 (GMT)
Subject: [swift-evolution]
=?utf-8?q?Proposal=3A_Re-instate_mandatory_self?=
=?utf-8?q?_for_accessing=09instance_properties_and_functions?=
Message-ID: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>

+1

I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.

I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.

On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:

I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?

Just as example, my proposition makes the following piece of code illegal:

```
struct FooBar {
var foo: String = "foobar"

func bar() {
print(foo) // compiler error
print(self.foo) // compiler happy
}

func bar2() {
bar() // compiler error
self.bar() // compiler happy
}
}
```
_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d4b8d3e8/attachment.html>

From clattner at apple.com  Fri Dec  4 17:29:46 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 15:29:46 -0800
Subject: [swift-evolution] NDAs, Open Source, and the Iron Curtain
In-Reply-To: <E5BD5629-914C-4542-AD2F-5679970B5FC4@ericasadun.com>
References: <E5BD5629-914C-4542-AD2F-5679970B5FC4@ericasadun.com>
Message-ID: <10D1A990-476A-4F2F-B819-4036A5E94F97@apple.com>


> On Dec 3, 2015, at 5:00 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
> Can we take it as a given that all language development is now out and in the clear and that, outside of specific dev-tool enhancements, we will transparently see the full progression of incorporated, proposed, and planned changes through this list, the repo, and the swift.org <http://swift.org/> site?

Hi Erica,

Nothing on swift.org or github is protected by an swift or apple NDA, we intend to do swift language design, evolution, and implementation in the open.

On the topic of Xcode, as usual, Apple folks don’t talk about or commit about future tools plans.  Also, when you get an Xcode beta or final release from apple, you’re still subject to its terms.

-Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/3e448eef/attachment.html>

From david at alkaline-solutions.com  Fri Dec  4 17:32:41 2015
From: david at alkaline-solutions.com (David Waite)
Date: Fri, 4 Dec 2015 16:32:41 -0700
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in
closures
In-Reply-To: <1449269507.2870902.458470841.617B34D2@webmail.messagingengine.com>
References: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
<20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
<1449269507.2870902.458470841.617B34D2@webmail.messagingengine.com>
Message-ID: <D387A01A-99F3-4D36-9B00-404B3088B38E@alkaline-solutions.com>


> On Dec 4, 2015, at 3:51 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> On Fri, Dec 4, 2015, at 09:36 AM, Joe Groff wrote:
>> Another way to do this would be to support scoped imports, to make a set of top-level functions locally available without polluting the global namespace:
>>
>> {
>>   import func QuickSpecBuilder.expect
>>
>>   expect(sections).to(....)
>> }
>>
>> Being able to elide self is already somewhat controversial, and a number of people find it makes code harder to read. I worry that allowing closures to change 'self' has the potential to be even more confusing. In Javascript, it's my understanding the ability to arbitrarily rebind 'this' is seen as a design flaw rather than a feature people regularly take advantage of.
>
> I like this idea. I'm very much against rebinding `self` because it seems like an excellent source for confusion. Not only that, but the actual underlying desire here isn't to remove `self` at all, but just to introduce new functions into function resolution within a scope. And this is precisely what adding imports in arbitrary scopes does (the only downside being you need a line of code to add them, but that's not a big deal). I know Rust allows this and it's pretty handy. I'd love to have this feature even when not using a DSL.
>
> -Kevin Ballard

A few thoughts:

1. In a lot of situations they are not pure functions - they have state associated across them determined by the context in which your closure was called. So the import would not be of a static function, but of an input parameter, aka:
it(“…”) {
builder in
import builder
expect(sections).to{…}
}

Assuming expect is the only function, this may very well be equivalent to

it(“…”) {
builder in
let expect = builder.expect
expect(sections).to{…}
}

2. expect, in the case of Nimble, is an overloaded function. I assume import would bring in all overloads?
3. I like the idea of providing additional scope rather than overriding self, as you would likely need to bind self to a new name per my proposal (aka [my = self] self in…)
4. I like the idea of this having lexical scope, and import being usable outside of closures
5. Imports likely should generate conflicts at compile-time if they shadow defined functions if you can do wildcard imports. No need to have syntax to alias names - one should either change the code to not conflict or use the longer-form names
6. import could be an attribute:
it(“…”) {
@import builder in
expect(sections).to{…}
}


-DW

From kevin at sb.org  Fri Dec  4 17:34:57 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 15:34:57 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
Message-ID: <1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>

I use that flatMap() variant on sequences very often. I don't think I've
actually _ever_ used the variant that returns [T]. I understand the
monadic argument you're making, but I believe the practical choice here
is to keep this flatMap() variant as-is. Giving it a different name
would I think reduce clarity, since it's conceptually performing the
same operation (e.g. the closure returns some value that is flattened;
whether the values an array or an optional it doesn't matter), and
adding .filterNils() would not only reduce clarity but would, as you
said, have a performance impact.

Personally, I'd be in favor of making Optional conform to SequenceType.
I've filed a radar on it before, and I seem to recall a message
(probably to this list) yesterday suggesting the exact same thing. It
may even want to go ahead and adopt CollectionType too, completely
replacing CollectionOfOne (though the ability to subscript an optional
may be confusing, so it may be better to just adopt SequenceType and
keep CollectionOfOne around for CollectionType use-cases).

-Kevin Ballard

On Fri, Dec 4, 2015, at 03:26 PM, Andy Matuschak wrote:
> Hello, all! This SequenceType-implemented flatMap recently caused some
> confusion on my team:
>
>> func flatMap<T>(@noescape transform: (Self.Generator.Element) throws
>> -> T?) rethrows -> [T]
>
> I’m a big fan of this operator in various functional libraries, but I
> admit I was a bit surprised to see the “flatMap” terminology appear in
> the Swift stdlib in the first place—its naming is certainly a notch
> obscure!
>
> From the reactions of teammates in code reviews involving these
> methods, there was a significant difference in comprehensibility
> between the Element -> [T] variant and the Element -> T? variant. The
> former was easily explained by “it’s a map, followed by a flatten,”
> whereas the same explanation failed in the latter case.
>
> I expect that the inspiration came from Scala, where the equivalent
> definition has a transformer essentially of type  Element ->
> GeneratorType<T>; separately, their optionals are implicitly
> convertible to (their equivalent of) GeneratorType. So, in the end, in
> Scala, you can effectively flatMap with an Element -> T? transformer.
>
> But Optional doesn’t implement GeneratorType, and I’d (weakly) argue
> that it shouldn’t. And if we think about flatMap in the context of a
> monadic bind (I do, anyway!), it’s especially surprising that the
> transformer is operating in a different monadic context (Optional)
> than the receiver (SequenceType). Unless we made Optional adopt
> SequenceType, in which case we could consider the bind to be happening
> in that context.
>
> In conclusion, I argue that this overload is confusing both to folks
> unfamiliar with FP (because it doesn’t feel like Optionals can be
> flattened) and to folks familiar with FP (because it implies binding
> across monadic contexts).
>
> ~
>
> In terms of what to do instead: I do think that this is a useful
> method, and I’d like to keep this functionality easily accessible!
> Two ideas:
>
> 1. We expose a separate operator like:
>
>> extension SequenceType where Generator.Element: OptionalType { func
>> filterNils() -> [Generator.Element.Wrapped] }
>>
>> // To deal with limitations on protocol extension type restriction:
>> protocol OptionalType { typealias Wrapped func
>> flatMap<Result>(@noescape f: Wrapped -> Result?) -> Result? }
>> extension Optional: OptionalType {}
>>
> Clients would do myArray.map(optionalReturningTransform).filterNils().
> There would be some performance impact from the intermediate array.
>
> 2. We give the foo variant a more specific name, e.g.
>    mappedArrayFilteringNils etc. Naming this is tricky (which probably
>    implies it should be decomposed?).
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ea5637ce/attachment-0001.html>

From plxswift at icloud.com  Fri Dec  4 17:35:22 2015
From: plxswift at icloud.com (plx)
Date: Fri, 04 Dec 2015 17:35:22 -0600
Subject: [swift-evolution] Proposal: Automatic Wrapper Synthesis /
"deriving"
In-Reply-To: <B591D5C1-3E01-4724-B1D7-67F9AE3A2EA5@apple.com>
References: <12DD7FBE-CA6D-4667-A854-9F0FE492A883@icloud.com>
<B591D5C1-3E01-4724-B1D7-67F9AE3A2EA5@apple.com>
Message-ID: <FF8317B5-6DEE-40C2-9579-C8DE32E9C628@icloud.com>


> On Dec 4, 2015, at 4:26 PM, John McCall <rjmccall at apple.com> wrote:
>
>> On Dec 4, 2015, at 1:19 PM, plx <plxswift at icloud.com> wrote:
>> # A `wrapper` / `deriving` Construct
>>
>> I'm sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.
>>
>> The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.
>>
>> ## Design Sketch
>>
>> It ought to be possible to write something like this:
>>
>>   // an example:
>>   struct SectionIndex
>>     wrapping Int
>>     as index
>>     satisfying precondition { $0 >= 0 }
>>     deriving Equatable, Comparable, Hashable {
>>     // declaration can continue in here
>>   }
>>
>> ...which, when compiled, would be "expanded" along these lines:
>>
>>   struct SectionIndex {
>>
>>     // would have been `wrappedValue` w/out the `as index` clause
>>     let index: Int
>>
>>     init(_ index: Int) {
>>       precondition(index >= 0)
>>       // ^ would have been assert(index >= 0)
>>       //   had we used `satisfying { $0 >= 0 }`,
>>       //   and omitted entirely had we omitted a `satisfying` clause
>>       self.index = index
>>     }
>>
>>   }
>>
>>   extension SectionIndex : Equatable {
>>   }
>>
>>   // synthesized unless explicitly written-out
>>   func ==(lhs: SectionIndex, rhs: SectionIndex) -> Bool {
>>     return lhs.index == rhs.index
>>   }
>>
>>   // same for Comparable, Hashable, all done in the obvious way
>>
>>   // there’s a lot of utility in synthesizing something like this,
>>   //  I can expand on it if necessary:
>>   extension SectionIndex: ValueWrapperType {
>>     typealias WrappedType = Int
>>   }
>>
>> ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols' typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.
>>
>> I think this enough to sketch the way the feature would look and how it would work.
>
> I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.
>
> I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.
>
> For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).
>
> John.

Apologies for leaving too much out.

I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).

Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:

- `on` is unambiguous as there’s only one thing it can be “on"
- there’s no ordering-of-operations to have to worry about
- there’s no merging-of-results to have to worry about
- i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)
- there’s no associated-type incoherency to worry about (unless user error introduces it)

…there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).

…and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest.

Thanks for taking the time to read and send feedback.

PS:

On the other hand, if this becomes writable:

protocol WrapperType {
typealias WrappedValue
var wrappedValue: { get }
}

extension WrapperType : Equatable where WrappedValue: Equatable {
}

func ==<W:WrapperType where W.WrappedValue:Equatable>(lhs: W, rhs: W) -> Bool {
return lhs.wrappedValue == rhs.wrappedValue
}

…etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e604e794/attachment.html>

From kevin at sb.org  Fri Dec  4 17:37:50 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 15:37:50 -0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>
References: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>
Message-ID: <1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>

Do you use Xcode to edit Swift? Xcode gives a color to
properties/methods and doesn't color local variables/arguments. Is that
not sufficient to distinguish this? In my experience the color is
actually better than seeing the explicit `self.` because the color can
be recognized faster than reading a word, and is visible in a high-level
"squint" view of the function.

If you're using another editor, well, my best suggestion there is to
look into what it would take to integrate SourceKit functionality into
that editor for more intelligent coloring :)

-Kevin

On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
> +1
>
> I've had a lot of weird things happen that I've traced to mistakes in
> properties having the same name as function arguments. I've hardly
> ever had this issue in modern Obj-C.
>
> I'm a little more ok with functions not needing self as it's less
> likely for those to shadow something like an argument, but I guess the
> consistency would be nice too.
>
> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>> I don't understand the reasoning behind removing the need to access
>> instance properties and functions using self. Swift has always seemed
>> to prefer readability to brevity and the feature makes the
>> distinction between local and instance variables/functions crystal
>> clear. Any good reason I shouldn't go on with the proposition?
>>
>> Just as example, my proposition makes the following piece of code
>> illegal:
>>
>> ``` struct FooBar { var foo: String = "foobar"
>>
>>  func bar() { print(foo) // compiler error print(self.foo) //
>>  compiler happy }
>>
>>  func bar2() { bar() // compiler error self.bar() // compiler happy
>>  } } ```
>> _______________________________________________
>> swift-evolution mailing list swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8dfd0be3/attachment.html>

From gribozavr at gmail.com  Fri Dec  4 17:37:47 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Fri, 4 Dec 2015 15:37:47 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
<1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
Message-ID: <CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>

On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard <kevin at sb.org> wrote:
> Personally, I'd be in favor of making Optional conform to SequenceType. I've filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.

This would be an interesting direction, but we have discussed it a
long time ago, and found an issue in the way it would interact with
implicit promotions to optionals.  Basically, in a call to a function
accepting a Sequence, one would be able to write any non-sequence,
non-optional value, that would be implicitly promoted to optional, and
thus eligible to be passed as a Sequence.  This is the only argument
for not adding this conformance that I know of, but it is a show
stopper unfortunately.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From kevin at sb.org  Fri Dec  4 17:52:30 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 15:52:30 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
<1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
<CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
Message-ID: <1449273150.2882766.458514697.0D2F1330@webmail.messagingengine.com>

Can implicit optional promotion not be redefined to only occur when the
destination type is explicitly optional (as opposed to being generic)?
The problem you describe sounds like it could affect third-party code as
well if anyone has a reason to declare a protocol and extend Optional to
conform to it.

-Kevin Ballard

On Fri, Dec 4, 2015, at 03:37 PM, Dmitri Gribenko wrote:
> On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard <kevin at sb.org> wrote:
> > Personally, I'd be in favor of making Optional conform to SequenceType. I've filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.
>
> This would be an interesting direction, but we have discussed it a
> long time ago, and found an issue in the way it would interact with
> implicit promotions to optionals.  Basically, in a call to a function
> accepting a Sequence, one would be able to write any non-sequence,
> non-optional value, that would be implicitly promoted to optional, and
> thus eligible to be passed as a Sequence.  This is the only argument
> for not adding this conformance that I know of, but it is a show
> stopper unfortunately.
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From amichail at gmail.com  Fri Dec  4 17:53:27 2015
From: amichail at gmail.com (Amir Michail)
Date: Fri, 4 Dec 2015 18:53:27 -0500
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
Message-ID: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>

Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.

For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.

If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.


From mailing at xenonium.com  Fri Dec  4 17:54:32 2015
From: mailing at xenonium.com (Jean-Daniel Dupas)
Date: Sat, 5 Dec 2015 00:54:32 +0100
Subject: [swift-evolution] Proposal: Bridging for Swift Structs in
Objective-C
In-Reply-To: <99C67754-3AE5-4F28-9466-24700135B845@gmail.com>
References: <99C67754-3AE5-4F28-9466-24700135B845@gmail.com>
Message-ID: <F7887CFE-2021-4104-95F7-997B0B6F424D@xenonium.com>

How do you deal with the fact that structs have value semantic, while your generated class have reference semantic ?

> Le 4 déc. 2015 à 23:06, Dan Stenmark <daniel.j.stenmark at gmail.com> a écrit :
>
> Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.
>
> @objc struct Letter {
> 	var address : String?
>
> 	init(withAddress address : String? ) {
> 		self.address = address
> 	}
> }
>
> At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.
>
> Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
> MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’
>
> With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.
>
> @objc(US) struct Letter {
> 	var address : String?
>
> 	init(withAddress address : String? ) {
> 		self.address = address
> 	}
> }
>
> -------
>
> USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
> USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’
>
> Nested types would also be represented via this proposal:
>
> @objc(US) class PostalService {
> 	struct Letter {
> 		var address : String?
>
> 		init(withAddress address : String? ) {
> 			self.address = address
> 		}
> 	}
> }
>
> -------
>
> USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’
> USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’
>
> Dan
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b49e4e0a/attachment.html>

From gribozavr at gmail.com  Fri Dec  4 17:59:21 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Fri, 4 Dec 2015 15:59:21 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <1449273150.2882766.458514697.0D2F1330@webmail.messagingengine.com>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
<1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
<CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
<1449273150.2882766.458514697.0D2F1330@webmail.messagingengine.com>
Message-ID: <CA+Y5xYfx76e2dKNMt=9x6_0sRimO12GobP1zZZmSivXYxXXpWg@mail.gmail.com>

On Fri, Dec 4, 2015 at 3:52 PM, Kevin Ballard <kevin at sb.org> wrote:
> Can implicit optional promotion not be redefined to only occur when the
> destination type is explicitly optional (as opposed to being generic)?
> The problem you describe sounds like it could affect third-party code as
> well if anyone has a reason to declare a protocol and extend Optional to
> conform to it.

It can be created by third-party code, but many other problems can be
created by third-party code, too (like making String conform to
IntegerLiteralConvertible), so it is not a concern for me in that
sense.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From maxs at apple.com  Fri Dec  4 18:00:23 2015
From: maxs at apple.com (Maxwell Swadling)
Date: Fri, 04 Dec 2015 16:00:23 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
<1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
<CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
Message-ID: <2F117775-2592-4740-9E99-6D3EE9DFE164@apple.com>


> On 4 Dec 2015, at 3:37 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard <kevin at sb.org> wrote:
>> Personally, I'd be in favor of making Optional conform to SequenceType. I've filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.
>
> This would be an interesting direction, but we have discussed it a
> long time ago, and found an issue in the way it would interact with
> implicit promotions to optionals.  Basically, in a call to a function
> accepting a Sequence, one would be able to write any non-sequence,
> non-optional value, that would be implicitly promoted to optional, and
> thus eligible to be passed as a Sequence.  This is the only argument
> for not adding this conformance that I know of, but it is a show
> stopper unfortunately.
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

I can not reproduce this behaviour. I'm not sure which version of the compiler had this behaviour.


From gribozavr at gmail.com  Fri Dec  4 18:01:49 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Fri, 4 Dec 2015 16:01:49 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <2F117775-2592-4740-9E99-6D3EE9DFE164@apple.com>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
<1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
<CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
<2F117775-2592-4740-9E99-6D3EE9DFE164@apple.com>
Message-ID: <CA+Y5xYcR4U+BoM-BTuifg--VPESzyDonQpaMZ8+u_7rS7vrwAg@mail.gmail.com>

On Fri, Dec 4, 2015 at 4:00 PM, Maxwell Swadling <maxs at apple.com> wrote:
>
>> On 4 Dec 2015, at 3:37 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>>
>> On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard <kevin at sb.org> wrote:
>>> Personally, I'd be in favor of making Optional conform to SequenceType. I've filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.
>>
>> This would be an interesting direction, but we have discussed it a
>> long time ago, and found an issue in the way it would interact with
>> implicit promotions to optionals.  Basically, in a call to a function
>> accepting a Sequence, one would be able to write any non-sequence,
>> non-optional value, that would be implicitly promoted to optional, and
>> thus eligible to be passed as a Sequence.  This is the only argument
>> for not adding this conformance that I know of, but it is a show
>> stopper unfortunately.
>>
>> Dmitri
>>
>> --
>> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
>> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> I can not reproduce this behaviour. I'm not sure which version of the compiler had this behaviour.

The fact that the compiler does not do it means it is not implementing
the language model.  The compiler is not the source of truth about the
language, or we wouldn't have any bugs -- they all would be features.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From manav1907 at gmail.com  Fri Dec  4 18:04:15 2015
From: manav1907 at gmail.com (Manav Gabhawala)
Date: Fri, 4 Dec 2015 19:04:15 -0500
Subject: [swift-evolution] Type Inferencing For Error Handling (try catch
blocks)
Message-ID: <etPan.566229ff.3f8f3108.10e90@Manav-Gabhawalas-MacBook-Pro.local>

First of all, Swift is an absolute dream of a programming language and is really taking the future of programming in the right direction.

However, it seems backwards to me that everything in swift is type safe and complete (like enum cases) but error handling seems lacking on that end. It would be a huge feature if the compiler could infer the types of errors functions throw and make sure you catch all the different types of errors at the call site. The compiler could also chain the types through multiple throwing function callers. This feature would require no extra work on the programmers part because the compiler would infer the types of errors being thrown. For example,


func foo() throws
{
...
throw ErrorType1.BadRequest
...
throw ErrorType1.NoAuthentication
...
throw ErrorType2.NoResourceFound
}
func main()
{
do
{
foo()
}
catch (ErrorType1.BadRequest)
{

}
catch (ErrorType2.NoResourceFound)
{
}
// Compiler error because ErrorType1.NoAuthentication is not included.
}

Errors can also be chained together such that each function statically identifies the types thrown and if a call is made to a throwing function all the uncaught types are propagated out of the call stack. This would firstly be beneficial because we wouldn’t need the ridiculous empty catch { } block at the end that most people end up doing and secondly would ensure programmers are completely and always aware the possible errors that can be thrown by the function calls they make.

Regards,
Manav
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/1a38a3a4/attachment.html>

From clattner at apple.com  Fri Dec  4 18:04:33 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 16:04:33 -0800
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
Message-ID: <8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>


> On Dec 4, 2015, at 1:18 PM, Per Melin <p at greendale.se> wrote:
>
> On Fri, Dec 4, 2015 at 1:03 AM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>
> I really don’t like having to put the ! suffix in boolean contexts:
>
> To be explicit:
>
>     let a: Bool! = false
>
>     if a == false { }  // Works as expected
>
>     if !a { }  // Works as expected
>
>     if a { }   // "error: optional type 'Bool!' cannot be used as a boolean; test for '!= nil' instead"
>
> Xcode "fixes" the last line like this:
>
>     if (a != nil) { }

Huh ok.  Out of curiosity, why are you using IUOs for this?  I’m interested in (continuing to ) dramatically reduce the prevalence of IOUs in code (eliminating the need to use them), and reduce their power in various ways.  IUOs are one of the biggest sources of surprising behavior in Swift, and while they were a necessary feature to start with, their importance is going down over time.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/74ac8e53/attachment-0001.html>

From david at owensd.io  Fri Dec  4 18:05:56 2015
From: david at owensd.io (David Owens II)
Date: Fri, 4 Dec 2015 16:05:56 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
<B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>
<E43D5828-DEA0-4A44-B795-B4C4D3834FAE@apple.com>
<3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>
Message-ID: <52841F46-67E8-4B5B-AB5E-81A1F9FC6BE8@owensd.io>

I created a pull request for this issue: https://github.com/apple/swift-evolution/pull/26

There was a question on GitHub:

> The proposal seems to be ignoring the negative implementation experience in Java. Why is Swift different?

*Moving the discussion back to the alias*

--

I guess first and foremost, the proposal basically boils down to a syntactical sugar request for what could be considered `Error<T>` and `Result<T, U>` types as the realized return values.

The second fundamental ask is this: give us the ability to handle errors in a way that we can verify all of the potential codepaths with the compiler.

My experience in Java was many years ago, so I can only speak to what I remember, but what I do remember was the proliferation of exceptions for every little minute thing. In the end, they became a mechanism for control flow instead of for actual error cases.

An example would be a `FileNotFoundException`. Is it really exceptional that a file doesn't exist? No, obviously not. Bad API decisions cannot help you abuse language constructs.

The other problem seemed to be the shear number of exceptions that would be marked as throwable from any particular method. In the proposal, I specifically call out only allowing a single type. The purpose is to avoid such a proliferation problem.

This is what all of my do-catch code boils down to:

```swift
do {
try f()
}
catch KnownError.Case1 { }
catch KnownError.ThatsAllOfThem {}
catch { fatalError("Well... if someone else adds another case, I better crash here and hopefully I'll see it before my customers do") }
```

Now, if I chose to use a catch-all `catch` clause, then that's fine. However, Swift forces me to do it today. So my option is to either:

1. Crash the user's app so that a potentially subtle bug doesn't propagate through the app causing a more serious error, or
2. Roll the dice and see what happens. Hopefully I have telemetry data here so I know when these handlers are happening, because the compiler cannot tell me.

If you have another option, I'm willing to hear it.


> On Dec 4, 2015, at 12:54 PM, David Owens II <david at owensd.io> wrote:
>
>
>> On Dec 4, 2015, at 11:54 AM, John McCall <rjmccall at apple.com> wrote:
>>
>>> On Dec 4, 2015, at 11:36 AM, David Owens II <david at owensd.io> wrote:
>>> For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.
>>>
>>>  var vendingMachine = VendingMachine()
>>>  vendingMachine.coinsDeposited = 8
>>>
>>>  do {
>>>      try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
>>>  } catch VendingMachineError.InvalidSelection {
>>>      print("Invalid Selection.")
>>>  } catch VendingMachineError.OutOfStock {
>>>      print("Out of Stock.")
>>>  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
>>>      print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
>>>  } catch { fatalError("this is always needed…”) }
>>
>> But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.
>
> This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.
>
> The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.
>
> That’s my concern.
>
> Instead, if we could annotate throws, we could move this into a compile-time validation.
>
>    enum VendingMachineError: ErrorType {
>        case InvalidSelection
>        case InsufficientFunds(coinsNeeded: Int)
>        case OutOfStock
>    }
>
>    func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws VendingMachineError {
>        let snackName = favoriteSnacks[person] ?? "Candy Bar"
>        try vendingMachine.vend(itemNamed: snackName)
>    }
>
> This allows the compiler to validate the only error information leaving this call site is a `VendingMachineError` and it allows all callers to ensure that they are indeed handling the all of the errors for `VendingMachineError`.
>
> To me, that is a very practical and pragmatic problem and is fundamentally no different than the treatment of exhaustive switch cases needed when dealing with other enum values.
>
> Instead, if I turned the `buyFavoriteSnack` into this:
>
>    enum Error<ErrorType> {
>        case Ok,
>        case Error(ErrorType)
>    }
>
>    func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) -> Error<VendingMachineError>
>
> I then get to leverage the compiler to check that I’m indeed handling all of the VendingMachineErrors.
>
> Yes, I do realize that multiple error types would complicate that, but honestly, I’d rather than the limitation that only a single error type can be propagated up the callstack than to have the ability to have no typed error information at all.
>
> Of course, I can do this myself, but the language is going to win so I still have to deal with how `throws` is treated within the language as a whole.
>
> -David
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From clattner at apple.com  Fri Dec  4 18:07:07 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 16:07:07 -0800
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
Message-ID: <0FF9C6F7-80FC-44F8-AD76-036C2D141D2C@apple.com>


> On Dec 4, 2015, at 3:04 AM, Dapeng Gao <gdapeng at icloud.com> wrote:
>
> It would be handy if Swift can support generic `typealias`s, which would probably look like this:
>
> typealias Handler<Element> = [Element] -> Void

Yes, this is definitely something that I (at least) would like to see.  Patches welcome :-)

-Chris


>
> One common way to achieve this is to define a generic `struct` and use a nested `typealias`:
>
> struct HandlerWrapper<Element> {
>     typealias Hander = [Element] -> Void
> }
>
> HandlerWrapper<SomeType>.Hander
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0ca8487b/attachment.html>

From rjmccall at apple.com  Fri Dec  4 18:07:31 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 16:07:31 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
<B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>
<E43D5828-DEA0-4A44-B795-B4C4D3834FAE@apple.com>
<3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>
Message-ID: <D7E02A74-9F95-44B3-B3C1-8E5B880BC8DB@apple.com>

> On Dec 4, 2015, at 12:54 PM, David Owens II <david at owensd.io> wrote:
>> On Dec 4, 2015, at 11:54 AM, John McCall <rjmccall at apple.com> wrote:
>>
>>> On Dec 4, 2015, at 11:36 AM, David Owens II <david at owensd.io> wrote:
>>> For the most part, I feel that typed errors are more of a response to how we need to handle errors within Swift today.
>>>
>>>  var vendingMachine = VendingMachine()
>>>  vendingMachine.coinsDeposited = 8
>>>
>>>  do {
>>>      try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
>>>  } catch VendingMachineError.InvalidSelection {
>>>      print("Invalid Selection.")
>>>  } catch VendingMachineError.OutOfStock {
>>>      print("Out of Stock.")
>>>  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
>>>      print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
>>>  } catch { fatalError("this is always needed…”) }
>>
>> But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.
>
> This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.

Ah, right, I knew I recognized that example.

This code is intended to demonstrate the ability to chain catches more than it is intended to demonstrate best practice for working with errors.  In real code, this would be better done by giving VendingMachineError a conformance to CustomStringConvertible and just having this at the catch site:

catch {
print(error)
}

> The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.

AnyObject and ImplicitlyUnwrappedOptional come immediately to mind.  I expect that we will gradually more dynamic features, hopefully more like the former than the latter.

> That’s my concern.
>
> Instead, if we could annotate throws, we could move this into a compile-time validation.

I understand what you want to do.  I am saying that, as a language designer, I am reluctant to add features that seem to be, frankly, aspirational bluffs.

I would like you to think about what your concrete error types will look like in their entirety and reconsider whether that static type would actually tell you anything useful.  I certainly don’t believe that they’re worth the costs, which are quite high.

> Yes, I do realize that multiple error types would complicate that, but honestly, I’d rather than the limitation that only a single error type can be propagated up the callstack than to have the ability to have no typed error information at all.

This is what I mean.  Your code will use other code, which will produce its own errors.  Your "single error type” will therefore end up providing at least one case, and probably several, that simply wraps other, opaque error types without providing any extra information.  Thus, it will simply rebroadcast all of your library dependencies, and it will need to be modified whenever your implementation changes.  You will have meaningless translation/wrapping code scattered at every library boundary just to appease the compiler, and anybody trying to recognize specific problems will have to pattern match through an arbitrarily-nested tree of such wrappers.  This is all essentially an inevitable consequence of statically typed errors, and it is a bad outcome.

John.

From jgroff at apple.com  Fri Dec  4 18:08:57 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 16:08:57 -0800
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
Message-ID: <16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>


> On Dec 4, 2015, at 3:04 AM, Dapeng Gao <gdapeng at icloud.com> wrote:
>
> It would be handy if Swift can support generic `typealias`s, which would probably look like this:
>
> typealias Handler<Element> = [Element] -> Void
>
> One common way to achieve this is to define a generic `struct` and use a nested `typealias`:
>
> struct HandlerWrapper<Element> {
>     typealias Hander = [Element] -> Void
> }
>
> HandlerWrapper<SomeType>.Hander

Definitely. I'd say this falls under the (totally arbitrary) umbrella of "obvious things that we didn't get around to implementing yet" instead of formal changes to the language. If you (or anyone else!) were to implement this, we'd consider the pull request immediately.

-Joe

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/27240f64/attachment-0001.html>

From maxs at apple.com  Fri Dec  4 18:13:21 2015
From: maxs at apple.com (Maxwell Swadling)
Date: Fri, 04 Dec 2015 16:13:21 -0800
Subject: [swift-evolution] Reconsidering the (Element -> T?) variant of
SequenceType.flatMap
In-Reply-To: <CA+Y5xYcR4U+BoM-BTuifg--VPESzyDonQpaMZ8+u_7rS7vrwAg@mail.gmail.com>
References: <F001F7AB-1925-492E-B365-485CE779217C@andymatuschak.org>
<1449272097.2878210.458502881.6149AD50@webmail.messagingengine.com>
<CA+Y5xYcyb=+y1a4Qv2FFSNzLpG6nuT05evqyuMv8=8UApSqPWw@mail.gmail.com>
<2F117775-2592-4740-9E99-6D3EE9DFE164@apple.com>
<CA+Y5xYcR4U+BoM-BTuifg--VPESzyDonQpaMZ8+u_7rS7vrwAg@mail.gmail.com>
Message-ID: <FCBCE09B-D76B-4F2C-8F12-A6FD8F6EAA04@apple.com>


> On 4 Dec 2015, at 4:01 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Fri, Dec 4, 2015 at 4:00 PM, Maxwell Swadling <maxs at apple.com> wrote:
>>
>>> On 4 Dec 2015, at 3:37 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>>>
>>> On Fri, Dec 4, 2015 at 3:34 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>> Personally, I'd be in favor of making Optional conform to SequenceType. I've filed a radar on it before, and I seem to recall a message (probably to this list) yesterday suggesting the exact same thing.
>>>
>>> This would be an interesting direction, but we have discussed it a
>>> long time ago, and found an issue in the way it would interact with
>>> implicit promotions to optionals.  Basically, in a call to a function
>>> accepting a Sequence, one would be able to write any non-sequence,
>>> non-optional value, that would be implicitly promoted to optional, and
>>> thus eligible to be passed as a Sequence.  This is the only argument
>>> for not adding this conformance that I know of, but it is a show
>>> stopper unfortunately.
>>>
>>> Dmitri
>>>
>>> --
>>> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
>>> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> I can not reproduce this behaviour. I'm not sure which version of the compiler had this behaviour.
>
> The fact that the compiler does not do it means it is not implementing
> the language model.  The compiler is not the source of truth about the
> language, or we wouldn't have any bugs -- they all would be features.
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

I think you were observing a bug at the time and it is safe to say it isn't part of the language. Otherwise programs like this would be accepted:

func f<a: CustomDebugStringConvertible>(x: a) {
print(x.debugDescription)
}
f(1)

or

1.debugDescription

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/44b256b6/attachment.html>

From clattner at apple.com  Fri Dec  4 18:13:36 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 16:13:36 -0800
Subject: [swift-evolution] Failable arithmetic
In-Reply-To: <81F08B04-0675-442A-A35B-C3DDFBA35E4F@architechies.com>
References: <81F08B04-0675-442A-A35B-C3DDFBA35E4F@architechies.com>
Message-ID: <A4D6524B-3B20-4BE5-8D24-77A1803BC795@apple.com>


> On Dec 4, 2015, at 2:40 PM, Brent Royal-Gordon <brent at architechies.com> wrote:
>
> Currently, Swift has three ways to handle potential overflows and other errors in arithmetic:
>
> 	// 1: Crashes
> 	Int.max + 1
>
> 	// 2: Returns the wrong answer (Int.min in this case)
> 	Int.max &+ 1
>
> 	// 3: Returns a tuple with the value of &+ and a boolean indicating whether it overflowed
> 	Int.addWithOverflow(Int.max, 1)
>
> The problem is, if you want to handle overflows in some simple way, none of these are very good. 1 terminates your app, 2 gives the wrong answer, and 3 is very awkward to use. If you’re, for instance, working with numbers input by the user or downloaded from the Internet, you don’t want 1 or 2, and 3 is a major pain. You’re not looking to figure out exactly what went wrong; you just want to show the user “Arithmetic error” or something, rather than crashing or giving a wildly incorrect answer.
>
> Therefore, I propose that we add failable arithmetic operators (e.g. +?). These return nil on overflow and the result on non-overflow.
>
> 	1 +? 1			// => Optional(1)
> 	Int.max +? 1		// => nil
>
> 	1 -? 1			// => Optional(0)
> 	Int.min -? 1		// => nil
>
> 	1 /? 1			// => Optional(1)
> 	1 /? 0			// => nil
>
> One important consideration is that you ought to be able to chain such operations together into expressions like "m *? x +? c”. The simplest way to do this would be to make these operators take optional arguments; then the implementations would all look something like this:

This is similar to the request for a “force unwrap” operator that is catch’able.  If we were to do something along these lines, I’d rather see these be modeled as operators that can throw, rather than operators that produce an optional.  This will allow them to chain properly and compose correctly with other operations.

There are other questions in this family: we’ve discussed adding saturating integer arithmetic operators as a way to handle this.  We have also discussed the idea of having “-ffast-math” floating point operators as well.  If you take this to the logical conclusion, you end up with large families of operators, all distinguished by magic sigil families that no one can remember :-)

Another way to think about this as a need to modify the behavior of failing operators.  This is not intended as a syntax proposal (just to get the idea across), but wouldn’t it be cool to be able to do:

{
#pragma failure_should_throw    // again, #pragma is really not the right way to spell this :-)
try t = m * x + c
}

and have the operators magically do the right thing?  Then you could generalize the behavior to support other families by using an english word to describe the semantics.

-Chris



>
> 	func +? <Integer: IntegerArithmeticType>(lhs: Integer?, rhs: Integer?) -> Integer? {
> 	    guard let lhs = lhs, rhs = rhs else {
> 	        return nil
> 	    }
>
> 	    let (result, overflowed) = Integer.addWithOverflow(lhs, rhs)
> 	    if overflowed {
> 	        return nil
> 	    }
> 	    else {
> 	        return result
> 	    }
> 	}
>
> However, that might encourage people to misuse these operators to simply perform arithmetic on optional integers even when they don’t want nil-on-overflow. There may be some clever way to get these operators to allow chaining from other failable operators, but prevent the use of other nil-returning expressions; I’m not sure how that would be done, but I wouldn’t mind if Swift forced that sort of hygiene on this feature.
>
> An alternative approach might be to write throwing variants of these operators which require the use of “try". These would have a few advantages: they would naturally short-circuit, they wouldn’t form an attractive nuisance for people trying to do arithmetic with optional integers, and the errors they throw could provide additional detail. However, unlike the association of Optional with ?, there’s no obvious way to associate these operators with the idea of trying and throwing. For this example, I’ve used “+!” purely for lack of a better idea:
>
> 	do {
> 	    print(try 1 +! 2 +! Int.max)
> 	}
> 	catch let error as IntegerArithmeticError {	// or perhaps IntegerArithmeticError<Int>
> 	    print(error)		// AdditionOverflow, or perhaps even AdditionOverflow(3, 9223372036854775807)
> 	}
>
> Of course, if you really did just want an optional, you could always use “try?” with this.
>
> --
> Brent Royal-Gordon
> Architechies
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From jon at jonshier.com  Fri Dec  4 18:14:25 2015
From: jon at jonshier.com (Jon Shier)
Date: Fri, 4 Dec 2015 19:14:25 -0500
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>
References: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>
<1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>
Message-ID: <561EDD12-9747-4B3D-BF0B-06106867DA03@jonshier.com>

Relying on syntax highlighting to convey rather important diagnostic issues is a bad idea for a variety of reason, not least of which is the fact that the highlighting can be customized in such a way as to render the distinction between scopes invisible. Not to mention the fact that Xcode’s syntax highlighting is especially poor by modern IDE standards, often failing to properly highlight code and susceptible to SourceKit crashes at swiftc’s whim. But even if Xcode’s highlighting had been updated in the last 5 years, it still wouldn’t be a good idea.
I love the removal of the self requirement, but the aliasing mentioned by Colin Cornaby is a real issue. Rather than requiring self in all instances, perhaps some additional diagnostics would be in line where the compiler detects aliasing against self properties. Of course, there are still contexts in which aliasing is perfectly fine, like an if let, but most of the time it seems like swiftc is rather lax about pointing out shadowing in the name of safety.


Jon Shier


> On Dec 4, 2015, at 6:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods and doesn't color local variables/arguments. Is that not sufficient to distinguish this? In my experience the color is actually better than seeing the explicit `self.` because the color can be recognized faster than reading a word, and is visible in a high-level "squint" view of the function.
>
> If you're using another editor, well, my best suggestion there is to look into what it would take to integrate SourceKit functionality into that editor for more intelligent coloring :)
>
> -Kevin
>
> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>> +1
>>
>> I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.
>>
>> I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.
>>
>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>>
>>> Just as example, my proposition makes the following piece of code illegal:
>>>
>>> ```
>>> struct FooBar {
>>> var foo: String = "foobar"
>>>
>>> func bar() {
>>> print(foo) // compiler error
>>> print(self.foo) // compiler happy
>>> }
>>>
>>> func bar2() {
>>> bar() // compiler error
>>> self.bar() // compiler happy
>>> }
>>> }
>>> ```
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d3445b84/attachment-0001.html>

From michael at buckleyisms.com  Fri Dec  4 18:14:42 2015
From: michael at buckleyisms.com (Michael Buckley)
Date: Fri, 4 Dec 2015 16:14:42 -0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <CANnbLjzUdW3vrrH0FCZADBS2YEhOpGnd7yNg73nzMGuBD7ehGg@mail.gmail.com>
References: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>
<1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>
<CANnbLjzUdW3vrrH0FCZADBS2YEhOpGnd7yNg73nzMGuBD7ehGg@mail.gmail.com>
Message-ID: <CANnbLjyFPWJiv+mNZUiubO=SuSSQ+49Hmx8wysCqec8bwd1f0Q@mail.gmail.com>

I'm +1 on this, for the reasons already stated by others, but not as
strongly as I was a year ago. I was very worried about this with Swift 1
was first released, but since then, I haven't actually made this mistake,
possibly because I'm so paranoid about it.

However, I really wanted to chime in about whether color should be
considered a sufficient differentiator. For me, it's much more useful to
have a textual differentiator. Perhaps I'm just really bad at memorizing
which colors mean what, but when reading code, the fact that instance
variables have a different coloring does not help me to read and understand
the code. I would sternly advocate that syntax highlighting colors not be
used as the basis for the design of this or any language.

On Fri, Dec 4, 2015 at 3:51 PM, Michael Buckley <michael at buckleyisms.com>
wrote:

> I'm +1 on this, for the reasons already stated by others, but not as
> strongly as I was a year ago. I was very worried about this with Swift 1
> was first released, but since then, I haven't actually made this mistake,
> possibly because I'm so paranoid about it.
>
> However, I really wanted to chime in about whether color should be
> considered a sufficient differentiator. For me, it's much more useful to
> have a textual differentiator. Perhaps I'm just really bad at memorizing
> which colors mean what, but when reading code, the fact that instance
> variables have a different coloring does not help me to read and understand
> the code. I would sternly advocate that syntax highlighting colors not be
> used as the basis for the design of this or any language.
>
>
>
> On Fri, Dec 4, 2015 at 3:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods
>> and doesn't color local variables/arguments. Is that not sufficient to
>> distinguish this? In my experience the color is actually better than seeing
>> the explicit `self.` because the color can be recognized faster than
>> reading a word, and is visible in a high-level "squint" view of the
>> function.
>>
>> If you're using another editor, well, my best suggestion there is to look
>> into what it would take to integrate SourceKit functionality into that
>> editor for more intelligent coloring :)
>>
>> -Kevin
>>
>> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>>
>> +1
>>
>> I've had a lot of weird things happen that I've traced to mistakes
>> in properties having the same name as function arguments. I've hardly ever
>> had this issue in modern Obj-C.
>>
>> I'm a little more ok with functions not needing self as it's less
>> likely for those to shadow something like an argument, but I guess the
>> consistency would be nice too.
>>
>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>
>> I don't understand the reasoning behind removing the need to access
>> instance properties and functions using self. Swift has always seemed to
>> prefer readability to brevity and the feature makes the distinction between
>> local and instance variables/functions crystal clear. Any good reason I
>> shouldn't go on with the proposition?
>>
>> Just as example, my proposition makes the following piece of code illegal:
>>
>> ```
>> struct FooBar {
>> var foo: String = "foobar"
>>
>> func bar() {
>> print(foo) // compiler error
>> print(self.foo) // compiler happy
>> }
>>
>> func bar2() {
>> bar() // compiler error
>> self.bar() // compiler happy
>> }
>> }
>> ```
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> *_______________________________________________*
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ee999620/attachment.html>

From rjmccall at apple.com  Fri Dec  4 18:15:21 2015
From: rjmccall at apple.com (John McCall)
Date: Fri, 04 Dec 2015 16:15:21 -0800
Subject: [swift-evolution] Type Inferencing For Error Handling (try
catch blocks)
In-Reply-To: <etPan.566229ff.3f8f3108.10e90@Manav-Gabhawalas-MacBook-Pro.local>
References: <etPan.566229ff.3f8f3108.10e90@Manav-Gabhawalas-MacBook-Pro.local>
Message-ID: <598691A3-A6F8-428C-BB16-E5C7AE48E5DD@apple.com>

> On Dec 4, 2015, at 4:04 PM, Manav Gabhawala <manav1907 at gmail.com> wrote:
> irst of all, Swift is an absolute dream of a programming language and is really taking the future of programming in the right direction.
>
> However, it seems backwards to me that everything in swift is type safe and complete (like enum cases) but error handling seems lacking on that end. It would be a huge feature if the compiler could infer the types of errors functions throw and make sure you catch all the different types of errors at the call site. The compiler could also chain the types through multiple throwing function callers. This feature would require no extra work on the programmers part because the compiler would infer the types of errors being thrown. For example,

This is a global type-checking problem.  It’s completely blocked by any dynamic features (like protocol or class methods) and library boundaries, so outside of toy examples, you will end up needing exhaustive pattern-matching pretty much everywhere.

John.


>
>
> func foo() throws
> {
> 	...
> 	throw ErrorType1.BadRequest
> 	...
> 	throw ErrorType1.NoAuthentication
> 	...
> 	throw ErrorType2.NoResourceFound
> }
> func main()
> {
> 	do
> 	{
> 		foo()
> 	}
> 	catch (ErrorType1.BadRequest)
> 	{
>
> 	}
> 	catch (ErrorType2.NoResourceFound)
> 	{
> 	}
> 	// Compiler error because ErrorType1.NoAuthentication is not included.
> }
>
> Errors can also be chained together such that each function statically identifies the types thrown and if a call is made to a throwing function all the uncaught types are propagated out of the call stack. This would firstly be beneficial because we wouldn’t need the ridiculous empty catch { } block at the end that most people end up doing and secondly would ensure programmers are completely and always aware the possible errors that can be thrown by the function calls they make.
>
> Regards,
> Manav
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/c351496d/attachment-0001.html>

From jgroff at apple.com  Fri Dec  4 18:18:23 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 16:18:23 -0800
Subject: [swift-evolution] Failable arithmetic
In-Reply-To: <A4D6524B-3B20-4BE5-8D24-77A1803BC795@apple.com>
References: <81F08B04-0675-442A-A35B-C3DDFBA35E4F@architechies.com>
<A4D6524B-3B20-4BE5-8D24-77A1803BC795@apple.com>
Message-ID: <9A1D2C6C-E608-4DEF-9EB5-76479576C54D@apple.com>


> On Dec 4, 2015, at 4:13 PM, Chris Lattner <clattner at apple.com> wrote:
>
>>
>> On Dec 4, 2015, at 2:40 PM, Brent Royal-Gordon <brent at architechies.com> wrote:
>>
>> Currently, Swift has three ways to handle potential overflows and other errors in arithmetic:
>>
>> 	// 1: Crashes
>> 	Int.max + 1
>>
>> 	// 2: Returns the wrong answer (Int.min in this case)
>> 	Int.max &+ 1
>>
>> 	// 3: Returns a tuple with the value of &+ and a boolean indicating whether it overflowed
>> 	Int.addWithOverflow(Int.max, 1)
>>
>> The problem is, if you want to handle overflows in some simple way, none of these are very good. 1 terminates your app, 2 gives the wrong answer, and 3 is very awkward to use. If you’re, for instance, working with numbers input by the user or downloaded from the Internet, you don’t want 1 or 2, and 3 is a major pain. You’re not looking to figure out exactly what went wrong; you just want to show the user “Arithmetic error” or something, rather than crashing or giving a wildly incorrect answer.
>>
>> Therefore, I propose that we add failable arithmetic operators (e.g. +?). These return nil on overflow and the result on non-overflow.
>>
>> 	1 +? 1			// => Optional(1)
>> 	Int.max +? 1		// => nil
>>
>> 	1 -? 1			// => Optional(0)
>> 	Int.min -? 1		// => nil
>>
>> 	1 /? 1			// => Optional(1)
>> 	1 /? 0			// => nil
>>
>> One important consideration is that you ought to be able to chain such operations together into expressions like "m *? x +? c”. The simplest way to do this would be to make these operators take optional arguments; then the implementations would all look something like this:
>
> This is similar to the request for a “force unwrap” operator that is catch’able.  If we were to do something along these lines, I’d rather see these be modeled as operators that can throw, rather than operators that produce an optional.  This will allow them to chain properly and compose correctly with other operations.
>
> There are other questions in this family: we’ve discussed adding saturating integer arithmetic operators as a way to handle this.  We have also discussed the idea of having “-ffast-math” floating point operators as well.  If you take this to the logical conclusion, you end up with large families of operators, all distinguished by magic sigil families that no one can remember :-)
>
> Another way to think about this as a need to modify the behavior of failing operators.  This is not intended as a syntax proposal (just to get the idea across), but wouldn’t it be cool to be able to do:
>
>  {
>      #pragma failure_should_throw    // again, #pragma is really not the right way to spell this :-)
>      try t = m * x + c
>  }
>
> and have the operators magically do the right thing?  Then you could generalize the behavior to support other families by using an english word to describe the semantics.

This is a place where scoped `import` might help too. For instance, you could import a module with throwing variants of the operators:

{
import ThrowingOnOverflow
try t = m * x + c
}

-Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a3e20348/attachment.html>

From jon at jonshier.com  Fri Dec  4 18:19:08 2015
From: jon at jonshier.com (Jon Shier)
Date: Fri, 4 Dec 2015 19:19:08 -0500
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
<8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
Message-ID: <C8CEEDF3-FD93-4036-8075-021F1AA23F68@jonshier.com>

I can’t answer for Per, but, at least in my iOS and OS X programming, I often find myself creating IUOs in view controller to represent properties that I’m guaranteed to have set before viewDidLoad, but don’t want a custom initializer, due to the pain of multiple required init methods. So while my IUO usage is perfectly safe, they’re rather awkward to use.
That said, I’d have to see a specific proposal to tell if it’s any better for my usage than IUOs.


Jon Shier

> On Dec 4, 2015, at 7:04 PM, Chris Lattner <clattner at apple.com> wrote:
>
>>
>> On Dec 4, 2015, at 1:18 PM, Per Melin <p at greendale.se <mailto:p at greendale.se>> wrote:
>>
>> On Fri, Dec 4, 2015 at 1:03 AM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>
>> I really don’t like having to put the ! suffix in boolean contexts:
>>
>> To be explicit:
>>
>>     let a: Bool! = false
>>
>>     if a == false { }  // Works as expected
>>
>>     if !a { }  // Works as expected
>>
>>     if a { }   // "error: optional type 'Bool!' cannot be used as a boolean; test for '!= nil' instead"
>>
>> Xcode "fixes" the last line like this:
>>
>>     if (a != nil) { }
>
> Huh ok.  Out of curiosity, why are you using IUOs for this?  I’m interested in (continuing to ) dramatically reduce the prevalence of IOUs in code (eliminating the need to use them), and reduce their power in various ways.  IUOs are one of the biggest sources of surprising behavior in Swift, and while they were a necessary feature to start with, their importance is going down over time.
>
> -Chris
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/13ca52ff/attachment-0001.html>

From camjknight at mac.com  Fri Dec  4 18:33:30 2015
From: camjknight at mac.com (Cameron Knight)
Date: Fri, 04 Dec 2015 18:33:30 -0600
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
Message-ID: <6D56E1A3-4F8D-4F26-A299-A7FDA8197F93@mac.com>

Unless I'm missing something, this should give you the results you are looking for:

class MyClass {
var foreignKey: Int64 {
didSet {
self.foreignObject = nil
}
}

lazy var foreignObject: ForeignClass! = {
return Database.expensiveSelect(self.foreignKey)
}()
}

Using an Implicitly Unwrapped Optional instead of an Optional allows you to set foreignObject to nil which will give you the same behavior you use in Objective-C (a.k.a. null_resettable).

> To me this actually feels more like something that might fit better as an additional type of optional, rather than a language feature.
>
> Setting this optional to nil could work normally, and any attempt to access the value when nil would cause the reload to occur. The initialization semantics might be a tad ugly though.
>
> var myLazyOpt = ReloadingOptional<ForeignClass>({
> return Database.expensiveSelect(self.foreignKey)
> })
>
> You could probably implement something like this yourself, though I'm not sure how elegant that would be without full language support.
>
> Thanks for your time,
> Cole Kurkowski
> > On Dec 4, 2015, at 07:40, David Hart <david at hartbit.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
> >
> > In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
> >
> > @interface MyClass : NSObject
> >
> > @property (nonatomic) ForeignClass* foreignObject;
> > @property (nonatomic) int64_t foreignKey;
> >
> > @end
> >
> > @implementation MyClass
> >
> > - (void)setForeignKey:(int64_t)foreignKey {
> >   _foreignKey = foreignKey;
> >   _foreignObject = nil;
> > }
> >
> > - (ForeignClass*)foreignObject {
> >   if (!_foreignObject) {
> >       _foreignObject = [Database expensiveSelect:_foreignKey];
> >   }
> >   return _foreignObject;
> > }
> >
> > @end
> >
> > Unfortunately, the lazy keyword in Swift, which was supposed to make the lazy initialization pattern more concsive does not work in this case:
> >
> > class MyClass {
> >   var foreignKey: Int64 {
> >       didSet {
> >           self.foreignObject = nil
> >       }
> >   }
> >
> >   lazy var foreignObject: ForeignClass? = {
> >       return Database.expensiveSelect(self.foreignKey)
> >   }()
> > }
> >
> > I'm forced to rewrite it this way:
> >
> > class MyClass {
> >   var foreignKey: Int64 {
> >       didSet {
> >           self.foreignObject = nil
> >       }
> >   }
> >
> >   private var _foreignObject: ForeignClass? = nil
> >   var foreignObject: ForeignClass? {
> >       if _foreignObject == nil {
> >           _foreignObject = Database.expensiveSelect(self.foreignKey)
> >       }
> >       return _foreignObject
> >   }
> > }
> >
> > When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
> > I want your opinion on three alternatives:
> >
> > 1- Do nothing, and use the slightly uglier Swift example when using a cache.
> > 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
> > 3- Add a cache modifier that re-calcualtes when nil.
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org <https://lists.swift.org/mailman/listinfo/swift-evolution>
> > https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f354edb3/attachment.html>

From daniel.j.stenmark at gmail.com  Fri Dec  4 18:34:16 2015
From: daniel.j.stenmark at gmail.com (Dan Stenmark)
Date: Fri, 4 Dec 2015 16:34:16 -0800
Subject: [swift-evolution] Proposal: Bridging for Swift Structs in
Objective-C
In-Reply-To: <F7887CFE-2021-4104-95F7-997B0B6F424D@xenonium.com>
References: <99C67754-3AE5-4F28-9466-24700135B845@gmail.com>
<F7887CFE-2021-4104-95F7-997B0B6F424D@xenonium.com>
Message-ID: <5555D3B6-956C-4B44-9C4E-99884EFFF9C0@gmail.com>

That’s expected, and there’s not much that can be done about that.  Effectively, much like how Swift’s String value type bridges to the NSString class, this proposal would enable a custom arbitrary struct to have an equivalent Obj-C bridge class with a mutable subclass ala NSMutableString.  The overall goal here is to be able to use Swift structs in some way from Objective-C.

Dan

> On Dec 4, 2015, at 3:54 PM, Jean-Daniel Dupas <mailing at xenonium.com> wrote:
>
> How do you deal with the fact that structs have value semantic, while your generated class have reference semantic ?
>
>> Le 4 déc. 2015 à 23:06, Dan Stenmark <daniel.j.stenmark at gmail.com <mailto:daniel.j.stenmark at gmail.com>> a écrit :
>>
>> Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.
>>
>> @objc struct Letter {
>> 	var address : String?
>>
>> 	init(withAddress address : String? ) {
>> 		self.address = address
>> 	}
>> }
>>
>> At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.
>>
>> Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
>> MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’
>>
>> With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.
>>
>> @objc(US) struct Letter {
>> 	var address : String?
>>
>> 	init(withAddress address : String? ) {
>> 		self.address = address
>> 	}
>> }
>>
>> -------
>>
>> USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
>> USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’
>>
>> Nested types would also be represented via this proposal:
>>
>> @objc(US) class PostalService {
>> 	struct Letter {
>> 		var address : String?
>>
>> 		init(withAddress address : String? ) {
>> 			self.address = address
>> 		}
>> 	}
>> }
>>
>> -------
>>
>> USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’
>> USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’
>>
>> Dan
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8d26424d/attachment-0001.html>

From kevin at sb.org  Fri Dec  4 18:38:21 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 16:38:21 -0800
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <6D56E1A3-4F8D-4F26-A299-A7FDA8197F93@mac.com>
References: <6D56E1A3-4F8D-4F26-A299-A7FDA8197F93@mac.com>
Message-ID: <1449275901.2890859.458535073.4A8DC2EB@webmail.messagingengine.com>

AFAIK this behavior isn't actually documented anywhere, which means the
fact that it works at all is surprising. I'm guessing it does this
because null_resettable properties are modeled as IUOs, but the fact
that it's not documented means I'm leery of relying on it.

I'd much rather that this didn't work, but that there was some syntax to
get access to the underlying storage of the lazy property so you can set
it to nil. Or alternatively that lazy properties actually had an
overloaded setter that accepted `nil` (or just a single setter that took
an optional, but I'm not convinced that's a good idea), and then
null_resettable could be translated directly into a lazy property.
Though I still actually want access to the underlying storage because I
want to be able to test if the lazy property is already initialized
without having to make the initializer record that fact elsewhere.

-Kevin Ballard

On Fri, Dec 4, 2015, at 04:33 PM, Cameron Knight wrote:
> Unless I'm missing something, this should give you the results you are
> looking for:
>
> class MyClass { var foreignKey: Int64 {        didSet {
> self.foreignObject = nil        }    }
>
> lazy var foreignObject: ForeignClass! = {
> returnDatabase.expensiveSelect(self.foreignKey)    }() }
>
> Using an Implicitly Unwrapped Optional instead of an Optional allows
> you to set foreignObject to nil which will give you the same behavior
> you use in Objective-C (a.k.a. null_resettable).
>
>
>> To me this actually feels more like something that might fit better
>> as an additional type of optional, rather than a language feature.

Setting this optional to nil could work normally, and any attempt to
access the value when nil would cause the reload to occur. The
initialization semantics might be a tad ugly though.

var myLazyOpt = ReloadingOptional<ForeignClass>({ return
Database.expensiveSelect(self.foreignKey) })

You could probably implement something like this yourself, though I'm
not sure how elegant that would be without full language support.

Thanks for your time, Cole Kurkowski
>* On Dec 4, 2015, at 07:40, David Hart <david at hartbit.com[1]> wrote:
*>**>* In Objective-C, I often used the lazy initialization pattern to
implement a cache for expensive operations. For exemple, here is an
often used scenario in a project where objects behind foreign keys in a
database ORM are only fetched when necessary: *>**>* @interface MyClass
: NSObject *>**>* @property (nonatomic) ForeignClass* foreignObject; *>*
@property (nonatomic) int64_t foreignKey; *>**>* @end *>**>*
@implementation MyClass *>**>* - (void)setForeignKey:(int64_t)foreignKey
{ *>*   _foreignKey = foreignKey; *>*   _foreignObject = nil; *>* }
*>**>* - (ForeignClass*)foreignObject { *>*   if (!_foreignObject) { *>*
_foreignObject = [Database expensiveSelect:_foreignKey]; *>*   } *>*
return _foreignObject; *>* } *>**>* @end *>**>* Unfortunately, the lazy
keyword in Swift, which was supposed to make the lazy initialization
pattern more concsive does not work in this case: *>**>* class MyClass {
*>*   var foreignKey: Int64 { *>*       didSet { *>*
self.foreignObject = nil *>*       } *>*   } *>**>*   lazy var
foreignObject: ForeignClass? = { *>*       return
Database.expensiveSelect(self.foreignKey) *>*   }() *>* } *>**>* I'm
forced to rewrite it this way: *>**>* class MyClass { *>*   var
foreignKey: Int64 { *>*       didSet { *>*           self.foreignObject
= nil *>*       } *>*   } *>**>*   private var _foreignObject:
ForeignClass? = nil *>*   var foreignObject: ForeignClass? { *>*
if _foreignObject == nil { *>*           _foreignObject =
Database.expensiveSelect(self.foreignKey) *>*       } *>*       return
_foreignObject *>*   } *>* } *>**>* When thinking about it, I came to
the conclusion that the use cases of lazy seem very narrow compared to
how useful the lazy initialization pattern was in Objective-C. *>* I
want your opinion on three alternatives: *>**>* 1- Do nothing, and use
the slightly uglier Swift example when using a cache. *>* 2- Modify lazy
semantics to re-calculates when nil (I think this is the worst
solution). *>* 3- Add a cache modifier that re-calcualtes when nil. *>*
_______________________________________________ *>* swift-evolution
mailing list *>*swift-evolution at swift.org[2]*>*
https://lists.swift.org/mailman/listinfo/swift-evolution*
>
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution



Links:

1. https://lists.swift.org/mailman/listinfo/swift-evolution
2. https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e620baf4/attachment.html>

From gbs at canishe.com  Fri Dec  4 18:45:45 2015
From: gbs at canishe.com (Gaelan Bright Steele)
Date: Fri, 4 Dec 2015 16:45:45 -0800
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
<54601BD9-E250-4BC2-98E0-769C4C5E8AAB@fifthace.com>
Message-ID: <5C5252D3-EDC2-4F8C-AF2D-D1B4F2131AE1@canishe.com>

JavaScript had a `with` operator for a while, but it was deprecated due to some edge cases, specifically something like this:

// Codebase 1 (a library)
class A {}
internal func foo() {
print("correct result")
}
func doSomethingWithA(a: A) {
with a {
/* do something with A */
foo()
/* do something else with A */
}
}
// Codebase 2 (Application code depending on CB1)
class B: A {
// presumably written without knowledge of the global foo
func foo() {
print("completely different result”)
}
}
doSomethingWithA(B()) //What happens here? Does the foo() call the global foo or B’s foo?

I think that in a static programming language we could avoid this problem by having the `with` operator use the knowledge of the type it is passed at compile-time (ignoring the runtime type). Still, we need to be careful about edge cases here.
> On Dec 4, 2015, at 1:35 PM, Sean Heber <sean at fifthace.com> wrote:
>
>>
>> On Dec 4, 2015, at 3:27 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>
>>
>>> On Dec 4, 2015, at 1:24 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>
>>> PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example:
>>>
>>> let task = NSTask()
>>> task.launchPath = "/usr/bin/mdfind"
>>> task.arguments = ["kMDItemDisplayName == *.playground"]
>>> task.standardOutput = pipe
>>>
>>> Here's another:
>>>
>>> let questionLabel = UILabel()
>>> questionLabel.textAlignment = .Center
>>> questionLabel.font =  UIFont(name:"DnealianManuscript", size: 72)
>>> questionLabel.text = currentQuestion.questionText
>>> questionLabel.numberOfLines = 0
>>>
>>> You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:
>>> This code feels unnecessarily redundant
>>> This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.
>>> The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.
>>> Further, if you have many instances to set up there's no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.
>>>
>>> PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:
>>>
>>> let task = NSTask()>>{
>>>    launchPath = "/usr/bin/mdfind"
>>>    arguments = ["kMDItemDisplayName == *.playground"]
>>>    standardOutput = pipe
>>> }
>>>
>>> In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.
>>
>> In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same 'self'. In Dart they use '..' for this:
>>
>> let task = NSTask()
>>  ..launchPath = "..."
>>  ..arguments = [...]
>>  ..standardOutput = pipe
>>
>> The nice thing about that is that it's a bit more generally applicable than just initialization.
>>
>> -Joe
>
> I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P
>
> with let task = NSTask() {
>    launchPath = "/usr/bin/mdfind"
>    arguments = ["kMDItemDisplayName == *.playground"]
>    standardOutput = pipe
> }
>
> Also valid:
>
> with someVariable {
>    func1()
>    func2(“etc")
> }
>
> Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).
>
> l8r
> Sean
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/4e8c8b21/attachment-0001.html>

From manav1907 at gmail.com  Fri Dec  4 18:49:22 2015
From: manav1907 at gmail.com (Manav Gabhawala)
Date: Fri, 4 Dec 2015 19:49:22 -0500
Subject: [swift-evolution]  Extending Failable Initializers
Message-ID: <etPan.56623492.1941fa2e.10e90@Manav-Gabhawalas-MacBook-Pro.local>

Its possible to extend the functionality of failable initializers beyond what they are capable of by making the parameters failable too. For instance:


var someString : String? = “1” // Assume for some reason this is optional

// Here the Int’s failable initializer allows for an optional Int even
// though it was only actually written for a non optional type because
// the failable initializer fails when you give it a nil value.
guard let someInt = Int(someString)
else { return }
// There are many possible use cases for this:

enum Some : String { case A, B, C }
let optionalString: String? = “A"
// This works too.
let value = Some(rawValue: optionalString)
// And can be extended out too.
let image = NSImage(named: optionalString)


There are several reasons this can be beneficial. This allows you to initialize using optional types and can be really useful if you’re trying to initialize things with stuff downloaded from the network or when using NSUserDefaults, etc. That way you don’t need to explicitly bind everything you use to ensure non-null values twice but the failable initializers take care of it for you, so its kind of like chaining the nil value to the failable initializers.

Regards,
Manav Gabhawala


From kevin at sb.org  Fri Dec  4 18:52:41 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 16:52:41 -0800
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
References: <D0C10115-D335-483B-BBEB-1ED9BB47EFCD@ericasadun.com>
<090593E1-4D93-45B8-8212-33468EDD4AE7@apple.com>
Message-ID: <1449276761.2894550.458542505.1002DB4F@webmail.messagingengine.com>

I'd be in favor of a solution like the '..' operator. Using a block-
based syntax for this seems like it's already close enough to defining
something like

func with<T>(x: T, @noescape _ f: inout T -> Void) -> T {    var value =
x    f(&value)    return value }

that it would be better to just go with the function instead of
complicating the Swift syntax. But the '..' operator has some nice
properties, such as being able to say something like

someLayoutConstraint =
label.leftAnchor.constraintEqualToAnchor(view.leftAnchor)..active = true

(I'm assuming here that '..' works by returning the receiver as the
value of the subsequent expression, rather than merely allowing several
'..' operators to be chained together, but I'm not actually familiar
with how this works in Smalltalk and Dart)

-Kevin Ballard

On Fri, Dec 4, 2015, at 01:27 PM, Joe Groff wrote:
> In Smalltalk and Dart, you can do this with method cascades, which
> apply multiple methods to the same 'self'. In Dart they use '..'
> for this:
>
> let task = NSTask()  ..launchPath = "..."  ..arguments = [...]
> ..standardOutput = pipe
>
> The nice thing about that is that it's a bit more generally applicable
> than just initialization.
>
> -Joe
>
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/64b7101e/attachment.html>

From p at greendale.se  Fri Dec  4 19:00:58 2015
From: p at greendale.se (Per Melin)
Date: Sat, 5 Dec 2015 02:00:58 +0100
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
<8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
Message-ID: <CADS5KKUX9Ux2zzdPR8KCgJFpCt76Kn+-=8ESVCEr17Ozq86GqA@mail.gmail.com>

On Sat, Dec 5, 2015 at 1:04 AM, Chris Lattner <clattner at apple.com> wrote:

>
> On Dec 4, 2015, at 1:18 PM, Per Melin <p at greendale.se> wrote:
>
> To be explicit:
>
>     let a: Bool! = false
>
>     if a == false { }  // Works as expected
>
>     if !a { }  // Works as expected
>
>     if a { }   // "error: optional type 'Bool!' cannot be used as a
> boolean; test for '!= nil' instead"
>
> Xcode "fixes" the last line like this:
>
>     if (a != nil) { }
>
>
> Huh ok.  Out of curiosity, why are you using IUOs for this?
>

I will leave that question to Amir who created this thread. I try to avoid
IUOs altogether. I only found the above when trying to figure out what the
heck he was talking about.



> I’m interested in (continuing to ) dramatically reduce the prevalence of
> IOUs in code (eliminating the need to use them), and reduce their power in
> various ways.  IUOs are one of the biggest sources of surprising behavior
> in Swift, and while they were a necessary feature to start with, their
> importance is going down over time.
>

What surprised me was the IIUOs. I did not expect Swift to happily help me
shoot myself in the foot quite so easily as this.

func isNegative(i: Int?) -> Bool {
return i < 0
}

(No, I have never actually written code like this. I can't tell how likely
it is that I would make this mistake.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/53b552a3/attachment.html>

From brent at architechies.com  Fri Dec  4 19:11:07 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 17:11:07 -0800
Subject: [swift-evolution] Failable arithmetic
In-Reply-To: <A4D6524B-3B20-4BE5-8D24-77A1803BC795@apple.com>
References: <81F08B04-0675-442A-A35B-C3DDFBA35E4F@architechies.com>
<A4D6524B-3B20-4BE5-8D24-77A1803BC795@apple.com>
Message-ID: <1BCB7F1D-B89A-45DC-B07C-F4A3A1E8D590@architechies.com>

> Another way to think about this as a need to modify the behavior of failing operators.  This is not intended as a syntax proposal (just to get the idea across), but wouldn’t it be cool to be able to do:
>
>  {
>      #pragma failure_should_throw    // again, #pragma is really not the right way to spell this :-)
>      try t = m * x + c
>  }
>
> and have the operators magically do the right thing?  Then you could generalize the behavior to support other families by using an english word to describe the semantics.

I like the idea of having multiple semantics and selecting the one you want for an entire expression, rather than dangling sigils on all your operators.

This is, of course, easy to do if you introduce enough abstraction: <https://gist.github.com/brentdax/6fc5d717f7c85e159ec7> I assume this would be very slow as written, but perhaps the optimizer could do something along the lines of constant folding to convert the operation tree into straight-line code.

--
Brent Royal-Gordon
Architechies


From gogosapiens at gmail.com  Fri Dec  4 19:29:03 2015
From: gogosapiens at gmail.com (=?utf-8?B?0JjQs9C+0YDRjCDQpdC80YPRgNC10YY=?=)
Date: Sat, 5 Dec 2015 04:29:03 +0300
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <C8CEEDF3-FD93-4036-8075-021F1AA23F68@jonshier.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
<8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
<C8CEEDF3-FD93-4036-8075-021F1AA23F68@jonshier.com>
Message-ID: <CC4779EF-F105-4CC4-8572-4F35067EEF07@gmail.com>

Also don’t like this pain with multiple required init methods in UIViewController, have to use IUO for properties here.
-Igor.

> On Dec 5, 2015, at 03:19, Jon Shier <jon at jonshier.com> wrote:
>
> 	I can’t answer for Per, but, at least in my iOS and OS X programming, I often find myself creating IUOs in view controller to represent properties that I’m guaranteed to have set before viewDidLoad, but don’t want a custom initializer, due to the pain of multiple required init methods. So while my IUO usage is perfectly safe, they’re rather awkward to use.
> 	That said, I’d have to see a specific proposal to tell if it’s any better for my usage than IUOs.
>
>
> Jon Shier
>
>> On Dec 4, 2015, at 7:04 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>
>>>
>>> On Dec 4, 2015, at 1:18 PM, Per Melin <p at greendale.se <mailto:p at greendale.se>> wrote:
>>>
>>> On Fri, Dec 4, 2015 at 1:03 AM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>>
>>> I really don’t like having to put the ! suffix in boolean contexts:
>>>
>>> To be explicit:
>>>
>>>     let a: Bool! = false
>>>
>>>     if a == false { }  // Works as expected
>>>
>>>     if !a { }  // Works as expected
>>>
>>>     if a { }   // "error: optional type 'Bool!' cannot be used as a boolean; test for '!= nil' instead"
>>>
>>> Xcode "fixes" the last line like this:
>>>
>>>     if (a != nil) { }
>>
>> Huh ok.  Out of curiosity, why are you using IUOs for this?  I’m interested in (continuing to ) dramatically reduce the prevalence of IOUs in code (eliminating the need to use them), and reduce their power in various ways.  IUOs are one of the biggest sources of surprising behavior in Swift, and while they were a necessary feature to start with, their importance is going down over time.
>>
>> -Chris
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/6e168fae/attachment-0001.html>

From brent at architechies.com  Fri Dec  4 19:29:31 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 17:29:31 -0800
Subject: [swift-evolution] Extending Failable Initializers
In-Reply-To: <etPan.56623492.1941fa2e.10e90@Manav-Gabhawalas-MacBook-Pro.local>
References: <etPan.56623492.1941fa2e.10e90@Manav-Gabhawalas-MacBook-Pro.local>
Message-ID: <E8E3DACD-F229-48AA-9177-64E391518279@architechies.com>

> Its possible to extend the functionality of failable initializers beyond what they are capable of by making the parameters failable too. For instance:
>
> 	var someString : String? = “1” // Assume for some reason this is optional
>
> 	// Here the Int’s failable initializer allows for an optional Int even
> 	// though it was only actually written for a non optional type because
> 	// the failable initializer fails when you give it a nil value.
> 	guard let someInt = Int(someString)
> 	else { return }

You can get this kind of behavior with higher-order programming:

var someString: String? = “1”
guard let someInt = someString.flatMap(Int.init) else { return }

This says “if someString is nil, return nil; otherwise, initialize an Int passing the unwrapped value, and return the result”.

In general, Optional.map and Optional.flatMap let you do optional-chaining-like things in a much more general way. They’re pretty neat!

--
Brent Royal-Gordon
Architechies


From kevin at sb.org  Fri Dec  4 19:29:56 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 17:29:56 -0800
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
<16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>
Message-ID: <1449278996.2900573.458561001.2AA2DC14@webmail.messagingengine.com>

I've filed a ticket on bugs.swift.org to serve as a hint to any
interested party that this is something that is actively desired and
patches are welcome.

https://bugs.swift.org/browse/SR-64

I figure that's probably the right course of action for obvious
improvements that we know we want but aren't candidates for the full swift-
evolution process.

-Kevin Ballard

On Fri, Dec 4, 2015, at 04:08 PM, Joe Groff wrote:
>
>> On Dec 4, 2015, at 3:04 AM, Dapeng Gao <gdapeng at icloud.com> wrote:
>>
>> It would be handy if Swift can support generic `typealias`s, which
>> would probably look like this:
>>
>> typealias Handler<Element> = [Element] -> Void
>>
>> One common way to achieve this is to define a generic `struct` and
>> use a nested `typealias`:
>>
>> struct HandlerWrapper<Element> { typealias Hander = [Element]
>> -> Void }
>>
>> HandlerWrapper<SomeType>.Hander
>
> Definitely. I'd say this falls under the (totally arbitrary) umbrella
> of "obvious things that we didn't get around to implementing yet"
> instead of formal changes to the language. If you (or anyone else!)
> were to implement this, we'd consider the pull request immediately.
>
> -Joe
>
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ec386144/attachment.html>

From clattner at apple.com  Fri Dec  4 19:35:32 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 17:35:32 -0800
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <CADS5KKUX9Ux2zzdPR8KCgJFpCt76Kn+-=8ESVCEr17Ozq86GqA@mail.gmail.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
<8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
<CADS5KKUX9Ux2zzdPR8KCgJFpCt76Kn+-=8ESVCEr17Ozq86GqA@mail.gmail.com>
Message-ID: <A4ABDD80-B275-41DC-8F24-C95B24E780D8@apple.com>

On Dec 4, 2015, at 5:00 PM, Per Melin <p at greendale.se> wrote:
>> Xcode "fixes" the last line like this:
>>
>>     if (a != nil) { }
>
> Huh ok.  Out of curiosity, why are you using IUOs for this?
>
> I will leave that question to Amir who created this thread. I try to avoid IUOs altogether. I only found the above when trying to figure out what the heck he was talking about.
>
>
> I’m interested in (continuing to ) dramatically reduce the prevalence of IOUs in code (eliminating the need to use them), and reduce their power in various ways.  IUOs are one of the biggest sources of surprising behavior in Swift, and while they were a necessary feature to start with, their importance is going down over time.
>
> What surprised me was the IIUOs. I did not expect Swift to happily help me shoot myself in the foot quite so easily as this.
>
> func isNegative(i: Int?) -> Bool {
>     return i < 0
> }
>
> (No, I have never actually written code like this. I can't tell how likely it is that I would make this mistake.)

This is a separate problem.  One of the things we plan to discuss (once things settle down a bit) is how to narrow the implicit conversion from T to T? in cases like this.  This implicit promotion, as well as the T <-> T! promotions are problematic in a number of ways, and we need a holistic solution to them.

We have several specific ideas, but Joe Pamer is driving the effort and he is preoccupied with personal things for the next several weeks.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/4f45344a/attachment.html>

From kevin at sb.org  Fri Dec  4 19:35:57 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 17:35:57 -0800
Subject: [swift-evolution] Extending Failable Initializers
In-Reply-To: <E8E3DACD-F229-48AA-9177-64E391518279@architechies.com>
References: <etPan.56623492.1941fa2e.10e90@Manav-Gabhawalas-MacBook-Pro.local>
<E8E3DACD-F229-48AA-9177-64E391518279@architechies.com>
Message-ID: <1449279357.2901447.458561817.198194AE@webmail.messagingengine.com>

Note that this exact example actually fails to compile:

error: type of expression is ambiguous without more context
guard let someInt = someString.flatMap(Int.init) else { return }
~~~~^~~~

The problem here is the initializer has a default parameter, but default
parameters are lost when treating methods (including initializers) as
function types. So you can actually say something like

let args: (String, Int)? = ("1", 10)
guard let someInt = args.flatMap(Int.init) else { return }

It would be great if the Swift language rules were altered to allow both
of these forms to work.

-Kevin Ballard

On Fri, Dec 4, 2015, at 05:29 PM, Brent Royal-Gordon wrote:
> > Its possible to extend the functionality of failable initializers beyond what they are capable of by making the parameters failable too. For instance:
> >
> > 	var someString : String? = “1” // Assume for some reason this is optional
> >
> > 	// Here the Int’s failable initializer allows for an optional Int even
> > 	// though it was only actually written for a non optional type because
> > 	// the failable initializer fails when you give it a nil value.
> > 	guard let someInt = Int(someString)
> > 	else { return }
>
> You can get this kind of behavior with higher-order programming:
>
> 	var someString: String? = “1”
> 	guard let someInt = someString.flatMap(Int.init) else { return }
>
> This says “if someString is nil, return nil; otherwise, initialize an Int
> passing the unwrapped value, and return the result”.
>
> In general, Optional.map and Optional.flatMap let you do
> optional-chaining-like things in a much more general way. They’re pretty
> neat!
>
> --
> Brent Royal-Gordon
> Architechies
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From jgroff at apple.com  Fri Dec  4 20:45:33 2015
From: jgroff at apple.com (Joe Groff)
Date: Fri, 04 Dec 2015 18:45:33 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
Message-ID: <B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>


> On Dec 4, 2015, at 3:27 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> The @convention(selector) as proposed is a neat idea, but it will
> completely break target/action. This is because the
> @convention(selector) is a strongly-typed function signature, but
> target/action relies on the fact that it can provide 2 parameters to the
> method and this will work with any method that matches one of the 3
> forms (2 forms on OS X):
>
> - (void)action
> - (void)action:(id)sender
> - (void)action:(id)sender forEvent:(UIEvent *)event
>
> But these 3 forms translate into the 3 distinct types:
>
> @convention(selector) T -> () -> Void
> @convention(selector) T -> AnyObject -> Void
> @convention(selector) T -> AnyObject -> UIEvent -> Void
>
> But the only way to handle this in a reasonable fashion is to allow
> these 3 types to implicitly coerce to each other, which seems like a bad
> idea and removes a lot of the benefit of trying to strongly type them.
> There's also the confusion around the receiver type T here; a selector
> can't possibly encode the receiver type, because the whole point of
> selectors is the caller doesn't care what the receiver is, it only cares
> how the receiver behaves. You could make the receiver be AnyObject, but
> now you can create a selector from one type and call it with another
> type.

Why couldn't this be covered by overloads? It's unlikely we'd be able to import selectors from Objective-C to specific types because of this and other reasons, so we'd still need an untyped Selector type, but we could easily provide well-typed overloads in Swift overlays that convert from typed selectors to untyped.
>
> Furthermore, how would you even handle this for methods that take
> selectors of arbitrary types, e.g. respondsToSelector() or various obj-c
> runtime methods? Allowing implicit conversion to a single common form
> like `@convention(selector) () -> Void` is no better than keeping the
> current Selector (and is in fact worse because it implies strong typing
> where there is none), and keeping the current Selector in addition to
> @convention(selector) is not a great solution either (it leaves the
> language as more complex, without really providing the strong typing
> that @convention(selector) looks like it's trying to do).

It seems to me that things like performSelector could be replaced by generics in the overlay in a similar way. 'respondsToSelector' is probably fine taking untyped Selectors (with a subtype relationship from @convention(selector) T -> U to Selector).

-Joe

> I also worry that allowing something like @convention(selector) would be
> confusing, because it would look like the following two code snippets
> should be identical:
>
>    foo.performSelector(Foo.handleBar)
>
> and
>
>    let sel = Foo.handleBar
>    foo.performSelector(sel)
>
> But this can't work because it requires the ability to convert from
> @convention(swift) T -> U into @convention(selector) T -> U, which can't
> work because not all closures will have associated selectors. You'd need
> to introduce something else, like @convention(objc_swift) T -> U, that
> includes a selector and implicitly converts to both @convention(swift)
> and @convention(objc), but this is quickly becoming needlessly complex.
> And it still doesn't solve the type-safety issues above.
>
> ---
>
> My simpler proposal here would be to simply embrace the fact that
> selectors are weakly-typed, to say that any API that wants type safety
> should be changed to just take a closure (or to have an overload that
> does), and then to just have a bit of Swift syntax that gives you the
> selector for any method. I'm not sure offhand what the syntax should be,
> but I filed a couple of radars a long time ago that also asked for a
> syntax to get at the willSet/didSet property observers and the
> underlying storage for lazy properties, and suggested that these could
> all use the same bit of syntax. I don't know what the syntax should be,
> but general meaning of the syntax would be to access pieces of
> information about members (where "members" means properties and
> methods). As an example of what I'm talking about, if we decided that
> the syntax should be to use `` to access things like "foo.storage" as a
> value the way you can use it for keywords-as-identifiers, then you could
> say things like
>
>    notificationCenter.addObserver(foo, selector:
>    Foo.`observeBar.selector`, name: /* ... */)
>    self.`lazyBar.storage` = nil
>    self.`baz.didSet`(oldValue: qux)
>
> Note that I'm not actually suggesting this is the right syntax to use
> (while I like that it re-uses existing syntax, it's also pretty weird),
> but the concept is sound.
>
> -Kevin Ballard
>
> On Fri, Dec 4, 2015, at 02:26 PM, Joe Groff wrote:
>>
>>> On Dec 4, 2015, at 2:22 PM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>>>
>>> Currently in Swift you can get a closure by referring to a method:
>>>
>>> 	let x = NSString.hasPrefix
>>> 	// x is of type NSString -> String -> Bool
>>>
>>> Something that would be useful here is if the closure created from Objective-C methods were special in that they could implicitly be converted to a Selector. Instead of writing manually a selector as a string, you'd just have to refer to the method, and you know there's no typo (or else you get a compile-time error). For instance, adding an observer to a NSNotificationCenter would work like this:
>>>
>>> 	notificationCenter.addObserver(self, selector: MyClass.observeNotification, name: NSSomeNotificationName, object: nil)
>>>
>>> This, making sure the correct selector is used for the designated method, seem like it should be somewhat more important in Swift 3 if it includes Evolution Proposal 0005 that suggests many Objective-C methods will be given Swift-specific names.
>>> https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md
>>>
>>> But why stop there when you can go one step further and actually improve type-safety? Instead of taking a Selector parameter, the NSNotificationCenter.addObserver method above could request a @convention(selector) closure of this form:
>>>
>>> 	@convention(selector) AnyObject -> NSNotification -> Void
>>>
>>> Under the hood that closure is still a plain selector pointer, but the compiler attaches proper type information to the arguments. Since `addObserver` now declares it wants a selector with the given signature, the compiler can enforce that the arguments and return type for the passed selector are compatible. You
>>
>> This is a great approach, and it's mostly exactly what I've had in mind
>> for this. Another nice thing about @convention(selector) is that the
>> compiler could also context-free closures, like with @convention(c), by
>> compiling them down to categories with mangled methods.
>>
>>>
>>> Moreover, the @convention(selector) closure you get can then be used as a normal closure inside a Swift method that can be called from Objective-C:
>>>
>>> 	@objc func callSelector(selector: @convention(selector) NSString -> String -> Bool) -> Bool {
>>> 		let str = NSString(string: "hello")
>>> 		return selector(str)("hell")
>>> 	}
>>>
>>> 	let x = NSString.hasPrefix
>>> 	// x is of type @convention(selector) NSString -> String -> Bool
>>> 	callSelector(x)
>>>
>>> So that would make selectors less error-prone because the compiler can type-check them, and you can use selectors in Swift code in a very natural manner.
>>
>> I would say that 'let x = NSString.hasPrefix' should still give you a
>> @convention(swift) function value by default; that's what we do with
>> method references in general, but you could ask for a
>> @convention(selector) reference explicitly:
>>
>> let x: @convention(selector) X -> Y -> Z = X.hasPrefix
>>
>> -Joe
>>
>>> - - -
>>>
>>> This is inspired from the D/Objective-C compiler I prototyped a while ago. There, I made selectors typed with their arguments because:
>>>
>>> 1. I wanted to preserve D's type-safety while still being able to use selectors, and
>>> 2. I needed to decouple selector names from method names in the code; this would later allow me to implement overloading by adding some name mangling in selectors. Obtaining selectors by referring to the method allowed selectors to become an implementation detail while providing a nice way to associate the parameter types.
>>>
>>> For reference, here is the meager documentation for that feature:
>>> https://michelf.ca/projects/d-objc/syntax/#selector-literals
>>> And for the selector-name mangling:
>>> https://michelf.ca/projects/d-objc/syntax/#generated-selectors
>>>
>>>
>>> --
>>> Michel Fortin
>>> michel.fortin at michelf.ca
>>> https://michelf.ca
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From michel.fortin at michelf.ca  Fri Dec  4 20:46:12 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Fri, 4 Dec 2015 21:46:12 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
Message-ID: <13B323C5-8361-437F-88B3-62F9659C83DF@michelf.ca>

Le 4 déc. 2015 à 18:27, Kevin Ballard <kevin at sb.org> a écrit :

> The @convention(selector) as proposed is a neat idea, but it will
> completely break target/action. This is because the
> @convention(selector) is a strongly-typed function signature, but
> target/action relies on the fact that it can provide 2 parameters to the
> method and this will work with any method that matches one of the 3
> forms (2 forms on OS X):
>
> - (void)action
> - (void)action:(id)sender
> - (void)action:(id)sender forEvent:(UIEvent *)event
>
> But these 3 forms translate into the 3 distinct types:
>
> @convention(selector) T -> () -> Void
> @convention(selector) T -> AnyObject -> Void
> @convention(selector) T -> AnyObject -> UIEvent -> Void
>
> But the only way to handle this in a reasonable fashion is to allow
> these 3 types to implicitly coerce to each other, which seems like a bad
> idea and removes a lot of the benefit of trying to strongly type them.

I don't think it removes the benefit of strongly typing them. The reason to strongly type selectors is to avoid generating buggy code such as when passing an Int to a method that expects a pointer. Implicitly converting "@convention(selector) T -> (AnyObject, UIEvent) -> Void" to "@convention(selector) T -> () -> Void" is perfectly safe (we know it and do all the time) and the compiler could verify that for you before allowing the conversion to happen.

I agree with you though that if this implicit conversion does not work, it's going to be annoying despite the type-safety benefits.


> There's also the confusion around the receiver type T here; a selector
> can't possibly encode the receiver type, because the whole point of
> selectors is the caller doesn't care what the receiver is, it only cares
> how the receiver behaves. You could make the receiver be AnyObject, but
> now you can create a selector from one type and call it with another
> type.

That's indeed true. I hadn't realized. The fact that the selector lives separately from its target object makes things difficult because the expected target type is almost always going to be AnyObject. Implicit conversions cannot happen safely in the direction SubType to BaseType for the arguments, including the target object. That makes Joe Groff's approach the only type-safe solution: make an extension of the base object and generate a method that does what you want. Which means that instead of this:

view.action = MyObject.doSomething

you could write this:

view.action = { (target: AnyObject) in {
(target as! MyObject).doSomething()
}

...which is safe. Maybe the compiler should just auto-generate that boilerplate for you.


> Furthermore, how would you even handle this for methods that take
> selectors of arbitrary types, e.g. respondsToSelector() or various obj-c
> runtime methods? Allowing implicit conversion to a single common form
> like `@convention(selector) () -> Void` is no better than keeping the
> current Selector (and is in fact worse because it implies strong typing
> where there is none), and keeping the current Selector in addition to
> @convention(selector) is not a great solution either (it leaves the
> language as more complex, without really providing the strong typing
> that @convention(selector) looks like it's trying to do).

Having a @convention(selector) does not mean you have to get rid of Selector everywhere. When you have a selector of an unknown kind (such as in respondsToSelector), just use Selector, as you do currently. Perhaps it should be renamed to UnsafeSelector.

And with an UnsafeSelector you should be able to unsafely convert it to a selector closure that you can then call:

let sel: UnsafeSelector = NSString.lengthOfBytesUsingEncoding
// sel has no type information for the target or arguments
let closure = sel.convertTo<@convention(selector) NSString -> UInt -> Int>()
// now that we've reinjected the type information, we can call it
let result = closure("hello")(NSASCIIStringEncoding)

One important reason for having @convention(selector) is so you can call the selector from Swift.


> I also worry that allowing something like @convention(selector) would be
> confusing, because it would look like the following two code snippets
> should be identical:
>
>    foo.performSelector(Foo.handleBar)
>
> and
>
>    let sel = Foo.handleBar
>    foo.performSelector(sel)
>
> But this can't work because it requires the ability to convert from
> @convention(swift) T -> U into @convention(selector) T -> U, which can't
> work because not all closures will have associated selectors.

No, you certainly can't convert from @convention(swift) to @convention(selector). The reverse is possible however. That's why my first idea was to have "Foo.handleBar" be @convention(selector) with implicit conversion to @convention(swift) when necessary. Then Joe Groff suggested that this should only happen if you explicitly specify the type of "sel" to be @convention(selector). It makes sense from a performance standpoint that you don't want to wrap calls more than necessary.

Like you I feel like the two code snippets above should be equivalent. But if there's going to be a performance cost because of an implicit conversion from @convention(selector) to @convention(swift), then I think Joe's idea is the right one: force the user to specify early the type he needs and don't implicitly convert between conventions. Which gives you this:

let sel: UnsafeSelector = Foo.handleBar
foo.performSelector(sel)

or this (type-safe using objc_msgSend):

let sel: @convention(selector) Foo -> () -> () = Foo.handleBar
sel(foo)()

or this (type-safe using swift convention):

let closure = Foo.handleBar
closure(foo)() // likely the most performant


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From brent at architechies.com  Fri Dec  4 20:49:58 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 18:49:58 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
Message-ID: <12115F95-4B8C-4051-AC36-AAAEFA979356@architechies.com>

> But these 3 forms translate into the 3 distinct types:
>
> @convention(selector) T -> () -> Void
> @convention(selector) T -> AnyObject -> Void
> @convention(selector) T -> AnyObject -> UIEvent -> Void

Niggle: the third one is actually "T -> (AnyObject, UIEvent) -> Void”—arguments that go in the same parentheses live together in a tuple. Well, technically, the UIEvent is optional too, but that’s beside the point.

Addressing something out of order:

> There's also the confusion around the receiver type T here; a selector
> can't possibly encode the receiver type, because the whole point of
> selectors is the caller doesn't care what the receiver is, it only cares
> how the receiver behaves. You could make the receiver be AnyObject, but
> now you can create a selector from one type and call it with another
> type.

I’m not entirely sure what you’re objecting to here.

If you’re worried about compile-time type checking of the call site, generics can help tie the selector to the object it’s intended for:

func addTarget<T: NSObject>(target: T?, action: @convention(selector) T -> AnyObject -> Void, forControlEvents: UIControlEvents)

Within the body of addTarget(_:action:forControlEvents:), the type information would be attached to the action *variable*, not the *value* in the variable. This would allow you to support a syntax like this for calling a selector “closure”, instead of relying on performSelector or NSInvocation:

action(target)(sender)

I believe that natively, this would only allow a ‘target’ that ‘is’ whatever class the action was taken from. Anything less wouldn’t typecheck.

Casting from a typed @convention(selector) closure to a plain Selector would indeed strip away its type information, and casting from a Selector back to an @convention(selector) closure would be unsafe. Perhaps Selector would become “UnsafeSelector" and you’d need an unsafeBitcast() to cast it back into a callable typed selector.

Or are you objecting to the fact that, if the Swift bridging doesn’t correctly reflect the semantics, Objective-C code can still do the wrong thing? Objective-C code can *always* do the wrong thing.

> But the only way to handle this in a reasonable fashion is to allow
> these 3 types to implicitly coerce to each other, which seems like a bad
> idea and removes a lot of the benefit of trying to strongly type them.

Or you can bridge it with several overloaded signatures:

// This is what’s actually in the Objective-C
func addTarget(target: AnyObject?, action: UnsafeSelector, forControlEvents: UIControlEvents)

// These three are added by the bridging layer
func addTarget<T: NSObject>(target: T?, action: @convention(selector) T -> () -> Void, forControlEvents: UIControlEvents)
func addTarget<T: NSObject>(target: T?, action: @convention(selector) T -> (AnyObject) -> Void, forControlEvents: UIControlEvents)
func addTarget<T: NSObject>(target: T?, action: @convention(selector) T -> (AnyObject, UIEvent?) -> Void, forControlEvents: UIControlEvents)

This looks slightly gross, but it’s just reflecting the underlying sloppiness of the target-action mechanism. And it would have helped me a couple months ago, when I forgot that UIGestureRecognizer does *not* have a form which takes an event and lost an hour trying to write a gesture recognizer handler which inspected it. (For added fun, this broke in different ways on the simulator and device.)

> Furthermore, how would you even handle this for methods that take
> selectors of arbitrary types, e.g. respondsToSelector() or various obj-c
> runtime methods?

By taking a Selector, just as it works currently:

func respondsToSelector(selector: UnsafeSelector) -> Bool

By bridging it as a generic method:

func respondsToSelector<Args, Return>(selector: @convention(selector) Self -> Args -> Return) -> Bool

By bridging it with Any, which permits any tuple, and otherwise can’t bridge to Objective-C:

func respondsToSelector(selector: @convention(selector) Self -> Any -> Any) -> Bool

(I *think* the first Any is technically unsound—it should be a bottom type—but a selector with an Any would be uncallable anyway.)

I can think of a few options.

> Allowing implicit conversion to a single common form
> like `@convention(selector) () -> Void` is no better than keeping the
> current Selector (and is in fact worse because it implies strong typing
> where there is none), and keeping the current Selector in addition to
> @convention(selector) is not a great solution either (it leaves the
> language as more complex, without really providing the strong typing
> that @convention(selector) looks like it's trying to do).

The way I see it, @convention(selector) is an opt-in form of strong typing. You can work with bare selectors if you want, just as you can pass around AnyObjects if you want, but when you *do* use @convention(selector) you get extra safety checks.

And, to add a carrot, you could probably get benefits at the call site too—I see no reason Swift couldn’t infer the proper type based on the type of the target parameter if you said:

incrementButton.addTarget(self, action: .increment, forControlEvents: .PrimaryActionTriggered)

> My simpler proposal here would be to simply embrace the fact that
> selectors are weakly-typed, to say that any API that wants type safety
> should be changed to just take a closure (or to have an overload that
> does), and then to just have a bit of Swift syntax that gives you the
> selector for any method.

In "should be changed to just take a closure”, the “just” carries a lot of water. For instance, that “just” includes redesigning the entire target-action system in two UI frameworks. And how does the concept of dispatching to the first responder apply here? Or is the responder chain basically dead to Swift?

Beware the word “just”.

--
Brent Royal-Gordon
Architechies


From michel.fortin at michelf.ca  Fri Dec  4 21:03:03 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Fri, 4 Dec 2015 22:03:03 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
Message-ID: <696892CF-2B26-41A5-87DA-599CF995DB9C@michelf.ca>

Le 4 déc. 2015 à 21:45, Joe Groff <jgroff at apple.com> a écrit :
>
>> - (void)action
>> - (void)action:(id)sender
>> - (void)action:(id)sender forEvent:(UIEvent *)event
>
> Why couldn't this be covered by overloads? It's unlikely we'd be able to import selectors from Objective-C to specific types because of this and other reasons, so we'd still need an untyped Selector type, but we could easily provide well-typed overloads in Swift overlays that convert from typed selectors to untyped.

Good point. Overloads in framework overlays. That's much simpler than having the compiler trying to infer compatibility as I just suggested.


Le 4 déc. 2015 à 21:49, Brent Royal-Gordon <brent at architechies.com> a écrit :

> If you’re worried about compile-time type checking of the call site, generics can help tie the selector to the object it’s intended for:
>
> 	func addTarget<T: NSObject>(target: T?, action: @convention(selector) T -> AnyObject -> Void, forControlEvents: UIControlEvents)

Nice.

Damned OS X with its target and action properties you have to set separately. Of course you could use the extension below, but it's still bad that you can then set the two properties separately.

extension NSControl {
func setTarget<T: NSObject>(target: T?, action: @convention(selector) T -> AnyObject -> Void) {
self.target = target
self.action = action
}
}


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From dan.appel00 at gmail.com  Fri Dec  4 21:05:26 2015
From: dan.appel00 at gmail.com (Dan Appel)
Date: Sat, 05 Dec 2015 03:05:26 +0000
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
Message-ID: <CADQN+5as0oDhsK=QfvGEE1LzPYnQESHgQR4i6+P6QH+cr8bv-A@mail.gmail.com>

I'm not sure how I feel about this, but in either case, why limit it to
default parameters? It's useful in other situations, too.

Take this for example:
struct Foo {
let bar: String
let bas: Int
let baz: Double
init(self.bar: String, self.bas: Int, bax: Int) {
self.baz = Double(bax)
}
}

where the need to say

self.bar = bar
self.bas = bas

is now avoided.

On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas <me at tal.by> wrote:

> There’s lots of boilerplate of initializing structs with stored properties
> and initializer parameters. I’d like to create a syntax for alleviating
> that in the 90% case.
>
> ```swift
> struct Foo {
>     let bar: String
>     let baz: Int
>
>     init(self.bar: String = "default", counter self.baz: Int) {
>     }
> }
> ```
>
> This would be identical to:
> ```swift
> struct Foo {
>     let bar: String
>     let baz: Int
>
>     init(bar: String = "default", counter baz: Int) {
>         self.bar = bar
>         self.baz = baz
>     }
> }
> ```
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
--
Dan Appel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/901ade23/attachment.html>

From jaden.geller at gmail.com  Fri Dec  4 21:58:30 2015
From: jaden.geller at gmail.com (Jaden Geller)
Date: Fri, 4 Dec 2015 19:58:30 -0800
Subject: [swift-evolution] Idea for declaring expected types and value
ranges
Message-ID: <7F577EFC-40CE-4D93-9358-5D00DA5FB90F@gmail.com>

This seems to me like it’d require dependent types for all but trivial things. For example, imagine the condition `x > 0`. The compiler must know how all function that act on `x` behave. It must know that, when acting on a positive, multiplying by a negative always flips the sign, subtracting a positive sometimes flips the sign, and adding a positive never flips the sign. The compiler must be taught rules about each each and every operation. It’s infeasible for the Swift compiler to infer these rules automatically with the current type system.

I’d definitely find it exciting if Swift ventured into dependent typing territory, but it’d be a significant complication of the type system.

— Jaden Geller

From matthew at anandabits.com  Fri Dec  4 21:59:21 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Fri, 4 Dec 2015 21:59:21 -0600
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <CADQN+5as0oDhsK=QfvGEE1LzPYnQESHgQR4i6+P6QH+cr8bv-A@mail.gmail.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<CADQN+5as0oDhsK=QfvGEE1LzPYnQESHgQR4i6+P6QH+cr8bv-A@mail.gmail.com>
Message-ID: <B2247953-F125-4344-821A-8EDBAD969FB0@anandabits.com>

I think this idea scratches at the surface of a problem with initializers that definitely merits some attention.  Boilerplate is common in initializers which can lead to types that don’t allow as much flexibility to callers as might be desirable.

More importantly, it can also lead to “initialized” instances that are not fully or properly configured, (implicitly unwrapped?) optional members, and mutability that shouldn’t be necessary past the initial configuration stage of the instance.  For example, if a type provides a family of initializers, but also has several members which are intended to be initialized / configured directly by callers a developer could choose to avoid the boilerplate by declaring the additional members as as an implicitly unwrapped optional var members.  No doubt this is a bad idea.  If the caller does not initialize all of the additional members there is a bomb waiting to go off.  Furthermore, there is the potential for mutation after initialization that may not be expected or intended.  By requiring a nontrivial amount of boilerplate to avoid this situation the language is unintentionally nudging lazy developers towards bad practices like this.

Let's start with the current proposal but go a bit further and see how much boilerplate can be removed.  The type information is already known from the property declaration, and furthermore a default may also be available in the property declaration.

struct Foo {
let bar: String
let bas: Int = 1
let bat:  Float = 0
let bax: String = “default"
let baz: Double

// self.bar is known to be a String but does not have a default value so it must be provided by the caller
// self.bas is known to be an Int and implicitly has a default value of 1 specified by the property
// so it does not need to be provided by the caller
// self.bat is known to be a Float, but the default is overridden to be 1 instead of 0
// external labels are provided that correspond to the names of the properties
init(self.bar, self.bas, self.bat = 1) {
// the initializer does not receive a value for baz and the property does not provide a default
// so it must be initialized here before the first phase of initialization is complete
// if all stored properties had received values through parameters or through property defaults
// the first phase of initialization would have already been completed when the body of the initializer was entered
self.baz = someComputedDoubleValue()
// now all stored properties have been initialized so the first phase of initialization is complete
}
}

This structure allows us to remove the boilerplate of the property type and default value.

Given the significant difference from regular function parameters, it may make sense to set these apart syntactically in some way, although I am not sure what would make the most sense.  For example, we could just have a second parameter tuple in the initializer declaration which represents the “member parameters” to the initializer like this:

init(foo: Int)(self.bar, self.bas, self.bat = 1)

or a vertical pipe like this:

init(foo: Int | self.bar, self.bas, self.bat = 1)

Setting these “member parameters” apart syntactically could also facilitate additional mechanisms to further reduce boilerplate if we find that the same group of “member parameters" exist for several different initializers in the same type.  For example, it might become possible to implement a memberwise initializer like this:

// @automembers expands to match all stored properties
init()(@automembers) {}

At this point we have eliminated virtually all of the boilerplate, encouraging developers to use concise *and* safe, yet still flexible initialization strategies.

Matthew



> On Dec 4, 2015, at 9:05 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>
> I'm not sure how I feel about this, but in either case, why limit it to default parameters? It's useful in other situations, too.
>
> Take this for example:
> struct Foo {
>     let bar: String
>     let bas: Int
>     let baz: Double
>     init(self.bar: String, self.bas: Int, bax: Int) {
>         self.baz = Double(bax)
>     }
> }
>
> where the need to say
>
> self.bar = bar
> self.bas = bas
>
> is now avoided.
>
> On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas <me at tal.by <mailto:me at tal.by>> wrote:
> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.
>
> ```swift
> struct Foo {
>     let bar: String
>     let baz: Int
>
>     init(self.bar: String = "default", counter self.baz: Int) {
>     }
> }
> ```
>
> This would be identical to:
> ```swift
> struct Foo {
>     let bar: String
>     let baz: Int
>
>     init(bar: String = "default", counter baz: Int) {
>         self.bar = bar
>         self.baz = baz
>     }
> }
> ```
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> --
> Dan Appel
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a1c79ea3/attachment.html>

From dgregor at apple.com  Fri Dec  4 22:35:13 2015
From: dgregor at apple.com (Douglas Gregor)
Date: Fri, 04 Dec 2015 20:35:13 -0800
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
<16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>
Message-ID: <E971616A-DD04-4CE5-B1B9-142A2DB4433B@apple.com>



Sent from my iPhone

> On Dec 4, 2015, at 4:08 PM, Joe Groff <jgroff at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 3:04 AM, Dapeng Gao <gdapeng at icloud.com> wrote:
>>
>> It would be handy if Swift can support generic `typealias`s, which would probably look like this:
>>
>> typealias Handler<Element> = [Element] -> Void
>>
>> One common way to achieve this is to define a generic `struct` and use a nested `typealias`:
>>
>> struct HandlerWrapper<Element> {
>>     typealias Hander = [Element] -> Void
>> }
>>
>> HandlerWrapper<SomeType>.Hander
>
> Definitely. I'd say this falls under the (totally arbitrary) umbrella of "obvious things that we didn't get around to implementing yet" instead of formal changes to the language. If you (or anyone else!) were to implement this, we'd consider the pull request immediately.

I would rather not have such an umbrella, because how would one know what's in it and who gets to decide? Even "obvious" things need design, and some things that might sound like obvious goodness can benefit from review. ++ sounded like obvious goodness at one point in time, too.

- Doug

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/7e3ff8f0/attachment.html>

From babt at me.com  Fri Dec  4 22:36:29 2015
From: babt at me.com (Bill Abt)
Date: Fri, 04 Dec 2015 23:36:29 -0500
Subject: [swift-evolution] fcntl() should be added to the standard library.
Message-ID: <BFC1C4B7-37FE-4C60-A169-793F48823609@me.com>

The fcntl() API is a variadic standard “C” library and as such not supported currently by Swift.  Any visit to GitHub looking for a socket implementation will invariably find a .c or .mm file included that exposes fcntl() to Swift via a shim.  There are only 3 forms of this API, all returning int.  The first takes 2 integers and sets the 3rd to 0.  The second takes 3 integers.  The last and final form take 2 integers and a void pointer.  Looking at the standard library source, it’s trivial to implement.  It’ll take longer to write the tests than it will to write the functions.  Once implemented, it would eliminate the need for shims for this API.

This seems like one of those obvious things that just haven’t been implemented yet, no?


Regards,
Bill Abt
babt at me.com <mailto:babt at me.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0b311f44/attachment-0001.html>

From xiaozhenbang at gmail.com  Fri Dec  4 22:37:02 2015
From: xiaozhenbang at gmail.com (Stark Shaw)
Date: Sat, 5 Dec 2015 04:37:02 +0000
Subject: [swift-evolution] Proposal: More Command-line Compatibilities
Message-ID: <0BEE6C45-92F3-49ED-A8B6-58DAE4476819@gmail.com>

Hi all,
I have an idea which is add a full CLI feature framework(like Console in C#), e.g. scanf-like feature to support input in the terminal. And also, differentiate print() and println().

All the best.


From harlan at harlanhaskins.com  Fri Dec  4 22:56:01 2015
From: harlan at harlanhaskins.com (Harlan Haskins)
Date: Fri, 4 Dec 2015 23:56:01 -0500
Subject: [swift-evolution] Revisiting Optionals as Sequences
Message-ID: <5C599593-83C0-40E0-A1C0-0244119AFB6E@harlanhaskins.com>

Y’know, map and flatMap being part of SequenceType is really a misnomer.

We could always just add Functor and Monad in the standard library!

protocol Functor {
typealias A
typealias B
typealias FB

func map(_: A -> B) -> FB
}

protocol Monad: Functor {
static func pure(f: A) -> Self
func flatMap(f: A -> FB) -> FB
func >>=(x: Self, f: A -> FB) -> FB
}

infix operator >>= { associativity left }
func >>=<M: Monad>(x: M, f: M.A -> M.FB) -> M.FB {
return x.flatMap(f)
}
> A few months ago I sent a pair of radars (22414579 nee 22448207 and 21961711) about Optional’s extant overloading of flatMap and how it doesn’t align with either the STL or the reasons given for the closing of both radars.
>
> > This issue behaves as intended based on the following:
> >
> > Yes, we are aware that this overload of flatMap could be viewed as unconventional. Nevertheless, it is useful and fits the overload set in general, if you view Optional as a sequence of zero or one T. It resembles this overload, where the closure returns an arbitrary sequence:
> >
> > extension SequenceType {
> >   public func flatMap<S : SequenceType>(transform: (Generator.Element) -> S) -> [S.Generator.Element]
> > }
> >
> > The type checker ensures that there is no ambiguity between the two overloads, and we don't see a reason to give one of the overloads a different name (and force users to learn it, and differentiate between the two), since conceptually the operation is the same.
>
> If Swift wishes to regard Optionals as collections with 1 or 0 elements, then I propose that it should reflect that thinking with additions to the standard library.
>
> Possible changes include:
>
> 1) Remove or rename Optional’s flatMap.
> This would cause a bit of breaking behavior, but it’s nothing some fixits couldn’t help with.
>
> 2) Add a SequenceType instance for Optional.
> This kills 2 birds with 1 stone in that, if the radar rejection is to ring true, Optional should have a SequenceType instance in the STL, and such an instance would automatically come with its own proper overloading flatMap necessitating change 1.
>
>  Over in TypeLift land we’ve already implemented what we believe the SequenceType extensions should look like (https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 <https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145> <https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 <https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145>>).

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/186a6e80/attachment.html>

From crk at fastmail.com  Fri Dec  4 23:20:22 2015
From: crk at fastmail.com (crk at fastmail.com)
Date: Fri, 4 Dec 2015 23:20:22 -0600
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <B2247953-F125-4344-821A-8EDBAD969FB0@anandabits.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<CADQN+5as0oDhsK=QfvGEE1LzPYnQESHgQR4i6+P6QH+cr8bv-A@mail.gmail.com>
<B2247953-F125-4344-821A-8EDBAD969FB0@anandabits.com>
Message-ID: <445b3686-2a66-4f10-a18b-e6cd3f9bebf0@Spark>

I'm not entirely sure what your proposal changes, other than omitting the argument labels and us wing self to refer to the property. Could you try a trivial example that would be runnable if the change was implemented?

Thanks for your time,
Cole Kurkowski

On Dec 4, 2015, 21:59 -0600, Matthew Johnson<matthew at anandabits.com>, wrote:
> I think this idea scratches at the surface of a problem with initializers that definitely merits some attention.Boilerplate is common in initializers which can lead to types that don’t allow as much flexibility to callers as might be desirable.
>
> More importantly, it can also lead to “initialized” instances that are not fully or properly configured, (implicitly unwrapped?) optional members, and mutability that shouldn’t be necessary past the initial configuration stage of the instance.For example, if a type provides a family of initializers, but also has several members which are intended to be initialized / configured directly by callers a developer could choose to avoid the boilerplate by declaring the additional members as as an implicitly unwrapped optional var members.No doubt this is a bad idea.If the caller does not initialize all of the additional members there is a bomb waiting to go off.Furthermore, there is the potential for mutation after initialization that may not be expected or intended.By requiring a nontrivial amount of boilerplate to avoid this situation the language is unintentionally nudging lazy developers towards bad practices like this.
>
> Let's start with the current proposal but go a bit further and see how much boilerplate can be removed.The type information is already known from the property declaration, and furthermore a default may also be available in the property declaration.
>
> struct Foo {
> let bar: String
> let bas: Int = 1
> let bat:Float = 0
> let bax: String = “default"
> let baz: Double
>
> // self.bar is known to be a String but does not have a default value so it must be provided by the caller
> // self.bas is known to be an Int and implicitly has a default value of 1 specified by the property
> // so it does not need to be provided by the caller
> // self.bat is known to be a Float, but the default is overridden to be 1 instead of 0
> // external labels are provided that correspond to the names of the properties
> init(self.bar, self.bas, self.bat = 1) {
> // the initializer does not receive a value for baz and the property does not provide a default
> // so it must be initialized here before the first phase of initialization is complete
> // if all stored properties had received values through parameters or through property defaults
> // the first phase of initialization would have already been completed when the body of the initializer was entered
> self.baz = someComputedDoubleValue()
> // now all stored properties have been initialized so the first phase of initialization is complete
> }
> }
>
> This structure allows us to remove the boilerplate of the property type and default value.
>
> Given the significant difference from regular function parameters, it may make sense to set these apart syntactically in some way, although I am not sure what would make the most sense.For example, we could just have a second parameter tuple in the initializer declaration which represents the “member parameters” to the initializer like this:
>
> init(foo: Int)(self.bar, self.bas, self.bat = 1)
>
> or a vertical pipe like this:
>
> init(foo: Int | self.bar, self.bas, self.bat = 1)
>
> Setting these “member parameters” apart syntactically could also facilitate additional mechanisms to further reduce boilerplate if we find that the same group of “member parameters" exist for several different initializers in the same type.For example, it might become possible to implement a memberwise initializer like this:
>
> // @automembers expands to match all stored properties
> init()(@automembers) {}
>
> At this point we have eliminated virtually all of the boilerplate, encouraging developers to use concise *and* safe, yet still flexible initialization strategies.
>
> Matthew
>
>
>
> > On Dec 4, 2015, at 9:05 PM, Dan Appel<dan.appel00 at gmail.com(mailto:dan.appel00 at gmail.com)>wrote:
> > I'm not sure how I feel about this, but in either case, why limit it to default parameters? It's useful in other situations, too.
> >
> > Take this for example:
> > struct Foo {
> > let bar: String
> > let bas: Int
> > let baz: Double
> > init(self.bar: String, self.bas: Int, bax: Int) {
> > self.baz = Double(bax)
> > }
> > }
> >
> > where the need to say
> >
> > self.bar = bar
> > self.bas = bas
> >
> > is now avoided.
> > On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas<me at tal.by(mailto:me at tal.by)>wrote:
> > > There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.
> > >
> > > ```swift
> > > struct Foo {
> > > let bar: String
> > > let baz: Int
> > >
> > > init(self.bar: String = "default", counter self.baz: Int) {
> > > }
> > > }
> > >
> > > ```
> > >
> > > This would be identical to:
> > > ```swift
> > > struct Foo {
> > > let bar: String
> > > let baz: Int
> > >
> > > init(bar: String = "default", counter baz: Int) {
> > > self.bar = bar
> > > self.baz = baz
> > > }
> > > }
> > >
> > > ```
> > >
> > > _______________________________________________
> > > swift-evolution mailing list
> > > swift-evolution at swift.org(mailto:swift-evolution at swift.org)
> > > https://lists.swift.org/mailman/listinfo/swift-evolution
> > --
> > Dan Appel
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org(mailto:swift-evolution at swift.org)
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/cd9a8125/attachment-0001.html>

From austinzheng at gmail.com  Fri Dec  4 23:57:21 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Fri, 4 Dec 2015 21:57:21 -0800
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <E971616A-DD04-4CE5-B1B9-142A2DB4433B@apple.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
<16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>
<E971616A-DD04-4CE5-B1B9-142A2DB4433B@apple.com>
Message-ID: <0A7EA827-4E74-4C2F-95E6-FA5B1BB9201E@gmail.com>

Perhaps we should "formalize" a proposal as a starting point for further discussion/development.

Currently, Swift supports defining an alias for an existing non-generic or fully bound generic type using the 'typealias' keyword:

typealias Foo = Int
typealias Bar = Dictionary<String : Int>

In this example, the type referred to by the identifier 'Foo' is exactly equivalent to the existing type Int. Any occurrence of the type identifier "Int" can be replaced in a Swift source code text by the typealias identifier "Foo" without changing the behavior of the program.

When a typealias is defined, the underlying type can be the underlying type of another typealias:

typealias Baz = Foo // Baz is typealias of Int now

However, the typealias mechanism does not allow an unbound generic type to be typealiased:

// This fails
typealias MyArray = Array
// as does this
typealias MyArray<T> = Array<T>

There are at least two potential ways to extend the typealias mechanism to support typealiasing unbound generic types.

1. Allow an unbound generic type to be directly typealiased to a different identifier. The alias can then be used in place of the original generic type identifier anywhere where the latter would have been valid, in such a way that a direct textual substitution of the original identifier for the new identifier (or vice versa) would not change the meaning of a Swift program.

typealias HashMap = Dictionary
let x : HashMap<String, Int> = ["hello" : 1234]	// identical to x : Dictionary<String : Int> = ...

2. Allow an identifier to serve as a typealias to a partially specialized or fully unspecialized generic type. When declaring the typealias identifier, type parameter aliases can be declared as well within a generic type signature, akin to the "<>" generic type signature supported by type decls and function decls. When declaring the underlying type, unbound generic type parameters can then be bound to the type parameter aliases defined alongside the typealias identifier. Instead of an type parameter identifier, a concrete type can be used to partially specialize the type referred to by the typealias. For example:

typealias HomogenousDict<T> = Dictionary<T, T>
// A declaration of HomogenousDict<Int> is exactly equivalent to a declaration of Dictionary<Int, Int>.
typealias DontDoThis<U, T> = Dictionary<T, U>
// A declaration of DontDoThis<String, Int> is exactly equivalent to a declaration of Dictionary<Int, String>.
// This might be a potential issue.
typealias IntKeyDicts<Value> = Dictionary<Int, Value>
// A declaration of IntKeyDicts<String> is then exactly equivalent to a declaration of Dictionary<Int, String>

I hope this can serve as a starting point for discussion of the design of this feature, as well as identification of potential semantic and implementation issues.

Best,
Austin


> On Dec 4, 2015, at 8:35 PM, Douglas Gregor <dgregor at apple.com> wrote:
>
>
>
> Sent from my iPhone
>
> On Dec 4, 2015, at 4:08 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>
>>
>>> On Dec 4, 2015, at 3:04 AM, Dapeng Gao <gdapeng at icloud.com <mailto:gdapeng at icloud.com>> wrote:
>>>
>>> It would be handy if Swift can support generic `typealias`s, which would probably look like this:
>>>
>>> typealias Handler<Element> = [Element] -> Void
>>>
>>> One common way to achieve this is to define a generic `struct` and use a nested `typealias`:
>>>
>>> struct HandlerWrapper<Element> {
>>>     typealias Hander = [Element] -> Void
>>> }
>>>
>>> HandlerWrapper<SomeType>.Hander
>>
>> Definitely. I'd say this falls under the (totally arbitrary) umbrella of "obvious things that we didn't get around to implementing yet" instead of formal changes to the language. If you (or anyone else!) were to implement this, we'd consider the pull request immediately.
>
> I would rather not have such an umbrella, because how would one know what's in it and who gets to decide? Even "obvious" things need design, and some things that might sound like obvious goodness can benefit from review. ++ sounded like obvious goodness at one point in time, too.
>
>   - Doug
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f6860ad6/attachment.html>

From austinzheng at gmail.com  Sat Dec  5 00:03:18 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Fri, 4 Dec 2015 22:03:18 -0800
Subject: [swift-evolution] Generic `typealias`s
In-Reply-To: <0A7EA827-4E74-4C2F-95E6-FA5B1BB9201E@gmail.com>
References: <77641AE4-2AE5-42FF-91B8-CDFC918966FA@icloud.com>
<16100495-9FE9-4029-A918-5D0A1B20E961@apple.com>
<E971616A-DD04-4CE5-B1B9-142A2DB4433B@apple.com>
<0A7EA827-4E74-4C2F-95E6-FA5B1BB9201E@gmail.com>
Message-ID: <CA5E2A9A-5F3C-4FD5-9131-D1D9B90ED9E4@gmail.com>

A few clarifying addenda:

1. the comment "// identical to x : Dictionary<String : Int> = ..." should be "// identical to x : Dictionary<String, Int> = ..."

2. For proposal #2, the compiler should require that all type parameter aliases declared on the LHS of the "=" be used when declaring the underlying type on the RHS of the "=".

3. For proposal #2, the only valid values for the type arguments when declaring the underlying type on the RHS of the "=" are type parameter aliases declared on the LHS, and valid concrete types.

Best,
Austin

> On Dec 4, 2015, at 9:57 PM, Austin Zheng <austinzheng at gmail.com> wrote:
>
> Perhaps we should "formalize" a proposal as a starting point for further discussion/development.
>
> Currently, Swift supports defining an alias for an existing non-generic or fully bound generic type using the 'typealias' keyword:
>
> typealias Foo = Int
> typealias Bar = Dictionary<String : Int>
>
> In this example, the type referred to by the identifier 'Foo' is exactly equivalent to the existing type Int. Any occurrence of the type identifier "Int" can be replaced in a Swift source code text by the typealias identifier "Foo" without changing the behavior of the program.
>
> When a typealias is defined, the underlying type can be the underlying type of another typealias:
>
> typealias Baz = Foo // Baz is typealias of Int now
>
> However, the typealias mechanism does not allow an unbound generic type to be typealiased:
>
> // This fails
> typealias MyArray = Array
> // as does this
> typealias MyArray<T> = Array<T>
>
> There are at least two potential ways to extend the typealias mechanism to support typealiasing unbound generic types.
>
> 1. Allow an unbound generic type to be directly typealiased to a different identifier. The alias can then be used in place of the original generic type identifier anywhere where the latter would have been valid, in such a way that a direct textual substitution of the original identifier for the new identifier (or vice versa) would not change the meaning of a Swift program.
>
> typealias HashMap = Dictionary
> let x : HashMap<String, Int> = ["hello" : 1234]	// identical to x : Dictionary<String : Int> = ...
>
> 2. Allow an identifier to serve as a typealias to a partially specialized or fully unspecialized generic type. When declaring the typealias identifier, type parameter aliases can be declared as well within a generic type signature, akin to the "<>" generic type signature supported by type decls and function decls. When declaring the underlying type, unbound generic type parameters can then be bound to the type parameter aliases defined alongside the typealias identifier. Instead of an type parameter identifier, a concrete type can be used to partially specialize the type referred to by the typealias. For example:
>
> typealias HomogenousDict<T> = Dictionary<T, T>
> // A declaration of HomogenousDict<Int> is exactly equivalent to a declaration of Dictionary<Int, Int>.
> typealias DontDoThis<U, T> = Dictionary<T, U>
> // A declaration of DontDoThis<String, Int> is exactly equivalent to a declaration of Dictionary<Int, String>.
> // This might be a potential issue.
> typealias IntKeyDicts<Value> = Dictionary<Int, Value>
> // A declaration of IntKeyDicts<String> is then exactly equivalent to a declaration of Dictionary<Int, String>
>
> I hope this can serve as a starting point for discussion of the design of this feature, as well as identification of potential semantic and implementation issues.
>
> Best,
> Austin
>
>
>> On Dec 4, 2015, at 8:35 PM, Douglas Gregor <dgregor at apple.com <mailto:dgregor at apple.com>> wrote:
>>
>>
>>
>> Sent from my iPhone
>>
>> On Dec 4, 2015, at 4:08 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>
>>>
>>>> On Dec 4, 2015, at 3:04 AM, Dapeng Gao <gdapeng at icloud.com <mailto:gdapeng at icloud.com>> wrote:
>>>>
>>>> It would be handy if Swift can support generic `typealias`s, which would probably look like this:
>>>>
>>>> typealias Handler<Element> = [Element] -> Void
>>>>
>>>> One common way to achieve this is to define a generic `struct` and use a nested `typealias`:
>>>>
>>>> struct HandlerWrapper<Element> {
>>>>     typealias Hander = [Element] -> Void
>>>> }
>>>>
>>>> HandlerWrapper<SomeType>.Hander
>>>
>>> Definitely. I'd say this falls under the (totally arbitrary) umbrella of "obvious things that we didn't get around to implementing yet" instead of formal changes to the language. If you (or anyone else!) were to implement this, we'd consider the pull request immediately.
>>
>> I would rather not have such an umbrella, because how would one know what's in it and who gets to decide? Even "obvious" things need design, and some things that might sound like obvious goodness can benefit from review. ++ sounded like obvious goodness at one point in time, too.
>>
>>   - Doug
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d8743261/attachment-0001.html>

From kevin at sb.org  Sat Dec  5 00:23:33 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 22:23:33 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
Message-ID: <1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>

On Fri, Dec 4, 2015, at 06:45 PM, Joe Groff wrote:

> Why couldn't this be covered by overloads? It's unlikely we'd be able
> to import selectors from Objective-C to specific types because of this
> and other reasons, so we'd still need an untyped Selector type, but we
> could easily provide well-typed overloads in Swift overlays that
> convert from typed selectors to untyped.

This can only be covered by overloads when the selector is passed to a
function. So that would work for target/action in iOS, where you use
addTarget(_:action:forControlEvents:). But it won't work for OS X, where
target/action is exposed as two independent properties, because you
can't overload properties.

On Fri, Dec 4, 2015, at 06:46 PM, Michel Fortin wrote:

> Implicit conversions cannot happen safely in the direction SubType to BaseType for
> the arguments, including the target object. That makes Joe Groff's
> approach the only type-safe solution: make an extension of the base
> object and generate a method that does what you want. Which means that
> instead of this:
>
> 	view.action = MyObject.doSomething
>
> you could write this:
>
> 	view.action = { (target: AnyObject) in {
> 		(target as! MyObject).doSomething()
> 	}
>
> ...which is safe. Maybe the compiler should just auto-generate that
> boilerplate for you.

How can you write that? A @convention(selector) can't actually contain
any executable code, because there's nowhere to store that code (since
the runtime representation of a @convention(selector) is just a SEL,
because the message dispatch is done strictly with the SEL and the
receiver object). So you can't make this type-safe on the receiver,
because the object that receives the selector is by definition the
receiver, and there's no way to force this to be the same type as the
type you generated the selector from.

-Kevin Ballard

From harlan at harlanhaskins.com  Sat Dec  5 00:46:41 2015
From: harlan at harlanhaskins.com (Harlan Haskins)
Date: Sat, 5 Dec 2015 01:46:41 -0500
Subject: [swift-evolution] Proposal: Automatic Wrapper Synthesis / "deriving"
Message-ID: <98365168-A35C-43B3-9632-2ABDF9627DDB@harlanhaskins.com>

I feel like, if we implement automatic derivation for structs that wrap one value, we can just as easily implement automatic derivation for all product types for which the children conform to the protocols in question, and there’s a provided implementation for derivation by combining values.

Consider Hashable. A very common implementation of hashValue is xor-ing all the members’ hash values together.
We could actually implement this right now given Swift’s reflection system (if we were able to conditionally cast to Hashable or any protocol with a Self requirement).

Consider this:

struct HashableDerivable deriving Hashable {
let string: String // because String is already Hashable
let integer: Int   // and Int is Hashable
// then HashableDerivable is trivially Hashable.
}

/// This implementation is absolutely derivable at compile time.
extension HashableDerivable: Hashable {
var hashValue: Int {
return string.hashValue ^ integer.hashValue
}
}
func ==(lhs: HashableDerivable, rhs: HashableDerivable) -> Bool {
return lhs.string == rhs.string && lhs.integer == rhs.integer
}

// one can also use Reflection to derive this at runtime

extension Mirror {
func canDeriveHashable() -> Bool {
if self.subjectType is Hashable { return true } // this is currently a compiler error
for child in self.children {
let mirror = Mirror(reflecting: child)
if !mirror.canDeriveHashable() { return false }
}
return true
}
func deriveHashValue() -> Int {
if !self.canDeriveHashable() { fatalError("Boy, I wish this didn't have to happen at runtime.") }
guard let firstChild = self.children.first as? Hashable /* also an error */ else { fatalError("no children") }
return self.children.dropFirst().reduce(firstChild.hashValue) { (hash, _: (_: String?, value: Any)) -> T in
return hash ^ (value as! Hashable).hashValue
}
}
}

Of course, this is something that can be done at compile time, which would make protocol conformance really, really simple.

We already do this, using the Mirror API, for CustomStringConvertible.
> > On Dec 4, 2015, at 4:26 PM, John McCall <rjmccall at apple.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
> >
> >> On Dec 4, 2015, at 1:19 PM, plx <plxswift at icloud.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
> >> # A `wrapper` / `deriving` Construct
> >>
> >> I'm sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.
> >>
> >> The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.
> >>
> >> ## Design Sketch
> >>
> >> It ought to be possible to write something like this:
> >>
> >>   // an example:
> >>   struct SectionIndex
> >>     wrapping Int
> >>     as index
> >>     satisfying precondition { $0 >= 0 }
> >>     deriving Equatable, Comparable, Hashable {
> >>     // declaration can continue in here
> >>   }
> >>
> >> ...which, when compiled, would be "expanded" along these lines:
> >>
> >>   struct SectionIndex {
> >>
> >>     // would have been `wrappedValue` w/out the `as index` clause
> >>     let index: Int
> >>
> >>     init(_ index: Int) {
> >>       precondition(index >= 0)
> >>       // ^ would have been assert(index >= 0)
> >>       //   had we used `satisfying { $0 >= 0 }`,
> >>       //   and omitted entirely had we omitted a `satisfying` clause
> >>       self.index = index
> >>     }
> >>
> >>   }
> >>
> >>   extension SectionIndex : Equatable {
> >>   }
> >>
> >>   // synthesized unless explicitly written-out
> >>   func ==(lhs: SectionIndex, rhs: SectionIndex) -> Bool {
> >>     return lhs.index == rhs.index
> >>   }
> >>
> >>   // same for Comparable, Hashable, all done in the obvious way
> >>
> >>   // there’s a lot of utility in synthesizing something like this,
> >>   //  I can expand on it if necessary:
> >>   extension SectionIndex: ValueWrapperType {
> >>     typealias WrappedType = Int
> >>   }
> >>
> >> ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols' typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.
> >>
> >> I think this enough to sketch the way the feature would look and how it would work.
> >
> > I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.
> >
> > I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.
> >
> > For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).
> >
> > John.
>
> Apologies for leaving too much out.
>
> I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).
>
> Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:
>
> - `on` is unambiguous as there’s only one thing it can be “on"
> - there’s no ordering-of-operations to have to worry about
> - there’s no merging-of-results to have to worry about
> - i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)
> - there’s no associated-type incoherency to worry about (unless user error introduces it)
>
> …there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).
>
> …and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest.
>
> Thanks for taking the time to read and send feedback.
>
> PS:
>
> On the other hand, if this becomes writable:
>
>     protocol WrapperType {
>        typealias WrappedValue
>        var wrappedValue: { get }
>     }
>
>     extension WrapperType : Equatable where WrappedValue: Equatable {
>     }
>
>     func ==<W:WrapperType where W.WrappedValue:Equatable>(lhs: W, rhs: W) -> Bool {
>       return lhs.wrappedValue == rhs.wrappedValue
>     }
>
> …etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7d638166/attachment.html>

From kevin at sb.org  Sat Dec  5 00:59:53 2015
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 04 Dec 2015 22:59:53 -0800
Subject: [swift-evolution] Revisiting Optionals as Sequences
In-Reply-To: <5C599593-83C0-40E0-A1C0-0244119AFB6E@harlanhaskins.com>
References: <5C599593-83C0-40E0-A1C0-0244119AFB6E@harlanhaskins.com>
Message-ID: <1449298793.2430717.458680585.6C9533AB@webmail.messagingengine.com>

That definition is unusable, since it restricts the type of the
map operation to be whatever type you chose when you implemented
the protocol.

To see this for yourself, try implementing Functor on Array. You can't
do it, unless you pick the B type ahead of time, and if you do that you
can only ever map() to that single type B. The map() function is
supposed to be generic on the result type of the function, but since
Swift doesn't have higher-order types there's no way to express that the
result of the map() function is the same underlying data structure with
a separate generic parameter.

-Kevin Ballard


On Fri, Dec 4, 2015, at 08:56 PM, Harlan Haskins wrote:
>
> Y’know, map and flatMap being part of SequenceType is really a
> misnomer.
>
> We could always just add Functor and Monad in the standard library!
>
> protocol Functor {    typealias A    typealias B    typealias FB
>


> func map(_: A -> B) -> FB }
>
> protocol Monad: Functor {    static func pure(f: A) -> Self    func
> flatMap(f: A -> FB) -> FB    func >>=(x: Self, f: A -> FB) -> FB }
>
> infix operator >>= { associativity left } func >>=<M: Monad>(x: M, f:
> M.A -> M.FB) -> M.FB {    return x.flatMap(f) }
>> A few months ago I sent a pair of radars (22414579 nee 22448207 and
>> 21961711) about Optional’s extant overloading of flatMap and how it
>> doesn’t align with either the STL or the reasons given for the
>> closing of both radars.

>* This issue behaves as intended based on the following:
*>**>* Yes, we are aware that this overload of flatMap could be viewed
as unconventional. Nevertheless, it is useful and fits the overload set
in general, if you view Optional as a sequence of zero or one T. It
resembles this overload, where the closure returns an arbitrary
sequence: *>**>* extension SequenceType { *>*   public func flatMap<S :
SequenceType>(transform: (Generator.Element) -> S) ->
[S.Generator.Element] *>* } *>**>* The type checker ensures that there
is no ambiguity between the two overloads, and we don't see a reason to
give one of the overloads a different name (and force users to learn it,
and differentiate between the two), since conceptually the operation is
the same. * If Swift wishes to regard Optionals as collections with 1 or
0 elements, then I propose that it should reflect that thinking with
additions to the standard library.

Possible changes include:

1) Remove or rename Optional’s flatMap. This would cause a bit of
breaking behavior, but it’s nothing some fixits couldn’t help with.

2) Add a SequenceType instance for Optional. This kills 2 birds with 1
stone in that, if the radar rejection is to ring true, Optional
should have a SequenceType instance in the STL, and such an instance
would automatically come with its own proper overloading flatMap
necessitating change 1.

Over in TypeLift land we’ve already implemented what we believe the
SequenceType extensions should look like (https://github.com/typelift/-
Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145
<https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145>
).
>
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b57a7251/attachment-0001.html>

From cloutiertyler at aol.com  Sat Dec  5 01:14:16 2015
From: cloutiertyler at aol.com (Tyler Cloutier)
Date: Fri, 4 Dec 2015 23:14:16 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
Message-ID: <EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>

Indeed. Python doesn't have it, and there isn't much concern about the learning curve or the missing functionality there, it seems. I actually didn't even realize it was missing from Python until I stopped and thought about it.

At first I was concerned about losing C style for loops, but I really can imagine a scenario in which they are more succinct while still maintaining clarity of intent. Plus they're a pain to type out.

From time to time when programming in C or JS I will include more than one statement or more complicated logic in the increment part of the for loop (perhaps move 2 indices in a complicated way), but perhaps that would be clearer just to implement as a while loop with the logic at the end.

One thing I will say is that it's nice to have your loop variables scoped to the loop, which is more difficult (impossible?) to accomplish with a while loop.

Perhaps some while loop syntax like:

while (x < someThing) start var x = 0, y = 11 {
x += someOtherThing
}

Which is decidedly terrible syntax, but that's kind of the idea anyway.

Tyler





> On Dec 4, 2015, at 3:21 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>
> This is a nice solution that translates nicely without creating too much concern about changing the nature of an algorithm in a complex system. 👍
>
> Should at least get a nice "fix it" in Xcode though. On survey, we do have developers using the C style syntax, but we're early in the process of transitioning.
>
>> On Dec 04, 2015, at 02:52 PM, Johan Jensen <jj at johanjensen.dk> wrote:
>>
>
>> With the removal of post/pre-increment/decrement you might as well translate C-style for-loops to something akin to
>>
>> for var i in 0..<10 {
>>     ...
>> }
>>
>> If more advanced C-style for-loops are needed, I am sure most developers can use a while-loop (as mentioned by Ray Fix) until they get accustomed to Swift’s syntax.
>>
>>> On Fri, Dec 4, 2015 at 11:37 PM, Joe Groff <jgroff at apple.com> wrote:
>>> You might ease the pain by approximating C-style 'for' by a higher-order function:
>>>
>>> func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
>>>   // left as an exercise
>>> }
>>>
>>> var i = 0
>>> cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
>>>   print(i)
>>> }
>>>
>>> -Joe
>>>
>>>> On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>>>>
>>>> I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...
>>>>
>>>> It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.
>>>>
>>>> We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.
>>>>
>>>> But if it's actively hurting some other part of the language we could probably be talked into it.
>>>>
>>>>> On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>
>>>>
>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>
>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>
>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>
>>>>> -- E
>>>>>
>>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/21193072/attachment.html>

From john.calsbeek+lists at gmail.com  Sat Dec  5 01:37:42 2015
From: john.calsbeek+lists at gmail.com (John Calsbeek)
Date: Fri, 4 Dec 2015 23:37:42 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
Message-ID: <E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>

`fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.

It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.

One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).

switch op {
case LOAD_INDIRECT:
in0 = memory[in1]
fallthrough
case LOAD:
out0 = memory[in0]
//...
}

I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.

Cheers,
John

> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:
>
>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>
> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>
> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>
> John.
>
>>
>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>
>> -Kevin Ballard
>>
>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>
>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>
>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>
>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>> case .Enum1, .Enum2:
>>>> expressed as
>>>> case .Enum1: fallthrough
>>>> case .Enum2:
>>>>
>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>
>>>>
>>>>
>>>>
>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>
>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>
>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>
>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>
>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>
>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>
>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>
>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>
>>>>> Thoughts?
>>>>>
>>>>> Daniel
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f96726e9/attachment-0001.html>

From jtbandes at gmail.com  Sat Dec  5 01:38:17 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Fri, 4 Dec 2015 23:38:17 -0800
Subject: [swift-evolution] Type information containing multiple
additional protocols
In-Reply-To: <A9BD5D7C-E99C-44F7-A7BB-A501C8788083@gmail.com>
References: <A9BD5D7C-E99C-44F7-A7BB-A501C8788083@gmail.com>
Message-ID: <CADcs6kPdJsDHyRK2Ar23O0UL-gaWhSMnSTn2HLiSXBtyVSpvgA@mail.gmail.com>

I think this is a very useful feature of Obj-C that I've missed several
times while writing Swift code.

However, calling it "TheClass<Protocol1, Protocol2>" directly conflicts
with the syntax for specifying generic type parameters.

If we use "protocol<TheClass, Protocol1, Protocol2>" for this case, then
`protocol` stops making sense. Maybe the keyword `class` could be allowed
instead, like "class<TheClass, Protocol1, Protocol2>".

Or, it might work to omit the keyword entirely, leaving only the angle
brackets:

class C {
weak var delegate: <UIViewController, UICollectionViewDelegate>?
}

if let task = object as? <NSManagedObject, Task> {
task.coreDataRelatedFunction()
task.taskRelatedFunction()
}

Jacob Bandes-Storch

On Fri, Dec 4, 2015 at 3:07 PM, Daniel Muhra <daniel.muhra at gmail.com> wrote:

> Currently it doesn’t seem possible to define a property or variable of a
> specific class that also implements one or more protocols.
> Take as an example the following definition from Objective C:
>
> NSManagedObject<NSCoding, Task>* someObject;
>
> To my knowledge, currently it is only possible to define multiple
> protocols only:
>
> var object : protocol<NSCoding, Task>
>
> However, given the first example, sometimes it is not possible to restrict
> to protocols only. This becomes especially cumbersome, if you would need to
> cast down to such a construct within a single method and perform several
> steps which would require all those type information:
>
> func doSomething(object: AnyObject) {
>     if let managedObject = object as? NSManagedObject {
>         // Do core data related stuff
>     }
>
>
>     if let task = object as? Task {
>         // Do task related stuff
>     }
> }
>
> In this case you now have managedObject and task though you operate on the
> same object. Also it is not (easily) possible to interleave actions of
> those two.
>
> My first idea here would be to introduce an Objective C like style of type
> naming. This also has the benefit, that it is perfectly clear, whether a
> type name refers to a class or a protocol (without first having to check
> it).
> The downside, of course, is that protocol type variables would become
> something like Any<MyProtocol>
>
> Any other ideas are welcome, but the initial problem still stands and
> should be addressed.
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/9d522b94/attachment.html>

From brent at architechies.com  Sat Dec  5 01:43:16 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Fri, 4 Dec 2015 23:43:16 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
Message-ID: <2BF5CB07-61DD-43C9-95ED-F20E50639283@architechies.com>

>> Why couldn't this be covered by overloads? It's unlikely we'd be able
>> to import selectors from Objective-C to specific types because of this
>> and other reasons, so we'd still need an untyped Selector type, but we
>> could easily provide well-typed overloads in Swift overlays that
>> convert from typed selectors to untyped.
>
> This can only be covered by overloads when the selector is passed to a
> function. So that would work for target/action in iOS, where you use
> addTarget(_:action:forControlEvents:). But it won't work for OS X, where
> target/action is exposed as two independent properties, because you
> can't overload properties.

So? I mean, it’s sad that OS X can’t force you to use a selector that matches the target. But you’re still going to get some typing benefits.

Suppose NSControl is bridged to Swift with these properties:

var target: NSObjectProtocol?
var action: Selector

And you set it up like so:

frobButton.target = controller
frobButton.action = MyViewController.frobnicate

Swift can’t prove that myViewController is of type MyViewController. But this code still proves that:

1. controller is an NSObjectProtocol, and thus a plausible target.
2. frobnicate is a real method on MyViewController (it’s not misspelled, it’s not on the window controller or something).
3. frobnicate is an @objc method.
4. frobnicate will be called if target is a MyViewController (i.e. the user doesn’t have to understand how Objective-C selectors map to Swift methods or worry about whether that particular method has an @objc(replacementName:) attribute).

Now let’s give action a more precise definition:

var action: (@convention(selector) NSObjectProtocol -> AnyObject -> Void)?

(This doesn’t support no-sender actions, but technically, I don’t think OS X is supposed to allow them. They coincidentally work because the ABI is loosey-goosey in the right places.)

To the above four guarantees, this definition adds a fifth:

5. frobnicate takes one parameter which can accept an AnyObject.

Do these guarantees mean that you can’t ever mismatch the target and action? No. But do they eliminate several other common target/action bugs? Yes! That seems worth doing to me.

And that’s assuming you don’t take any artistic license in the bridging. There’s no reason the Swift overlay can’t do as Michel Fortin suggested and hide the target and action setters, replacing them with a method which provides the same features and guarantees as UIKit’s overloaded calls:

func setTarget<T: NSObjectProtocol>(target: T?, action: (@convention(selector) T -> AnyObject -> Void)?)

--
Brent Royal-Gordon
Architechies


From cloutiertyler at aol.com  Sat Dec  5 01:49:28 2015
From: cloutiertyler at aol.com (Tyler Cloutier)
Date: Fri, 4 Dec 2015 23:49:28 -0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>
References: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>
<1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>
Message-ID: <EE0D56C4-2782-4020-BBD0-60B93A52FA64@aol.com>

I'm not sure how many Swift users this effects, but I'm colorblind and I really struggle with the local vs properties syntax coloring.

Tyler



> On Dec 4, 2015, at 3:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods and doesn't color local variables/arguments. Is that not sufficient to distinguish this? In my experience the color is actually better than seeing the explicit `self.` because the color can be recognized faster than reading a word, and is visible in a high-level "squint" view of the function.
>
> If you're using another editor, well, my best suggestion there is to look into what it would take to integrate SourceKit functionality into that editor for more intelligent coloring :)
>
> -Kevin
>
>> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>> +1
>>
>> I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.
>>
>> I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.
>>
>>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>>
>>> Just as example, my proposition makes the following piece of code illegal:
>>>
>>> ```
>>> struct FooBar {
>>> var foo: String = "foobar"
>>>
>>> func bar() {
>>> print(foo) // compiler error
>>> print(self.foo) // compiler happy
>>> }
>>>
>>> func bar2() {
>>> bar() // compiler error
>>> self.bar() // compiler happy
>>> }
>>> }
>>> ```
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/320afa16/attachment.html>

From gribozavr at gmail.com  Sat Dec  5 01:54:25 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Fri, 4 Dec 2015 23:54:25 -0800
Subject: [swift-evolution] Lazy flatMap for Optionals
In-Reply-To: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>
References: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>
Message-ID: <CA+Y5xYcL6hjYmMJm+rA1bKDmft4iSGtqMw64aX3ErXBEKQb1GA@mail.gmail.com>

On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney <
oisin.kidney at gmail.com> wrote:

> Currently, several of the methods on SequenceType in the standard library
> have lazy variants. flatMap, though, (seems) to have a version missing:
> while there’s a lazy version for nested sequences, there’s no lazy version
> for sequences of Optionals. Is there maybe a reason for this that I
> haven’t thought of? At any rate, here’s what I had in mind:
>
> public struct FlatMapOptionalGenerator<G: GeneratorType, Element>:
> GeneratorType {
>   private let f: G.Element -> Element?
>   private var g: G
>   public mutating func next() -> Element? {
>     while let x = g.next() {
>       if let y = f(x) {
>         return y
>       }
>     }
>     return nil
>   }
> }
>
> public struct FlatMapOptionalSequence<S: LazySequenceType, Element>:
> LazySequenceType {
>   private let f: S.Generator.Element -> Element?
>   private let s: S
>   public func generate() -> FlatMapOptionalGenerator<S.Generator, Element>
> {
>     return FlatMapOptionalGenerator(f: f, g: s.generate())
>   }
> }
>
> extension LazySequenceType {
>   public func flatMap<T>(transform: Generator.Element -> T?) ->
> FlatMapOptionalSequence<Self, T> {
>     return FlatMapOptionalSequence(f: transform, s: self)
>   }
> }
>
> Does this seem like a good idea?
>

Hi Oisin,

This is just an omission.  Please submit a formal proposal as a pull
request to the swift-evolution repository.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/81d1765a/attachment-0001.html>

From rols at rols.org  Sat Dec  5 01:54:49 2015
From: rols at rols.org (Roland King)
Date: Sat, 5 Dec 2015 15:54:49 +0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
Message-ID: <437319C0-F168-480E-A234-834645C90487@rols.org>

I must be the only person who still likes C-style for loops on occasion. eg a loop with something floating point

for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
{
// more than a few lines of code with early escape continues
}

shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.

In the float case yes you can use stride

for var floatingThing in start.stride( through : end, by : delta )
{
}

but it’s not terribly pretty and you have to be sure whether you mean stride( through:, end:) or stride( to:, end:)

That’s not a problem with integers where you have the ‘0..<n’ syntax which reads very clearly in a for .. in construct but in other cases the old c-style for can be a clearer read than for .. in with an iterator.



> On 5 Dec 2015, at 15:14, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>
> Indeed. Python doesn't have it, and there isn't much concern about the learning curve or the missing functionality there, it seems. I actually didn't even realize it was missing from Python until I stopped and thought about it.
>
> At first I was concerned about losing C style for loops, but I really can imagine a scenario in which they are more succinct while still maintaining clarity of intent. Plus they're a pain to type out.
>
> From time to time when programming in C or JS I will include more than one statement or more complicated logic in the increment part of the for loop (perhaps move 2 indices in a complicated way), but perhaps that would be clearer just to implement as a while loop with the logic at the end.
>
> One thing I will say is that it's nice to have your loop variables scoped to the loop, which is more difficult (impossible?) to accomplish with a while loop.
>
> Perhaps some while loop syntax like:
>
> while (x < someThing) start var x = 0, y = 11 {
> 	x += someOtherThing
> }
>
> Which is decidedly terrible syntax, but that's kind of the idea anyway.
>
> Tyler
>
>
>
>
>
> On Dec 4, 2015, at 3:21 PM, Colin Cornaby <colin.cornaby at mac.com <mailto:colin.cornaby at mac.com>> wrote:
>
>> This is a nice solution that translates nicely without creating too much concern about changing the nature of an algorithm in a complex system. 👍
>>
>> Should at least get a nice "fix it" in Xcode though. On survey, we do have developers using the C style syntax, but we're early in the process of transitioning.
>>
>> On Dec 04, 2015, at 02:52 PM, Johan Jensen <jj at johanjensen.dk <mailto:jj at johanjensen.dk>> wrote:
>>
>>> With the removal of post/pre-increment/decrement you might as well translate C-style for-loops to something akin to
>>>
>>> for var i in 0..<10 {
>>>     ...
>>> }
>>>
>>> If more advanced C-style for-loops are needed, I am sure most developers can use a while-loop (as mentioned by Ray Fix) until they get accustomed to Swift’s syntax.
>>>
>>> On Fri, Dec 4, 2015 at 11:37 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>> You might ease the pain by approximating C-style 'for' by a higher-order function:
>>>
>>> func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
>>>   // left as an exercise
>>> }
>>>
>>> var i = 0
>>> cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
>>>   print(i)
>>> }
>>>
>>> -Joe
>>>
>>>> On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com <mailto:colin.cornaby at mac.com>> wrote:
>>>>
>>>> I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...
>>>>
>>>> It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.
>>>>
>>>> We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.
>>>>
>>>> But if it's actively hurting some other part of the language we could probably be talked into it.
>>>>
>>>> On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>
>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>
>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>
>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>
>>>>> -- E
>>>>>
>>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ecf7a13a/attachment.html>

From clattner at apple.com  Sat Dec  5 01:59:28 2015
From: clattner at apple.com (Chris Lattner)
Date: Fri, 04 Dec 2015 23:59:28 -0800
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <C8CEEDF3-FD93-4036-8075-021F1AA23F68@jonshier.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
<8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
<C8CEEDF3-FD93-4036-8075-021F1AA23F68@jonshier.com>
Message-ID: <4C3C060E-1BAC-4C59-8957-D30E358F7786@apple.com>


> On Dec 4, 2015, at 4:19 PM, Jon Shier <jon at jonshier.com> wrote:
>
> 	I can’t answer for Per, but, at least in my iOS and OS X programming, I often find myself creating IUOs in view controller to represent properties that I’m guaranteed to have set before viewDidLoad, but don’t want a custom initializer, due to the pain of multiple required init methods. So while my IUO usage is perfectly safe, they’re rather awkward to use.
> 	That said, I’d have to see a specific proposal to tell if it’s any better for my usage than IUOs.

Sure.  For that use case, you’d be better served by a “delayed” property, which is initialized exactly once - but after init is done.  There is some infrastructure that is missing to support that, but we’re interested in providing it.

-Chris


From david at hartbit.com  Sat Dec  5 03:35:08 2015
From: david at hartbit.com (David Hart)
Date: Sat, 5 Dec 2015 10:35:08 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <EE0D56C4-2782-4020-BBD0-60B93A52FA64@aol.com>
References: <14bc9a8f-1a5c-4710-b831-7abd8eafd471@me.com>
<1449272270.2878887.458505385.20BA835B@webmail.messagingengine.com>
<EE0D56C4-2782-4020-BBD0-60B93A52FA64@aol.com>
Message-ID: <F9CA7C02-6596-4C36-A867-3613DE3D7DB7@hartbit.com>

As I said previously, same for me. But even if that weren't the case; I find it difficult to defend the readability of a language's feature uniquely by an editor's syntax highlighting.

The proposal here had the same objectives (but is more elegant) to what created conventions like Hungarian notation where m_ prefixes member variables.



Sent from my iPhone
> On 05 Dec 2015, at 08:49, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>
> I'm not sure how many Swift users this effects, but I'm colorblind and I really struggle with the local vs properties syntax coloring.
>
> Tyler
>
>
>
>> On Dec 4, 2015, at 3:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods and doesn't color local variables/arguments. Is that not sufficient to distinguish this? In my experience the color is actually better than seeing the explicit `self.` because the color can be recognized faster than reading a word, and is visible in a high-level "squint" view of the function.
>>
>> If you're using another editor, well, my best suggestion there is to look into what it would take to integrate SourceKit functionality into that editor for more intelligent coloring :)
>>
>> -Kevin
>>
>>> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>>> +1
>>>
>>> I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.
>>>
>>> I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.
>>>
>>>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>>>
>>>> Just as example, my proposition makes the following piece of code illegal:
>>>>
>>>> ```
>>>> struct FooBar {
>>>> var foo: String = "foobar"
>>>>
>>>> func bar() {
>>>> print(foo) // compiler error
>>>> print(self.foo) // compiler happy
>>>> }
>>>>
>>>> func bar2() {
>>>> bar() // compiler error
>>>> self.bar() // compiler happy
>>>> }
>>>> }
>>>> ```
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/50153819/attachment.html>

From mail at hollance.com  Sat Dec  5 04:10:42 2015
From: mail at hollance.com (Matthijs Hollemans)
Date: Sat, 5 Dec 2015 11:10:42 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <437319C0-F168-480E-A234-834645C90487@rols.org>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
Message-ID: <F395A787-4509-4F56-AFBA-2E9E68984D88@hollance.com>

You’re not the only one, I like them too. :-)

I notice that the SE-0007 proposal only includes positive feedback from the community. I hope that counter arguments will be added too.

The thing that bothers me about this first batch of proposals is that they seem to be about “dumbing down” the language. Personally, I think it would be a mistake to remove “power” features such as the C-style for loop. I like Swift but I don’t want it to hold my hand all the time.

You may think the following is horrible code — I like the expressiveness:

extension LinkedList {
public func reverse() {
for var node = head; node != nil; head = node, node = node!.previous {
// swap next and previous
}
}
}

Another example from the same LinkedList class. It finds the right place to insert a new node:

for next = head; next != nil && index > 0; prev = next, next = next!.next, --index { }

Extreme? Probably, but I like it better than the same thing done in five lines of while loop.

Another benefit of a C-style for loop is that it simply ignores the loop when n <= i, as in the following example,

for var i = 100; i < n; ++i { ...

while the Swifty version gives an error because it cannot create a range where the end is smaller than the start:

for i in 100..<n { ...

Of course, you can add an if-statement to catch this but in the C-style loop this is implicit. Hence, it is more expressive.

Personally, I tend to use for-in as much as possible but I dislike it for going backwards. It’s a style thing but I much prefer,

for var i = 100; i > 0; --i { ...

over:

for i in 100.stride(to: 0, by: -1) { ...

Ideally I’d write this instead, but Swift doesn’t allow such ranges:

for i in 100...1 {

In all these examples, I admit that a C-style for loop is harder to learn. So what? People are only beginners for a short time. I only have a little insight into this but from what I can tell, most beginners don’t have a problem learning the language so much as the frameworks.

We shouldn’t “simplify” the language in the belief that this will help beginners, without a clear understanding of what sort of problems beginners actually have. So far all I’ve seen are assumptions, not actual data. (I only have anecdotal evidence myself.)

Just to be clear: I’m not against making the language easier to learn, but that should not get in the way of allowing more advanced programmers to do their jobs.

-Matthijs




> On 5 dec. 2015, at 08:54, Roland King <rols at rols.org> wrote:
>
> I must be the only person who still likes C-style for loops on occasion. eg a loop with something floating point

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/5fd9c7ec/attachment-0001.html>

From adrian.kashivskyy at me.com  Sat Dec  5 04:15:10 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sat, 05 Dec 2015 11:15:10 +0100
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>
References: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>
Message-ID: <80FA7736-F062-44BF-9846-260B09DFAA53@me.com>

I'm -1 on that – compiler should guarantee the program correctness, not style correctness.

> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)

I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.

> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.

My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).

Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.


Regards,
Adrian Kashivskyy
iOS Developer at Netguru

> Wiadomość napisana przez Amir Michail <amichail at gmail.com> w dniu 05.12.2015, o godz. 00:53:
>
> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>
> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>
> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/24f94159/attachment.html>

From ycao at me.com  Sat Dec  5 04:16:22 2015
From: ycao at me.com (Yichen Cao)
Date: Sat, 05 Dec 2015 18:16:22 +0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self
for	accessing instance properties and functions (David Hart)
In-Reply-To: <mailman.379.1449310286.15739.swift-evolution@swift.org>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
Message-ID: <32D55766-386B-4584-8563-54AB8C1EDBFB@me.com>

Teaching wise, its much less confusing for self to be required so students don't mix up instance properties and local vars. Especially when self is required in closures, it confuses students. If self is mandatory for all instance properties, it would be so much clearer and much easier to read.

Yichen

> On Dec 5, 2015, at 18:11, swift-evolution-request at swift.org wrote:
>
> Re: Proposal: Re-instate mandatory self for	accessing
>      instance properties and functions (David Hart)

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d8c2654d/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 3557 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d8c2654d/attachment.p7s>

From adrian.kashivskyy at me.com  Sat Dec  5 04:18:10 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sat, 05 Dec 2015 11:18:10 +0100
Subject: [swift-evolution] Type Inferencing For Error Handling (try
catch blocks)
In-Reply-To: <598691A3-A6F8-428C-BB16-E5C7AE48E5DD@apple.com>
References: <etPan.566229ff.3f8f3108.10e90@Manav-Gabhawalas-MacBook-Pro.local>
<598691A3-A6F8-428C-BB16-E5C7AE48E5DD@apple.com>
Message-ID: <5DE50203-B3CC-4825-9049-B6B8E211176E@me.com>

Related: https://lists.swift.org/pipermail/swift-evolution/2015-December/000076.html

Regards,
Adrian Kashivskyy
iOS Developer at Netguru

> Wiadomość napisana przez John McCall <rjmccall at apple.com> w dniu 05.12.2015, o godz. 01:15:
>
>> On Dec 4, 2015, at 4:04 PM, Manav Gabhawala <manav1907 at gmail.com <mailto:manav1907 at gmail.com>> wrote:
>> irst of all, Swift is an absolute dream of a programming language and is really taking the future of programming in the right direction.
>>
>> However, it seems backwards to me that everything in swift is type safe and complete (like enum cases) but error handling seems lacking on that end. It would be a huge feature if the compiler could infer the types of errors functions throw and make sure you catch all the different types of errors at the call site. The compiler could also chain the types through multiple throwing function callers. This feature would require no extra work on the programmers part because the compiler would infer the types of errors being thrown. For example,
>
> This is a global type-checking problem.  It’s completely blocked by any dynamic features (like protocol or class methods) and library boundaries, so outside of toy examples, you will end up needing exhaustive pattern-matching pretty much everywhere.
>
> John.
>
>
>>
>>
>> func foo() throws
>> {
>> 	...
>> 	throw ErrorType1.BadRequest
>> 	...
>> 	throw ErrorType1.NoAuthentication
>> 	...
>> 	throw ErrorType2.NoResourceFound
>> }
>> func main()
>> {
>> 	do
>> 	{
>> 		foo()
>> 	}
>> 	catch (ErrorType1.BadRequest)
>> 	{
>>
>> 	}
>> 	catch (ErrorType2.NoResourceFound)
>> 	{
>> 	}
>> 	// Compiler error because ErrorType1.NoAuthentication is not included.
>> }
>>
>> Errors can also be chained together such that each function statically identifies the types thrown and if a call is made to a throwing function all the uncaught types are propagated out of the call stack. This would firstly be beneficial because we wouldn’t need the ridiculous empty catch { } block at the end that most people end up doing and secondly would ensure programmers are completely and always aware the possible errors that can be thrown by the function calls they make.
>>
>> Regards,
>> Manav
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9bbee5b9/attachment-0001.html>

From cloutiertyler at aol.com  Sat Dec  5 04:27:12 2015
From: cloutiertyler at aol.com (Tyler Cloutier)
Date: Sat, 5 Dec 2015 02:27:12 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <437319C0-F168-480E-A234-834645C90487@rols.org>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
Message-ID: <5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>

Hmm, yeah, that is definitely a good point. It can be easy enough to throw a continue into a while loop an completely skip the increment step. Of course you could add syntax to a while loop to allow for block/loop scoping of variables and then it might be tempting to add some finally logic to ensure that the incrementing is never skipped. Which, then what you have is a C style for loop with unfamiliar/unprecedented syntax, which would be silly.

Perhaps the question is, is it worth keeping the C style around for loop syntax for these particular types of uses?


On a total side note, I figure while I'm proposing silly things and decidedly terrible syntax, I might as well mention that when I originally began programming I was confused about the need for two different styles of loops. It seemed like "while" was a special case of "for" and was redundant (but made for a nicer looking syntax). An interesting thought experiment is to think about what dropping "while" might look like.

Just like there is for-in

for x in someGenerator {
// code
}

There could also be for-if-repeat and for-repeat-if

for var x = 0 if x < 7 repeat {
// code
} then x + 7

for var x = 0 repeat {
// code
} if x < 7 then x + 7

Certainly an unnecessary change considering the problem at hand and has obvious downsides, but I think fun to think about.

Tyler


> On Dec 4, 2015, at 11:54 PM, Roland King <rols at rols.org> wrote:
>
> I must be the only person who still likes C-style for loops on occasion. eg a loop with something floating point
>
> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
> {
> 	// more than a few lines of code with early escape continues
> }
>
> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.
>
> In the float case yes you can use stride
>
> for var floatingThing in start.stride( through : end, by : delta )
> {
> }
>
> but it’s not terribly pretty and you have to be sure whether you mean stride( through:, end:) or stride( to:, end:)
>
> That’s not a problem with integers where you have the ‘0..<n’ syntax which reads very clearly in a for .. in construct but in other cases the old c-style for can be a clearer read than for .. in with an iterator.
>
>
>
>> On 5 Dec 2015, at 15:14, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>>
>> Indeed. Python doesn't have it, and there isn't much concern about the learning curve or the missing functionality there, it seems. I actually didn't even realize it was missing from Python until I stopped and thought about it.
>>
>> At first I was concerned about losing C style for loops, but I really can imagine a scenario in which they are more succinct while still maintaining clarity of intent. Plus they're a pain to type out.
>>
>> From time to time when programming in C or JS I will include more than one statement or more complicated logic in the increment part of the for loop (perhaps move 2 indices in a complicated way), but perhaps that would be clearer just to implement as a while loop with the logic at the end.
>>
>> One thing I will say is that it's nice to have your loop variables scoped to the loop, which is more difficult (impossible?) to accomplish with a while loop.
>>
>> Perhaps some while loop syntax like:
>>
>> while (x < someThing) start var x = 0, y = 11 {
>> 	x += someOtherThing
>> }
>>
>> Which is decidedly terrible syntax, but that's kind of the idea anyway.
>>
>> Tyler
>>
>>
>>
>>
>>
>>> On Dec 4, 2015, at 3:21 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>>>
>>> This is a nice solution that translates nicely without creating too much concern about changing the nature of an algorithm in a complex system. 👍
>>>
>>> Should at least get a nice "fix it" in Xcode though. On survey, we do have developers using the C style syntax, but we're early in the process of transitioning.
>>>
>>>> On Dec 04, 2015, at 02:52 PM, Johan Jensen <jj at johanjensen.dk> wrote:
>>>>
>>>
>>>> With the removal of post/pre-increment/decrement you might as well translate C-style for-loops to something akin to
>>>>
>>>> for var i in 0..<10 {
>>>>     ...
>>>> }
>>>>
>>>> If more advanced C-style for-loops are needed, I am sure most developers can use a while-loop (as mentioned by Ray Fix) until they get accustomed to Swift’s syntax.
>>>>
>>>>> On Fri, Dec 4, 2015 at 11:37 PM, Joe Groff <jgroff at apple.com> wrote:
>>>>> You might ease the pain by approximating C-style 'for' by a higher-order function:
>>>>>
>>>>> func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
>>>>>   // left as an exercise
>>>>> }
>>>>>
>>>>> var i = 0
>>>>> cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
>>>>>   print(i)
>>>>> }
>>>>>
>>>>> -Joe
>>>>>
>>>>>> On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com> wrote:
>>>>>>
>>>>>> I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...
>>>>>>
>>>>>> It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.
>>>>>>
>>>>>> We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.
>>>>>>
>>>>>> But if it's actively hurting some other part of the language we could probably be talked into it.
>>>>>>
>>>>>>> On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>
>>>>>>
>>>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>>>
>>>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>>>
>>>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>>>
>>>>>>> -- E
>>>>>>>
>>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/abc41ea7/attachment.html>

From rols at rols.org  Sat Dec  5 05:28:34 2015
From: rols at rols.org (Roland King)
Date: Sat, 5 Dec 2015 19:28:34 +0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
<5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>
Message-ID: <945B200D-4785-48AE-B53D-3168C28E7E23@rols.org>


> On 5 Dec 2015, at 18:27, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>
> Hmm, yeah, that is definitely a good point. It can be easy enough to throw a continue into a while loop an completely skip the increment step. Of course you could add syntax to a while loop to allow for block/loop scoping of variables and then it might be tempting to add some finally logic to ensure that the incrementing is never skipped. Which, then what you have is a C style for loop with unfamiliar/unprecedented syntax, which would be silly.

Yes - I’m still thinking it through. while() is really a special case of the c-style for, just without the initializer and the pre-test increment (which I don’t like calling increment because it’s far more useful than that). The fact it calls the increment code every time before the test, with the notable exception of the first time, makes for a powerful sequence of test-do-increment-test-do-increment-test ..  which while() alone doesn’t quite replicate. A continue in a for loop doesn’t translate well into a while() at all, obviously you can do it with nested ifs and other means but I think the power of the sequence for() gives you along with continue and break lets you write simple, understandable loop code.

So I’m not convinced by the argument that where you see a for() you can write a while() with a bit of code shuffling, for() is more powerful than while(), while() is the special case.

So that moves on to for .. in. That looks persuasively like a syntax which you can always change a C-style for into. And of course you can, you can make a generic generator which takes a few closures and does exactly what the c-style for does if you want. It’s easy however to just think in terms of things which have natural generators, 1..<n, an array of things, and when you use those with for .. in you get a very understandable line of code

for var element in myArray {}

is very clear because Array has a natural generator. Under the hood this is of course sugar for a c-style for loop where the initialisation and increment are predefined.

In other non-natural-generator cases, turning things into generators in order to use them with for .. in makes the code harder to read and understand. I brought up iterating floats, some of Matthijs’ examples from a couple of mails ago really would look a bit nasty shoehorned into an iterator paradigm so for .. in could un-shoehorn them again and turn them into the original for test-do-modify-test-do-modify-test he started with.

I’ve now had my 2c twice - I will be quiet.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/52a625de/attachment-0001.html>

From robear18 at gmail.com  Sat Dec  5 05:34:47 2015
From: robear18 at gmail.com (Dan)
Date: Sat, 5 Dec 2015 12:34:47 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <mailman.379.1449310286.15739.swift-evolution@swift.org>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
Message-ID: <03365B58-9067-47E7-98E4-B8620ABBC603@gmail.com>

I have the same feeling. Syntax highlighting is not enough to make things clear and even with it we are sometimes confused. We read swift code on GitHub, which doesn't have highlighting. Sometimes we do so in plain text. It looks like the only way to detect iVars is to open our Swift code is to open it in Xcode. So Swift is outsourcing iVar readability to Xcode, when it should be a language feature.

Given this, some teams use underscores for their iVars which is very unfortunate. Myself, I use self whenever possible to be explicit. I'd like the language to force us to be clear.
I would also like to point out that colours are a very unsafe mechanism of communicating programmer intent.

> Message: 1
> Date: Sat, 5 Dec 2015 10:35:08 +0100
> From: David Hart <david at hartbit.com>
> To: Tyler Cloutier <cloutiertyler at aol.com>
> Cc: swift-evolution at swift.org
> Subject: Re: [swift-evolution] Proposal: Re-instate mandatory self for
> 	accessing instance properties and functions
> Message-ID: <F9CA7C02-6596-4C36-A867-3613DE3D7DB7 at hartbit.com>
> Content-Type: text/plain; charset="utf-8"
>
> As I said previously, same for me. But even if that weren't the case; I find it difficult to defend the readability of a language's feature uniquely by an editor's syntax highlighting.
>
> The proposal here had the same objectives (but is more elegant) to what created conventions like Hungarian notation where m_ prefixes member variables.
>
>
>
> Sent from my iPhone
>> On 05 Dec 2015, at 08:49, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>>
>> I'm not sure how many Swift users this effects, but I'm colorblind and I really struggle with the local vs properties syntax coloring.
>>
>> Tyler
>>
>>
>>
>>> On Dec 4, 2015, at 3:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods and doesn't color local variables/arguments. Is that not sufficient to distinguish this? In my experience the color is actually better than seeing the explicit `self.` because the color can be recognized faster than reading a word, and is visible in a high-level "squint" view of the function.
>>>
>>> If you're using another editor, well, my best suggestion there is to look into what it would take to integrate SourceKit functionality into that editor for more intelligent coloring :)
>>>
>>> -Kevin
>>>
>>>> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>>>> +1
>>>>
>>>> I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.
>>>>
>>>> I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.
>>>>
>>>>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>>>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>>>>
>>>>> Just as example, my proposition makes the following piece of code illegal:
>>>>>
>>>>> ```
>>>>> struct FooBar {
>>>>> var foo: String = "foobar"
>>>>>
>>>>> func bar() {
>>>>> print(foo) // compiler error
>>>>> print(self.foo) // compiler happy
>>>>> }
>>>>>
>>>>> func bar2() {
>>>>> bar() // compiler error
>>>>> self.bar() // compiler happy
>>>>> }
>>>>> }
>>>>> ```
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution


From rvojta at me.com  Sat Dec  5 05:48:54 2015
From: rvojta at me.com (Robert Vojta)
Date: Sat, 05 Dec 2015 12:48:54 +0100
Subject: [swift-evolution] Proposal: weakStrong self in completion handler
closures
Message-ID: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>

Hi all,

let’s say we have a completion handler closure for some function (networking, …) and we have [weak self] there. Example …

doSomething() { [weak self] result in
…
}

… then we can use self?.whatever to access self properties, methods. Or we can try to check if self exists ...

guard let strongSelf = self else { return }

… and use strongSelf.

Can we introduce [weakStrong self] with following behavior:

- self is a weak reference
- when the closure is going to be executed, all weakStrong weak references are checked if they do exist
- if they do exist, they’re strong referenced for the closure and the closure is executed
- if they don’t exist, closure is not executed

doSomething() { [weakStrong self] result in
// Closure code is not executed if self no longer exists
// self is a strong reference now
}

What do you think? Does it make sense?

My motivation is to get rid off of the repetitive code like this one:

doSomething() { [weak self] result in
guard let strongSelf = self else { return }
strongSelf.doSomethingWithResult(result)
}

Robert

From jhull at gbis.com  Sat Dec  5 06:27:50 2015
From: jhull at gbis.com (Jonathan Hull)
Date: Sat, 5 Dec 2015 04:27:50 -0800
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
Message-ID: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>

I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.

…but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).


I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).

For example:
• If an Int is casting to a larger size (Int16 -> Int32)
• Float -> Double
• Float -> CGFloat
• Int -> Float, Double, or CGFloat (but not the other way)

I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?

On a side note, can we get a version of floor() which returns an Int (or have I missed that somewhere)?

Thanks,
Jon

From michel.fortin at michelf.ca  Sat Dec  5 06:30:02 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sat, 5 Dec 2015 07:30:02 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <12115F95-4B8C-4051-AC36-AAAEFA979356@architechies.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<12115F95-4B8C-4051-AC36-AAAEFA979356@architechies.com>
Message-ID: <78D70088-A09D-4EDB-AD13-D5693CCB1A91@michelf.ca>

Le 4 déc. 2015 à 21:49, Brent Royal-Gordon <brent at architechies.com> a écrit :

> 	func addTarget<T: NSObject>(target: T?, action: @convention(selector) T -> AnyObject -> Void, forControlEvents: UIControlEvents)

Ok, just realized there's a problem here. This is a valid action method:

func someAction(sender: UIButton)

It won't work with the above addTarget because it expects a UIButton instead of AnyObject. The signature should say "Self" in the selector type instead of AnyObject so that you can only pass it to addTarget if the control is a UIButton... But you can't use Self in this context, so it still doesn't work.

--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From michel.fortin at michelf.ca  Sat Dec  5 06:30:48 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sat, 5 Dec 2015 07:30:48 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
Message-ID: <8508E135-791E-4B88-A758-9208388DA878@michelf.ca>

On Fri, Dec 4, 2015, at 06:46 PM, Michel Fortin wrote:

>> Implicit conversions cannot happen safely in the direction SubType to BaseType for
>> the arguments, including the target object. That makes Joe Groff's
>> approach the only type-safe solution: make an extension of the base
>> object and generate a method that does what you want. Which means that
>> instead of this:
>>
>> 	view.action = MyObject.doSomething
>>
>> you could write this:
>>
>> 	view.action = { (target: AnyObject) in {
>> 		(target as! MyObject).doSomething()
>> 	}
>>
>> ...which is safe. Maybe the compiler should just auto-generate that
>> boilerplate for you.
>
> How can you write that? A @convention(selector) can't actually contain
> any executable code [...]

Like this:

view.action = "_doSomething_UniqueSelector1234_currentModuleName_blahblah"

extension NSObject {
func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {
let target = self
(target as! MyObject).doSomething()
}
}

(Joe Groff suggested it first.) This simply assumes the receiver will derive from NSObject. You also need to set a non-nil target. And note that the closure is context-free, meaning you can't capture variables with it.

I wonder how many methods like this you can add to NSObject before it starts to impact objc_msgSend dispatch performance...


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From mailing at xenonium.com  Sat Dec  5 06:45:00 2015
From: mailing at xenonium.com (Jean-Daniel Dupas)
Date: Sat, 5 Dec 2015 13:45:00 +0100
Subject: [swift-evolution] Type Inferencing For Error Handling (try
catch blocks)
In-Reply-To: <5DE50203-B3CC-4825-9049-B6B8E211176E@me.com>
References: <etPan.566229ff.3f8f3108.10e90@Manav-Gabhawalas-MacBook-Pro.local>
<598691A3-A6F8-428C-BB16-E5C7AE48E5DD@apple.com>
<5DE50203-B3CC-4825-9049-B6B8E211176E@me.com>
Message-ID: <77B7AC2D-CED9-4F33-A951-30E3EEA8875A@xenonium.com>

One problem I see with that pattern, is that the exception declared will be part of the ABI, and adding a new exception will break backward compatibility.

As one goal of swift 3 is to provide a stable ABI by working around fragile ABI pattern, adding such a feature would probably be very difficult, and maybe not worth it.

> Le 5 déc. 2015 à 11:18, Adrian Kashivskyy <adrian.kashivskyy at me.com> a écrit :
>
> Related: https://lists.swift.org/pipermail/swift-evolution/2015-December/000076.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000076.html>
>
> Regards,
> Adrian Kashivskyy
> iOS Developer at Netguru
>
>> Wiadomość napisana przez John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> w dniu 05.12.2015, o godz. 01:15:
>>
>>> On Dec 4, 2015, at 4:04 PM, Manav Gabhawala <manav1907 at gmail.com <mailto:manav1907 at gmail.com>> wrote:
>>> irst of all, Swift is an absolute dream of a programming language and is really taking the future of programming in the right direction.
>>>
>>> However, it seems backwards to me that everything in swift is type safe and complete (like enum cases) but error handling seems lacking on that end. It would be a huge feature if the compiler could infer the types of errors functions throw and make sure you catch all the different types of errors at the call site. The compiler could also chain the types through multiple throwing function callers. This feature would require no extra work on the programmers part because the compiler would infer the types of errors being thrown. For example,
>>
>> This is a global type-checking problem.  It’s completely blocked by any dynamic features (like protocol or class methods) and library boundaries, so outside of toy examples, you will end up needing exhaustive pattern-matching pretty much everywhere.
>>
>> John.
>>
>>
>>>
>>>
>>> func foo() throws
>>> {
>>> 	...
>>> 	throw ErrorType1.BadRequest
>>> 	...
>>> 	throw ErrorType1.NoAuthentication
>>> 	...
>>> 	throw ErrorType2.NoResourceFound
>>> }
>>> func main()
>>> {
>>> 	do
>>> 	{
>>> 		foo()
>>> 	}
>>> 	catch (ErrorType1.BadRequest)
>>> 	{
>>>
>>> 	}
>>> 	catch (ErrorType2.NoResourceFound)
>>> 	{
>>> 	}
>>> 	// Compiler error because ErrorType1.NoAuthentication is not included.
>>> }
>>>
>>> Errors can also be chained together such that each function statically identifies the types thrown and if a call is made to a throwing function all the uncaught types are propagated out of the call stack. This would firstly be beneficial because we wouldn’t need the ridiculous empty catch { } block at the end that most people end up doing and secondly would ensure programmers are completely and always aware the possible errors that can be thrown by the function calls they make.
>>>
>>> Regards,
>>> Manav
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b510c805/attachment-0001.html>

From amichail at gmail.com  Sat Dec  5 07:02:30 2015
From: amichail at gmail.com (Amir Michail)
Date: Sat, 5 Dec 2015 08:02:30 -0500
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <80FA7736-F062-44BF-9846-260B09DFAA53@me.com>
References: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>
<80FA7736-F062-44BF-9846-260B09DFAA53@me.com>
Message-ID: <75A92E10-A106-41D0-8D54-0F72A515E769@gmail.com>

The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.

> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>
>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>
> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>
>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>
> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>
> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>
>
> Regards,
> Adrian Kashivskyy
> iOS Developer at Netguru
>
>> Wiadomość napisana przez Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> w dniu 05.12.2015, o godz. 00:53:
>>
>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>
>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>
>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/a3a01419/attachment.html>

From pyry.jahkola at iki.fi  Sat Dec  5 07:05:19 2015
From: pyry.jahkola at iki.fi (Pyry Jahkola)
Date: Sat, 5 Dec 2015 15:05:19 +0200
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
In-Reply-To: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
References: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
Message-ID: <E08C66CC-9957-4058-AC8D-070BC139D081@iki.fi>

> On 05 Dec 2015, at 14:27, Jonathan Hull <jhull at gbis.com> wrote:
>
> For example:
> • Int -> Float, Double, or CGFloat (but not the other way)

These are not "safe" conversions in general. A Float can only hold integral values up to 2^24, and Double a only up to 2^53. Neither can fit 64-bit integers and the former not even Int32.

> On a side note, can we get a version of floor() which returns an Int (or have I missed that somewhere)?


This would be nice. As would be similar versions of ceil and round.

— Pyry Jahkola
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0c738563/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0c738563/attachment.sig>

From p at greendale.se  Sat Dec  5 07:09:06 2015
From: p at greendale.se (Per Melin)
Date: Sat, 5 Dec 2015 14:09:06 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <F395A787-4509-4F56-AFBA-2E9E68984D88@hollance.com>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
<F395A787-4509-4F56-AFBA-2E9E68984D88@hollance.com>
Message-ID: <CADS5KKX7qL180FBXteYt8HnRTTxNJbbDk08c76aD+8ikfryr2w@mail.gmail.com>

On Sat, Dec 5, 2015 at 11:10 AM, Matthijs Hollemans <mail at hollance.com>
wrote:

>
>
Another example from the same LinkedList class. It finds the right place to
> insert a new node:
>
>   for next = head; next != nil && index > 0; prev = next, next = next!.
> next, --index { }
>
> Extreme? Probably, but I like it better than the same thing done in five
> lines of while loop.
>

next = head; while next != nil && index > 0 { prev = next; next =
next!.next; --index }

A 'for' statement gets away with a single line only because it substitutes
semicolons and commas for line breaks. You can do the same with 'while'.

But as Joe pointed out, you can recreate an almost identical 'for'
with autoclosures
anyway.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/03a80003/attachment.html>

From brent at architechies.com  Sat Dec  5 07:10:03 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 05:10:03 -0800
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
In-Reply-To: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
References: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
Message-ID: <48D8DCF6-3CE7-449E-9689-BB12F0756ED5@architechies.com>

> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.
>
> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).
>
>
> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).
>
> For example:
> • If an Int is casting to a larger size (Int16 -> Int32)
> • Float -> Double
> • Float -> CGFloat
> • Int -> Float, Double, or CGFloat (but not the other way)
>
> I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?

Well, certain large Ints may not have a corresponding Float, and very large ones (on 64-bit platforms) might not have an exact Double. In fact, even Float -> Double conversions can go subtly wrong, as I recall.

One reason not to do this is that I suspect it may slow down type inference, and thus the compiler. If every numeric type can be implicitly converted to a long list of larger types, that’s a lot more types for the compiler to think about every time you add two numbers.

Another is simply that it’s not clear how you would express to the type system which conversions could be done implicitly and which were verboten. Remember, Int and friends are all ordinary Swift structs; we don’t want to give them magical powers that aren’t available to other types. (I seem to recall that in the early Swift betas, there was a magic _convert() method or something that you could overload, but this was dropped as the language was redesigned. Perhaps the people who actually did the dropping could explain that one.)

A third is that conversions can, in some cases, cost time. Usually not much, but in a tight arithmetic loop it might matter.

A fourth: your code should probably not be using so many numeric types. There’s rarely a good reason to use an explicitly-sized integer, an unsigned integer, or a Float. That means most of your code should be using only Int, Double, and CGFloat (which is unavoidable). If you’re converting because an awkwardly-bridged API uses an explicitly sized type, overload the API with a wrapper that’s correctly typed. If you’re converting because you’re doing bit-twiddling, you probably need fine control over when values are resized.

Finally, if all that fails and you do need to convert, I prefer the strategy of marking your conversion sites explicitly. This (old, possibly out-of-date) code sample shows what I mean: <https://gist.github.com/brentdax/f85ede7dd7b26c6e716e> Marking conversions explicitly with a low-visual-impact operator which only allows widening conversions gets you the same safety as your proposal and nearly the same convenience, but also makes your meaning explicit, is kinder to the type checker, and doesn’t require any new features to be added to the type system.

--
Brent Royal-Gordon
Architechies


From a.michail at me.com  Sat Dec  5 07:14:16 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 08:14:16 -0500
Subject: [swift-evolution] "if case" syntax is ugly
Message-ID: <7F244C47-974E-4BC1-85BC-BFCA4905B488@me.com>

Maybe instead of: if case 1...3 = x { … }

You could have: if x case 1..3 { … }

And loops could be handled similarly: for x case 1..3 in z { … }


From austinzheng at gmail.com  Sat Dec  5 07:14:36 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Sat, 5 Dec 2015 05:14:36 -0800
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <75A92E10-A106-41D0-8D54-0F72A515E769@gmail.com>
References: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>
<80FA7736-F062-44BF-9846-260B09DFAA53@me.com>
<75A92E10-A106-41D0-8D54-0F72A515E769@gmail.com>
Message-ID: <368AE5B8-1202-4655-84EF-01831552ECF7@gmail.com>

Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.

Austin

> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com> wrote:
>
> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>
>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>
>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>
>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>
>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>
>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>
>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>
>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>
>>
>> Regards,
>> Adrian Kashivskyy
>> iOS Developer at Netguru
>>
>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> w dniu 05.12.2015, o godz. 00:53:
>>>
>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>
>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>
>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c451d368/attachment.html>

From michel.fortin at michelf.ca  Sat Dec  5 07:17:41 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sat, 5 Dec 2015 08:17:41 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <437319C0-F168-480E-A234-834645C90487@rols.org>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
Message-ID: <A2B6547D-CC4B-4A16-A481-522F9BF01813@michelf.ca>

Le 5 déc. 2015 à 2:54, Roland King <rols at rols.org> a écrit :

> Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue.

Well... you can do that:

var x = 0
while x < 10 {
defer { x += 1 } // warning: also increment x if an exception is thrown
continue
}

Or maybe the C-style for loop could just be made more readable. You could replace the semicolons with words:

for var x = 0 while x < 10 defer x += 1 {
}

But that might be slightly misleading. "defer" would imply that this part is executed when an exception is thrown, which would be unlike a regular for loop.

--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From amichail at gmail.com  Sat Dec  5 07:43:11 2015
From: amichail at gmail.com (Amir Michail)
Date: Sat, 5 Dec 2015 08:43:11 -0500
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <368AE5B8-1202-4655-84EF-01831552ECF7@gmail.com>
References: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>
<80FA7736-F062-44BF-9846-260B09DFAA53@me.com>
<75A92E10-A106-41D0-8D54-0F72A515E769@gmail.com>
<368AE5B8-1202-4655-84EF-01831552ECF7@gmail.com>
Message-ID: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>


> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com> wrote:
>
> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.

All programming languages are already enforcing subjective views about best practice in one form or another.

>
> Austin
>
>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> wrote:
>>
>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>>
>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>>
>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>>
>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>>
>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>>
>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>
>>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>>
>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>>
>>>
>>> Regards,
>>> Adrian Kashivskyy
>>> iOS Developer at Netguru
>>>
>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> w dniu 05.12.2015, o godz. 00:53:
>>>>
>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>>
>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>
>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/4ae5fcf8/attachment-0001.html>

From xcvista at me.com  Sat Dec  5 07:43:53 2015
From: xcvista at me.com (Maxthon Chan)
Date: Sat, 05 Dec 2015 21:43:53 +0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <03365B58-9067-47E7-98E4-B8620ABBC603@gmail.com>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
<03365B58-9067-47E7-98E4-B8620ABBC603@gmail.com>
Message-ID: <79F17F34-5A88-47AE-81D8-158C1A875754@me.com>

Keep it an option (-fself-ivar-access and -Wself-ivar-access) only please, or you break compatibility.

> On Dec 5, 2015, at 19:34, Dan <robear18 at gmail.com> wrote:
>
> I have the same feeling. Syntax highlighting is not enough to make things clear and even with it we are sometimes confused. We read swift code on GitHub, which doesn't have highlighting. Sometimes we do so in plain text. It looks like the only way to detect iVars is to open our Swift code is to open it in Xcode. So Swift is outsourcing iVar readability to Xcode, when it should be a language feature.
>
> Given this, some teams use underscores for their iVars which is very unfortunate. Myself, I use self whenever possible to be explicit. I'd like the language to force us to be clear.
> I would also like to point out that colours are a very unsafe mechanism of communicating programmer intent.
>
>> Message: 1
>> Date: Sat, 5 Dec 2015 10:35:08 +0100
>> From: David Hart <david at hartbit.com>
>> To: Tyler Cloutier <cloutiertyler at aol.com>
>> Cc: swift-evolution at swift.org
>> Subject: Re: [swift-evolution] Proposal: Re-instate mandatory self for
>> 	accessing instance properties and functions
>> Message-ID: <F9CA7C02-6596-4C36-A867-3613DE3D7DB7 at hartbit.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> As I said previously, same for me. But even if that weren't the case; I find it difficult to defend the readability of a language's feature uniquely by an editor's syntax highlighting.
>>
>> The proposal here had the same objectives (but is more elegant) to what created conventions like Hungarian notation where m_ prefixes member variables.
>>
>>
>>
>> Sent from my iPhone
>>> On 05 Dec 2015, at 08:49, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>>>
>>> I'm not sure how many Swift users this effects, but I'm colorblind and I really struggle with the local vs properties syntax coloring.
>>>
>>> Tyler
>>>
>>>
>>>
>>>> On Dec 4, 2015, at 3:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods and doesn't color local variables/arguments. Is that not sufficient to distinguish this? In my experience the color is actually better than seeing the explicit `self.` because the color can be recognized faster than reading a word, and is visible in a high-level "squint" view of the function.
>>>>
>>>> If you're using another editor, well, my best suggestion there is to look into what it would take to integrate SourceKit functionality into that editor for more intelligent coloring :)
>>>>
>>>> -Kevin
>>>>
>>>>> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>>>>> +1
>>>>>
>>>>> I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.
>>>>>
>>>>> I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.
>>>>>
>>>>>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>>>>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>>>>>
>>>>>> Just as example, my proposition makes the following piece of code illegal:
>>>>>>
>>>>>> ```
>>>>>> struct FooBar {
>>>>>> var foo: String = "foobar"
>>>>>>
>>>>>> func bar() {
>>>>>> print(foo) // compiler error
>>>>>> print(self.foo) // compiler happy
>>>>>> }
>>>>>>
>>>>>> func bar2() {
>>>>>> bar() // compiler error
>>>>>> self.bar() // compiler happy
>>>>>> }
>>>>>> }
>>>>>> ```
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4097 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f872ccab/attachment.p7s>

From austinzheng at gmail.com  Sat Dec  5 07:54:53 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Sat, 5 Dec 2015 05:54:53 -0800
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
References: <96AC7996-064F-4659-870E-2DFC0FE34009@gmail.com>
<80FA7736-F062-44BF-9846-260B09DFAA53@me.com>
<75A92E10-A106-41D0-8D54-0F72A515E769@gmail.com>
<368AE5B8-1202-4655-84EF-01831552ECF7@gmail.com>
<557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
Message-ID: <E251DBF9-4211-437B-B135-18D69116F0DA@gmail.com>

This is a bit pedantic. Every programming language and associated community (that I am aware of) makes a distinction between the set of inputs accepted by the compiler/interpreter, and the set of inputs constrained by whatever community conventions have evolved over time.

Anyways, I am -1 on this as well for the same reasons Adrian brought up: endless disagreement over what constitutes "OOP", "functional", etc programming style, and the loss of the ability to leverage Swift in a multi-paradigm fashion without ugly boilerplate.

Austin

> On Dec 5, 2015, at 5:43 AM, Amir Michail <amichail at gmail.com> wrote:
>
>>
>> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com <mailto:austinzheng at gmail.com>> wrote:
>>
>> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.
>
> All programming languages are already enforcing subjective views about best practice in one form or another.
>
>>
>> Austin
>>
>>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> wrote:
>>>
>>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>>>
>>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>>>
>>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>>>
>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>>>
>>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>>>
>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>
>>>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>>>
>>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>>>
>>>>
>>>> Regards,
>>>> Adrian Kashivskyy
>>>> iOS Developer at Netguru
>>>>
>>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> w dniu 05.12.2015, o godz. 00:53:
>>>>>
>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>>>
>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>
>>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0d1febb0/attachment-0001.html>

From griotspeak at gmail.com  Sat Dec  5 07:55:04 2015
From: griotspeak at gmail.com (T.J. Usiyan)
Date: Sat, 5 Dec 2015 19:25:04 +0530
Subject: [swift-evolution] Proposal: Tail Call Optimization keyword/attribute
Message-ID: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>

## Introduction

Tail call optimization can be a powerful tool when implementing certain
types of algorithms. Unfortunately, ARC's semantics interfere with our
ability to handle all possible cases of tail call recursion. An attribute,
similar to Scala's `tailrec`, along with LLVM warnings, could allow a clear
indicator of when such optimizations are not guaranteed to work.

## Motivation

LLVM will, currently, perform tail call optimization when possible cannot
guarantee such optimizations. ARC can interfere with tail call recursion by
inserting a method call after the intended 'last' recursive call. The
ability to insert this call is fundamental to ARC and, because of this,
swift developers currently have no insight into when TCO can/will occur.

``` swift
func fact(input: Int) -> Int {
func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
if n <= 0 {
return (0, value)
} else {
return _fact(n - 1, value: n * value)
}
}

return _fact(input, value: 1).value
}
```
In the provided example, the developer can be sure that tail call
optimization is possible but, without either a universal guarantee or
something like the proposed attribute, there is no wait to be sure that
such an optimization will occur.

## Proposed solution

Providing an attribute would provide developers with concrete klnowledge of
when TCO can and will be performed by LLVM in compiling their swift code.

``` swift
func fact(input: Int) -> Int {
@tailrec
func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
...
```
With this attribute, the developer can express the desire for TCO and
warnings can be emitted if TCO cannot be guaranteed. If there are currently
only a few such cases, developers are made aware of what those cases are
and can design implementations with this information at hand. As LLVM's
ability to provide TCO increases, the allowed cases simply grow with no
effect for the initial narrow cases.


## Detailed design
In an ideal situation, implementation of this feature can consist solely of
the attribute and output from LLVM indicating whether or not the requested
ptimization can be guaranteed. This proposal does not call for an expansion
of accepted cases.

## Impact on existing code

This should not have any breaking impact as it is strictly additive and
diagnostic.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/e4fea1bd/attachment.html>

From paulyoungonline at gmail.com  Sat Dec  5 08:09:49 2015
From: paulyoungonline at gmail.com (Paul Young)
Date: Sat, 05 Dec 2015 06:09:49 -0800 (PST)
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
Message-ID: <1449324589110.9d79fd62@Nodemailer>

Amir, you may be interested in SwiftLint: https://github.com/realm/SwiftLint

On Sat, Dec 5, 2015 at 1:43 PM, Amir Michail <amichail at gmail.com> wrote:

>> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com> wrote:
>>
>> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.
> All programming languages are already enforcing subjective views about best practice in one form or another.
>>
>> Austin
>>
>>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> wrote:
>>>
>>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>>>
>>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>>>
>>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>>>
>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>>>
>>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>>>
>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>
>>>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>>>
>>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>>>
>>>>
>>>> Regards,
>>>> Adrian Kashivskyy
>>>> iOS Developer at Netguru
>>>>
>>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> w dniu 05.12.2015, o godz. 00:53:
>>>>>
>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>>>
>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>
>>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/892dc461/attachment-0001.html>

From matthew at anandabits.com  Sat Dec  5 08:39:16 2015
From: matthew at anandabits.com (Anandabits)
Date: Sat, 5 Dec 2015 08:39:16 -0600
Subject: [swift-evolution] Proposal: Tail Call Optimization
keyword/attribute
In-Reply-To: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
References: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
Message-ID: <B2C9345B-198B-43B3-ADCC-4CB432EE9202@anandabits.com>

I like this proposal and I like the general approach even more.  Allow the programmer to make an assertion about performance and receive a warning or error when the compiler cannot guarantee the assertion will be met.  This will make it easier to reason about the performance of code in a language where performance is extremely reliant on optimizations.

Sent from my iPad

> On Dec 5, 2015, at 7:55 AM, T.J. Usiyan <griotspeak at gmail.com> wrote:
>
> ## Introduction
>
> Tail call optimization can be a powerful tool when implementing certain types of algorithms. Unfortunately, ARC's semantics interfere with our ability to handle all possible cases of tail call recursion. An attribute, similar to Scala's `tailrec`, along with LLVM warnings, could allow a clear indicator of when such optimizations are not guaranteed to work.
>
> ## Motivation
>
> LLVM will, currently, perform tail call optimization when possible cannot guarantee such optimizations. ARC can interfere with tail call recursion by inserting a method call after the intended 'last' recursive call. The ability to insert this call is fundamental to ARC and, because of this, swift developers currently have no insight into when TCO can/will occur.
>
> ``` swift
> func fact(input: Int) -> Int {
>     func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
>         if n <= 0 {
>             return (0, value)
>         } else {
>             return _fact(n - 1, value: n * value)
>         }
>     }
>
>     return _fact(input, value: 1).value
> }
> ```
> In the provided example, the developer can be sure that tail call optimization is possible but, without either a universal guarantee or something like the proposed attribute, there is no wait to be sure that such an optimization will occur.
>
> ## Proposed solution
>
> Providing an attribute would provide developers with concrete klnowledge of when TCO can and will be performed by LLVM in compiling their swift code.
>
> ``` swift
> func fact(input: Int) -> Int {
> 	@tailrec
>     func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
>         ...
> ```
> With this attribute, the developer can express the desire for TCO and warnings can be emitted if TCO cannot be guaranteed. If there are currently only a few such cases, developers are made aware of what those cases are and can design implementations with this information at hand. As LLVM's ability to provide TCO increases, the allowed cases simply grow with no effect for the initial narrow cases.
>
>
> ## Detailed design
> In an ideal situation, implementation of this feature can consist solely of the attribute and output from LLVM indicating whether or not the requested ptimization can be guaranteed. This proposal does not call for an expansion of accepted cases.
>
> ## Impact on existing code
>
> This should not have any breaking impact as it is strictly additive and diagnostic.
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/5fff9bdf/attachment.html>

From p at greendale.se  Sat Dec  5 08:41:44 2015
From: p at greendale.se (Per Melin)
Date: Sat, 5 Dec 2015 15:41:44 +0100
Subject: [swift-evolution] Please remove obscure "!" requirements for
implicitly unwrapped optionals
In-Reply-To: <A4ABDD80-B275-41DC-8F24-C95B24E780D8@apple.com>
References: <64434997-883A-4C7E-9D4E-5E588EC03251@me.com>
<005B4E50-5B96-4CAC-BB37-635DED459A54@apple.com>
<BE5C9398-FB8A-42F3-A2DB-F5508E6DEF6F@me.com>
<CADS5KKXUjrJSX-_-KYG9VRR0jPu_gifnKmzoJrC_RRBpp86j=Q@mail.gmail.com>
<8737035D-5799-4D68-9BF8-AF7EB6827681@apple.com>
<CADS5KKUX9Ux2zzdPR8KCgJFpCt76Kn+-=8ESVCEr17Ozq86GqA@mail.gmail.com>
<A4ABDD80-B275-41DC-8F24-C95B24E780D8@apple.com>
Message-ID: <CADS5KKXBAupNVfWuKLZ+kgi=g=ifmpP5KHaNThAx8LiaAtw6bw@mail.gmail.com>

On Sat, Dec 5, 2015 at 2:35 AM, Chris Lattner <clattner at apple.com> wrote:

> On Dec 4, 2015, at 5:00 PM, Per Melin <p at greendale.se> wrote:
>
> What surprised me was the IIUOs. I did not expect Swift to happily help me
> shoot myself in the foot quite so easily as this.
>
> func isNegative(i: Int?) -> Bool {
>     return i < 0
> }
>
> (No, I have never actually written code like this. I can't tell how likely
> it is that I would make this mistake.)
>
>
> This is a separate problem.  One of the things we plan to discuss (once
> things settle down a bit) is how to narrow the implicit conversion from T
> to T? in cases like this.  This implicit promotion, as well as the T <-> T!
> promotions are problematic in a number of ways, and we need a holistic
> solution to them.
>

I noticed that the promotion is recursive.

let n: Int??? = 0
true ? 4711 : n // => Optional(Optional(Optional(4711)))

Implicit promotions aside, what is the strong case for even having (T?, T?)
variants of the non-equatable comparable operators? I can see the
convenience when sorting optionals, but I must be missing something else?

Once everyone gets the bikeshedding over syntax out of their system,
hopefully the discussion can focus on more fundamental issues.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b93fd62c/attachment.html>

From cheyo at masters3d.com  Sat Dec  5 09:02:39 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Sat, 5 Dec 2015 09:02:39 -0600
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
Message-ID: <CAAcV4sZfM84x7rPWa=q-PNpoUQt7L+a9q9joz3Kt10W0kRukYg@mail.gmail.com>

Hi Sergey,

Are you thinking on writing the formal proposal for the if expression?

https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html


On Friday, December 4, 2015, Sergey Shulepov <s.pepyakin at gmail.com> wrote:

> Hello.
>
> It would be cool if control flow statements like "switch", "if" can be
> used as expressions, such as in languages like Scala, Rust and Kotlin,
> so instead of writing:
>
> var message: String
> if x % 2 == 0 {
>  message = "x is even"
> } else {
>  message = "x is odd"
> }
>
> you can write:
>
> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>
> I'm not into any kind of compiler development, and don't know is it
> feasible to introduce such change at the moment, but at least, I would like
> to hear why not.
> Thanks!
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/29231e61/attachment.html>

From p at greendale.se  Sat Dec  5 09:08:16 2015
From: p at greendale.se (Per Melin)
Date: Sat, 5 Dec 2015 16:08:16 +0100
Subject: [swift-evolution] Proposal: Tail Call Optimization
keyword/attribute
In-Reply-To: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
References: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
Message-ID: <CADS5KKXX_6FokEur3DyTdBw37eR7FN0SbbMNLrN2mjcs7FfVJQ@mail.gmail.com>

On Sat, Dec 5, 2015 at 2:55 PM, T.J. Usiyan <griotspeak at gmail.com> wrote:

>
> Tail call optimization can be a powerful tool when implementing certain
> types of algorithms. Unfortunately, ARC's semantics interfere with our
> ability to handle all possible cases of tail call recursion. An attribute,
> similar to Scala's `tailrec`, along with LLVM warnings, could allow a clear
> indicator of when such optimizations are not guaranteed to work.
>

I have primarily worked in functional languages with guaranteed tail call
elimination for many years. Turning to Swift, I (grudgingly) try to avoid
recursion altogether simply because of the risk of blowing the stack.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b17900f6/attachment-0001.html>

From david at hartbit.com  Sat Dec  5 09:13:45 2015
From: david at hartbit.com (David Hart)
Date: Sat, 5 Dec 2015 16:13:45 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions
In-Reply-To: <79F17F34-5A88-47AE-81D8-158C1A875754@me.com>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
<03365B58-9067-47E7-98E4-B8620ABBC603@gmail.com>
<79F17F34-5A88-47AE-81D8-158C1A875754@me.com>
Message-ID: <1CE915A8-7D9E-4DF9-8105-36AAC7D63D4D@hartbit.com>

Perhaps it could be a warning option. But I don’t think that breaking compatibility is an argument: many changes in Swift 3 continue to break source compatibility. Swift is not yet source stable, and still one year from being ABI stable.

> On 05 Dec 2015, at 14:43, Maxthon Chan <xcvista at me.com> wrote:
>
> Keep it an option (-fself-ivar-access and -Wself-ivar-access) only please, or you break compatibility.
>
>> On Dec 5, 2015, at 19:34, Dan <robear18 at gmail.com> wrote:
>>
>> I have the same feeling. Syntax highlighting is not enough to make things clear and even with it we are sometimes confused. We read swift code on GitHub, which doesn't have highlighting. Sometimes we do so in plain text. It looks like the only way to detect iVars is to open our Swift code is to open it in Xcode. So Swift is outsourcing iVar readability to Xcode, when it should be a language feature.
>>
>> Given this, some teams use underscores for their iVars which is very unfortunate. Myself, I use self whenever possible to be explicit. I'd like the language to force us to be clear.
>> I would also like to point out that colours are a very unsafe mechanism of communicating programmer intent.
>>
>>> Message: 1
>>> Date: Sat, 5 Dec 2015 10:35:08 +0100
>>> From: David Hart <david at hartbit.com>
>>> To: Tyler Cloutier <cloutiertyler at aol.com>
>>> Cc: swift-evolution at swift.org
>>> Subject: Re: [swift-evolution] Proposal: Re-instate mandatory self for
>>> 	accessing instance properties and functions
>>> Message-ID: <F9CA7C02-6596-4C36-A867-3613DE3D7DB7 at hartbit.com>
>>> Content-Type: text/plain; charset="utf-8"
>>>
>>> As I said previously, same for me. But even if that weren't the case; I find it difficult to defend the readability of a language's feature uniquely by an editor's syntax highlighting.
>>>
>>> The proposal here had the same objectives (but is more elegant) to what created conventions like Hungarian notation where m_ prefixes member variables.
>>>
>>>
>>>
>>> Sent from my iPhone
>>>> On 05 Dec 2015, at 08:49, Tyler Cloutier <cloutiertyler at aol.com> wrote:
>>>>
>>>> I'm not sure how many Swift users this effects, but I'm colorblind and I really struggle with the local vs properties syntax coloring.
>>>>
>>>> Tyler
>>>>
>>>>
>>>>
>>>>> On Dec 4, 2015, at 3:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>>
>>>>> Do you use Xcode to edit Swift? Xcode gives a color to properties/methods and doesn't color local variables/arguments. Is that not sufficient to distinguish this? In my experience the color is actually better than seeing the explicit `self.` because the color can be recognized faster than reading a word, and is visible in a high-level "squint" view of the function.
>>>>>
>>>>> If you're using another editor, well, my best suggestion there is to look into what it would take to integrate SourceKit functionality into that editor for more intelligent coloring :)
>>>>>
>>>>> -Kevin
>>>>>
>>>>>> On Fri, Dec 4, 2015, at 03:29 PM, Colin Cornaby wrote:
>>>>>> +1
>>>>>>
>>>>>> I've had a lot of weird things happen that I've traced to mistakes in properties having the same name as function arguments. I've hardly ever had this issue in modern Obj-C.
>>>>>>
>>>>>> I'm a little more ok with functions not needing self as it's less likely for those to shadow something like an argument, but I guess the consistency would be nice too.
>>>>>>
>>>>>>> On Dec 04, 2015, at 01:20 PM, David Hart <david at hartbit.com> wrote:
>>>>>>> I don't understand the reasoning behind removing the need to access instance properties and functions using self. Swift has always seemed to prefer readability to brevity and the feature makes the distinction between local and instance variables/functions crystal clear. Any good reason I shouldn't go on with the proposition?
>>>>>>>
>>>>>>> Just as example, my proposition makes the following piece of code illegal:
>>>>>>>
>>>>>>> ```
>>>>>>> struct FooBar {
>>>>>>> var foo: String = "foobar"
>>>>>>>
>>>>>>> func bar() {
>>>>>>> print(foo) // compiler error
>>>>>>> print(self.foo) // compiler happy
>>>>>>> }
>>>>>>>
>>>>>>> func bar2() {
>>>>>>> bar() // compiler error
>>>>>>> self.bar() // compiler happy
>>>>>>> }
>>>>>>> }
>>>>>>> ```
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From jgroff at apple.com  Sat Dec  5 09:17:30 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 07:17:30 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
Message-ID: <1C5141F0-FAF2-475C-BB17-05669A1B0E7D@apple.com>


> On Dec 5, 2015, at 4:30 AM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> On Fri, Dec 4, 2015, at 06:46 PM, Michel Fortin wrote:
>
>>> Implicit conversions cannot happen safely in the direction SubType to BaseType for
>>> the arguments, including the target object. That makes Joe Groff's
>>> approach the only type-safe solution: make an extension of the base
>>> object and generate a method that does what you want. Which means that
>>> instead of this:
>>>
>>> 	view.action = MyObject.doSomething
>>>
>>> you could write this:
>>>
>>> 	view.action = { (target: AnyObject) in {
>>> 		(target as! MyObject).doSomething()
>>> 	}
>>>
>>> ...which is safe. Maybe the compiler should just auto-generate that
>>> boilerplate for you.
>>
>> How can you write that? A @convention(selector) can't actually contain
>> any executable code [...]
>
> Like this:
>
> 	view.action = "_doSomething_UniqueSelector1234_currentModuleName_blahblah"
>
> 	extension NSObject {
> 		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {
> 			let target = self
> 			(target as! MyObject).doSomething()
> 		}
> 	}
>
> (Joe Groff suggested it first.) This simply assumes the receiver will derive from NSObject. You also need to set a non-nil target. And note that the closure is context-free, meaning you can't capture variables with it.
>
> I wonder how many methods like this you can add to NSObject before it starts to impact objc_msgSend dispatch performance...

The receiver doesn't have to inherit NSObject. Pure Swift classes on Darwin are id-compatible and can have categories as well.

-Joe

From me at tal.by  Sat Dec  5 09:23:52 2015
From: me at tal.by (Tal Atlas)
Date: Sat, 05 Dec 2015 15:23:52 +0000
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <445b3686-2a66-4f10-a18b-e6cd3f9bebf0@Spark>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<CADQN+5as0oDhsK=QfvGEE1LzPYnQESHgQR4i6+P6QH+cr8bv-A@mail.gmail.com>
<B2247953-F125-4344-821A-8EDBAD969FB0@anandabits.com>
<445b3686-2a66-4f10-a18b-e6cd3f9bebf0@Spark>
Message-ID: <CA+ddMk0kRFbbHF0z3KOFRzOt1YUJEM5tCbSP63+t0tfNWeJcZQ@mail.gmail.com>

I still think that it should include the type in the initializer definition
because if you have private properties you’d need to expose the type
information somehow and that type inference doesn’t work that way anywhere
else in swift, so explicitly requiring the type information in the
initializer is consistent with the rest of swift.

On Sat, Dec 5, 2015 at 12:20 AM <crk at fastmail.com> wrote:

> I'm not entirely sure what your proposal changes, other than omitting the
> argument labels and us wing self to refer to the property. Could you try a
> trivial example that would be runnable if the change was implemented?
>
> Thanks for your time,
> Cole Kurkowski
>
> On Dec 4, 2015, 21:59 -0600, Matthew Johnson <matthew at anandabits.com>,
> wrote:
>
> I think this idea scratches at the surface of a problem with initializers
> that definitely merits some attention.  Boilerplate is common in
> initializers which can lead to types that don’t allow as much flexibility
> to callers as might be desirable.
>
> More importantly, it can also lead to “initialized” instances that are not
> fully or properly configured, (implicitly unwrapped?) optional members, and
> mutability that shouldn’t be necessary past the initial configuration stage
> of the instance.  For example, if a type provides a family of initializers,
> but also has several members which are intended to be initialized /
> configured directly by callers a developer could choose to avoid the
> boilerplate by declaring the additional members as as an implicitly
> unwrapped optional var members.  No doubt this is a bad idea.  If the
> caller does not initialize all of the additional members there is a bomb
> waiting to go off.  Furthermore, there is the potential for mutation after
> initialization that may not be expected or intended.  By requiring a
> nontrivial amount of boilerplate to avoid this situation the language is
> unintentionally nudging lazy developers towards bad practices like this.
>
> Let's start with the current proposal but go a bit further and see how
> much boilerplate can be removed.  The type information is already known
> from the property declaration, and furthermore a default may also be
> available in the property declaration.
>
> struct Foo {
>     let bar: String
>     let bas: Int = 1
>     let bat:  Float = 0
>     let bax: String = “default"
>     let baz: Double
>
>     // self.bar is known to be a String but does not have a default value
> so it must be provided by the caller
>     // self.bas is known to be an Int and implicitly has a default value
> of 1 specified by the property
>     // so it does not need to be provided by the caller
>     // self.bat is known to be a Float, but the default is overridden to
> be 1 instead of 0
>     // external labels are provided that correspond to the names of the
> properties
>     init(self.bar, self.bas, self.bat = 1) {
> // the initializer does not receive a value for baz and the property does
> not provide a default
>         // so it must be initialized here before the first phase of
> initialization is complete
>         // if all stored properties had received values through parameters
> or through property defaults
>         // the first phase of initialization would have already been
> completed when the body of the initializer was entered
>         self.baz = someComputedDoubleValue()
>         // now all stored properties have been initialized so the first
> phase of initialization is complete
>     }
> }
>
> This structure allows us to remove the boilerplate of the property type
> and default value.
>
> Given the significant difference from regular function parameters, it may
> make sense to set these apart syntactically in some way, although I am not
> sure what would make the most sense.  For example, we could just have a
> second parameter tuple in the initializer declaration which represents the
> “member parameters” to the initializer like this:
>
> init(foo: Int)(self.bar, self.bas, self.bat = 1)
>
> or a vertical pipe like this:
>
> init(foo: Int | self.bar, self.bas, self.bat = 1)
>
> Setting these “member parameters” apart syntactically could also
> facilitate additional mechanisms to further reduce boilerplate if we find
> that the same group of “member parameters" exist for several different
> initializers in the same type.  For example, it might become possible to
> implement a memberwise initializer like this:
>
> // @automembers expands to match all stored properties
> init()(@automembers) {}
>
> At this point we have eliminated virtually all of the boilerplate,
> encouraging developers to use concise *and* safe, yet still flexible
> initialization strategies.
>
> Matthew
>
>
>
> On Dec 4, 2015, at 9:05 PM, Dan Appel <dan.appel00 at gmail.com> wrote:
>
> I'm not sure how I feel about this, but in either case, why limit it to
> default parameters? It's useful in other situations, too.
>
> Take this for example:
> struct Foo {
>     let bar: String
>     let bas: Int
>     let baz: Double
>     init(self.bar: String, self.bas: Int, bax: Int) {
>         self.baz = Double(bax)
>     }
> }
>
> where the need to say
>
> self.bar = bar
> self.bas = bas
>
> is now avoided.
>
> On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas <me at tal.by> wrote:
>
>> There’s lots of boilerplate of initializing structs with stored
>> properties and initializer parameters. I’d like to create a syntax for
>> alleviating that in the 90% case.
>>
>> ```swift
>> struct Foo {
>>     let bar: String
>>     let baz: Int
>>
>>     init(self.bar: String = "default", counter self.baz: Int) {
>>     }
>> }
>> ```
>>
>> This would be identical to:
>> ```swift
>> struct Foo {
>>     let bar: String
>>     let baz: Int
>>
>>     init(bar: String = "default", counter baz: Int) {
>>         self.bar = bar
>>         self.baz = baz
>>     }
>> }
>> ```
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
> --
> Dan Appel
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7920b864/attachment-0001.html>

From adrian.zubarev at devandartist.com  Sat Dec  5 09:26:21 2015
From: adrian.zubarev at devandartist.com (Adrian Zubarev)
Date: Sat, 5 Dec 2015 16:26:21 +0100
Subject: [swift-evolution] Proposal: Finalization in protocol extensions and
default implementations
Message-ID: <etPan.5663021d.1380a8b3.1f6@mscience.fritz.box>

Hello there,

I wonder if it is a good idea to be able to finalize in protocols and default implementations.

Here is an example:

protocol MagicType {

final var foo: Int { get }
final func boo()
}

class X: MagicType {

final var foo: Int {

return 42
}

final func boo() {

print("magic")
}
}

class Y: X {

// can't override func boo or var foo in here
}

//===================================================//

protocol SomeType {}

extension SomeType {

final func foo() {

print("Hello World")
}
}

class A: SomeType {}

class B: SomeType {

/* this should raise an error, because the class B shouldn't */
/* be able to override that function from SomeType */

func foo() {
// do something else
}
}


—
Regards Adrian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/2dc2398e/attachment.html>

From michel.fortin at michelf.ca  Sat Dec  5 09:29:08 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sat, 5 Dec 2015 10:29:08 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1C5141F0-FAF2-475C-BB17-05669A1B0E7D@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
<1C5141F0-FAF2-475C-BB17-05669A1B0E7D@apple.com>
Message-ID: <ED8A8EA1-A0FD-4756-A9BD-76509DFB29D1@michelf.ca>

Le 5 déc. 2015 à 10:17, Joe Groff <jgroff at apple.com> a écrit :
> The receiver doesn't have to inherit NSObject. Pure Swift classes on Darwin are id-compatible and can have categories as well.

Does that mean that the compiler has to write two categories? one for NSObject and one for the root Swift class?

--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From jgroff at apple.com  Sat Dec  5 09:30:36 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 07:30:36 -0800
Subject: [swift-evolution] Proposal: Tail Call Optimization
keyword/attribute
In-Reply-To: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
References: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
Message-ID: <0A765714-4F27-49A2-AF87-41551FF44199@apple.com>

Requiring an explicit 'tail' annotation for tail calls is definitely the right way to approach this. However, ARC is not the only (or even the primary) reason tail recursion is problematic for Swift. ARC operations are not strictly ordered, unlike C++ destructors; the compiler is free to release values at any point after their last use. As long as a tail-callable function uses a convention where the callee takes ownership of all of its refcounted parameters, then ARC can avoid interfering with tail calls. However, there are other low-level resources that need to be managed in the case of an arbitrary tail call, such as space on the callstack and memory for indirectly-passed parameters. Being able to manage these would require a special machine-level calling convention that would have overhead we don't want to spend pervasively to make arbitrary functions tail-callable. Because of this, we'd have to put further restrictions on what can be tail-called. Some options, in rough order of complexity, include:

- only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,
- only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,
- only allowing tail calls between functions in the same module or external functions marked with a '@tail_callable' attribute.

-Joe

> On Dec 5, 2015, at 5:55 AM, T.J. Usiyan <griotspeak at gmail.com> wrote:
>
> ## Introduction
>
> Tail call optimization can be a powerful tool when implementing certain types of algorithms. Unfortunately, ARC's semantics interfere with our ability to handle all possible cases of tail call recursion. An attribute, similar to Scala's `tailrec`, along with LLVM warnings, could allow a clear indicator of when such optimizations are not guaranteed to work.
>
> ## Motivation
>
> LLVM will, currently, perform tail call optimization when possible cannot guarantee such optimizations. ARC can interfere with tail call recursion by inserting a method call after the intended 'last' recursive call. The ability to insert this call is fundamental to ARC and, because of this, swift developers currently have no insight into when TCO can/will occur.
>
> ``` swift
> func fact(input: Int) -> Int {
>     func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
>         if n <= 0 {
>             return (0, value)
>         } else {
>             return _fact(n - 1, value: n * value)
>         }
>     }
>
>     return _fact(input, value: 1).value
> }
> ```
> In the provided example, the developer can be sure that tail call optimization is possible but, without either a universal guarantee or something like the proposed attribute, there is no wait to be sure that such an optimization will occur.
>
> ## Proposed solution
>
> Providing an attribute would provide developers with concrete klnowledge of when TCO can and will be performed by LLVM in compiling their swift code.
>
> ``` swift
> func fact(input: Int) -> Int {
> 	@tailrec
>     func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
>         ...
> ```
> With this attribute, the developer can express the desire for TCO and warnings can be emitted if TCO cannot be guaranteed. If there are currently only a few such cases, developers are made aware of what those cases are and can design implementations with this information at hand. As LLVM's ability to provide TCO increases, the allowed cases simply grow with no effect for the initial narrow cases.
>
>
> ## Detailed design
> In an ideal situation, implementation of this feature can consist solely of the attribute and output from LLVM indicating whether or not the requested ptimization can be guaranteed. This proposal does not call for an expansion of accepted cases.
>
> ## Impact on existing code
>
> This should not have any breaking impact as it is strictly additive and diagnostic.
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1f5fc2da/attachment.html>

From jgroff at apple.com  Sat Dec  5 09:31:38 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 07:31:38 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <ED8A8EA1-A0FD-4756-A9BD-76509DFB29D1@michelf.ca>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
<1C5141F0-FAF2-475C-BB17-05669A1B0E7D@apple.com>
<ED8A8EA1-A0FD-4756-A9BD-76509DFB29D1@michelf.ca>
Message-ID: <D66F3B20-5C11-4BD5-8496-BFD7D7F882A9@apple.com>


> On Dec 5, 2015, at 7:29 AM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
> Le 5 déc. 2015 à 10:17, Joe Groff <jgroff at apple.com> a écrit :
>> The receiver doesn't have to inherit NSObject. Pure Swift classes on Darwin are id-compatible and can have categories as well.
>
> Does that mean that the compiler has to write two categories? one for NSObject and one for the root Swift class?

If the selector is expected to exist on an arbitrary `id`, maybe. If it only needs to exist on its `Self` type, it seems to me we can emit the category onto the specific class.

-Joe

From jhull at gbis.com  Sat Dec  5 09:35:01 2015
From: jhull at gbis.com (Jonathan Hull)
Date: Sat, 5 Dec 2015 07:35:01 -0800
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <CAAcV4sZfM84x7rPWa=q-PNpoUQt7L+a9q9joz3Kt10W0kRukYg@mail.gmail.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<CAAcV4sZfM84x7rPWa=q-PNpoUQt7L+a9q9joz3Kt10W0kRukYg@mail.gmail.com>
Message-ID: <0F0E10B2-B838-4FFD-BF9E-182CFAF981BD@gbis.com>

Don’t we already have the following?

let message:String = (x % 2) ? “x is even” : “x is odd"


> On Dec 5, 2015, at 7:02 AM, J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>
> Hi Sergey,
>
> Are you thinking on writing the formal proposal for the if expression?
>
> https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html>
>
>
> On Friday, December 4, 2015, Sergey Shulepov <s.pepyakin at gmail.com <mailto:s.pepyakin at gmail.com>> wrote:
> Hello.
>
> It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
> so instead of writing:
>
> var message: String
> if x % 2 == 0 {
>  message = "x is even"
> } else {
>  message = "x is odd"
> }
>
> you can write:
>
> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>
> I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.
> Thanks!
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/09b73a83/attachment.html>

From jhull at gbis.com  Sat Dec  5 09:41:16 2015
From: jhull at gbis.com (Jonathan Hull)
Date: Sat, 5 Dec 2015 07:41:16 -0800
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <0F0E10B2-B838-4FFD-BF9E-182CFAF981BD@gbis.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<CAAcV4sZfM84x7rPWa=q-PNpoUQt7L+a9q9joz3Kt10W0kRukYg@mail.gmail.com>
<0F0E10B2-B838-4FFD-BF9E-182CFAF981BD@gbis.com>
Message-ID: <5BB541C3-F47F-4194-9AD8-89BB821288C0@gbis.com>

Sorry, that should be:

let message:String = (x % 2 == 0) ? “x is even” : “x is odd”

> On Dec 5, 2015, at 7:35 AM, Jonathan Hull <jhull at gbis.com> wrote:
>
> Don’t we already have the following?
>
> let message:String = (x % 2) ? “x is even” : “x is odd"
>
>
>> On Dec 5, 2015, at 7:02 AM, J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>
>> Hi Sergey,
>>
>> Are you thinking on writing the formal proposal for the if expression?
>>
>> https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html>
>>
>>
>> On Friday, December 4, 2015, Sergey Shulepov <s.pepyakin at gmail.com <mailto:s.pepyakin at gmail.com>> wrote:
>> Hello.
>>
>> It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
>> so instead of writing:
>>
>> var message: String
>> if x % 2 == 0 {
>>  message = "x is even"
>> } else {
>>  message = "x is odd"
>> }
>>
>> you can write:
>>
>> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>>
>> I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.
>> Thanks!
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <javascript:;>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f6ed35d1/attachment.html>

From matthew at anandabits.com  Sat Dec  5 09:55:12 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 09:55:12 -0600
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <CA+ddMk0kRFbbHF0z3KOFRzOt1YUJEM5tCbSP63+t0tfNWeJcZQ@mail.gmail.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<CADQN+5as0oDhsK=QfvGEE1LzPYnQESHgQR4i6+P6QH+cr8bv-A@mail.gmail.com>
<B2247953-F125-4344-821A-8EDBAD969FB0@anandabits.com>
<445b3686-2a66-4f10-a18b-e6cd3f9bebf0@Spark>
<CA+ddMk0kRFbbHF0z3KOFRzOt1YUJEM5tCbSP63+t0tfNWeJcZQ@mail.gmail.com>
Message-ID: <A4F1F138-D314-4B16-9DC8-AA23FC176098@anandabits.com>

Even though a private property is not visible to compilers it is visible to the compiler.  If the developer makes a request to expose that property in an initializer the compiler could easily insert the type information in the signature of the initializer.

That said, the most important point I want to emphasize is the problems caused by boilerplate in initializers.  I showed one way this problem could be solved building on the previous proposal syntactically.  The exact solution and syntax don’t really matter that much to me but I would like to see Swift better support flexible and safe initialization without requiring boilerplate in one way or another.

If there is interest I will try to track down some examples to make the discussion more concrete.

> On Dec 5, 2015, at 9:23 AM, Tal Atlas <me at tal.by> wrote:
>
> I still think that it should include the type in the initializer definition because if you have private properties you’d need to expose the type information somehow and that type inference doesn’t work that way anywhere else in swift, so explicitly requiring the type information in the initializer is consistent with the rest of swift.
>
> On Sat, Dec 5, 2015 at 12:20 AM <crk at fastmail.com <mailto:crk at fastmail.com>> wrote:
> I'm not entirely sure what your proposal changes, other than omitting the argument labels and us wing self to refer to the property. Could you try a trivial example that would be runnable if the change was implemented?
>
> Thanks for your time,
> Cole Kurkowski
>
> On Dec 4, 2015, 21:59 -0600, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>>, wrote:
>> I think this idea scratches at the surface of a problem with initializers that definitely merits some attention.  Boilerplate is common in initializers which can lead to types that don’t allow as much flexibility to callers as might be desirable.
>>
>> More importantly, it can also lead to “initialized” instances that are not fully or properly configured, (implicitly unwrapped?) optional members, and mutability that shouldn’t be necessary past the initial configuration stage of the instance.  For example, if a type provides a family of initializers, but also has several members which are intended to be initialized / configured directly by callers a developer could choose to avoid the boilerplate by declaring the additional members as as an implicitly unwrapped optional var members.  No doubt this is a bad idea.  If the caller does not initialize all of the additional members there is a bomb waiting to go off.  Furthermore, there is the potential for mutation after initialization that may not be expected or intended.  By requiring a nontrivial amount of boilerplate to avoid this situation the language is unintentionally nudging lazy developers towards bad practices like this.
>>
>> Let's start with the current proposal but go a bit further and see how much boilerplate can be removed.  The type information is already known from the property declaration, and furthermore a default may also be available in the property declaration.
>>
>> struct Foo {
>>     let bar: String
>>     let bas: Int = 1
>>     let bat:  Float = 0
>>     let bax: String = “default"
>>     let baz: Double
>>
>>     // self.bar is known to be a String but does not have a default value so it must be provided by the caller
>>     // self.bas is known to be an Int and implicitly has a default value of 1 specified by the property
>>     // so it does not need to be provided by the caller
>>     // self.bat is known to be a Float, but the default is overridden to be 1 instead of 0
>>     // external labels are provided that correspond to the names of the properties
>>     init(self.bar, self.bas, self.bat = 1) {
>> // the initializer does not receive a value for baz and the property does not provide a default
>>         // so it must be initialized here before the first phase of initialization is complete
>>         // if all stored properties had received values through parameters or through property defaults
>>         // the first phase of initialization would have already been completed when the body of the initializer was entered
>>         self.baz = someComputedDoubleValue()
>>         // now all stored properties have been initialized so the first phase of initialization is complete
>>     }
>> }
>>
>> This structure allows us to remove the boilerplate of the property type and default value.
>>
>> Given the significant difference from regular function parameters, it may make sense to set these apart syntactically in some way, although I am not sure what would make the most sense.  For example, we could just have a second parameter tuple in the initializer declaration which represents the “member parameters” to the initializer like this:
>>
>> init(foo: Int)(self.bar, self.bas, self.bat = 1)
>>
>> or a vertical pipe like this:
>>
>> init(foo: Int | self.bar, self.bas, self.bat = 1)
>>
>> Setting these “member parameters” apart syntactically could also facilitate additional mechanisms to further reduce boilerplate if we find that the same group of “member parameters" exist for several different initializers in the same type.  For example, it might become possible to implement a memberwise initializer like this:
>>
>> // @automembers expands to match all stored properties
>> init()(@automembers) {}
>>
>> At this point we have eliminated virtually all of the boilerplate, encouraging developers to use concise *and* safe, yet still flexible initialization strategies.
>>
>> Matthew
>>
>>
>>
>>> On Dec 4, 2015, at 9:05 PM, Dan Appel <dan.appel00 at gmail.com <mailto:dan.appel00 at gmail.com>> wrote:
>>>
>>> I'm not sure how I feel about this, but in either case, why limit it to default parameters? It's useful in other situations, too.
>>>
>>> Take this for example:
>>> struct Foo {
>>>     let bar: String
>>>     let bas: Int
>>>     let baz: Double
>>>     init(self.bar: String, self.bas: Int, bax: Int) {
>>>         self.baz = Double(bax)
>>>     }
>>> }
>>>
>>> where the need to say
>>>
>>> self.bar = bar
>>> self.bas = bas
>>>
>>> is now avoided.
>>>
>>> On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas <me at tal.by <mailto:me at tal.by>> wrote:
>>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.
>>>
>>> ```swift
>>> struct Foo {
>>>     let bar: String
>>>     let baz: Int
>>>
>>>     init(self.bar: String = "default", counter self.baz: Int) {
>>>     }
>>> }
>>> ```
>>>
>>> This would be identical to:
>>> ```swift
>>> struct Foo {
>>>     let bar: String
>>>     let baz: Int
>>>
>>>     init(bar: String = "default", counter baz: Int) {
>>>         self.bar = bar
>>>         self.baz = baz
>>>     }
>>> }
>>> ```
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>> --
>>> Dan Appel
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1ae7233c/attachment-0001.html>

From david at hartbit.com  Sat Dec  5 09:56:18 2015
From: david at hartbit.com (David Hart)
Date: Sat, 5 Dec 2015 16:56:18 +0100
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <5BB541C3-F47F-4194-9AD8-89BB821288C0@gbis.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<CAAcV4sZfM84x7rPWa=q-PNpoUQt7L+a9q9joz3Kt10W0kRukYg@mail.gmail.com>
<0F0E10B2-B838-4FFD-BF9E-182CFAF981BD@gbis.com>
<5BB541C3-F47F-4194-9AD8-89BB821288C0@gbis.com>
Message-ID: <959CF80B-4021-4475-A585-5D9B83B4A0AA@hartbit.com>

The ternary operator is indeed equivalent to an if expression but:

1) There is no equivalent for switch.
2) There is also a proposition to remove the ternary operator in favour of a if expression.

David.

> On 05 Dec 2015, at 16:41, Jonathan Hull <jhull at gbis.com> wrote:
>
> Sorry, that should be:
>
> let message:String = (x % 2 == 0) ? “x is even” : “x is odd”
>
>> On Dec 5, 2015, at 7:35 AM, Jonathan Hull <jhull at gbis.com <mailto:jhull at gbis.com>> wrote:
>>
>> Don’t we already have the following?
>>
>> let message:String = (x % 2) ? “x is even” : “x is odd"
>>
>>
>>> On Dec 5, 2015, at 7:02 AM, J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>>
>>> Hi Sergey,
>>>
>>> Are you thinking on writing the formal proposal for the if expression?
>>>
>>> https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000165.html>
>>>
>>>
>>> On Friday, December 4, 2015, Sergey Shulepov <s.pepyakin at gmail.com <mailto:s.pepyakin at gmail.com>> wrote:
>>> Hello.
>>>
>>> It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
>>> so instead of writing:
>>>
>>> var message: String
>>> if x % 2 == 0 {
>>>  message = "x is even"
>>> } else {
>>>  message = "x is odd"
>>> }
>>>
>>> you can write:
>>>
>>> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>>>
>>> I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.
>>> Thanks!
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/e7773e40/attachment.html>

From plxswift at icloud.com  Sat Dec  5 09:57:37 2015
From: plxswift at icloud.com (plx)
Date: Sat, 05 Dec 2015 09:57:37 -0600
Subject: [swift-evolution] Proposal: Automatic Wrapper Synthesis /
"deriving"
In-Reply-To: <98365168-A35C-43B3-9632-2ABDF9627DDB@harlanhaskins.com>
References: <98365168-A35C-43B3-9632-2ABDF9627DDB@harlanhaskins.com>
Message-ID: <965ADE10-8F98-465E-9030-2050C51524E1@icloud.com>

I definitely got off on the wrong foot by using `deriving`; what I was trying to ask for is more of a stronger typealias (perhaps `newtype`-esque is the right analogy?), which — at least for my purposes — would *ideally* have the following capabilities / rules:

- when Y is a wrapper around an X, Y has only a single, “synthesized" stored property (of type X)
- the user can control the name of the stored property by one of these mechanisms (which one is used is moot to me):
- override the name of the synthesized stored property
- indicate another name and have an accessor auto-generated
- every protocol adopted by X *can* be auto-synthesized for Y
- but the user has to explicitly request each specific protocol be synthesized…
- …because it’s very important that it be possible to *not* adopt every one of X’s protocols
- the user can optionally provide some predicate (of type (X) -> Bool), which then:
- is included as an assert/precondition inside a synthesized `init(_ x: X)`
- is perhaps/can-be used inside some synthesized `init?(_ x: X)` (this is trickier at present, and might be better as a static func)
- is ideally available on some methods like `func isInvariantSatisfied() -> Bool; static func isWrappableValue(x: X) -> Bool` (e.g. for debugging/testing)
- …are essentially for documentation and some very modest runtime verification
- there’s some standard/principled way to do type-erasure "back down to X” as-needed

Only supporting single-value-wrappers should make the needed syntheses essentially trivial as far as I can tell; the only obviously non-trivial aspect is that, in practice, it’d seem likely that you’d want to occasionally “override” the typealiases from X with wrappers thereof; e.g. if you had a type Y wrapping Set<Foo>, you might want Y’s `Index` to be a wrapper around `SetIndex<Foo>` and *not just* `SetIndex<Foo>`; this doesn’t seem overly-complicated semantically but it isn’t “trivial”, either, and would perhaps need additional syntax support to read nicely in-use.

Here are a few concrete example motivating the above requests:

## UI-Level Section/Item Indices

It’s a nice — albeit minor — improvement to work with Int-wrappers like `SectionIndex` and `ItemIndex` rather than as primitive, interchangeable `Int` everywhere. It’s particularly handy if trying to write reasonably-generic implementations of the common UI-level datasource/delegate protocols.

For this:

- it’s nice to have the wrapped value accessible as `index` (as opposed to e.g. `wrappedValue` or `storage`, etc.)
- it’s nice to *not* wind up with the arithmetic operations from `Int`:
- accidental use of e.g. `*` or `+` or `-` (etc.) on `SectionIndex` or `ItemIndex` is *probably* an error!
- it’s nice to *not* wind up as `IntegerLiteralConvertible`:
- hard-coded literal indices are rarely advisable in application code!
- being `IntegerLiteralConvertible` reintroduces transposition-error risk!
- it’s nice to have the constructors assert that the wrapped indices aren’t:
- == NSNotFound
- negative

…and although this can be done by hand, it’s an example of a use that *could* be synthesized.

## URL Segregation

It can be moderately useful to have a bunch of lightweight URL-wrapper types to avoid transposition errors and also to ensure appropriate handling (e.g. using the appropriate URL session); picture, say, `IconImageURL`, `HeroImageURL`, `DetailImageURL`, `APIEndpointURL` (etc.).

If you *did* go this route, some standard way of doing "type-erasure” down to the underlying type can be useful:

class ActiveTransferMonitor {
private var activeTransfers: [URL:TransferMetrics] = [:]

func didBeginTransfer<T:ValueWrapperType where T.WrappedValue: URL>(transferURL: T) {
self.activeTransfers[transferURL.URL] = TransferMetrics()
}
}

…but this is the example I feel least strongly about (it’s just here to motivate the “standard type-erasure mechanism” aspect).

## Bluetooth

For Bluetooth LE, you have peripherals, which have *services*, which contain *characteristics*, which can have associated *descriptors*. Each service, characteristic, or descriptor is identified by a unique identifier, which is modeled in CoreBluetooth as instances of the `CBUUID` class.

It’s handy here for correctness to have distinct wrapper types, let’s call them `ServiceUUID`, `CharacteristicUUID`, and `DescriptorUUID`, both to guard against simple transposition errors and to make some internal APIs more self-documenting.

It’s handy here for readability to have the wrapped UUID be accessible as, e.g. `.UUID`, and not as some generic `.wrappedValue`:

extension CBPeripheral {

func locatePrimaryService(serviceIdentifier: ServiceUUID) -> CBService? {
return self.services?.firstElementSatisfying() {
$0.UUID.isEqual(serviceIdentifier.UUID)
}
}

}

At present, the easiest way to get these all setup was as-follows:

- create a protocol like `BluetoothEntityUUIDType` that:
- also adopts the protocols it should
- has as many default implementations as possible
- create a struct for `ServiceUUID` that:
- wraps a single CBUUID instance
- conforms to `BluetoothEntityUUIDType`
- manually adds any missing conformances / logic
- create files for `CharacteristicUUID` and `DescriptorUUID`
- copy-and-paste the definition of `ServiceUUID` into the `CharacteristicUUID` file
- find-and-replace `Service` with `Characteristic`
- copy-and-paste the definition of `ServiceUUID` into the `DescriptorUUID` file
- find-and-replace `Service` with `Descriptor`
- edit the `init` (etc.) for `DescriptorUUID ` to add asserts that the passed-in `CBUUID` is one of 6 allowed, pre-defined CBUUIDs applicable to CBDescriptor

…it works, it’s not too terrible as a one-off, but it’s also tedious and runs the risk of implementation drift (especially due to `CBDescriptor` having validation logic the others don’t) in the event that the initial copy-paste-edit cycle needs to be repeated.

Likewise, there’s small things that are nice utilities to tack-onto the various identifier types (utilities to check if they are some well-known ID) that risk getting accidentally blown away if the copy-paste-edit cycle gets repeated; these *can* be defined in other files, but that in turn *can* require “unnatural” choice of visibility (in some cases).

## Closing Comments

For anyone who read this far, thanks for taking the time. I hope the concrete examples helps shed some light on both the motivation and the intended scope for this feature request.

The common theme in the examples is that in the individual use, the amount of wrapping is small enough that:

- it can be done by hand
- there are not enough wrappers to really justify writing a code-gen tool…
- …especially since (in practice) many of the wrappers benefit from small “customization” here-and-there
- there are readability-and-correctness benefits to having the wrappers available

…but I think having wrapper-synthesis — or a functional equivalent — as an easily-accessible part of the language would open the door more broadly to writing in this style, in ways which aren't always cost-or-time-effective today.

Finally, as I keep mentioning, it’s entirely possible that improvements to the type system will make protocols + default method implementations able to get this features’ benefits without requiring any additional support from the language or tooling; I’d be happy-enough with that outcome also.

Thanks again for the time and feedback. If there’s enough community interest I can prepare a formal proposal, otherwise I’ve said everything I have to say on this idea.

## PS: Product-Type Handling

I honestly think that handling product types with deriving is hard-enough it’s not really worth trying to do; there’s certainly some limited value in being able to synthesize (component-wise) `Equatable` and so on, but once you get past the very foundational protocols like `Equatable` / `Comparable` / `Hashable` / `CustomStringConvertible` / `CustomDebugStringConvertible` you start hitting tricky problems it’s not clear .

EG: how do you synthesize a CollectionType implementation for, e.g., a product of two `CollectionType` types? Sure, you can safely bet the type of the synthesized Element is going to be the product of the component elements, but how do you plan to synthesize the implementation of a proper `ForwardIndexType` from the product of the component collections' `ForwardIndexType`s? There’s a lot of ways to do this, with different resulting iteration ordering and different performance/resource tradeoffs, and it’s hard to do auto-synthesis here that doesn’t either just “pick a winner” (and leave you hanging if you wanted a different implementation) or wind up introducing a mini-language to let you indicate which variant it should synthesize.

Moreover, note that even for, e.g., `Hashable`, there are actually at least a couple common strategies I often see.

One is the `xor`-everything strategy, except:

- it’s IMHO a good idea to rotate some of the constituent hashes to avoid accidentally hashing a lot of stuff to zero
- you don’t always want to hash *everything*
- you may want/need to hash transformed/normalized forms of constituent values, not the “raw” values

Another is the “forward to a good identifier” strategy, e.g.:

- you have a type like `struct ContentMetadata { let identifier: ContentIdentifier; let metadata: [String:MetadataItem] }`
- a good `hashValue` here can be had by simply forwarding the hashValue for `identifier`

…and at least IMHO, in a perfect world, if you *were* to introduce automatic synthesis of `Hashable` for product types, I’d want to be able to indicate which implementation-strategy should be used.

Which, honestly, seems hard to do without baking in special handling for Hashable, and by extension without each synthesis-supporting protocol getting special treatment (and thus leaving “third party” protocols a bit hamstrung in terms of being availble-for-synthesis themselves).

Even mere `Comparable` has similar amounts of fiddly detail — you probably want lexicographic, but in what ordering? do you want any of the constituent types' orderings flipped? — and so on and so forth.

> On Dec 5, 2015, at 12:46 AM, Harlan Haskins <harlan at harlanhaskins.com> wrote:
>
> I feel like, if we implement automatic derivation for structs that wrap one value, we can just as easily implement automatic derivation for all product types for which the children conform to the protocols in question, and there’s a provided implementation for derivation by combining values.
>
> Consider Hashable. A very common implementation of hashValue is xor-ing all the members’ hash values together.
> We could actually implement this right now given Swift’s reflection system (if we were able to conditionally cast to Hashable or any protocol with a Self requirement).
>
> Consider this:
>
> struct HashableDerivable deriving Hashable {
>     let string: String // because String is already Hashable
>     let integer: Int   // and Int is Hashable
>     // then HashableDerivable is trivially Hashable.
> }
>
> /// This implementation is absolutely derivable at compile time.
> extension HashableDerivable: Hashable {
>     var hashValue: Int {
>         return string.hashValue ^ integer.hashValue
>     }
> }
> func ==(lhs: HashableDerivable, rhs: HashableDerivable) -> Bool {
>     return lhs.string == rhs.string && lhs.integer == rhs.integer
> }
>
> // one can also use Reflection to derive this at runtime
>
> extension Mirror {
>     func canDeriveHashable() -> Bool {
>         if self.subjectType is Hashable { return true } // this is currently a compiler error
>         for child in self.children {
>             let mirror = Mirror(reflecting: child)
>             if !mirror.canDeriveHashable() { return false }
>         }
>         return true
>     }
>     func deriveHashValue() -> Int {
>         if !self.canDeriveHashable() { fatalError("Boy, I wish this didn't have to happen at runtime.") }
>         guard let firstChild = self.children.first as? Hashable /* also an error */ else { fatalError("no children") }
>         return self.children.dropFirst().reduce(firstChild.hashValue) { (hash, _: (_: String?, value: Any)) -> T in
>             return hash ^ (value as! Hashable).hashValue
>         }
>     }
> }
>
> Of course, this is something that can be done at compile time, which would make protocol conformance really, really simple.
>
> We already do this, using the Mirror API, for CustomStringConvertible.
>> > On Dec 4, 2015, at 4:26 PM, John McCall <rjmccall at apple.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
>> >
>> >> On Dec 4, 2015, at 1:19 PM, plx <plxswift at icloud.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
>> >> # A `wrapper` / `deriving` Construct
>> >>
>> >> I'm sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.
>> >>
>> >> The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.
>> >>
>> >> ## Design Sketch
>> >>
>> >> It ought to be possible to write something like this:
>> >>
>> >>   // an example:
>> >>   struct SectionIndex
>> >>     wrapping Int
>> >>     as index
>> >>     satisfying precondition { $0 >= 0 }
>> >>     deriving Equatable, Comparable, Hashable {
>> >>     // declaration can continue in here
>> >>   }
>> >>
>> >> ...which, when compiled, would be "expanded" along these lines:
>> >>
>> >>   struct SectionIndex {
>> >>
>> >>     // would have been `wrappedValue` w/out the `as index` clause
>> >>     let index: Int
>> >>
>> >>     init(_ index: Int) {
>> >>       precondition(index >= 0)
>> >>       // ^ would have been assert(index >= 0)
>> >>       //   had we used `satisfying { $0 >= 0 }`,
>> >>       //   and omitted entirely had we omitted a `satisfying` clause
>> >>       self.index = index
>> >>     }
>> >>
>> >>   }
>> >>
>> >>   extension SectionIndex : Equatable {
>> >>   }
>> >>
>> >>   // synthesized unless explicitly written-out
>> >>   func ==(lhs: SectionIndex, rhs: SectionIndex) -> Bool {
>> >>     return lhs.index == rhs.index
>> >>   }
>> >>
>> >>   // same for Comparable, Hashable, all done in the obvious way
>> >>
>> >>   // there’s a lot of utility in synthesizing something like this,
>> >>   //  I can expand on it if necessary:
>> >>   extension SectionIndex: ValueWrapperType {
>> >>     typealias WrappedType = Int
>> >>   }
>> >>
>> >> ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols' typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.
>> >>
>> >> I think this enough to sketch the way the feature would look and how it would work.
>> >
>> > I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.
>> >
>> > I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.
>> >
>> > For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).
>> >
>> > John.
>>
>> Apologies for leaving too much out.
>>
>> I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).
>>
>> Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:
>>
>> - `on` is unambiguous as there’s only one thing it can be “on"
>> - there’s no ordering-of-operations to have to worry about
>> - there’s no merging-of-results to have to worry about
>> - i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)
>> - there’s no associated-type incoherency to worry about (unless user error introduces it)
>>
>> …there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).
>>
>> …and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest.
>>
>> Thanks for taking the time to read and send feedback.
>>
>> PS:
>>
>> On the other hand, if this becomes writable:
>>
>>     protocol WrapperType {
>>        typealias WrappedValue
>>        var wrappedValue: { get }
>>     }
>>
>>     extension WrapperType : Equatable where WrappedValue: Equatable {
>>     }
>>
>>     func ==<W:WrapperType where W.WrappedValue:Equatable>(lhs: W, rhs: W) -> Bool {
>>       return lhs.wrappedValue == rhs.wrappedValue
>>     }
>>
>> …etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/8da52390/attachment-0001.html>

From matthew at anandabits.com  Sat Dec  5 10:04:00 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 10:04:00 -0600
Subject: [swift-evolution] Proposal: Automatic Wrapper Synthesis /
"deriving"
In-Reply-To: <965ADE10-8F98-465E-9030-2050C51524E1@icloud.com>
References: <98365168-A35C-43B3-9632-2ABDF9627DDB@harlanhaskins.com>
<965ADE10-8F98-465E-9030-2050C51524E1@icloud.com>
Message-ID: <F0E530F2-BD96-4F1C-852F-4C4301859C66@anandabits.com>

I would also like to see a feature that supports concisely wrapping a type akin to Haskell’s newtype.  However I wonder if it might be worthwhile to give consideration a more general feature that also supports composition and forwarding more generally, with “newtype” being the simplest, most straightforward use of the feature.


> On Dec 5, 2015, at 9:57 AM, plx <plxswift at icloud.com> wrote:
>
> I definitely got off on the wrong foot by using `deriving`; what I was trying to ask for is more of a stronger typealias (perhaps `newtype`-esque is the right analogy?), which — at least for my purposes — would *ideally* have the following capabilities / rules:
>
> - when Y is a wrapper around an X, Y has only a single, “synthesized" stored property (of type X)
> - the user can control the name of the stored property by one of these mechanisms (which one is used is moot to me):
>   - override the name of the synthesized stored property
>   - indicate another name and have an accessor auto-generated
> - every protocol adopted by X *can* be auto-synthesized for Y
>   - but the user has to explicitly request each specific protocol be synthesized…
>   - …because it’s very important that it be possible to *not* adopt every one of X’s protocols
> - the user can optionally provide some predicate (of type (X) -> Bool), which then:
>   - is included as an assert/precondition inside a synthesized `init(_ x: X)`
>   - is perhaps/can-be used inside some synthesized `init?(_ x: X)` (this is trickier at present, and might be better as a static func)
>   - is ideally available on some methods like `func isInvariantSatisfied() -> Bool; static func isWrappableValue(x: X) -> Bool` (e.g. for debugging/testing)
>   - …are essentially for documentation and some very modest runtime verification
> - there’s some standard/principled way to do type-erasure "back down to X” as-needed
>
> Only supporting single-value-wrappers should make the needed syntheses essentially trivial as far as I can tell; the only obviously non-trivial aspect is that, in practice, it’d seem likely that you’d want to occasionally “override” the typealiases from X with wrappers thereof; e.g. if you had a type Y wrapping Set<Foo>, you might want Y’s `Index` to be a wrapper around `SetIndex<Foo>` and *not just* `SetIndex<Foo>`; this doesn’t seem overly-complicated semantically but it isn’t “trivial”, either, and would perhaps need additional syntax support to read nicely in-use.
>
> Here are a few concrete example motivating the above requests:
>
> ## UI-Level Section/Item Indices
>
> It’s a nice — albeit minor — improvement to work with Int-wrappers like `SectionIndex` and `ItemIndex` rather than as primitive, interchangeable `Int` everywhere. It’s particularly handy if trying to write reasonably-generic implementations of the common UI-level datasource/delegate protocols.
>
> For this:
>
> - it’s nice to have the wrapped value accessible as `index` (as opposed to e.g. `wrappedValue` or `storage`, etc.)
> - it’s nice to *not* wind up with the arithmetic operations from `Int`:
>   - accidental use of e.g. `*` or `+` or `-` (etc.) on `SectionIndex` or `ItemIndex` is *probably* an error!
> - it’s nice to *not* wind up as `IntegerLiteralConvertible`:
>   - hard-coded literal indices are rarely advisable in application code!
>   - being `IntegerLiteralConvertible` reintroduces transposition-error risk!
> - it’s nice to have the constructors assert that the wrapped indices aren’t:
>   - == NSNotFound
>   - negative
>
> …and although this can be done by hand, it’s an example of a use that *could* be synthesized.
>
> ## URL Segregation
>
> It can be moderately useful to have a bunch of lightweight URL-wrapper types to avoid transposition errors and also to ensure appropriate handling (e.g. using the appropriate URL session); picture, say, `IconImageURL`, `HeroImageURL`, `DetailImageURL`, `APIEndpointURL` (etc.).
>
> If you *did* go this route, some standard way of doing "type-erasure” down to the underlying type can be useful:
>
>     class ActiveTransferMonitor {
>       private var activeTransfers: [URL:TransferMetrics] = [:]
>
>       func didBeginTransfer<T:ValueWrapperType where T.WrappedValue: URL>(transferURL: T) {
>         self.activeTransfers[transferURL.URL] = TransferMetrics()
>       }
>     }
>
> …but this is the example I feel least strongly about (it’s just here to motivate the “standard type-erasure mechanism” aspect).
>
> ## Bluetooth
>
> For Bluetooth LE, you have peripherals, which have *services*, which contain *characteristics*, which can have associated *descriptors*. Each service, characteristic, or descriptor is identified by a unique identifier, which is modeled in CoreBluetooth as instances of the `CBUUID` class.
>
> It’s handy here for correctness to have distinct wrapper types, let’s call them `ServiceUUID`, `CharacteristicUUID`, and `DescriptorUUID`, both to guard against simple transposition errors and to make some internal APIs more self-documenting.
>
> It’s handy here for readability to have the wrapped UUID be accessible as, e.g. `.UUID`, and not as some generic `.wrappedValue`:
>
>     extension CBPeripheral {
>
>       func locatePrimaryService(serviceIdentifier: ServiceUUID) -> CBService? {
>         return self.services?.firstElementSatisfying() {
>           $0.UUID.isEqual(serviceIdentifier.UUID)
>         }
>       }
>
>     }
>
> At present, the easiest way to get these all setup was as-follows:
>
> - create a protocol like `BluetoothEntityUUIDType` that:
>   - also adopts the protocols it should
>   - has as many default implementations as possible
> - create a struct for `ServiceUUID` that:
>   - wraps a single CBUUID instance
>   - conforms to `BluetoothEntityUUIDType`
>   - manually adds any missing conformances / logic
> - create files for `CharacteristicUUID` and `DescriptorUUID`
>   - copy-and-paste the definition of `ServiceUUID` into the `CharacteristicUUID` file
>   - find-and-replace `Service` with `Characteristic`
>   - copy-and-paste the definition of `ServiceUUID` into the `DescriptorUUID` file
>   - find-and-replace `Service` with `Descriptor`
>   - edit the `init` (etc.) for `DescriptorUUID ` to add asserts that the passed-in `CBUUID` is one of 6 allowed, pre-defined CBUUIDs applicable to CBDescriptor
>
> …it works, it’s not too terrible as a one-off, but it’s also tedious and runs the risk of implementation drift (especially due to `CBDescriptor` having validation logic the others don’t) in the event that the initial copy-paste-edit cycle needs to be repeated.
>
> Likewise, there’s small things that are nice utilities to tack-onto the various identifier types (utilities to check if they are some well-known ID) that risk getting accidentally blown away if the copy-paste-edit cycle gets repeated; these *can* be defined in other files, but that in turn *can* require “unnatural” choice of visibility (in some cases).
>
> ## Closing Comments
>
> For anyone who read this far, thanks for taking the time. I hope the concrete examples helps shed some light on both the motivation and the intended scope for this feature request.
>
> The common theme in the examples is that in the individual use, the amount of wrapping is small enough that:
>
> - it can be done by hand
> - there are not enough wrappers to really justify writing a code-gen tool…
> - …especially since (in practice) many of the wrappers benefit from small “customization” here-and-there
> - there are readability-and-correctness benefits to having the wrappers available
>
> …but I think having wrapper-synthesis — or a functional equivalent — as an easily-accessible part of the language would open the door more broadly to writing in this style, in ways which aren't always cost-or-time-effective today.
>
> Finally, as I keep mentioning, it’s entirely possible that improvements to the type system will make protocols + default method implementations able to get this features’ benefits without requiring any additional support from the language or tooling; I’d be happy-enough with that outcome also.
>
> Thanks again for the time and feedback. If there’s enough community interest I can prepare a formal proposal, otherwise I’ve said everything I have to say on this idea.
>
> ## PS: Product-Type Handling
>
> I honestly think that handling product types with deriving is hard-enough it’s not really worth trying to do; there’s certainly some limited value in being able to synthesize (component-wise) `Equatable` and so on, but once you get past the very foundational protocols like `Equatable` / `Comparable` / `Hashable` / `CustomStringConvertible` / `CustomDebugStringConvertible` you start hitting tricky problems it’s not clear .
>
> EG: how do you synthesize a CollectionType implementation for, e.g., a product of two `CollectionType` types? Sure, you can safely bet the type of the synthesized Element is going to be the product of the component elements, but how do you plan to synthesize the implementation of a proper `ForwardIndexType` from the product of the component collections' `ForwardIndexType`s? There’s a lot of ways to do this, with different resulting iteration ordering and different performance/resource tradeoffs, and it’s hard to do auto-synthesis here that doesn’t either just “pick a winner” (and leave you hanging if you wanted a different implementation) or wind up introducing a mini-language to let you indicate which variant it should synthesize.
>
> Moreover, note that even for, e.g., `Hashable`, there are actually at least a couple common strategies I often see.
>
> One is the `xor`-everything strategy, except:
>
> - it’s IMHO a good idea to rotate some of the constituent hashes to avoid accidentally hashing a lot of stuff to zero
> - you don’t always want to hash *everything*
> - you may want/need to hash transformed/normalized forms of constituent values, not the “raw” values
>
> Another is the “forward to a good identifier” strategy, e.g.:
>
> - you have a type like `struct ContentMetadata { let identifier: ContentIdentifier; let metadata: [String:MetadataItem] }`
> - a good `hashValue` here can be had by simply forwarding the hashValue for `identifier`
>
> …and at least IMHO, in a perfect world, if you *were* to introduce automatic synthesis of `Hashable` for product types, I’d want to be able to indicate which implementation-strategy should be used.
>
> Which, honestly, seems hard to do without baking in special handling for Hashable, and by extension without each synthesis-supporting protocol getting special treatment (and thus leaving “third party” protocols a bit hamstrung in terms of being availble-for-synthesis themselves).
>
> Even mere `Comparable` has similar amounts of fiddly detail — you probably want lexicographic, but in what ordering? do you want any of the constituent types' orderings flipped? — and so on and so forth.
>
>> On Dec 5, 2015, at 12:46 AM, Harlan Haskins <harlan at harlanhaskins.com <mailto:harlan at harlanhaskins.com>> wrote:
>>
>> I feel like, if we implement automatic derivation for structs that wrap one value, we can just as easily implement automatic derivation for all product types for which the children conform to the protocols in question, and there’s a provided implementation for derivation by combining values.
>>
>> Consider Hashable. A very common implementation of hashValue is xor-ing all the members’ hash values together.
>> We could actually implement this right now given Swift’s reflection system (if we were able to conditionally cast to Hashable or any protocol with a Self requirement).
>>
>> Consider this:
>>
>> struct HashableDerivable deriving Hashable {
>>     let string: String // because String is already Hashable
>>     let integer: Int   // and Int is Hashable
>>     // then HashableDerivable is trivially Hashable.
>> }
>>
>> /// This implementation is absolutely derivable at compile time.
>> extension HashableDerivable: Hashable {
>>     var hashValue: Int {
>>         return string.hashValue ^ integer.hashValue
>>     }
>> }
>> func ==(lhs: HashableDerivable, rhs: HashableDerivable) -> Bool {
>>     return lhs.string == rhs.string && lhs.integer == rhs.integer
>> }
>>
>> // one can also use Reflection to derive this at runtime
>>
>> extension Mirror {
>>     func canDeriveHashable() -> Bool {
>>         if self.subjectType is Hashable { return true } // this is currently a compiler error
>>         for child in self.children {
>>             let mirror = Mirror(reflecting: child)
>>             if !mirror.canDeriveHashable() { return false }
>>         }
>>         return true
>>     }
>>     func deriveHashValue() -> Int {
>>         if !self.canDeriveHashable() { fatalError("Boy, I wish this didn't have to happen at runtime.") }
>>         guard let firstChild = self.children.first as? Hashable /* also an error */ else { fatalError("no children") }
>>         return self.children.dropFirst().reduce(firstChild.hashValue) { (hash, _: (_: String?, value: Any)) -> T in
>>             return hash ^ (value as! Hashable).hashValue
>>         }
>>     }
>> }
>>
>> Of course, this is something that can be done at compile time, which would make protocol conformance really, really simple.
>>
>> We already do this, using the Mirror API, for CustomStringConvertible.
>>> > On Dec 4, 2015, at 4:26 PM, John McCall <rjmccall at apple.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
>>> >
>>> >> On Dec 4, 2015, at 1:19 PM, plx <plxswift at icloud.com <https://lists.swift.org/mailman/listinfo/swift-evolution>> wrote:
>>> >> # A `wrapper` / `deriving` Construct
>>> >>
>>> >> I'm sure a construct along these lines has been requested numerous times and is hopefully already on the roadmap.
>>> >>
>>> >> The point of this email is to put out a reasonably-*concrete* sketch as a way of soliciting community feedback on the specifics of how such a construct might look-and-work within Swift; hopefully I’ve gone far-enough to be interesting, but not too much further than that.
>>> >>
>>> >> ## Design Sketch
>>> >>
>>> >> It ought to be possible to write something like this:
>>> >>
>>> >>   // an example:
>>> >>   struct SectionIndex
>>> >>     wrapping Int
>>> >>     as index
>>> >>     satisfying precondition { $0 >= 0 }
>>> >>     deriving Equatable, Comparable, Hashable {
>>> >>     // declaration can continue in here
>>> >>   }
>>> >>
>>> >> ...which, when compiled, would be "expanded" along these lines:
>>> >>
>>> >>   struct SectionIndex {
>>> >>
>>> >>     // would have been `wrappedValue` w/out the `as index` clause
>>> >>     let index: Int
>>> >>
>>> >>     init(_ index: Int) {
>>> >>       precondition(index >= 0)
>>> >>       // ^ would have been assert(index >= 0)
>>> >>       //   had we used `satisfying { $0 >= 0 }`,
>>> >>       //   and omitted entirely had we omitted a `satisfying` clause
>>> >>       self.index = index
>>> >>     }
>>> >>
>>> >>   }
>>> >>
>>> >>   extension SectionIndex : Equatable {
>>> >>   }
>>> >>
>>> >>   // synthesized unless explicitly written-out
>>> >>   func ==(lhs: SectionIndex, rhs: SectionIndex) -> Bool {
>>> >>     return lhs.index == rhs.index
>>> >>   }
>>> >>
>>> >>   // same for Comparable, Hashable, all done in the obvious way
>>> >>
>>> >>   // there’s a lot of utility in synthesizing something like this,
>>> >>   //  I can expand on it if necessary:
>>> >>   extension SectionIndex: ValueWrapperType {
>>> >>     typealias WrappedType = Int
>>> >>   }
>>> >>
>>> >> ...where each method/init/subscript/etc in the derived protocols gets synthesized at compile-time, if not explicitly implemented; similarly, if not explicitly-declared, the derived protocols' typealiases can be synthesized in obvious ways, and it seems acceptable to simply fail to compile (and inform the user of the need to make an explicit-declaration) in cases where such synthesis is impossible.
>>> >>
>>> >> I think this enough to sketch the way the feature would look and how it would work.
>>> >
>>> > I’m not sure what work is being done by “wrapping X as Y” here; it seems like just another way of expressing a stored property.
>>> >
>>> > I think we’re all interested in a “deriving” proposal.  However, the key problem that a serious proposal would have to address is not picking the syntax, but describing how derivation would actually work.  We’d prefer not to just hard-code rules in the compiler for specific protocols.
>>> >
>>> > For example, derivation presumably involves recursively invoking the given operation on each of the stored properties (what does “on” mean? which parameters are changed, and which are passed through?) and then merging the results (how?).
>>> >
>>> > John.
>>>
>>> Apologies for leaving too much out.
>>>
>>> I meant to propose that the `deriving` in this place would enforce the wrapper type only wrapped a single stored value, warranting the distinct syntax; I seem to have edited-out both an explicit statement that this assumed a single-stored-property and to have omitted a comment in the `//declaration can continue in here` that no additional stored-properties could be declared (analogous to the rules current applied within extensions).
>>>
>>> Yes, constraining a `deriving` construct to only support wrappers containing a single stored property would, on the one hand, be somewhat limiting, but on the other hand it would seemingly allow trivial solutions to the issues you bring up:
>>>
>>> - `on` is unambiguous as there’s only one thing it can be “on"
>>> - there’s no ordering-of-operations to have to worry about
>>> - there’s no merging-of-results to have to worry about
>>> - i’m guessing there’s no parameters needing to getting changed (but I’m not 100% on what you mean here)
>>> - there’s no associated-type incoherency to worry about (unless user error introduces it)
>>>
>>> …there’s least one tricky case (if you want the wrapper to replace one of the wrapped type’s typealiases with a wrapper).
>>>
>>> …and at least for me, there’s enough value in that simplified wrapper-synthesis / deriving-type construct to take the time to check community interest.
>>>
>>> Thanks for taking the time to read and send feedback.
>>>
>>> PS:
>>>
>>> On the other hand, if this becomes writable:
>>>
>>>     protocol WrapperType {
>>>        typealias WrappedValue
>>>        var wrappedValue: { get }
>>>     }
>>>
>>>     extension WrapperType : Equatable where WrappedValue: Equatable {
>>>     }
>>>
>>>     func ==<W:WrapperType where W.WrappedValue:Equatable>(lhs: W, rhs: W) -> Bool {
>>>       return lhs.wrappedValue == rhs.wrappedValue
>>>     }
>>>
>>> …etc., then it’s possible (albeit moderately unpleasant) to just write suitable glue logic out longhand on an as-needed basis (and with the caveat that all types wrapping T would potentially adopt all of T’s protocols even when potentially undesirable).
>>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/77d78447/attachment-0001.html>

From matthew at anandabits.com  Sat Dec  5 10:10:50 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 10:10:50 -0600
Subject: [swift-evolution] Proposal: floating point static min / max
properties
Message-ID: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>

In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.

Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.

import Darwin

public extension Float {
static let min = -FLT_MAX
static let max = FLT_MAX
}

public extension Double {
static let min = -DBL_MAX
static let max = DBL_MAX
}

Is there interest in adding this?  If so, what is the right way to proceed?

Matthew

From me at koke.me  Sat Dec  5 10:21:18 2015
From: me at koke.me (Jorge Bernal)
Date: Sat, 5 Dec 2015 17:21:18 +0100
Subject: [swift-evolution] Allow Selectors to be used as Closures
In-Reply-To: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>
References: <CANttdkY0_RkjVLYwD=YS74fyFymCv5L_OL--xuRn2AMrU1MaeQ@mail.gmail.com>
Message-ID: <3E22F6FC-1E70-4749-8319-300BA4974EC4@koke.me>

I think this has more to do with the UIKit API than the Swift language, but since we’re discussing it, here’s my 2¢

> On 04 Dec 2015, at 19:49, Chris Byatt <byatt.chris at gmail.com> wrote:
>
> We should be able to do:
>
> UIBarButtonItem(title: "Press", style: .Done, target: self, action: {
>     // Do Something
> })

If action is just a closure, why is target needed? This example doesn’t match what was proposed in the subject “Selectors to be used as Closures”.
I see a couple solutions to this:

1. Make it UIBarButtonIttem(title:style:action:), and pass any closure. That’s the most flexible, but as David mentioned it makes it too easy to create reference cycles.
2. Keep the target/action pattern, but make action’s type match the expected selector signature. To avoid cycles, the button item would keep a weak reference to self, and only call action if target != nil

class MyController: UIViewController {
override func viewDidLoad() {
super.viewDidLoad()

self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Press", style: .Done, target: self, action: MyController.functionToCall)
}

func functionToCall(button: UIBarButtonItem) {
// Do stuff
}
}


--
Jorge Bernal | jbernal at gmail.com | jorge at automattic.com
Mobile Engineer @ Automattic | http://automattic.com/

http://koke.me/ | http://jorgebernal.es/ | http://twitter.com/koke

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/5312b46d/attachment.html>

From a.michail at me.com  Sat Dec  5 10:36:32 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 11:36:32 -0500
Subject: [swift-evolution] reinitializing part of an object where calling
super.init is optional
Message-ID: <F3526712-50DE-4595-81E3-6CEF2A00EFEC@me.com>

This would be useful in reinitializing a custom widget for example where the UIView is allocated and initialized only once. The reinitialization would not call super.init in this case.

From clattner at apple.com  Sat Dec  5 10:49:05 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 08:49:05 -0800
Subject: [swift-evolution] Proposal: Typed throws
In-Reply-To: <3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>
References: <DE011F47-65E5-4375-9747-DBF33D79900D@me.com>
<899D2E72-7140-4627-8D42-F11D199F152C@me.com>
<AAF089FF-DE87-4678-9D3D-FAF146E81877@apple.com>
<B19820CE-B771-4AE6-AC63-657F94E8A9F3@owensd.io>
<E43D5828-DEA0-4A44-B795-B4C4D3834FAE@apple.com>
<3109D6EE-B54E-4DD7-95FD-FD83A07CB6CD@owensd.io>
Message-ID: <E3A87542-99D5-46A9-BB9E-3D33D2654A88@apple.com>

On Dec 4, 2015, at 12:54 PM, David Owens II <david at owensd.io> wrote:
>>>
>>>  do {
>>>      try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
>>>  } catch VendingMachineError.InvalidSelection {
>>>      print("Invalid Selection.")
>>>  } catch VendingMachineError.OutOfStock {
>>>      print("Out of Stock.")
>>>  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
>>>      print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
>>>  } catch { fatalError("this is always needed…”) }
>>
>> But this is printing.  Of course you should be able to generically display an error, but you don’t need static typing for that.  Also, I certainly hope you are not actually repeating all this stuff at every catch site.
>
> This was a sample from the Swift docs: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508. I added the missing final `catch` that is required with Swift today.
>
> The point being, the error enum is fully defined but we still need the final `catch` at the end because there is no type information on the `throws` annotation for `buyFavoriteSnack`. So unlike the case when dealing with enums and switch-statements, we lose all compile-time information about coverage of error states when we could know them. The current implementation of `throws` is the only (as far as I can tell) place in Swift that turns a compile-time validation problem into a run-time validation problem.
>
> That’s my concern.
>
> Instead, if we could annotate throws, we could move this into a compile-time validation.

FWIW, if you’re interested in the Swift error handling model, then this document is required reading:
https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst

John drove the design efforts for error handling in Swift 2 and wrote it to capture the thinking of the team.  There is also this document that describes the intent of the feature as well, but it has been subsumed by The Swift Programming Langauge:
https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst


My take on it is that typed throws would be a great feature to add for all of the reasons you specify.  However, rolling it out in Swift 2 would have been very problematic, because we didn’t (and still don’t) have the Swift 3 resilience model in place.

The resilience model addresses how the public API from a module can evolve without breaking clients (either at the source level or ABI level).  Notably, we want the ability to be able to add enum cases to something by default, but also to allow API authors to opt into more performance/strictness by saying that a public enum is “fragile” or “closed for evolution”.

In the case of typed throws, you should only get the “exhaustiveness checking” of catch blocks if you’re catching an enum defined in your own module, or if it is a public enum from some other module that is defined as being fragile.

-Chris


From harlan at harlanhaskins.com  Sat Dec  5 10:52:14 2015
From: harlan at harlanhaskins.com (Harlan Haskins)
Date: Sat, 5 Dec 2015 11:52:14 -0500
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <1449324589110.9d79fd62@Nodemailer>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
Message-ID: <CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>

SwiftLint looks really nice, but one thing I'd really like is automatic formatting. I'd absolutely like to see clang-format adapted with Swift support. Maybe the SwiftLint people can, now that Swift is open source, contribute the bulk of the SwiftLint project directly into clang-format.

> On Dec 5, 2015, at 9:09 AM, Paul Young <paulyoungonline at gmail.com> wrote:
>
> Amir, you may be interested in SwiftLint: https://github.com/realm/SwiftLint
>
>
>
>> On Sat, Dec 5, 2015 at 1:43 PM, Amir Michail <amichail at gmail.com> wrote:
>>
>>> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com> wrote:
>>>
>>> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.
>>
>> All programming languages are already enforcing subjective views about best practice in one form or another.
>>
>>>
>>> Austin
>>>
>>>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com> wrote:
>>>>
>>>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>>>>
>>>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>>>>>
>>>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>>>>
>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>>>>
>>>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>>>>
>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>
>>>>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>>>>
>>>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>>>>
>>>>>
>>>>> Regards,
>>>>> Adrian Kashivskyy
>>>>> iOS Developer at Netguru
>>>>>
>>>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com> w dniu 05.12.2015, o godz. 00:53:
>>>>>>
>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>>>>
>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>>
>>>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d48cbf49/attachment-0001.html>

From clattner at apple.com  Sat Dec  5 10:52:34 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 08:52:34 -0800
Subject: [swift-evolution] "if case" syntax is ugly
In-Reply-To: <7F244C47-974E-4BC1-85BC-BFCA4905B488@me.com>
References: <7F244C47-974E-4BC1-85BC-BFCA4905B488@me.com>
Message-ID: <444C8AAE-91C3-4D50-B03C-398FC4404D7E@apple.com>


> On Dec 5, 2015, at 5:14 AM, Amir Michail <a.michail at me.com> wrote:
>
> Maybe instead of: if case 1...3 = x { … }
>
> You could have: if x case 1..3 { … }
>
> And loops could be handled similarly: for x case 1..3 in z { … }

Hi Amir,

It is hard to understand how your proposal would work.  Could you suggest a change to the formal grammar, which is described in the TSPL (https://swift.org/documentation/)?

-Chris

From clattner at apple.com  Sat Dec  5 11:02:45 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 09:02:45 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
Message-ID: <ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>

On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com wrote:
> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?

I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are "syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.

All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness" of fallthrough.

-Chris

From clattner at apple.com  Sat Dec  5 11:09:36 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 09:09:36 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
Message-ID: <40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>


> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez <cheyo at masters3d.com> wrote:
>
> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy.
>
> Some interesting code in the standard library that uses the ternary operator quite a bit.
>
> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357>

FWIW, I have no love for the ternary operator (it is totally "bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.

If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9fbdba0f/attachment.html>

From phabouzit at apple.com  Sat Dec  5 11:15:26 2015
From: phabouzit at apple.com (Pierre Habouzit)
Date: Sat, 05 Dec 2015 09:15:26 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>
Message-ID: <5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com>


> On Dec 5, 2015, at 9:02 AM, Chris Lattner <clattner at apple.com> wrote:
>
> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com wrote:
>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>
> I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are "syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.
>
> All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness" of fallthrough.

Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.

in system programming C, I find myself writing things like this very often:


switch (some_value) {
case ENUM_VALUE_REFINED:
if (validate(some_value)) {
return NULL;
}
/* fallthrough */
case ENUM_VALUE_BASE:
handle_enum_value();
…
}

Where the swift equivalent would roughly be:

switch some_value {
case .REFINED:
if !validate(some_value) { return NULL }
fallthrough
case .BASE:
handle_enum_value();
}

This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.

Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:

switch (some_value) {
case ENUM_VALUE_REFINED_1:
if (validate(some_value)) {
return NULL;
}
goto base_value;
case ENUM_VALUE_REFINED_2:
if (validate(some_value)) {
return NULL;
}
goto base_value;

case ENUM_VALUE_BASE:
base_value:
handle_enum_value();
…
}


cannot be written in swift, despite also being quite useful.

Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.

-Pierre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0198fd04/attachment-0001.html>

From rols at rols.org  Sat Dec  5 11:28:13 2015
From: rols at rols.org (Roland King)
Date: Sun, 6 Dec 2015 01:28:13 +0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <1BF1986B-7D9A-4E2B-A218-43100F5319BB@web.de>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
<5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>
<1BF1986B-7D9A-4E2B-A218-43100F5319BB@web.de>
Message-ID: <14FCD24F-4CD7-4C36-B3BB-834345C36579@rols.org>


> On 5 Dec 2015, at 19:35, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>
> I’m not a big fan of the C-style for loop, mostly because i find the parts of it badly separated by those tiny semicolons which are easily overlooked.
>
> Therefore for me it would be ok if the C-style for loop would be dropped but transforming its syntax into more Swift like syntax like suggested by Tyler might be even better as Roland and Tyler made some good points about advantages of the for loop (especially the guaranteed execution of the increment part). Being able to have the loop variable scoped locally to the loop is another advantage over the while loop.

I’d be perfectly happy if a semantic equivalent, but syntactically more easily comprehensible, alternative to the c-style for loop was introduced. An extension to while sounds reasonable if there’s a version which is generally agreed to be clearer. I’d like not to throw away what the fullness of what a c-style for loop can express, I don’t mind at all if we throw away the semicolons currently used to express it and replace them with an alternative and more readable syntax. I thought Thorsten’s suggestion for one was fine, I’m sure there are others.


From scanon at apple.com  Sat Dec  5 11:41:16 2015
From: scanon at apple.com (Stephen Canon)
Date: Sat, 05 Dec 2015 12:41:16 -0500
Subject: [swift-evolution] Proposal: floating point static min /
max	properties
In-Reply-To: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>
References: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>
Message-ID: <9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>

Hi Matthew —

This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:

/// Positive infinity.
///
/// Compares greater than all finite numbers.
static var infinity: Self { get }

/// The greatest finite value.
///
/// Compares greater than or equal to all finite numbers, but less than
/// infinity.
static var greatestFiniteMagnitude: Self { get }

/// The least positive normal value.
///
/// Compares less than or equal to all positive normal numbers.  There may
/// be smaller positive numbers, but they are "subnormal", meaning that
/// they are represented with less precision than normal numbers.
static var leastNormalMagnitude: Self { get }

/// The least positive value.
///
/// Compares less than or equal to all positive numbers, but greater than
/// zero.  If the target supports subnormal values, this is smaller than
/// `leastNormalMagnitude`; otherwise they are equal.
static var leastMagnitude: Self { get }

– Steve

> On Dec 5, 2015, at 11:10 AM, Matthew Johnson <matthew at anandabits.com> wrote:
>
> In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.
>
> Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.
>
> import Darwin
>
> public extension Float {
>   static let min = -FLT_MAX
>   static let max = FLT_MAX
> }
>
> public extension Double {
>   static let min = -DBL_MAX
>   static let max = DBL_MAX
> }
>
> Is there interest in adding this?  If so, what is the right way to proceed?
>
> Matthew
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c979acfe/attachment.html>

From clattner at apple.com  Sat Dec  5 11:52:34 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 09:52:34 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <D9C67AEB-E65D-48A7-BAFA-576E6051F0D3@apple.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
<DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
<53591A2C-1187-41E6-BB06-8F0327C03238@fifthace.com>
<92C9CAD1-2A9B-4CC0-941C-F7850B806C8B@sb.org>
<D9C67AEB-E65D-48A7-BAFA-576E6051F0D3@apple.com>
Message-ID: <8FEC76AA-7CA4-4732-9FDC-D20A5B409D3D@apple.com>


> On Dec 4, 2015, at 9:47 AM, John McCall <rjmccall at apple.com> wrote:
>
>
>> On Dec 3, 2015, at 11:07 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>> If we change anything based on this, I’d suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of
>>
>>    if let foo = bar {
>>
>> become the almost-identical
>>
>>    if let foo? = bar {
>
> This is something we carefully considered after introducing the ? pattern, and in fact it was even implemented for a time.  The lesson we took from that experience was that optional-binding is really, really important, and it really is worthwhile to recognize that importance by giving it special syntactic support.

+1 to what John said.  You can see this in the history, start with 20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9.  Sorry, but I don’t know how to turn that hash into a github URL.

-Chris

From clattner at apple.com  Sat Dec  5 11:57:35 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 09:57:35 -0800
Subject: [swift-evolution] Proposal: Bridging for Swift Structs
in	Objective-C
In-Reply-To: <99C67754-3AE5-4F28-9466-24700135B845@gmail.com>
References: <99C67754-3AE5-4F28-9466-24700135B845@gmail.com>
Message-ID: <3031D2F7-9B6F-4EB6-B364-09BF33765C11@apple.com>


> On Dec 4, 2015, at 2:06 PM, Dan Stenmark <daniel.j.stenmark at gmail.com> wrote:
>
> Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.
>
> @objc struct Letter {
> 	var address : String?
>
> 	init(withAddress address : String? ) {
> 		self.address = address
> 	}
> }

I’m generally a fan of anything that can make Swift get exposed back to Objective-C better, but such things generally need implementation work on Clang as well as on Swift (and thus, need Clang community buy-in as well).  Further, as other folks have pointed out, as proposed, this has some challenges in terms of design and implementation.  Are you planning to lead the implementation effort?

-Chris


>
> At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.
>
> Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
> MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’
>
> With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.
>
> @objc(US) struct Letter {
> 	var address : String?
>
> 	init(withAddress address : String? ) {
> 		self.address = address
> 	}
> }
>
> -------
>
> USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’
> USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’
>
> Nested types would also be represented via this proposal:
>
> @objc(US) class PostalService {
> 	struct Letter {
> 		var address : String?
>
> 		init(withAddress address : String? ) {
> 			self.address = address
> 		}
> 	}
> }
>
> -------
>
> USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’
> USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’
>
> Dan
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f641c11a/attachment-0001.html>

From vinivendra at gmail.com  Sat Dec  5 12:04:26 2015
From: vinivendra at gmail.com (Vinicius Vendramini)
Date: Sat, 5 Dec 2015 13:04:26 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>
<5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com>
Message-ID: <656EA51E-3A37-4A39-988A-7A84ED84C690@gmail.com>

I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.

In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like

if some_value == .Refined && !validate(some_value) {
return NULL
}
handle_enum_value()

More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.

> On Dec 5, 2015, at 12:15 PM, Pierre Habouzit <phabouzit at apple.com> wrote:
>
>
>> On Dec 5, 2015, at 9:02 AM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>
>> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>
>> I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are "syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.
>>
>> All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness" of fallthrough.
>
> Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.
>
> in system programming C, I find myself writing things like this very often:
>
>
> switch (some_value) {
> case ENUM_VALUE_REFINED:
>     if (validate(some_value)) {
>         return NULL;
>     }
>     /* fallthrough */
> case ENUM_VALUE_BASE:
>     handle_enum_value();
>     …
> }
>
> Where the swift equivalent would roughly be:
>
> switch some_value {
> case .REFINED:
>     if !validate(some_value) { return NULL }
>     fallthrough
> case .BASE:
>     handle_enum_value();
> }
>
> This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.
>
> Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:
>
> switch (some_value) {
> case ENUM_VALUE_REFINED_1:
>     if (validate(some_value)) {
>         return NULL;
>     }
>     goto base_value;
> case ENUM_VALUE_REFINED_2:
>     if (validate(some_value)) {
>         return NULL;
>     }
>     goto base_value;
>
> case ENUM_VALUE_BASE:
> base_value:
>     handle_enum_value();
>     …
> }
>
>
> cannot be written in swift, despite also being quite useful.
>
> Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.
>
> -Pierre
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/2db69eba/attachment.html>

From david at owensd.io  Sat Dec  5 12:13:10 2015
From: david at owensd.io (David Owens II)
Date: Sat, 5 Dec 2015 10:13:10 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <656EA51E-3A37-4A39-988A-7A84ED84C690@gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>
<5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com>
<656EA51E-3A37-4A39-988A-7A84ED84C690@gmail.com>
Message-ID: <7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io>

Is there a reason we cannot use labelled case statements?

switch some_value {
case .REFINED:
if !validate(some_value) { return NULL }
fallthrough base

base: case .BASE:
handle_enum_value();
}

At least this is explicit now.

> On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini <vinivendra at gmail.com> wrote:
>
> I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.
>
> In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like
>
> if some_value == .Refined && !validate(some_value) {
> 	return NULL
> }
> handle_enum_value()
>
> More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.
>
>> On Dec 5, 2015, at 12:15 PM, Pierre Habouzit <phabouzit at apple.com <mailto:phabouzit at apple.com>> wrote:
>>
>>
>>> On Dec 5, 2015, at 9:02 AM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>
>>> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>
>>> I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are "syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.
>>>
>>> All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness" of fallthrough.
>>
>> Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.
>>
>> in system programming C, I find myself writing things like this very often:
>>
>>
>> switch (some_value) {
>> case ENUM_VALUE_REFINED:
>>     if (validate(some_value)) {
>>         return NULL;
>>     }
>>     /* fallthrough */
>> case ENUM_VALUE_BASE:
>>     handle_enum_value();
>>     …
>> }
>>
>> Where the swift equivalent would roughly be:
>>
>> switch some_value {
>> case .REFINED:
>>     if !validate(some_value) { return NULL }
>>     fallthrough
>> case .BASE:
>>     handle_enum_value();
>> }
>>
>> This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.
>>
>> Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:
>>
>> switch (some_value) {
>> case ENUM_VALUE_REFINED_1:
>>     if (validate(some_value)) {
>>         return NULL;
>>     }
>>     goto base_value;
>> case ENUM_VALUE_REFINED_2:
>>     if (validate(some_value)) {
>>         return NULL;
>>     }
>>     goto base_value;
>>
>> case ENUM_VALUE_BASE:
>> base_value:
>>     handle_enum_value();
>>     …
>> }
>>
>>
>> cannot be written in swift, despite also being quite useful.
>>
>> Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.
>>
>> -Pierre
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f210f882/attachment-0001.html>

From clattner at apple.com  Sat Dec  5 12:15:49 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 10:15:49 -0800
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
Message-ID: <7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com>


> On Dec 4, 2015, at 3:05 AM, Sergey Shulepov <s.pepyakin at gmail.com> wrote:
>
> Hello.
>
> It would be cool if control flow statements like "switch", "if" can be used as expressions, such as in languages like Scala, Rust and Kotlin,
> so instead of writing:
>
> var message: String
> if x % 2 == 0 {
> message = "x is even"
> } else {
> message = "x is odd"
> }
>
> you can write:
>
> let message: String = if x % 2 == 0 { "x is even" } else { "x is odd" }
>
> I'm not into any kind of compiler development, and don't know is it feasible to introduce such change at the moment, but at least, I would like to hear why not.

FWIW, I (and many other people) would like to consider turning many statement-y things in swift into expressions.  I’d love to see the weird ?: ternary operator get nuked and replaced with an if/else expression of some sort.  This is an area that the apple team hasn’t had bandwidth to consider carefully.

That said, there are challenges here in the details.  How will the grammar work? Exactly which statements should be included (certainly if and switch, any others)?

Further, it is important to consider whether the code written using this will actually be *better* than the code written with these things as statements.  For example, the “switch” blocks tend to be very large, and turning them into expressions encourages additional indentation.  Swift already allows ‘let’ values to be initialized on multiple paths, so is the win actually that great?

Given that statements-as-expressions would provide another way to do things (they are a purely syntax extension) the barrier should high to add them.  They will add complexity and surface area to the language, so they need to pay that complexity.

-Chris


From clattner at apple.com  Sat Dec  5 12:17:52 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 10:17:52 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <8FEC76AA-7CA4-4732-9FDC-D20A5B409D3D@apple.com>
References: <857CF1D4-278D-40A2-9A63-B1D78FBBB826@gmail.com>
<ECF3BD4D-CD8B-497A-9A48-CD4F98418341@hartbit.com>
<6F4DBB1E-F8D3-48FD-BB90-A58A9E4B2C1A@gmail.com>
<1449181105.2523071.457463665.2226D145@webmail.messagingengine.com>
<B43C09A6-572B-4C31-81BF-08397B63C40E@apple.com>
<2A2B09A7-97A1-4B6A-9C29-049949F754E2@alkaline-solutions.com>
<463C0562-C50D-4CAF-AAB3-316D162CBB11@fifthace.com>
<DCAE6AF9-61B2-4F0B-80CF-F9C7833D907B@gmail.com>
<53591A2C-1187-41E6-BB06-8F0327C03238@fifthace.com>
<92C9CAD1-2A9B-4CC0-941C-F7850B806C8B@sb.org>
<D9C67AEB-E65D-48A7-BAFA-576E6051F0D3@apple.com>
<8FEC76AA-7CA4-4732-9FDC-D20A5B409D3D@apple.com>
Message-ID: <E8159D4A-C1D9-4B3D-889F-A21DD7FC770B@apple.com>


> On Dec 5, 2015, at 9:52 AM, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 9:47 AM, John McCall <rjmccall at apple.com> wrote:
>>
>>
>>> On Dec 3, 2015, at 11:07 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>> If we change anything based on this, I’d suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of
>>>
>>>   if let foo = bar {
>>>
>>> become the almost-identical
>>>
>>>   if let foo? = bar {
>>
>> This is something we carefully considered after introducing the ? pattern, and in fact it was even implemented for a time.  The lesson we took from that experience was that optional-binding is really, really important, and it really is worthwhile to recognize that importance by giving it special syntactic support.
>
> +1 to what John said.  You can see this in the history, start with 20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9.  Sorry, but I don’t know how to turn that hash into a github URL.

Ah, here you go:
https://github.com/apple/swift/commit/20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9#diff-4513b692cdd5476630ebb66b73d5bf4b

The behavior was later reverted to the Swift 1 behavior of privileging “if let” for optionals.

-Chris

From devteam.codafi at gmail.com  Fri Dec  4 23:12:24 2015
From: devteam.codafi at gmail.com (Developer)
Date: Sat, 5 Dec 2015 00:12:24 -0500
Subject: [swift-evolution] Revisiting Optionals as Sequences
In-Reply-To: <5C599593-83C0-40E0-A1C0-0244119AFB6E@harlanhaskins.com>
References: <5C599593-83C0-40E0-A1C0-0244119AFB6E@harlanhaskins.com>
Message-ID: <83AF9CD1-C7CD-4F36-B054-01E996A32BCF@gmail.com>

Oh please, please, never let those leave TypeLift's repositories until HKTs get merged... :P

I guess what I want is consistency, either of implementation or of terminology.  Because right now the language has neither and is trampling a function with a very consistent, rigorous definition for what I'm not sure?

~Robert Widmann

2015/12/04 23:56、Harlan Haskins <harlan at harlanhaskins.com> のメッセージ:

> Y’know, map and flatMap being part of SequenceType is really a misnomer.
>
> We could always just add Functor and Monad in the standard library!
>
> protocol Functor {
>     typealias A
>     typealias B
>     typealias FB
>
>     func map(_: A -> B) -> FB
> }
>
> protocol Monad: Functor {
>     static func pure(f: A) -> Self
>     func flatMap(f: A -> FB) -> FB
>     func >>=(x: Self, f: A -> FB) -> FB
> }
>
> infix operator >>= { associativity left }
> func >>=<M: Monad>(x: M, f: M.A -> M.FB) -> M.FB {
>     return x.flatMap(f)
> }
>> A few months ago I sent a pair of radars (22414579 nee 22448207 and 21961711) about Optional’s extant overloading of flatMap and how it doesn’t align with either the STL or the reasons given for the closing of both radars.
>>
>> > This issue behaves as intended based on the following:
>> >
>> > Yes, we are aware that this overload of flatMap could be viewed as unconventional. Nevertheless, it is useful and fits the overload set in general, if you view Optional as a sequence of zero or one T. It resembles this overload, where the closure returns an arbitrary sequence:
>> >
>> > extension SequenceType {
>> >   public func flatMap<S : SequenceType>(transform: (Generator.Element) -> S) -> [S.Generator.Element]
>> > }
>> >
>> > The type checker ensures that there is no ambiguity between the two overloads, and we don't see a reason to give one of the overloads a different name (and force users to learn it, and differentiate between the two), since conceptually the operation is the same.
>>
>> If Swift wishes to regard Optionals as collections with 1 or 0 elements, then I propose that it should reflect that thinking with additions to the standard library.
>>
>> Possible changes include:
>>
>> 1) Remove or rename Optional’s flatMap.
>> This would cause a bit of breaking behavior, but it’s nothing some fixits couldn’t help with.
>>
>> 2) Add a SequenceType instance for Optional.
>> This kills 2 birds with 1 stone in that, if the radar rejection is to ring true, Optional should have a SequenceType instance in the STL, and such an instance would automatically come with its own proper overloading flatMap necessitating change 1.
>>
>>  Over in TypeLift land we’ve already implemented what we believe the SequenceType extensions should look like (https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 <https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145>).
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7c4ce914/attachment-0001.html>

From thorsten.seitz at web.de  Sat Dec  5 05:35:23 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sat, 5 Dec 2015 12:35:23 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
<5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>
Message-ID: <1BF1986B-7D9A-4E2B-A218-43100F5319BB@web.de>

I’m not a big fan of the C-style for loop, mostly because i find the parts of it badly separated by those tiny semicolons which are easily overlooked.

Therefore for me it would be ok if the C-style for loop would be dropped but transforming its syntax into more Swift like syntax like suggested by Tyler might be even better as Roland and Tyler made some good points about advantages of the for loop (especially the guaranteed execution of the increment part). Being able to have the loop variable scoped locally to the loop is another advantage over the while loop.

Moving the incrementation part after the loop body as suggested by Tyler puts too much distance between the parts defining the loop mechanics IMHO (although I have to admit that it makes the order very clear), so I’d rather stay more closely with the original syntax, just eliminating the semicolons.

Therefore I’d like to suggest the following syntax (for-while-loop):

for var x = start while x <= end loop x += delta {
// more than a few lines of code with early escape continues
}

The initialization part (between „for" and „while“) and the loop part (after „loop“) are allowed to contain more than one statement.
The scope of all variables introduced (in the example „x“) is local to the loop.

Additionally the following form (for-until-loop) could be provided:

for var x = start until x > end loop x += delta {
// more than a few lines of code with early escape continues
}

Question: should the initialization part be restricted to var declarations or should it allow all statements?

Alternatives to the „loop“ keyword might be: iterate (a bit long), step, advance, next

Thorsten


> Am 05.12.2015 um 11:27 schrieb Tyler Cloutier <cloutiertyler at aol.com>:
>
> Hmm, yeah, that is definitely a good point. It can be easy enough to throw a continue into a while loop an completely skip the increment step. Of course you could add syntax to a while loop to allow for block/loop scoping of variables and then it might be tempting to add some finally logic to ensure that the incrementing is never skipped. Which, then what you have is a C style for loop with unfamiliar/unprecedented syntax, which would be silly.
>
> Perhaps the question is, is it worth keeping the C style around for loop syntax for these particular types of uses?
>
>
> On a total side note, I figure while I'm proposing silly things and decidedly terrible syntax, I might as well mention that when I originally began programming I was confused about the need for two different styles of loops. It seemed like "while" was a special case of "for" and was redundant (but made for a nicer looking syntax). An interesting thought experiment is to think about what dropping "while" might look like.
>
> Just like there is for-in
>
> for x in someGenerator {
> 	// code
> }
>
> There could also be for-if-repeat and for-repeat-if
>
> for var x = 0 if x < 7 repeat {
> 	// code
> } then x + 7
>
> for var x = 0 repeat {
> 	// code
> } if x < 7 then x + 7
>
> Certainly an unnecessary change considering the problem at hand and has obvious downsides, but I think fun to think about.
>
> Tyler
>
>
> On Dec 4, 2015, at 11:54 PM, Roland King <rols at rols.org <mailto:rols at rols.org>> wrote:
>
>> I must be the only person who still likes C-style for loops on occasion. eg a loop with something floating point
>>
>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
>> {
>> 	// more than a few lines of code with early escape continues
>> }
>>
>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.
>>
>> In the float case yes you can use stride
>>
>> for var floatingThing in start.stride( through : end, by : delta )
>> {
>> }
>>
>> but it’s not terribly pretty and you have to be sure whether you mean stride( through:, end:) or stride( to:, end:)
>>
>> That’s not a problem with integers where you have the ‘0..<n’ syntax which reads very clearly in a for .. in construct but in other cases the old c-style for can be a clearer read than for .. in with an iterator.
>>
>>
>>
>>> On 5 Dec 2015, at 15:14, Tyler Cloutier <cloutiertyler at aol.com <mailto:cloutiertyler at aol.com>> wrote:
>>>
>>> Indeed. Python doesn't have it, and there isn't much concern about the learning curve or the missing functionality there, it seems. I actually didn't even realize it was missing from Python until I stopped and thought about it.
>>>
>>> At first I was concerned about losing C style for loops, but I really can imagine a scenario in which they are more succinct while still maintaining clarity of intent. Plus they're a pain to type out.
>>>
>>> From time to time when programming in C or JS I will include more than one statement or more complicated logic in the increment part of the for loop (perhaps move 2 indices in a complicated way), but perhaps that would be clearer just to implement as a while loop with the logic at the end.
>>>
>>> One thing I will say is that it's nice to have your loop variables scoped to the loop, which is more difficult (impossible?) to accomplish with a while loop.
>>>
>>> Perhaps some while loop syntax like:
>>>
>>> while (x < someThing) start var x = 0, y = 11 {
>>> 	x += someOtherThing
>>> }
>>>
>>> Which is decidedly terrible syntax, but that's kind of the idea anyway.
>>>
>>> Tyler
>>>
>>>
>>>
>>>
>>>
>>> On Dec 4, 2015, at 3:21 PM, Colin Cornaby <colin.cornaby at mac.com <mailto:colin.cornaby at mac.com>> wrote:
>>>
>>>> This is a nice solution that translates nicely without creating too much concern about changing the nature of an algorithm in a complex system. 👍
>>>>
>>>> Should at least get a nice "fix it" in Xcode though. On survey, we do have developers using the C style syntax, but we're early in the process of transitioning.
>>>>
>>>> On Dec 04, 2015, at 02:52 PM, Johan Jensen <jj at johanjensen.dk <mailto:jj at johanjensen.dk>> wrote:
>>>>
>>>>> With the removal of post/pre-increment/decrement you might as well translate C-style for-loops to something akin to
>>>>>
>>>>> for var i in 0..<10 {
>>>>>     ...
>>>>> }
>>>>>
>>>>> If more advanced C-style for-loops are needed, I am sure most developers can use a while-loop (as mentioned by Ray Fix) until they get accustomed to Swift’s syntax.
>>>>>
>>>>> On Fri, Dec 4, 2015 at 11:37 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>>>>> You might ease the pain by approximating C-style 'for' by a higher-order function:
>>>>>
>>>>> func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
>>>>>   // left as an exercise
>>>>> }
>>>>>
>>>>> var i = 0
>>>>> cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
>>>>>   print(i)
>>>>> }
>>>>>
>>>>> -Joe
>>>>>
>>>>>> On Dec 4, 2015, at 2:33 PM, Colin Cornaby <colin.cornaby at mac.com <mailto:colin.cornaby at mac.com>> wrote:
>>>>>>
>>>>>> I was talking with people in the office about this proposal today, in since there has been such a long discussion already I'll just reply to the top of the tree just to get our take in before the review...
>>>>>>
>>>>>> It's understood that Swift has better, more readable ways to do for loops, but C style for loops reduce friction for getting our C or C++ developers on board with Swift. Unless there is a gain elsewhere to be made in their removal, it would be nice to keep them. As we transition to Swift we can educate developers on better ways to iterate, but it would be nice to have one less thing in the way of getting people writing Swift code.
>>>>>>
>>>>>> We work on a lot of algorithmic code which would be well suited for Swift. And again, I understand that C style for loops are redundant. But it's just one less speed bump in understanding for some of our developers or for porting pure C or C++ code without having to do as much re-validation of algorithms for accidental changes.
>>>>>>
>>>>>> But if it's actively hurting some other part of the language we could probably be talked into it.
>>>>>>
>>>>>> On Dec 03, 2015, at 03:32 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>
>>>>>>> Does Swift still needs C-style for loops with conditions and incrementers?
>>>>>>>
>>>>>>> <Screen Shot 2015-12-03 at 4.30.15 PM.png>
>>>>>>>
>>>>>>> More Swift-like construction is already available with for-in-statements and stride.
>>>>>>> This would naturally starve the most common point for -- and ++ operators as well.
>>>>>>>
>>>>>>> -- E
>>>>>>>
>>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/cc2342e1/attachment-0001.html>

From adrian.kashivskyy at me.com  Sat Dec  5 12:23:41 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sat, 05 Dec 2015 19:23:41 +0100
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
Message-ID: <E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>

> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.

That's a feature of IDE, not the language itself.

Pozdrawiam – Regards,
Adrian Kashivskyy

> Wiadomość napisana przez Harlan Haskins <harlan at harlanhaskins.com> w dniu 05.12.2015, o godz. 17:52:
>
> SwiftLint looks really nice, but one thing I'd really like is automatic formatting. I'd absolutely like to see clang-format adapted with Swift support. Maybe the SwiftLint people can, now that Swift is open source, contribute the bulk of the SwiftLint project directly into clang-format.
>
> On Dec 5, 2015, at 9:09 AM, Paul Young <paulyoungonline at gmail.com <mailto:paulyoungonline at gmail.com>> wrote:
>
>> Amir, you may be interested in SwiftLint: https://github.com/realm/SwiftLint <https://github.com/realm/SwiftLint>
>>
>>
>>
>> On Sat, Dec 5, 2015 at 1:43 PM, Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> wrote:
>>
>>
>>> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com <mailto:austinzheng at gmail.com>> wrote:
>>>
>>> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.
>>
>> All programming languages are already enforcing subjective views about best practice in one form or another.
>>
>>>
>>> Austin
>>>
>>>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> wrote:
>>>>
>>>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>>>>
>>>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>>>>
>>>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>>>>
>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>>>>
>>>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>>>>
>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>
>>>>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>>>>
>>>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>>>>
>>>>>
>>>>> Regards,
>>>>> Adrian Kashivskyy
>>>>> iOS Developer at Netguru
>>>>>
>>>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com <mailto:amichail at gmail.com>> w dniu 05.12.2015, o godz. 00:53:
>>>>>>
>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>>>>
>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>>
>>>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c4274202/attachment.html>

From possen at gmail.com  Sat Dec  5 12:29:09 2015
From: possen at gmail.com (possen p)
Date: Sat, 5 Dec 2015 10:29:09 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
Message-ID: <C1A6C9E6-16CD-42EC-8301-6B8DC6042A3A@gmail.com>

The current ternary operator, for this example:

let val = p == 5 ? 10 : 40

Which I have always thought was hard to read but I do like the functionality it provides. That is, in one expression you can compactly get two different values based upon a condition. Swift seems to have adopted the C style ternary operators probably to not completly change everytihg. Similar to the drop of the ++ and -- operator I am proposing that there is to replace the ternary operator to improve readability but continue to provide that functionality.

Recommendation: most readable but changes rules about if-else always having braces and puts the “if” at end. It is only a little bit longer than the original. I think it is clearer to have the conditional at the end so the assignment part is where the variable is assigned. This also does not introduce new keywords or operators.

let val = 10 else 40 if p == 5

In looking at the Nil-Coalescing operator there is a similar idea but it is really not the same. In that the left hand side of the ?? operator returns itself when non nil, and the behavior of the ternary operator is different. It is also harder to read.

let val = 10 ?? 40 if p = 5

I also considered a bunch of other possibilities like using “where" or “when" instead of “if”, the python of putting conditional in the middle or the ruby style of “if" returning a value but did not like those.

// python style
let  val = 10 if p == 5 else 40

// ruby style
let val = if p == 5 then 10 else 40


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/6e586e90/attachment-0001.html>

From a.michail at me.com  Sat Dec  5 12:33:41 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 13:33:41 -0500
Subject: [swift-evolution] Redundant parentheses should result in compile
errors.
Message-ID: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>

This isn’t just a style issue.

Rather, it would force programmers to remember operator precedence better thus resulting in fewer bugs.

From adrian.kashivskyy at me.com  Sat Dec  5 12:35:32 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sat, 05 Dec 2015 19:35:32 +0100
Subject: [swift-evolution] Redundant parentheses should result in
compile errors.
In-Reply-To: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
References: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
Message-ID: <48CFE9F5-D6E5-4FAF-BAFC-45A26D374E3D@me.com>

It's hard to understand what you mean, could you provide come code examples?

Regards,
Adrian Kashivskyy
iOS Developer at Netguru

> Wiadomość napisana przez Amir Michail <a.michail at me.com> w dniu 05.12.2015, o godz. 19:33:
>
> This isn’t just a style issue.
>
> Rather, it would force programmers to remember operator precedence better thus resulting in fewer bugs.
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d9026b46/attachment.html>

From nickygerritsen at me.com  Sat Dec  5 12:36:47 2015
From: nickygerritsen at me.com (Nicky Gerritsen)
Date: Sat, 05 Dec 2015 19:36:47 +0100
Subject: [swift-evolution] Redundant parentheses should result in
compile errors.
In-Reply-To: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
References: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
Message-ID: <915C7D2B-0E51-49BC-AE65-BC447493DCB6@me.com>


> On 5 dec. 2015, at 19:33, Amir Michail <a.michail at me.com> wrote:
>
> This isn’t just a style issue.
>
> Rather, it would force programmers to remember operator precedence better thus resulting in fewer bugs.
But is this not also often used to make “bigger” expressions / conditions more readable?
I think already the example from https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID41 is a good example
2 + 3 % 4 * 5 is not at all readable for me without parentheses.

-- Nicky

From john.calsbeek+lists at gmail.com  Sat Dec  5 12:39:47 2015
From: john.calsbeek+lists at gmail.com (John Calsbeek)
Date: Sat, 5 Dec 2015 10:39:47 -0800
Subject: [swift-evolution] Proposal: floating point static min / max
properties
In-Reply-To: <9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>
References: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>
<9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>
Message-ID: <4326227E-3562-4D3F-8788-769FEBF0B440@gmail.com>

+1 on not calling them `max` and `min`.

I don’t have the history of the internal discussion, but I am not thrilled about that particular set of constants. Their names accurately describe the standard set of floating point constants (infinity, `FLT_MAX`, `FLT_MIN`, and smallest positive subnormal), but is that the best set of constants to expose?

How should I pick a starting value for a loop that takes the `min` or `max` of ints or floats in a sequence? With floats I should use `Float.greatestFiniteMagnitude` and `-Float.greatestFiniteMagnitude`, whereas with ints I should use `Int.max` and `Int.min`, because `-Int.max != Int.min`. Rather than parsing the three qualifiers in the name `greatestFiniteMagnitude` and reassure myself that negating it is the proper way to get the smallest finite value, I would rather type `Float.largestFinite` and `Float.smallestFinite` or something along those lines.

I have no problem with the name `leastNormalMagnitude`—if you want such a thing, you hopefully understand floats well enough for the name to not be confusing—but `leastMagnitude` is surprising to me. I think of subnormal numbers as being exceptional in the same way that infinities and NaNs are, so I wouldn’t expect to get a subnormal from a property called `leastMagnitude`. If there was a qualifier that explicitly meant “either normal or subnormal,” it would be the obvious choice here. I don’t know any, but I hope leaving off the qualifier entirely is not the best solution.

If I had to decide at this instant, I would probably pick `largestFinite`, `smallestFinite`, `leastNormalMagnitude`, and leave out `lastMagnitude` in favor of spelling it `Float(0).nextUp`.

</bikeshedding>

Cheers,
John

> On Dec 5, 2015, at 9:41 AM, Stephen Canon <scanon at apple.com> wrote:
>
> Hi Matthew —
>
> This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:
>
>   /// Positive infinity.
>   ///
>   /// Compares greater than all finite numbers.
>   static var infinity: Self { get }
>
>   /// The greatest finite value.
>   ///
>   /// Compares greater than or equal to all finite numbers, but less than
>   /// infinity.
>   static var greatestFiniteMagnitude: Self { get }
>
>   /// The least positive normal value.
>   ///
>   /// Compares less than or equal to all positive normal numbers.  There may
>   /// be smaller positive numbers, but they are "subnormal", meaning that
>   /// they are represented with less precision than normal numbers.
>   static var leastNormalMagnitude: Self { get }
>
>   /// The least positive value.
>   ///
>   /// Compares less than or equal to all positive numbers, but greater than
>   /// zero.  If the target supports subnormal values, this is smaller than
>   /// `leastNormalMagnitude`; otherwise they are equal.
>   static var leastMagnitude: Self { get }
>
> – Steve
>
>> On Dec 5, 2015, at 11:10 AM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>
>> In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.
>>
>> Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.
>>
>> import Darwin
>>
>> public extension Float {
>>   static let min = -FLT_MAX
>>   static let max = FLT_MAX
>> }
>>
>> public extension Double {
>>   static let min = -DBL_MAX
>>   static let max = DBL_MAX
>> }
>>
>> Is there interest in adding this?  If so, what is the right way to proceed?
>>
>> Matthew
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/15cc3459/attachment-0001.html>

From adrian.kashivskyy at me.com  Sat Dec  5 12:40:24 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sat, 05 Dec 2015 19:40:24 +0100
Subject: [swift-evolution] Redundant parentheses should result in
compile errors.
In-Reply-To: <915C7D2B-0E51-49BC-AE65-BC447493DCB6@me.com>
References: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
<915C7D2B-0E51-49BC-AE65-BC447493DCB6@me.com>
Message-ID: <D5C50E91-C253-4E1C-B6A7-CA3D1595D04F@me.com>

> 2 + 3 % 4 * 5 is not at all readable for me without parentheses.

Agree, it's neither readable, nor predictable, because of the operator precedence. That's why I don't understand why should one omit parentheses in such cases. I'm -1 on this for now.

Pozdrawiam – Regards,
Adrian Kashivskyy

> Wiadomość napisana przez Nicky Gerritsen <nickygerritsen at me.com> w dniu 05.12.2015, o godz. 19:36:
>
>
>> On 5 dec. 2015, at 19:33, Amir Michail <a.michail at me.com> wrote:
>>
>> This isn’t just a style issue.
>>
>> Rather, it would force programmers to remember operator precedence better thus resulting in fewer bugs.
> But is this not also often used to make “bigger” expressions / conditions more readable?
> I think already the example from https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID41 is a good example
> 2 + 3 % 4 * 5 is not at all readable for me without parentheses.
>
> -- Nicky
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/36d7936b/attachment.html>

From a.michail at me.com  Sat Dec  5 12:42:44 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 13:42:44 -0500
Subject: [swift-evolution] Redundant parentheses should result in
compile errors.
In-Reply-To: <D5C50E91-C253-4E1C-B6A7-CA3D1595D04F@me.com>
References: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
<915C7D2B-0E51-49BC-AE65-BC447493DCB6@me.com>
<D5C50E91-C253-4E1C-B6A7-CA3D1595D04F@me.com>
Message-ID: <C19F2587-E275-48F4-ACDF-80E19F0097DA@me.com>

Generally speaking, people put parentheses in expressions not to improve readability but because they can’t remember certain operator precedences and don’t want to bother looking them up.

> On Dec 5, 2015, at 1:40 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
>> 2 + 3 % 4 * 5 is not at all readable for me without parentheses.
>
> Agree, it's neither readable, nor predictable, because of the operator precedence. That's why I don't understand why should one omit parentheses in such cases. I'm -1 on this for now.
>
> Pozdrawiam – Regards,
> Adrian Kashivskyy
>
>> Wiadomość napisana przez Nicky Gerritsen <nickygerritsen at me.com <mailto:nickygerritsen at me.com>> w dniu 05.12.2015, o godz. 19:36:
>>
>>
>>> On 5 dec. 2015, at 19:33, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>>
>>> This isn’t just a style issue.
>>>
>>> Rather, it would force programmers to remember operator precedence better thus resulting in fewer bugs.
>> But is this not also often used to make “bigger” expressions / conditions more readable?
>> I think already the example from https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID41 <https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID41> is a good example
>> 2 + 3 % 4 * 5 is not at all readable for me without parentheses.
>>
>> -- Nicky
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/50ce4fc0/attachment.html>

From griotspeak at gmail.com  Sat Dec  5 12:45:25 2015
From: griotspeak at gmail.com (T.J. Usiyan)
Date: Sun, 6 Dec 2015 00:15:25 +0530
Subject: [swift-evolution] Proposal: Tail Call Optimization
keyword/attribute
In-Reply-To: <0A765714-4F27-49A2-AF87-41551FF44199@apple.com>
References: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
<0A765714-4F27-49A2-AF87-41551FF44199@apple.com>
Message-ID: <CAGJeWTo6gDkQOQrRhcHwttWzzhpi+07_K=h1C4QPNG=gRK1tfw@mail.gmail.com>

I did paint ARC as the sole culprit, didn't I? It makes sense that there
are other complications and it is interesting to note that ARC isn't the
the primary reason.

On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff <jgroff at apple.com> wrote:
>
>
> - only allowing self-recursive tail calls, which avoid some of the stack
> and memory management problems with arbitrary tail calls,
> - only allowing tail calls between functions in the same module, so that
> the compiler has enough information to use the tail-callable convention
> only where needed,
> - only allowing tail calls between functions in the same module or
> external functions marked with a '@tail_callable' attribute.
>
>
Even if none of these can be supported immediately, there is a case for
adding the attribute with the note that there are almost no supported
cases. Guaranteed support for self recursive tail calls, even if that is
all we added, would be a huge addition, in my opinion.

I don't know how useful the third option would be but the second case is
compelling. I am thinking of parser combinators in particular being a case
where the second option could help.

On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff <jgroff at apple.com> wrote:

> Requiring an explicit 'tail' annotation for tail calls is definitely the
> right way to approach this. However, ARC is not the only (or even the
> primary) reason tail recursion is problematic for Swift. ARC operations are
> not strictly ordered, unlike C++ destructors; the compiler is free to
> release values at any point after their last use. As long as a
> tail-callable function uses a convention where the callee takes ownership
> of all of its refcounted parameters, then ARC can avoid interfering with
> tail calls. However, there are other low-level resources that need to be
> managed in the case of an arbitrary tail call, such as space on the
> callstack and memory for indirectly-passed parameters. Being able to manage
> these would require a special machine-level calling convention that would
> have overhead we don't want to spend pervasively to make arbitrary
> functions tail-callable. Because of this, we'd have to put further
> restrictions on what can be tail-called. Some options, in rough order of
> complexity, include:
>
> - only allowing self-recursive tail calls, which avoid some of the stack
> and memory management problems with arbitrary tail calls,
> - only allowing tail calls between functions in the same module, so that
> the compiler has enough information to use the tail-callable convention
> only where needed,
> - only allowing tail calls between functions in the same module or
> external functions marked with a '@tail_callable' attribute.
>
> -Joe
>
> On Dec 5, 2015, at 5:55 AM, T.J. Usiyan <griotspeak at gmail.com> wrote:
>
> ## Introduction
>
> Tail call optimization can be a powerful tool when implementing certain
> types of algorithms. Unfortunately, ARC's semantics interfere with our
> ability to handle all possible cases of tail call recursion. An attribute,
> similar to Scala's `tailrec`, along with LLVM warnings, could allow a clear
> indicator of when such optimizations are not guaranteed to work.
>
> ## Motivation
>
> LLVM will, currently, perform tail call optimization when possible cannot
> guarantee such optimizations. ARC can interfere with tail call recursion by
> inserting a method call after the intended 'last' recursive call. The
> ability to insert this call is fundamental to ARC and, because of this,
> swift developers currently have no insight into when TCO can/will occur.
>
> ``` swift
> func fact(input: Int) -> Int {
>     func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
>         if n <= 0 {
>             return (0, value)
>         } else {
>             return _fact(n - 1, value: n * value)
>         }
>     }
>
>     return _fact(input, value: 1).value
> }
> ```
> In the provided example, the developer can be sure that tail call
> optimization is possible but, without either a universal guarantee or
> something like the proposed attribute, there is no wait to be sure that
> such an optimization will occur.
>
> ## Proposed solution
>
> Providing an attribute would provide developers with concrete klnowledge
> of when TCO can and will be performed by LLVM in compiling their swift
> code.
>
> ``` swift
> func fact(input: Int) -> Int {
> @tailrec
>     func _fact(n: Int, value: Int) -> (n: Int, value:Int) {
>         ...
> ```
> With this attribute, the developer can express the desire for TCO and
> warnings can be emitted if TCO cannot be guaranteed. If there are currently
> only a few such cases, developers are made aware of what those cases are
> and can design implementations with this information at hand. As LLVM's
> ability to provide TCO increases, the allowed cases simply grow with no
> effect for the initial narrow cases.
>
>
> ## Detailed design
> In an ideal situation, implementation of this feature can consist solely
> of the attribute and output from LLVM indicating whether or not the
> requested ptimization can be guaranteed. This proposal does not call for an
> expansion of accepted cases.
>
> ## Impact on existing code
>
> This should not have any breaking impact as it is strictly additive and
> diagnostic.
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/65b8a10c/attachment-0001.html>

From cloutiertyler at aol.com  Sat Dec  5 12:51:21 2015
From: cloutiertyler at aol.com (Tyler Cloutier)
Date: Sat, 5 Dec 2015 10:51:21 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <14FCD24F-4CD7-4C36-B3BB-834345C36579@rols.org>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
<5AD76999-0F6F-4E69-A08C-E73D9CE8F6F0@aol.com>
<1BF1986B-7D9A-4E2B-A218-43100F5319BB@web.de>
<14FCD24F-4CD7-4C36-B3BB-834345C36579@rols.org>
Message-ID: <A02E1A77-9F84-49C1-9D7C-5228A0F7489F@aol.com>

Yeah I just threw that syntax together after a few minutes, but if there's actual interesting in consolidating whiles and C style fors, perhaps it warrants further consideration? If list comprehensions are ever to be added, it might be a good idea to allow it to be compatible with the possibility that fors could be used as a generator expression. I know others are talking about a similar thing for if and switch.

Tyler

> On Dec 5, 2015, at 9:28 AM, Roland King <rols at rols.org> wrote:
>
>
>> On 5 Dec 2015, at 19:35, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>>
>> I’m not a big fan of the C-style for loop, mostly because i find the parts of it badly separated by those tiny semicolons which are easily overlooked.
>>
>> Therefore for me it would be ok if the C-style for loop would be dropped but transforming its syntax into more Swift like syntax like suggested by Tyler might be even better as Roland and Tyler made some good points about advantages of the for loop (especially the guaranteed execution of the increment part). Being able to have the loop variable scoped locally to the loop is another advantage over the while loop.
>
> I’d be perfectly happy if a semantic equivalent, but syntactically more easily comprehensible, alternative to the c-style for loop was introduced. An extension to while sounds reasonable if there’s a version which is generally agreed to be clearer. I’d like not to throw away what the fullness of what a c-style for loop can express, I don’t mind at all if we throw away the semicolons currently used to express it and replace them with an alternative and more readable syntax. I thought Thorsten’s suggestion for one was fine, I’m sure there are others.
>

From adrian.kashivskyy at me.com  Sat Dec  5 12:51:33 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sat, 05 Dec 2015 19:51:33 +0100
Subject: [swift-evolution] Redundant parentheses should result in
compile errors.
In-Reply-To: <C19F2587-E275-48F4-ACDF-80E19F0097DA@me.com>
References: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
<915C7D2B-0E51-49BC-AE65-BC447493DCB6@me.com>
<D5C50E91-C253-4E1C-B6A7-CA3D1595D04F@me.com>
<C19F2587-E275-48F4-ACDF-80E19F0097DA@me.com>
Message-ID: <FAB34C19-9950-4284-8DB3-94DA8B51F4E9@me.com>

And that's perfectly understandable and justified because it reduces a huge amount of "pain in the bottom" of looking the precedences up.

Besides, parentheses in calculations are as important as in pure math – I don't understand the reasoning behind the idea of disallowing them.

Pozdrawiam – Regards,
Adrian Kashivskyy

> Wiadomość napisana przez Amir Michail <a.michail at me.com> w dniu 05.12.2015, o godz. 19:42:
>
> Generally speaking, people put parentheses in expressions not to improve readability but because they can’t remember certain operator precedences and don’t want to bother looking them up.
>
>> On Dec 5, 2015, at 1:40 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>>
>>> 2 + 3 % 4 * 5 is not at all readable for me without parentheses.
>>
>> Agree, it's neither readable, nor predictable, because of the operator precedence. That's why I don't understand why should one omit parentheses in such cases. I'm -1 on this for now.
>>
>> Pozdrawiam – Regards,
>> Adrian Kashivskyy
>>
>>> Wiadomość napisana przez Nicky Gerritsen <nickygerritsen at me.com <mailto:nickygerritsen at me.com>> w dniu 05.12.2015, o godz. 19:36:
>>>
>>>
>>>> On 5 dec. 2015, at 19:33, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>>>
>>>> This isn’t just a style issue.
>>>>
>>>> Rather, it would force programmers to remember operator precedence better thus resulting in fewer bugs.
>>> But is this not also often used to make “bigger” expressions / conditions more readable?
>>> I think already the example from https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID41 <https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID41> is a good example
>>> 2 + 3 % 4 * 5 is not at all readable for me without parentheses.
>>>
>>> -- Nicky
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c5335bfd/attachment.html>

From phabouzit at apple.com  Sat Dec  5 12:52:04 2015
From: phabouzit at apple.com (Pierre Habouzit)
Date: Sat, 05 Dec 2015 10:52:04 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>
<5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com>
<656EA51E-3A37-4A39-988A-7A84ED84C690@gmail.com>
<7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io>
Message-ID: <B1396C92-D62B-4CA9-AB4E-9FC7F59632B4@apple.com>

> On Dec 5, 2015, at 10:13 AM, David Owens II <david at owensd.io> wrote:
>
> Is there a reason we cannot use labelled case statements?
>
>     switch some_value {
>     case .REFINED:
>         if !validate(some_value) { return NULL }
>         fallthrough base
>
>     base: case .BASE:
>         handle_enum_value();
>     }
>
> At least this is explicit now.

that would be awesome.

>
>> On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini <vinivendra at gmail.com <mailto:vinivendra at gmail.com>> wrote:
>>
>> I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.
>>
>> In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like

the pattern I showed is really really pervasive in system programming code, especially because in that example below:

>> if some_value == .Refined && !validate(some_value) {
>> 	return NULL
>> }
>> handle_enum_value()


the “validate” is shifted to the right, which hides the essential thing you’re doing, which is the validation.
it is important to me to see the validation stand out and be one indent level away, and not arbitrarily pushed to the right.

it allows to read your code keeping your eyes aligned on the first columns of your text editor to get a sense of the flow of what is going on.

David’s example has this property and I find it very desireable.


>> More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.
>>
>>> On Dec 5, 2015, at 12:15 PM, Pierre Habouzit <phabouzit at apple.com <mailto:phabouzit at apple.com>> wrote:
>>>
>>>
>>>> On Dec 5, 2015, at 9:02 AM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>>
>>>> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>
>>>> I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are "syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.
>>>>
>>>> All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness" of fallthrough.
>>>
>>> Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.
>>>
>>> in system programming C, I find myself writing things like this very often:
>>>
>>>
>>> switch (some_value) {
>>> case ENUM_VALUE_REFINED:
>>>     if (validate(some_value)) {
>>>         return NULL;
>>>     }
>>>     /* fallthrough */
>>> case ENUM_VALUE_BASE:
>>>     handle_enum_value();
>>>     …
>>> }
>>>
>>> Where the swift equivalent would roughly be:
>>>
>>> switch some_value {
>>> case .REFINED:
>>>     if !validate(some_value) { return NULL }
>>>     fallthrough
>>> case .BASE:
>>>     handle_enum_value();
>>> }
>>>
>>> This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.
>>>
>>> Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:
>>>
>>> switch (some_value) {
>>> case ENUM_VALUE_REFINED_1:
>>>     if (validate(some_value)) {
>>>         return NULL;
>>>     }
>>>     goto base_value;
>>> case ENUM_VALUE_REFINED_2:
>>>     if (validate(some_value)) {
>>>         return NULL;
>>>     }
>>>     goto base_value;
>>>
>>> case ENUM_VALUE_BASE:
>>> base_value:
>>>     handle_enum_value();
>>>     …
>>> }
>>>
>>>
>>> cannot be written in swift, despite also being quite useful.
>>>
>>> Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.
>>>
>>> -Pierre
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9cba0e16/attachment-0001.html>

From jgroff at apple.com  Sat Dec  5 12:52:21 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 10:52:21 -0800
Subject: [swift-evolution] Proposal: Tail Call Optimization
keyword/attribute
In-Reply-To: <CAGJeWTo6gDkQOQrRhcHwttWzzhpi+07_K=h1C4QPNG=gRK1tfw@mail.gmail.com>
References: <CAGJeWToFXi7=gOKrK0WViCspTi4KHYBjqV7GdRMuvgD0pJ15Hg@mail.gmail.com>
<0A765714-4F27-49A2-AF87-41551FF44199@apple.com>
<CAGJeWTo6gDkQOQrRhcHwttWzzhpi+07_K=h1C4QPNG=gRK1tfw@mail.gmail.com>
Message-ID: <BE5611A9-ED29-4ADB-B9A4-74FC80A5D581@apple.com>


> On Dec 5, 2015, at 10:45 AM, T.J. Usiyan <griotspeak at gmail.com> wrote:
>
> I did paint ARC as the sole culprit, didn't I? It makes sense that there are other complications and it is interesting to note that ARC isn't the the primary reason.
>
> On Sat, Dec 5, 2015 at 9:00 PM, Joe Groff <jgroff at apple.com <mailto:jgroff at apple.com>> wrote:
>
> - only allowing self-recursive tail calls, which avoid some of the stack and memory management problems with arbitrary tail calls,
> - only allowing tail calls between functions in the same module, so that the compiler has enough information to use the tail-callable convention only where needed,
> - only allowing tail calls between functions in the same module or external functions marked with a '@tail_callable' attribute.
>
>
> Even if none of these can be supported immediately, there is a case for adding the attribute with the note that there are almost no supported cases. Guaranteed support for self recursive tail calls, even if that is all we added, would be a huge addition, in my opinion.
>
> I don't know how useful the third option would be but the second case is compelling. I am thinking of parser combinators in particular being a case where the second option could help.

This seems like a reasonable evolution path. Getting only self-tail-calls working is indeed much simpler, and can likely be implemented mostly in SILGen by jumping to the entry block, without any supporting backend work. Arbitrary tail calls can be supported in the fullness of time.

-Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/3bc5dfb4/attachment.html>

From john.calsbeek+lists at gmail.com  Sat Dec  5 12:52:22 2015
From: john.calsbeek+lists at gmail.com (John Calsbeek)
Date: Sat, 5 Dec 2015 10:52:22 -0800
Subject: [swift-evolution] Redundant parentheses should result in
compile errors.
In-Reply-To: <C19F2587-E275-48F4-ACDF-80E19F0097DA@me.com>
References: <451B83CD-D6B3-457D-97AC-DB0C9662D175@me.com>
<915C7D2B-0E51-49BC-AE65-BC447493DCB6@me.com>
<D5C50E91-C253-4E1C-B6A7-CA3D1595D04F@me.com>
<C19F2587-E275-48F4-ACDF-80E19F0097DA@me.com>
Message-ID: <BED874D1-0098-4843-9376-BB7B63B9A594@gmail.com>

> On Dec 5, 2015, at 10:42 AM, Amir Michail <a.michail at me.com> wrote:
>
> Generally speaking, people put parentheses in expressions not to improve readability but because they can’t remember certain operator precedences and don’t want to bother looking them up.

Even if this is true, there exist cases where parentheses express intent, including cases where precedence is not in question.

For example, when working with floats I can rewrite `a * b * c * d` as `(a * b) * (c * d)`, whether for numerical reasons or performance reasons, but if I can only insert relevant parentheses, I must instead write `a * b * (c * d)`. That seems less clear—`c` and `d` are no more specially related than `a` and `b` are.

Or are you proposing forbidding parentheses whenever they don’t change precedence but allowing parentheses when they don’t change associativity?

On a different note: how would you ever _explain_ precedence without writing malformed code? Or write tests that verify operator precedence in a clear manner?

Cheers,
John

