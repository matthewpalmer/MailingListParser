From jgroff at apple.com  Sat Dec  5 12:56:04 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 10:56:04 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com>
<5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com>
<656EA51E-3A37-4A39-988A-7A84ED84C690@gmail.com>
<7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io>
Message-ID: <2E514F6E-5BF9-465D-AC41-D1182E0FA373@apple.com>


> On Dec 5, 2015, at 10:13 AM, David Owens II <david at owensd.io> wrote:
>
> Is there a reason we cannot use labelled case statements?
>
>     switch some_value {
>     case .REFINED:
>         if !validate(some_value) { return NULL }
>         fallthrough base
>
>     base: case .BASE:
>         handle_enum_value();
>     }
>
> At least this is explicit now.

Yeah, maybe there's a more general language feature that could replace 'fallthrough' here. Instead of labelling cases, we could support a 'reswitch' statement that redispatches the switch to the case matching the operand:

switch some_value {
case .REFINED:
if !validate(some_value) { return NULL }
reswitch .BASE

case .BASE:
handle_enum_value();
}

That should be easy to peephole to a proper fallthrough in constant cases, but would also nicely generalize to applications like interpreters, where it's often desirable to push the dispatch inline into the logic for better pipelining.

-Joe

>
>> On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini <vinivendra at gmail.com <mailto:vinivendra at gmail.com>> wrote:
>>
>> I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.
>>
>> In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like
>>
>> if some_value == .Refined && !validate(some_value) {
>> 	return NULL
>> }
>> handle_enum_value()
>>
>> More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.
>>
>>> On Dec 5, 2015, at 12:15 PM, Pierre Habouzit <phabouzit at apple.com <mailto:phabouzit at apple.com>> wrote:
>>>
>>>
>>>> On Dec 5, 2015, at 9:02 AM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>>>
>>>> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>
>>>> I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are "syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.
>>>>
>>>> All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness" of fallthrough.
>>>
>>> Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.
>>>
>>> in system programming C, I find myself writing things like this very often:
>>>
>>>
>>> switch (some_value) {
>>> case ENUM_VALUE_REFINED:
>>>     if (validate(some_value)) {
>>>         return NULL;
>>>     }
>>>     /* fallthrough */
>>> case ENUM_VALUE_BASE:
>>>     handle_enum_value();
>>>     …
>>> }
>>>
>>> Where the swift equivalent would roughly be:
>>>
>>> switch some_value {
>>> case .REFINED:
>>>     if !validate(some_value) { return NULL }
>>>     fallthrough
>>> case .BASE:
>>>     handle_enum_value();
>>> }
>>>
>>> This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.
>>>
>>> Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:
>>>
>>> switch (some_value) {
>>> case ENUM_VALUE_REFINED_1:
>>>     if (validate(some_value)) {
>>>         return NULL;
>>>     }
>>>     goto base_value;
>>> case ENUM_VALUE_REFINED_2:
>>>     if (validate(some_value)) {
>>>         return NULL;
>>>     }
>>>     goto base_value;
>>>
>>> case ENUM_VALUE_BASE:
>>> base_value:
>>>     handle_enum_value();
>>>     …
>>> }
>>>
>>>
>>> cannot be written in swift, despite also being quite useful.
>>>
>>> Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.
>>>
>>> -Pierre
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/193d117e/attachment.html>

From jtbandes at gmail.com  Sat Dec  5 13:21:55 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 05 Dec 2015 19:21:55 +0000
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
Message-ID: <CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>

Another approach would be to simply allow

guard let self = self else { return }
On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com> wrote:

> Hi all,
>
> let’s say we have a completion handler closure for some function
> (networking, …) and we have [weak self] there. Example …
>
> doSomething() { [weak self] result in
>   …
> }
>
> … then we can use self?.whatever to access self properties, methods. Or we
> can try to check if self exists ...
>
> guard let strongSelf = self else { return }
>
> … and use strongSelf.
>
> Can we introduce [weakStrong self] with following behavior:
>
>  - self is a weak reference
>  - when the closure is going to be executed, all weakStrong weak
> references are checked if they do exist
>  - if they do exist, they’re strong referenced for the closure and the
> closure is executed
>  - if they don’t exist, closure is not executed
>
> doSomething() { [weakStrong self] result in
>   // Closure code is not executed if self no longer exists
>   // self is a strong reference now
> }
>
> What do you think? Does it make sense?
>
> My motivation is to get rid off of the repetitive code like this one:
>
> doSomething() { [weak self] result in
>   guard let strongSelf = self else { return }
>   strongSelf.doSomethingWithResult(result)
> }
>
> Robert
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f22d5fa4/attachment.html>

From me at alexkolov.com  Sat Dec  5 13:24:07 2015
From: me at alexkolov.com (Alexander Kolov)
Date: Sat, 5 Dec 2015 20:24:07 +0100
Subject: [swift-evolution] Proposal: standard logging facility
Message-ID: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>

Hi everyone,

Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.

The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.

As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.

I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.

Thanks,
Alex


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/6ca5ad26/attachment.html>

From zarzycki at icloud.com  Sat Dec  5 13:26:13 2015
From: zarzycki at icloud.com (David Zarzycki)
Date: Sat, 05 Dec 2015 14:26:13 -0500
Subject: [swift-evolution] Feedback for SE-0004: Remove the ++ and --
operators
Message-ID: <A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com>

Hi Chris,

An observation about SE-0004: Remove the ++ and — operators:

Given that the above is accepted, the only remaining postfix operator in the language is ‘!’ — and that is implemented by the compiler. Please consider just removing user-defined postfix operators entirely. Doing so would define away a type checking ambiguity where “let f : T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.

Cheers,
Dave

From plxswift at icloud.com  Sat Dec  5 13:34:56 2015
From: plxswift at icloud.com (plx)
Date: Sat, 05 Dec 2015 13:34:56 -0600
Subject: [swift-evolution] Inquiry: Improved Composability of stdlib
Collections?
Message-ID: <C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com>

Swift’s standard library's core collections' value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set<V>], and plan to mutate the “inner" sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.

Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.

Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?



From david at hartbit.com  Sat Dec  5 13:40:43 2015
From: david at hartbit.com (David Hart)
Date: Sat, 5 Dec 2015 20:40:43 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
Message-ID: <BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>

> This is subtle and requires thought

What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.

David.

> On 05 Dec 2015, at 18:09, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>
>> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy.
>>
>> Some interesting code in the standard library that uses the ternary operator quite a bit.
>>
>> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357>
>
> FWIW, I have no love for the ternary operator (it is totally "bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.
>
> If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.
>
> -Chris
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/4bbc13a2/attachment.html>

From a.michail at me.com  Sat Dec  5 13:51:27 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 14:51:27 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
Message-ID: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>

Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also?

From cloutiertyler at aol.com  Sat Dec  5 13:53:35 2015
From: cloutiertyler at aol.com (Tyler Cloutier)
Date: Sat, 5 Dec 2015 11:53:35 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <A2B6547D-CC4B-4A16-A481-522F9BF01813@michelf.ca>
References: <40184c7c-c237-4076-85b7-298d08bdf188@me.com>
<EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com>
<437319C0-F168-480E-A234-834645C90487@rols.org>
<A2B6547D-CC4B-4A16-A481-522F9BF01813@michelf.ca>
Message-ID: <69616483-02EA-4925-8104-4DB8309605A1@aol.com>

Maybe a keyword like "oncontinue" would be a little more obvious about its behavior than "defer"?

> On Dec 5, 2015, at 5:17 AM, Michel Fortin <michel.fortin at michelf.ca> wrote:
>
>> Le 5 déc. 2015 à 2:54, Roland King <rols at rols.org> a écrit :
>>
>> Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue.
>
> Well... you can do that:
>
>    var x = 0
>    while x < 10 {
>        defer { x += 1 } // warning: also increment x if an exception is thrown
>        continue
>    }
>
> Or maybe the C-style for loop could just be made more readable. You could replace the semicolons with words:
>
>    for var x = 0 while x < 10 defer x += 1 {
>    }
>
> But that might be slightly misleading. "defer" would imply that this part is executed when an exception is thrown, which would be unlike a regular for loop.
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>

From thisisroshansmail at gmail.com  Sat Dec  5 14:16:22 2015
From: thisisroshansmail at gmail.com (Roshan)
Date: Sun, 6 Dec 2015 01:46:22 +0530
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
Message-ID: <CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com>

I have used Lumberjack[1] with Objective-C and I found it pretty good.
Maybe it's scope is too large for the standard library, but it could serve
as a good reference.

[1] - https://github.com/CocoaLumberjack/CocoaLumberjack

On Sun, Dec 6, 2015 at 12:54 AM, Alexander Kolov via swift-evolution <
swift-evolution at swift.org> wrote:

> Hi everyone,
>
> Coming from a short discussion in swift-corelibs-dev, I’m investigating
> the need of a standard logging API as a part of core libraries.
>
> The motivation behind this would be having a unified and configurable set
> of APIs between all first-party modules and third party applications and
> libraries.
> I think this will help each of us since right now we’re inventing our own
> solutions as well many bigger third-party library providers have formats
> and facilities of their own.
>
> As I currently see it would be somewhat similar to python logging and
> possibly even structlog (http://www.structlog.org/en/stable/), with
> configurable formatters and handlers, including and not limited to remote
> loggers and syslog support.
>
> I’d love to hear your opinions and feedback on this and possibly start
> with some more formalized proposal and implementation if there’s enough
> support and need.
>
> Thanks,
> Alex
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>


--
Warm regards
Roshan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/f3ff40e0/attachment.html>

From me at alexkolov.com  Sat Dec  5 14:26:27 2015
From: me at alexkolov.com (Alexander Kolov)
Date: Sat, 5 Dec 2015 21:26:27 +0100
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
<CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com>
Message-ID: <72739D97-A103-4894-AC0E-2BE87EFB99EA@alexkolov.com>

Yes, we could definitely use it as a reference of use cases and requirements.
For the standard library we'd need fast extensible solution upon which anyone can build their own handlers.

Sent from my iPhone

> On Dec 5, 2015, at 9:16 PM, Roshan <thisisroshansmail at gmail.com> wrote:
>
> I have used Lumberjack[1] with Objective-C and I found it pretty good. Maybe it's scope is too large for the standard library, but it could serve as a good reference.
>
> [1] - https://github.com/CocoaLumberjack/CocoaLumberjack
>
>> On Sun, Dec 6, 2015 at 12:54 AM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:
>> Hi everyone,
>>
>> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.
>>
>> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
>> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.
>>
>> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.
>>
>> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.
>>
>> Thanks,
>> Alex
>>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> --
> Warm regards
> Roshan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/eca40549/attachment.html>

From kevboh at gmail.com  Sat Dec  5 14:20:17 2015
From: kevboh at gmail.com (Kevin Barrett)
Date: Sat, 5 Dec 2015 15:20:17 -0500
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
Message-ID: <CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com>

+1 to this.

On Sat, Dec 5, 2015 at 2:24 PM, Alexander Kolov via swift-evolution <
swift-evolution at swift.org> wrote:

> Hi everyone,
>
> Coming from a short discussion in swift-corelibs-dev, I’m investigating
> the need of a standard logging API as a part of core libraries.
>
> The motivation behind this would be having a unified and configurable set
> of APIs between all first-party modules and third party applications and
> libraries.
> I think this will help each of us since right now we’re inventing our own
> solutions as well many bigger third-party library providers have formats
> and facilities of their own.
>
> As I currently see it would be somewhat similar to python logging and
> possibly even structlog (http://www.structlog.org/en/stable/), with
> configurable formatters and handlers, including and not limited to remote
> loggers and syslog support.
>
> I’d love to hear your opinions and feedback on this and possibly start
> with some more formalized proposal and implementation if there’s enough
> support and need.
>
> Thanks,
> Alex
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/390ac8ad/attachment.html>

From landerbrandt at gmail.com  Sat Dec  5 14:25:12 2015
From: landerbrandt at gmail.com (Lander Brandt)
Date: Sat, 5 Dec 2015 12:25:12 -0800
Subject: [swift-evolution] swift tool project init command
Message-ID: <193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com>

On the Swift package manager page on swift.org <http://swift.org/> (https://swift.org/package-manager/#example-usage <https://swift.org/package-manager/#example-usage>) the requirements for creating a package/application are clearly outlined, but why not include a command in the swift tool for autogenerating the require? I did a quick look and didn’t see any existing discussion, so I apologize if this has already been discussed.

Example of the tool command: `swift init foo --type=(lib|app)`

Would create a new directory called “foo” with the following tree structure for a project of type app:

foo
├── Package.swift
├── Packages
├── README.md
└── main.swift

And for project of type lib:

foo
├── Package.swift
├── README.md
└── Sources
└── Foo.swift

In both cases Package.swift would contain something basic like:

import PackageDescription

let package = Package(
name: “Foo",
dependencies: [
]
)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b2d8054f/attachment.html>

From kevin at sb.org  Sat Dec  5 14:35:46 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 05 Dec 2015 12:35:46 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
Message-ID: <1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com>

On Sat, Dec 5, 2015, at 04:30 AM, Michel Fortin wrote:
> Like this:
>
> 	view.action = "_doSomething_UniqueSelector1234_currentModuleName_blahblah"
>
> 	extension NSObject {
> 		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {
> 			let target = self
> 			(target as! MyObject).doSomething()
> 		}
> 	}
>
> (Joe Groff suggested it first.) This simply assumes the receiver will
> derive from NSObject. You also need to set a non-nil target. And note
> that the closure is context-free, meaning you can't capture variables
> with it.

How is this type-safe? You're using as! in there (and silently ignoring
the message if the receiver is wrong wouldn't be any better). If I send
a selector to the wrong receiver, it's still going to crash.

This comes back to my fundamental argument, which is that
@convention(selector) looks like it's type-safe, but there's so many
holes and so many implicit coercions that need to be added that you can
drive a gigantic truck full of unsafety right through it without even
noticing.

-Kevin Ballard

From david at alkaline-solutions.com  Sat Dec  5 14:46:22 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 13:46:22 -0700
Subject: [swift-evolution] Idea for enabling DSLs: bind to self in
closures
In-Reply-To: <1449272977.2880806.458506745.0738A7AA@webmail.messagingengine.com>
References: <D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com>
<20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com>
<1449269507.2870902.458470841.617B34D2@webmail.messagingengine.com>
<D387A01A-99F3-4D36-9B00-404B3088B38E@alkaline-solutions.com>
<1449272977.2880806.458506745.0738A7AA@webmail.messagingengine.com>
Message-ID: <E23C6CB7-7192-403C-AF80-5CEF176F92BD@alkaline-solutions.com>


> On Dec 4, 2015, at 4:49 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> On Fri, Dec 4, 2015, at 03:32 PM, David Waite wrote:
>> A few thoughts:
>>
>> 1. In a lot of situations they are not pure functions - they have state
>> associated across them determined by the context in which your closure
>> was called. So the import would not be of a static function, but of an
>> input parameter, aka:
>> 	it(“…”) {
>> 		builder in
>> 		import builder
>> 		expect(sections).to{…}
>>         }
>>
>> Assuming expect is the only function, this may very well be equivalent to
>>
>> 	it(“…”) {
>> 		builder in
>> 		let expect = builder.expect
>> 		expect(sections).to{…}
>>         }
>
> I don't think we want to add `import builder`, importing methods that
> are implicitly bound to some value seems like a dangerous can of worms
> to open up.

I’m not sure about that; isn’t that exactly what ‘self’ is? If anything, it is deciding whether it is worth having two cans of worms open. And the semantics would likely be similar to self - it has to be a fixed value type or reference through the scope.

Import might be a poor overloading of an existing concept though. Alternative syntax based on the setup closure thread’s ‘with’ syntax examples:

it(“…”) {
builder in
with builder {
expect(sections).to{…}
}
}

but obviously I would like to not have the extra level of nesting, so probably more like:
it(“…”) {
with builder in
expect(sections).to{…}
}

Using .. syntax likely would be inappropriate for this example, since there may be additional business logic in between calls to expect.

> If you need state (and don't want to encode that state as
> thread-local variables, though of course Swift doesn't currently have
> support for those outside of NSThread.threadDictionary), then personally
> I don't think it's a big deal to require the explicit state argument.
> You could even adopt a convention of using $ for the identifier here
> (while $0, $1, etc are defined by the language, $ appears to be open for
> use as an identifier), so that would look like
>
> describe("foo") { $ in
>    $.it("has bar") { $ in
>        $.expect(sections).to(...)
>    }
> }

This is probably the simplest alternative to my proposal, and requires no language changes. However,
- IMHO the $0, $1, etc syntax is meant for when terseness is a benefit that outweighs readability. This is primarily because $ looks more like an operator than part of a parameter name, and the names themselves aren’t based on the signature of the method calling the closure. Even after a fair amount of swift work, I stumble whenever I see $0, etc syntax. For this reason, using $ as the parameter name feels like it counteracts the expressiveness I was going for.
- Coming up with an alternative explicit name (builder? context?) for a passed parameter is hard, because the code is often not so much manipulating that state as it is operating within the context of that state. The term the language gives us for this is ‘self’, but that isn’t assignable/overridable. This could actually wind up making $ feel more like a keyword than an arbitrary parameter name choice.

>
> And you can also do things like make the expectations actually be static
> members of their return value, so you'd have code like
>
>    $.expect(sections).to(.contain(bar))

I hadn’t considered that - your Swift-fu is strong :-)

> In the future, if Swift ever gains a fully-fledged macro system, then
> maybe you'd be able to rewrite these scopes-with-state as macros that
> carry implicit state. Or, heck, maybe someday we'll have higher-order
> types AND a monadic system (and either custom syntax or macros to
> simulate Haskell's `do` notation) and then we can just use monads to
> represent the state :D
One could hope - although I don’t believe macro systems or monads/monoids as a concept (rather than an API influence like Optional) are conducive for learning languages.

>> 5. Imports likely should generate conflicts at compile-time if they
>> shadow defined functions if you can do wildcard imports. No need to have
>> syntax to alias names - one should either change the code to not conflict
>> or use the longer-form names
>
> I agree that imports should throw an error if they'd shadow something
> defined locally (though perhaps they can still shadow things from other
> imports?). But I would actually like an alias syntax so you can import
> something under a different name, even if it's just restricted to naming
> modules in some kind of `import qualified` syntax (that would require
> the module name to use any member), e.g. `import qualified
> LongModuleName as L; /* ... */ L.foo(bar)`.

I was thinking more that "import LongModuleName.foo as bar” perhaps would be abused.

>> 6. import could be an attribute:
>> 	it(“…”) {
>> 		@import builder in
>> 		expect(sections).to{…}
>>         }
>
> What would that actually be an attribute of? Attributes aren't distinct
> items, they modify something else. And why make this an attribute when
> we have a perfectly good `import` keyword already?

Yeah, drop that idea.

-DW

From jtbandes at gmail.com  Sat Dec  5 14:53:05 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 12:53:05 -0800
Subject: [swift-evolution] Proposal: add `noescape` attribute to public API
(particularly libdispatch)
Message-ID: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>

There are several functions in public API, such as dispatch_sync and
dispatch_apply, which do not allow their block parameters to escape the
function call.

However, they are not currently exposed to Swift as @noescape, meaning that
users are required to specify "self." or "[weak self]" in their closures.

The instances I can think of:

- dispatch_sync
- dispatch_barrier_sync
- dispatch_apply
- dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)

I provided a preliminary implementation at
https://github.com/apple/swift-corelibs-libdispatch/pull/6, but it needs
refinement. Tony Parker mentioned commented that there might be similar
changes to make for the swift-corelibs-foundation project.

Thoughts?

Question: does __attribute__((noescape)) have the same meaning when applied
to C function pointers? Namely, does Swift understand @noescape as it
applies to @convention(c)?

Jacob Bandes-Storch
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/dbc5556a/attachment.html>

From alex.blewitt at gmail.com  Sat Dec  5 14:54:39 2015
From: alex.blewitt at gmail.com (Alex Blewitt)
Date: Sat, 5 Dec 2015 21:54:39 +0100
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
<E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
Message-ID: <49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>



Sent from my iPhat 6

> On 5 Dec 2015, at 19:23, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.
>
> That's a feature of IDE, not the language itself.

Not necessarily. The existence of "go fmt" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments.

Letting "the IDE" do formatting is fine provided there is a maximum of one IDE.

Alex

> Pozdrawiam – Regards,
> Adrian Kashivskyy
>
>> Wiadomość napisana przez Harlan Haskins <harlan at harlanhaskins.com> w dniu 05.12.2015, o godz. 17:52:
>>
>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting. I'd absolutely like to see clang-format adapted with Swift support. Maybe the SwiftLint people can, now that Swift is open source, contribute the bulk of the SwiftLint project directly into clang-format.
>>
>>> On Dec 5, 2015, at 9:09 AM, Paul Young <paulyoungonline at gmail.com> wrote:
>>>
>>> Amir, you may be interested in SwiftLint: https://github.com/realm/SwiftLint
>>>
>>>
>>>
>>>> On Sat, Dec 5, 2015 at 1:43 PM, Amir Michail <amichail at gmail.com> wrote:
>>>>
>>>>> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com> wrote:
>>>>>
>>>>> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.
>>>>
>>>> All programming languages are already enforcing subjective views about best practice in one form or another.
>>>>
>>>>>
>>>>> Austin
>>>>>
>>>>>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com> wrote:
>>>>>>
>>>>>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.
>>>>>>
>>>>>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>>>>>>>
>>>>>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.
>>>>>>>
>>>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)
>>>>>>>
>>>>>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the "style exception" annotation for the whole file. This would become "public static void main" of Swift.
>>>>>>>
>>>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>>>
>>>>>>> My greatest concern is about who will define what "bad smell" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).
>>>>>>>
>>>>>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.
>>>>>>>
>>>>>>>
>>>>>>> Regards,
>>>>>>> Adrian Kashivskyy
>>>>>>> iOS Developer at Netguru
>>>>>>>
>>>>>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com> w dniu 05.12.2015, o godz. 00:53:
>>>>>>>>
>>>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.
>>>>>>>>
>>>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.
>>>>>>>>
>>>>>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>>  _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/38c0f194/attachment.html>

From matthew at anandabits.com  Sat Dec  5 14:58:21 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 14:58:21 -0600
Subject: [swift-evolution] Proposal: floating point static min / max
properties
In-Reply-To: <9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>
References: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>
<9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>
Message-ID: <981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com>

Hi Steve,

Thanks for looking at my proposal and sharing the internal consensus.  I do like the more explicit names.

One of the reasons I proposed this was to follow up with a proposal for a RangeDiscoverable protocol that would be conformed to by all numeric types:

protocol RangeDiscoverable {
static var min: Self { get }
static var max: Self { get }
}

A better interface would looks like this (not sure why I didn’t think of this before):

public protocol RangeDiscoverable {
static var representableRange: Range<Self> { get }
}

With conformances that look like this:

extension Int: RangeDiscoverable {
static let representableRange: Range<Int> = Int.min…Int.max
}

extension Float: RangeDiscoverable {
// not sure it would be better to use -Float. greatestFiniteMagnitude..Float. greatestFiniteMagnitude here or not
static let representableRange: Range<Float> = -Float.infinity...Float.infinity
}

This would require numeric types to conform to ForwardIndexType.  Integer types already conform to RandomAccessIndexType.  Floating point types do not currently conform to ForwardIndexType but could conform not just to ForwardIndexType, but also BidirectionalIndexType.

My original implementation looked like this:

extension Float: BidirectionalIndexType {
public func predecessor() -> Float {
return nextafterf(self, Float.min)
}
public func successor() -> Float {
return nextafterf(self, Float.max)
}
}

With the nextUp and nextDown properties I see in test/Prototypes/FloatingPoint.swift this could change to:

extension Float: BidirectionalIndexType {
public func predecessor() -> Float {
return nextDown
}
public func successor() -> Float {
return nextUp
}
}

What is your thought on adding a protocol similar to RangeDiscoverable (conformed to by all numeric types) and the supporting BidirectionalIndexType conformance for floating point types?  Is this something that would be considered?




> On Dec 5, 2015, at 11:41 AM, Stephen Canon <scanon at apple.com> wrote:
>
> Hi Matthew —
>
> This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:
>
>   /// Positive infinity.
>   ///
>   /// Compares greater than all finite numbers.
>   static var infinity: Self { get }
>
>   /// The greatest finite value.
>   ///
>   /// Compares greater than or equal to all finite numbers, but less than
>   /// infinity.
>   static var greatestFiniteMagnitude: Self { get }
>
>   /// The least positive normal value.
>   ///
>   /// Compares less than or equal to all positive normal numbers.  There may
>   /// be smaller positive numbers, but they are "subnormal", meaning that
>   /// they are represented with less precision than normal numbers.
>   static var leastNormalMagnitude: Self { get }
>
>   /// The least positive value.
>   ///
>   /// Compares less than or equal to all positive numbers, but greater than
>   /// zero.  If the target supports subnormal values, this is smaller than
>   /// `leastNormalMagnitude`; otherwise they are equal.
>   static var leastMagnitude: Self { get }
>
> – Steve
>
>> On Dec 5, 2015, at 11:10 AM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>
>> In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.
>>
>> Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.
>>
>> import Darwin
>>
>> public extension Float {
>>   static let min = -FLT_MAX
>>   static let max = FLT_MAX
>> }
>>
>> public extension Double {
>>   static let min = -DBL_MAX
>>   static let max = DBL_MAX
>> }
>>
>> Is there interest in adding this?  If so, what is the right way to proceed?
>>
>> Matthew
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d48ecfbc/attachment.html>

From brent at architechies.com  Sat Dec  5 15:03:55 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 13:03:55 -0800
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
Message-ID: <4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>

> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.
>
> ```swift
> struct Foo {
>     let bar: String
>     let baz: Int
>
>     init(self.bar: String = "default", counter self.baz: Int) {
>     }
> }
> ```

I’d like to propose an alternative approach.

Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.

I propose that we make it possible to explicitly ask for that default initializer:

struct Foo {
let bar: String
let baz: Int

init() {
bar = “default”
baz = 0
}

init default	// automatically generates init(bar: String, baz: Int)
}

Moreover, I propose we extend this to classes:

struct Foo: Bar {
let bar: String
let baz: Int

init() {
bar = “default”
baz = 0
}

init default()	// automatically generates init(bar: String, baz: Int) with super.init()
}

In a class, the “default” statement must have parens after it; these indicate the parameters to be added for the superclass initializer. If you need to super up to an initializer that takes parameters, you add the needed parameters there:

struct Foo {
let bar: String
let baz: Int

init() {
bar = “default”
baz = 0
}

init default(quux: Double)	// automatically generates init(quux: Double, bar: String, baz: Int) with super.init(quux: quux)
}

If you super up to a failable initializer, of course, that will have to be “init? default(quux: Double)”.

Now, one little quirk of the current system is that Swift may actually generate *two* default initializers: a parameterless initializer when all properties have default values, and a memberwise initializer which requires all values be provided. I further propose that these be unified into one default initializer by giving default values to parameters which map to properties with default values. This gives you all the parameter sets currently supported, plus a whole range in between.

struct Foo {
let bar: String = “default"
let baz: Int

init() {
bar = “default”
baz = 0
}

init default	// automatically generates init(bar: String = “default", baz: Int)
}

Finally, you can continue to decorate the “init” keyword with attributes as you normally would.

public init default
internal init default
private init default
required init default
override init default
@objc init default
@objc public required init default

(I don’t think convenience initializers make much sense here.)

This does not, unfortunately, eliminate boilerplate in initializers which do more than just set properties. Nor does it allow you to rename parameters, as your example does with “counter”.

--
Brent Royal-Gordon
Architechies


From david at alkaline-solutions.com  Sat Dec  5 15:05:14 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 14:05:14 -0700
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
<CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com>
Message-ID: <DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com>

I would propose the simplest interface that I can assume is available *everywhere* to be defined by the Swift standard library, so as a framework developer I can make assumptions on my ability to provide diagnostics for internals, expose information for statistical use, provide information needed for auditing usage if I’m working on a hosted service and not a GUI app, and so on.

Things like custom formatters and appenders providing integration into remote/system services are something that the application can decide when it chooses a logging framework that implements the standard-defined protocol.

There isn’t any sort of dependency injection/inversion of control at the core swift level, which usually means that either logging is done by global functions, or by a global factory returns an instance of some type implementing the logging protocol.

The only piece of this which jumps out as not pure swift would be default integration into something like syslog or NSLog, and possibly adding a new preprocessor “macro” like __MODULE__

-DW

> On Dec 5, 2015, at 1:20 PM, Kevin Barrett via swift-evolution <swift-evolution at swift.org> wrote:
>
> +1 to this.
>
> On Sat, Dec 5, 2015 at 2:24 PM, Alexander Kolov via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> Hi everyone,
>
> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.
>
> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.
>
> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.
>
> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.
>
> Thanks,
> Alex
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/51e34079/attachment.html>

From brent at architechies.com  Sat Dec  5 15:10:14 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 13:10:14 -0800
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
<E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
<49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
Message-ID: <63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com>

>>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.
>>
>> That's a feature of IDE, not the language itself.
>
> Not necessarily. The existence of "go fmt" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments.
>
> Letting "the IDE" do formatting is fine provided there is a maximum of one IDE.

This is perhaps out of scope for this group, but I’ve actually long wanted languages to move in a direction where indentation is not present at all in the source file—your git repo might never have an instance of /\n[ \t]/ in it. Instead, it’s automatically added by the IDE while displaying the code, based on the block beginnings and endings present in the actual source. This would make incorrectly indented code a thing of the past; it would also be obvious when you’re missing a curly bracket, because your code would be indented all wrong. And it would end the destructive whitespace wars, because everyone could just set their IDE to do whatever they liked best.

--
Brent Royal-Gordon
Architechies


From me at alexkolov.com  Sat Dec  5 15:13:56 2015
From: me at alexkolov.com (Alexander Kolov)
Date: Sat, 5 Dec 2015 22:13:56 +0100
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
<CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com>
<DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com>
Message-ID: <87E6ED33-E2D8-42CB-A999-14285D96AA40@alexkolov.com>

I agree we need as minimal interface in the core library as possible while allowing application to take over whole logging configuration process.
Specific formatters, handlers and such will have to be implemented as external packages of course.

Sent from my iPhone

> On Dec 5, 2015, at 10:05 PM, David Waite <david at alkaline-solutions.com> wrote:
>
> I would propose the simplest interface that I can assume is available *everywhere* to be defined by the Swift standard library, so as a framework developer I can make assumptions on my ability to provide diagnostics for internals, expose information for statistical use, provide information needed for auditing usage if I’m working on a hosted service and not a GUI app, and so on.
>
> Things like custom formatters and appenders providing integration into remote/system services are something that the application can decide when it chooses a logging framework that implements the standard-defined protocol.
>
> There isn’t any sort of dependency injection/inversion of control at the core swift level, which usually means that either logging is done by global functions, or by a global factory returns an instance of some type implementing the logging protocol.
>
> The only piece of this which jumps out as not pure swift would be default integration into something like syslog or NSLog, and possibly adding a new preprocessor “macro” like __MODULE__
>
> -DW
>
>> On Dec 5, 2015, at 1:20 PM, Kevin Barrett via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> +1 to this.
>>
>> On Sat, Dec 5, 2015 at 2:24 PM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:
>>> Hi everyone,
>>>
>>> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.
>>>
>>> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
>>> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.
>>>
>>> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.
>>>
>>> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.
>>>
>>> Thanks,
>>> Alex
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/eb25f8ba/attachment.html>

From rjmccall at apple.com  Sat Dec  5 15:31:05 2015
From: rjmccall at apple.com (John McCall)
Date: Sat, 05 Dec 2015 13:31:05 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
Message-ID: <444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>

> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:
> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>
> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.

Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.

On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.

John.

>
> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>
> switch op {
> case LOAD_INDIRECT:
>    in0 = memory[in1]
>    fallthrough
> case LOAD:
>    out0 = memory[in0]
> //...
> }
>
> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>
> Cheers,
> John
>
>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>
>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>
>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>
>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>
>> John.
>>
>>>
>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>
>>> -Kevin Ballard
>>>
>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>
>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>
>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>
>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>> case .Enum1, .Enum2:
>>>>> expressed as
>>>>> case .Enum1: fallthrough
>>>>> case .Enum2:
>>>>>
>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>
>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>
>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>
>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>
>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>
>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>
>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>
>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>
>>>>>> Thoughts?
>>>>>>
>>>>>> Daniel
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/969f0364/attachment.html>

From an00na at gmail.com  Sat Dec  5 15:31:34 2015
From: an00na at gmail.com (Ling Wang)
Date: Sat, 5 Dec 2015 15:31:34 -0600
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
Message-ID: <FDA512BC-9A25-4360-9BBC-718CAAC19E43@gmail.com>

+1. I filed a radar about it months ago.

> On Dec 5, 2015, at 1:24 PM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:
>
> Hi everyone,
>
> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.
>
> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.
>
> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.
>
> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.
>
> Thanks,
> Alex
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1a818c83/attachment.html>

From matthew at anandabits.com  Sat Dec  5 15:32:40 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 15:32:40 -0600
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
Message-ID: <9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>

Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.

The syntax I used is a bit different, but not too much for the default initializer case (and isn't as important as expressive power IMO).

If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.

Sent from my iPhone

On Dec 5, 2015, at 3:03 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:

>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.
>>
>> ```swift
>> struct Foo {
>>    let bar: String
>>    let baz: Int
>>
>>    init(self.bar: String = "default", counter self.baz: Int) {
>>    }
>> }
>> ```
>
> I’d like to propose an alternative approach.
>
> Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.
>
> I propose that we make it possible to explicitly ask for that default initializer:
>
>    struct Foo {
>        let bar: String
>        let baz: Int
>
>        init() {
>            bar = “default”
>            baz = 0
>        }
>
>        init default    // automatically generates init(bar: String, baz: Int)
>    }
>
> Moreover, I propose we extend this to classes:
>
>    struct Foo: Bar {
>        let bar: String
>        let baz: Int
>
>        init() {
>            bar = “default”
>            baz = 0
>        }
>
>        init default()    // automatically generates init(bar: String, baz: Int) with super.init()
>    }
>
> In a class, the “default” statement must have parens after it; these indicate the parameters to be added for the superclass initializer. If you need to super up to an initializer that takes parameters, you add the needed parameters there:
>
>    struct Foo {
>        let bar: String
>        let baz: Int
>
>        init() {
>            bar = “default”
>            baz = 0
>        }
>
>        init default(quux: Double)    // automatically generates init(quux: Double, bar: String, baz: Int) with super.init(quux: quux)
>    }
>
> If you super up to a failable initializer, of course, that will have to be “init? default(quux: Double)”.
>
> Now, one little quirk of the current system is that Swift may actually generate *two* default initializers: a parameterless initializer when all properties have default values, and a memberwise initializer which requires all values be provided. I further propose that these be unified into one default initializer by giving default values to parameters which map to properties with default values. This gives you all the parameter sets currently supported, plus a whole range in between.
>
>    struct Foo {
>        let bar: String = “default"
>        let baz: Int
>
>        init() {
>            bar = “default”
>            baz = 0
>        }
>
>        init default    // automatically generates init(bar: String = “default", baz: Int)
>    }
>
> Finally, you can continue to decorate the “init” keyword with attributes as you normally would.
>
>    public init default
>    internal init default
>    private init default
>    required init default
>    override init default
>    @objc init default
>    @objc public required init default
>
> (I don’t think convenience initializers make much sense here.)
>
> This does not, unfortunately, eliminate boilerplate in initializers which do more than just set properties. Nor does it allow you to rename parameters, as your example does with “counter”.
>
> --
> Brent Royal-Gordon
> Architechies
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From brent at architechies.com  Sat Dec  5 15:33:17 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 13:33:17 -0800
Subject: [swift-evolution] Proposal: floating point static min / max
properties
In-Reply-To: <981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com>
References: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>
<9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>
<981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com>
Message-ID: <76657877-5D42-4486-AD4B-79BFC8677941@architechies.com>

> extension Int: RangeDiscoverable {
> 	static let representableRange: Range<Int> = Int.min…Int.max
> }


There’s a problem with that:

24> Int.min...Int.max
fatal error: Range end index has no valid successor

The problem is that Int.min … Int.max is actually represented as Int.min ..< Int.max.successor(), which is obviously not going to work.

> This would require numeric types to conform to ForwardIndexType.  Integer types already conform to RandomAccessIndexType.  Floating point types do not currently conform to ForwardIndexType but could conform not just to ForwardIndexType, but also BidirectionalIndexType.

Floats don’t currently conform to the IndexType protocols because there’s no *natural* interval for them to use. nextUp/nextDown are rarely what you want in practice, while 1 breaks down at large sizes.

However, we can fix both of these issues by using ClosedInterval instead of Range. ClosedInterval requires only that the bounds be Comparable, and doesn’t try to add 1 to the end.

--
Brent Royal-Gordon
Architechies


From jtbandes at gmail.com  Sat Dec  5 15:36:28 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 13:36:28 -0800
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
<CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
<CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com>
Message-ID: <CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com>

When you use "weak self", self becomes Optional inside the closure, and
indeed it *can* become nil partway through. This is the same as __weak in
Objective-C, and there's actually a clang warning for it (search for
"repeated-use-of-weak" or see
http://devstreaming.apple.com/videos/wwdc/2013/404xbx2xvp1eaaqonr8zokm/404/404.pdf
).

That's why "guard let strongSelf = self" is important, and I think "guard
let self = self" would add value without adding confusion.

The current behavior is easily demonstrated:

import Foundation

class C {
func doStuff() {
dispatch_async(dispatch_get_global_queue(0, 0)) { [weak self] in
print("self is \(self), waiting...")
usleep(500_000)
print("self is \(self), waiting...")
usleep(500_000)
print("self is \(self)")
}
}
}

var obj: C? = C()
obj!.doStuff()

usleep(750_000)
print("main thread - releasing")
obj = nil

sleep(2)



On Sat, Dec 5, 2015 at 1:24 PM, Javier Soto <javier.api at gmail.com> wrote:

> My understanding was that [weak variable] behaved that way in Swift
> already (but now I'm not certain and can't find a definitive answer on the
> book), creating a strong reference. Otherwise this turns into inconsistent
> behavior, where the variable could deallocate and become nil at any point
> inside the closure.
>
> Those semantics are also important in a case with a closure within a
> closure:
>
> function1(){ [weak self] in
> function2() {
> // the value (If present) inside Optional<Self> is a strong reference here
> }
> }
> On Sat, Dec 5, 2015 at 11:22 AM Jacob Bandes-Storch via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> Another approach would be to simply allow
>>
>> guard let self = self else { return }
>> On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com> wrote:
>>
>>> Hi all,
>>>
>>> let’s say we have a completion handler closure for some function
>>> (networking, …) and we have [weak self] there. Example …
>>>
>>> doSomething() { [weak self] result in
>>>   …
>>> }
>>>
>>> … then we can use self?.whatever to access self properties, methods. Or
>>> we can try to check if self exists ...
>>>
>>> guard let strongSelf = self else { return }
>>>
>>> … and use strongSelf.
>>>
>>> Can we introduce [weakStrong self] with following behavior:
>>>
>>>  - self is a weak reference
>>>  - when the closure is going to be executed, all weakStrong weak
>>> references are checked if they do exist
>>>  - if they do exist, they’re strong referenced for the closure and the
>>> closure is executed
>>>  - if they don’t exist, closure is not executed
>>>
>>> doSomething() { [weakStrong self] result in
>>>   // Closure code is not executed if self no longer exists
>>>   // self is a strong reference now
>>> }
>>>
>>> What do you think? Does it make sense?
>>>
>>> My motivation is to get rid off of the repetitive code like this one:
>>>
>>> doSomething() { [weak self] result in
>>>   guard let strongSelf = self else { return }
>>>   strongSelf.doSomethingWithResult(result)
>>> }
>>>
>>> Robert
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
> --
> Javier Soto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ae0b1418/attachment.html>

From phabouzit at apple.com  Sat Dec  5 15:39:03 2015
From: phabouzit at apple.com (Pierre Habouzit)
Date: Sat, 05 Dec 2015 13:39:03 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: add `noescape`
attribute to public API (particularly libdispatch)
In-Reply-To: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
References: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
Message-ID: <E361A2D0-CD93-4AF9-BCBD-FBD4312E43D7@apple.com>


> On Dec 5, 2015, at 12:53 PM, Jacob Bandes-Storch via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:
>
> There are several functions in public API, such as dispatch_sync and dispatch_apply, which do not allow their block parameters to escape the function call.
>
> However, they are not currently exposed to Swift as @noescape, meaning that users are required to specify "self." or "[weak self]" in their closures.
>
> The instances I can think of:
>
> - dispatch_sync
> - dispatch_barrier_sync
> - dispatch_apply
> - dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)

I also pointed out dispatch_once(), which even it doesn’t make sense for swift where the globals already have the proper semantics, is still useful as the compiler can still implement various optimizations in how the block captures its variables (it is okay to use the things where they are on the stack as opposed to have to create a real state for the block).

> I provided a preliminary implementation at https://github.com/apple/swift-corelibs-libdispatch/pull/6 <https://github.com/apple/swift-corelibs-libdispatch/pull/6>, but it needs refinement. Tony Parker mentioned commented that there might be similar changes to make for the swift-corelibs-foundation project.
>
> Thoughts?
>
> Question: does __attribute__((noescape)) have the same meaning when applied to C function pointers? Namely, does Swift understand @noescape as it applies to @convention(c)?
>
> Jacob Bandes-Storch
>  _______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b39520e4/attachment.html>

From anthony.parker at apple.com  Sat Dec  5 15:40:17 2015
From: anthony.parker at apple.com (Tony Parker)
Date: Sat, 05 Dec 2015 13:40:17 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: add `noescape`
attribute to public	API (particularly libdispatch)
In-Reply-To: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
References: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
Message-ID: <E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>

Hi Jacob,

Thanks for bringing the discussion on this topic here.

One topic I wanted to discuss was finding a comprehensive list of API that needs the attribute. The next step after that is figuring out how to get this attribute to be consistent across Darwin and Swift open source.

One option was to use the API notes feature of the compiler to annotate these APIs as part of the import into Swift. Another is to get the C headers changed (on Darwin too) to add the attribute. We may want to do one approach in the short term and another in the long term.

- Tony

> On Dec 5, 2015, at 12:53 PM, Jacob Bandes-Storch via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:
>
> There are several functions in public API, such as dispatch_sync and dispatch_apply, which do not allow their block parameters to escape the function call.
>
> However, they are not currently exposed to Swift as @noescape, meaning that users are required to specify "self." or "[weak self]" in their closures.
>
> The instances I can think of:
>
> - dispatch_sync
> - dispatch_barrier_sync
> - dispatch_apply
> - dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)
>
> I provided a preliminary implementation at https://github.com/apple/swift-corelibs-libdispatch/pull/6 <https://github.com/apple/swift-corelibs-libdispatch/pull/6>, but it needs refinement. Tony Parker mentioned commented that there might be similar changes to make for the swift-corelibs-foundation project.
>
> Thoughts?
>
> Question: does __attribute__((noescape)) have the same meaning when applied to C function pointers? Namely, does Swift understand @noescape as it applies to @convention(c)?
>
> Jacob Bandes-Storch
>  _______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/3caa81b1/attachment.html>

From jtbandes at gmail.com  Sat Dec  5 15:44:33 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 13:44:33 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: add `noescape`
attribute to public API (particularly libdispatch)
In-Reply-To: <E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>
References: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
<E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>
Message-ID: <CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com>

>
> One option was to use the API notes feature of the compiler to annotate
> these APIs as part of the import into Swift. Another is to get the C
> headers changed (on Darwin too) to add the attribute. We may want to do one
> approach in the short term and another in the long term.
>

I've been operating under the assumption that __attribute__((noescape))
will eventually be deeply understood by clang, and allow the same elision
of "self" in Objective-C that @noescape does in Swift. (I filed
<rdar://19914650> for this some time ago.)

Thus, I think it makes the most sense to change the C headers.

However, if swift-corelibs-libdispatch isn't going to affect the Swift
versions that ship with Xcode in the near future, then I guess amending the
API notes is a good idea, so the @noescape versions can get into
developers' hands as soon as possible.

Jacob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/8598f3cf/attachment.html>

From rjmccall at apple.com  Sat Dec  5 15:45:33 2015
From: rjmccall at apple.com (John McCall)
Date: Sat, 05 Dec 2015 13:45:33 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
Message-ID: <EF1675F6-7918-4262-B535-696104BFC405@apple.com>

> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>
>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>
> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>
> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.

Oh, I see that Joe already brought this up, spelled “reswitch”.

John.

>
> John.
>
>>
>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>
>> switch op {
>> case LOAD_INDIRECT:
>>    in0 = memory[in1]
>>    fallthrough
>> case LOAD:
>>    out0 = memory[in0]
>> //...
>> }
>>
>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>
>> Cheers,
>> John
>>
>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>
>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>
>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>
>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>
>>> John.
>>>
>>>>
>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>
>>>> -Kevin Ballard
>>>>
>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>
>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>
>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>
>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>> case .Enum1, .Enum2:
>>>>>> expressed as
>>>>>> case .Enum1: fallthrough
>>>>>> case .Enum2:
>>>>>>
>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>
>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>
>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>
>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>
>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>
>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>
>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>
>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>
>>>>>>> Thoughts?
>>>>>>>
>>>>>>> Daniel
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d6649022/attachment.html>

From phabouzit at apple.com  Sat Dec  5 15:50:07 2015
From: phabouzit at apple.com (Pierre Habouzit)
Date: Sat, 05 Dec 2015 13:50:07 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: add `noescape`
attribute to public API (particularly libdispatch)
In-Reply-To: <CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com>
References: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
<E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>
<CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com>
Message-ID: <5585D80C-4127-4FD2-B405-F135400D823C@apple.com>

> On Dec 5, 2015, at 1:44 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:
>
> One option was to use the API notes feature of the compiler to annotate these APIs as part of the import into Swift. Another is to get the C headers changed (on Darwin too) to add the attribute. We may want to do one approach in the short term and another in the long term.
>
> I've been operating under the assumption that __attribute__((noescape)) will eventually be deeply understood by clang, and allow the same elision of "self" in Objective-C that @noescape does in Swift. (I filed <rdar://19914650> for this some time ago.)
>
> Thus, I think it makes the most sense to change the C headers.

I completely agree with that statement, and I think that this change should make it into Darwin and swift-corelibs-libdispatch both.

-Pierre

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7b5665e2/attachment.html>

From jtbandes at gmail.com  Sat Dec  5 15:56:51 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 13:56:51 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: add `noescape`
attribute to public API (particularly libdispatch)
In-Reply-To: <5585D80C-4127-4FD2-B405-F135400D823C@apple.com>
References: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
<E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>
<CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com>
<5585D80C-4127-4FD2-B405-F135400D823C@apple.com>
Message-ID: <CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com>

On Sat, Dec 5, 2015 at 1:50 PM, Pierre Habouzit <phabouzit at apple.com> wrote:
>
>
> I completely agree with that statement, and I think that this change
> should make it into Darwin and swift-corelibs-libdispatch both.
>
> -Pierre
>

Pardon my ignorance, but what is intended to be the difference between the
two? Will they diverge?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/dec69ae6/attachment.html>

From javier.api at gmail.com  Sat Dec  5 15:24:50 2015
From: javier.api at gmail.com (Javier Soto)
Date: Sat, 05 Dec 2015 21:24:50 +0000
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
<CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
Message-ID: <CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com>

My understanding was that [weak variable] behaved that way in Swift already
(but now I'm not certain and can't find a definitive answer on the book),
creating a strong reference. Otherwise this turns into inconsistent
behavior, where the variable could deallocate and become nil at any point
inside the closure.

Those semantics are also important in a case with a closure within a
closure:

function1(){ [weak self] in
function2() {
// the value (If present) inside Optional<Self> is a strong reference here
}
}
On Sat, Dec 5, 2015 at 11:22 AM Jacob Bandes-Storch via swift-evolution <
swift-evolution at swift.org> wrote:

> Another approach would be to simply allow
>
> guard let self = self else { return }
> On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com> wrote:
>
>> Hi all,
>>
>> let’s say we have a completion handler closure for some function
>> (networking, …) and we have [weak self] there. Example …
>>
>> doSomething() { [weak self] result in
>>   …
>> }
>>
>> … then we can use self?.whatever to access self properties, methods. Or
>> we can try to check if self exists ...
>>
>> guard let strongSelf = self else { return }
>>
>> … and use strongSelf.
>>
>> Can we introduce [weakStrong self] with following behavior:
>>
>>  - self is a weak reference
>>  - when the closure is going to be executed, all weakStrong weak
>> references are checked if they do exist
>>  - if they do exist, they’re strong referenced for the closure and the
>> closure is executed
>>  - if they don’t exist, closure is not executed
>>
>> doSomething() { [weakStrong self] result in
>>   // Closure code is not executed if self no longer exists
>>   // self is a strong reference now
>> }
>>
>> What do you think? Does it make sense?
>>
>> My motivation is to get rid off of the repetitive code like this one:
>>
>> doSomething() { [weak self] result in
>>   guard let strongSelf = self else { return }
>>   strongSelf.doSomethingWithResult(result)
>> }
>>
>> Robert
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
--
Javier Soto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/e452bd29/attachment.html>

From jtbandes at gmail.com  Sat Dec  5 16:25:43 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 14:25:43 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: add `noescape`
attribute to public API (particularly libdispatch)
In-Reply-To: <E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>
References: <CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com>
<E5B092E4-2635-4217-8946-7A374CD29F53@apple.com>
Message-ID: <CADcs6kP_v1E6FFwvrho4GsZQYqFhPu2ASKFVSXfpJYKbQQqYug@mail.gmail.com>

On Sat, Dec 5, 2015 at 1:40 PM, Tony Parker <anthony.parker at apple.com>
wrote:

> One topic I wanted to discuss was finding a comprehensive list of API that
> needs the attribute.
>

On this subject, here are some other APIs which could use the annotation.
Again, I think these should be annotated even in the C/Objective-C headers,
so they can benefit C/Objective-C callers as well.

- bsearch, heapsort, qsort, mergesort, psort, and their _b variants

"passing test" methods:
- -[{NSArray,NSOrderedSet} indexOfObjectPassingTest:]
- -[{NSArray,NSOrderedSet} indexesOfObjectsPassingTest:]
- -[{NSArray,NSOrderedSet} indexOfObjectsAtIndexes:passingTest:]
- -[{NSArray,NSOrderedSet} indexesOfObjectsAtIndexes:passingTest:]
- -[SCNNode childNodesPassingTest:]
- -[SCNSceneSource entriesPassingTest:]
- -[AVAudioUnitComponentManager componentsPassingTest:]
- -[NSIndexSet indexPassingTest:]
- -[NSIndexSet indexWithOptions:passingTest:]
- -[NSIndexSet indexesPassingTest:]
- -[NSIndexSet indexesWithOptions:passingTest:]
- -[NSIndexSet indexInRange:options:passingTest:]
- -[NSIndexSet indexesInRange:options:passingTest:]
- -[NSSet objectsPassingTest:]
- -[NSSet objectsWithOptions:passingTest:]
- -[NSDictionary keysOfEntriesPassingTest:]
- -[NSDictionary keysOfEntriesWithOptions:passingTest:]

"using comparator" methods:
- -[NSArray indexOfObject:inSortedRange:options:usingComparator:]
- -[NSArray sortedArrayUsingComparator:]
- -[NSArray sortedArrayWithOptions:usingComparator:]
- -[NSDictionary keysSortedByValueUsingComparator:]
- -[NSDictionary keysSortedByValueWithOptions:usingComparator:]
- -[NSMutableArray sortUsingComparator:]
- -[NSMutableArray sortWithOptions:usingComparator:]
- -[NSMutableOrderedSet sortWithOptions:usingComparator:]
- -[NSMutableOrderedSet sortRange:options:usingComparator:]

(and some of these have "usingFunction" variants)

"enumerate using block" methods:
- -[NSTableView enumerateAvailableRowViewsUsingBlock:]
- -[SKPhysicsWorld enumerateBodiesAtPoint:usingBlock:]
- -[SKPhysicsWorld enumerateBodiesInRect:usingBlock:]
- -[NSData enumerateByteRangesUsingBlock:]
- -[SCNNode enumerateChildNodesUsingBlock:]
- -[SCNNode enumerateChildNodesWithName:usingBlock:]
- -[NSIndexSet enumerateIndexesUsingBlock:]
- -[NSIndexSet enumerateIndexesWithOptions:usingBlock:]
- -[NSDictionary enumerateKeysAndObjectsUsingBlock:]
- -[NSDictionary enumerateKeysAndObjectsWithOptions:usingBlock:]
- -[NSString enumerateLinesUsingBlock:]
- -[NSString enumerateSubstringsInRange:options:usingBlock:]
- -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsUsingBlock:]
- -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsWithOptions:usingBlock:]
- -[NSIndexSet enumerateRangesUsingBlock:]
- -[NSIndexSet enumerateRangesWithOptions:usingBlock:]
- -[NSIndexSet enumerateRangesInRange:options:usingBlock:]
- -[MPMediaEntity enumerateValuesForProperties:usingBlock:]
- -[NSMetadataQuery enumerateResultsUsingBlock:]
- -[NSMetadataQuery enumerateResultsWithOptions:usingBlock:]

misc:
- -[NSDocument performSynchronousFileAccessUsingBlock:]

Wow, that's more than I expected to find! This is obviously beyond the
scope of just libdispatch, and I think a lot of these should probably
change upstream, in their original frameworks, internally (not something
that community members can really contribute to).

Arguably, the "enumerateXUsingBlock:" pattern should be bridged to Swift as
something SequenceType-ish which can be `for-in`ed.

Jacob Bandes-Storch
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/6f83b5e9/attachment.html>

From brent at architechies.com  Sat Dec  5 16:31:11 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 14:31:11 -0800
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
Message-ID: <63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>

> Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.

I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.

It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:

class Player {
var name: String
private(set) var points: Int

func addPoints(additionalPoints: Int) {
points += additionalPoints
}

// Creates init(name: String, score: Int)
init default()
}

Later, I decide to add syncing, and realize I need to change this model. I need to add a sync identifier, and I want to change `points` to be computed from a series of `PointChange` objects. (This is a common strategy to avoid sync conflicts.) However, I don’t want to disrupt any of my existing code when I do this.

class Player {
let syncIdentifier = NSUUID()
var name: String
private var pointChanges: Set<PointChange>

var points: Int {
get { return pointChanges.reduce(0, combine: +) }
}

func addPoints(additionalPoints: Int) {
pointChanges.insert(PointChange(offset: additionalPoints)
}

// We can no longer use init default(), but we can still create an initializer with the same signature
init(name: String, points: Int) {
self.name = name
pointChanges = [ PointChange(offset: score) ]
}
}

By *not* separating the properties into a different syntactical construct from the constructor parameters, I can update my type’s implementation without affecting its interface. If properties were separated syntactically from constructor parameters as you proposed, it would not be possible to change this seamlessly.

> If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.

Honestly, I would like to fix the boilerplate issue in more sophisticated initializers, but I don’t see a clean way to do that. The other proposals I’ve seen in this thread, along the lines of:

init(self.name, self.points) {}

Frankly do too much violence to the parameter list. Swift’s declarations have a lovely feature where the declaration basically looks like the usage, except that the concrete values in the usage are replaced by types in the declaration. These proposals destroy that property—when I look at the declaration, I can no longer envision what the call site will look like.

Basically, I focused on default initializers because they’re *really* easy to solve and cover a good portion of the common case. I really have no idea how to solve the larger problem, and I haven’t liked any of the other ideas in this thread, but I do know how to solve this more limited problem.

--
Brent Royal-Gordon
Architechies


From jhull at gbis.com  Sat Dec  5 17:09:38 2015
From: jhull at gbis.com (Jonathan Hull)
Date: Sat, 5 Dec 2015 15:09:38 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <C1A6C9E6-16CD-42EC-8301-6B8DC6042A3A@gmail.com>
References: <C1A6C9E6-16CD-42EC-8301-6B8DC6042A3A@gmail.com>
Message-ID: <4EBF960E-9FC8-4947-A9D7-3B6EEA864614@gbis.com>

Hmm… that is really interesting.  I wonder if we can use optionals to make this work in an elegant way.

Forget about else for a second.  What if there is an operation which says, this is either this value or nil based on whether it meets a condition?  Then else (and else if) can be handled by a combination of that operation and the nil-coelecing operator.

I once wrote a small DSL which had this behavior and it was really nice.

What about something like:

let x = value if? condition

x would have value if condition evaluates to true, or it would be nil. If I wanted an else statement:

let x = value if? condition ?? otherValue

Now it works just like the ternary operator, but is IMHO more readable.  Note: these can also be chained to give you else if style behavior:

let x = value if? condition ?? otherValue if? otherCondition ?? evenMoreValue

You could optionally (ha!) put things in parentheses as well, which I always end up doing with the ternary:

let x = (value if? condition) ?? (otherValue if? otherCondition) ?? evenMoreValue


Not a 100% there yet, but I do think it is a good start at something more elegant…

Thanks,
Jon



> On Dec 5, 2015, at 10:29 AM, possen p <possen at gmail.com> wrote:
>
> The current ternary operator, for this example:
>
> let val = p == 5 ? 10 : 40
>
> Which I have always thought was hard to read but I do like the functionality it provides. That is, in one expression you can compactly get two different values based upon a condition. Swift seems to have adopted the C style ternary operators probably to not completly change everytihg. Similar to the drop of the ++ and -- operator I am proposing that there is to replace the ternary operator to improve readability but continue to provide that functionality.
>
> Recommendation: most readable but changes rules about if-else always having braces and puts the “if” at end. It is only a little bit longer than the original. I think it is clearer to have the conditional at the end so the assignment part is where the variable is assigned. This also does not introduce new keywords or operators.
>
> let val = 10 else 40 if p == 5
>
> In looking at the Nil-Coalescing operator there is a similar idea but it is really not the same. In that the left hand side of the ?? operator returns itself when non nil, and the behavior of the ternary operator is different. It is also harder to read.
>
> let val = 10 ?? 40 if p = 5
>
> I also considered a bunch of other possibilities like using “where" or “when" instead of “if”, the python of putting conditional in the middle or the ruby style of “if" returning a value but did not like those.
>
> // python style
> let  val = 10 if p == 5 else 40
>
> // ruby style
> let val = if p == 5 then 10 else 40
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b963b936/attachment.html>

From ole at oleb.net  Sat Dec  5 17:12:44 2015
From: ole at oleb.net (Ole Begemann)
Date: Sun, 6 Dec 2015 00:12:44 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
Message-ID: <909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>

>> This is subtle and requires thought
>
> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.

One thing that comes to mind is that if "if" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:

func doSomething() { ... }

if condition {
doSomething()
}

Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical "imperative" code harder.

– Ole

From scanon at apple.com  Sat Dec  5 17:23:28 2015
From: scanon at apple.com (Steve Canon)
Date: Sat, 05 Dec 2015 18:23:28 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <EF1675F6-7918-4262-B535-696104BFC405@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
Message-ID: <CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>

Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".

I very much like specifying what case to fall through into, no matter how we spell it.

- Steve

> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>
>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:
>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>
>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>
>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>
>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>
> Oh, I see that Joe already brought this up, spelled “reswitch”.
>
> John.
>
>>
>> John.
>>
>>>
>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>
>>> switch op {
>>> case LOAD_INDIRECT:
>>>    in0 = memory[in1]
>>>    fallthrough
>>> case LOAD:
>>>    out0 = memory[in0]
>>> //...
>>> }
>>>
>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>
>>> Cheers,
>>> John
>>>
>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:
>>>>>
>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>
>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>
>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>
>>>> John.
>>>>
>>>>>
>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>
>>>>> -Kevin Ballard
>>>>>
>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>
>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>
>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>
>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for "fallthrough language:swift".
>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>> case .Enum1, .Enum2:
>>>>>>> expressed as
>>>>>>> case .Enum1: fallthrough
>>>>>>> case .Enum2:
>>>>>>>
>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
>>>>>>>>
>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>
>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>
>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>
>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>
>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>
>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>
>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>
>>>>>>>> Thoughts?
>>>>>>>>
>>>>>>>> Daniel
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9f7f5c97/attachment.html>

From jhull at gbis.com  Sat Dec  5 17:28:21 2015
From: jhull at gbis.com (Jonathan Hull)
Date: Sat, 5 Dec 2015 15:28:21 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
Message-ID: <852EF944-A503-4021-8A7F-AE6876438981@gbis.com>

I think I have a solution for the ternary part, but I am not sure I fully understand what is being asked for in the case of switch.  Could someone clarify?

There is another thread which goes into the idea a little more, but the basic idea is that we replace the ternary operator with ‘if?'

let x = value if? condition


If condition is true, then x is value… otherwise it is nil.  You can combine with the nil-coalescing operator to get else and else if style behavior:

let x = valueA if? conditionA ?? valueB if? conditionB ?? valueC


Thanks,
Jon


> On Dec 5, 2015, at 9:09 AM, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>
>> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy.
>>
>> Some interesting code in the standard library that uses the ternary operator quite a bit.
>>
>> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357>
>
> FWIW, I have no love for the ternary operator (it is totally "bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.
>
> If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.
>
> -Chris
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f2dbfff0/attachment.html>

From christopheramanse at gmail.com  Sat Dec  5 17:36:52 2015
From: christopheramanse at gmail.com (Chris Amanse)
Date: Sat, 05 Dec 2015 23:36:52 +0000
Subject: [swift-evolution] Proposal: Conforming NSDate to Comparable
Message-ID: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>

Hello Swift Developers,

I think it's a good idea to conform NSDate to the Comparable protocol, so
instead of using:

if someDate.compare(today) == .OrderedAscending { }

Developers can easily compare using compare dates using comparison
operators:

if someDate < today { }

In my opinion, the code is still readable if developers use comparison
operators on NSDates.

Here's a quick implementation from my swift-corelibs-foundation fork:
https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916

Thank you.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/115e5fd7/attachment.html>

From adrian.kashivskyy at me.com  Sat Dec  5 17:42:36 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sun, 06 Dec 2015 00:42:36 +0100
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
<E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
<49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
<63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com>
Message-ID: <26C0DF64-7EE4-4F56-BC99-2C8EAF9D8781@me.com>

How would you do code review then? ;)

Regards,
Adrian Kashivskyy
iOS Developer at Netguru

> Wiadomość napisana przez Brent Royal-Gordon <brent at architechies.com> w dniu 05.12.2015, o godz. 22:10:
>
>>>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.
>>>
>>> That's a feature of IDE, not the language itself.
>>
>> Not necessarily. The existence of "go fmt" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments.
>>
>> Letting "the IDE" do formatting is fine provided there is a maximum of one IDE.
>
> This is perhaps out of scope for this group, but I’ve actually long wanted languages to move in a direction where indentation is not present at all in the source file—your git repo might never have an instance of /\n[ \t]/ in it. Instead, it’s automatically added by the IDE while displaying the code, based on the block beginnings and endings present in the actual source. This would make incorrectly indented code a thing of the past; it would also be obvious when you’re missing a curly bracket, because your code would be indented all wrong. And it would end the destructive whitespace wars, because everyone could just set their IDE to do whatever they liked best.
>
> --
> Brent Royal-Gordon
> Architechies
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/869e05fb/attachment.html>

From adrian.kashivskyy at me.com  Sat Dec  5 17:50:22 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sun, 06 Dec 2015 00:50:22 +0100
Subject: [swift-evolution] A mode with no type checking to compete
with	Python.
In-Reply-To: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
Message-ID: <7240610C-B5DA-41B8-909A-D138404C6799@me.com>

I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...

Regards,
Adrian Kashivskyy
iOS Developer at Netguru

> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:
>
> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/6828fc24/attachment.html>

From brent at architechies.com  Sat Dec  5 17:51:48 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 15:51:48 -0800
Subject: [swift-evolution] Proposal: Conforming NSDate to Comparable
In-Reply-To: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
Message-ID: <97EB190C-895B-4698-A93E-C1050B92520B@architechies.com>

> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:
>
> if someDate.compare(today) == .OrderedAscending { }
>
> Developers can easily compare using compare dates using comparison operators:
>
> if someDate < today { }

I would also suggest we add Strideable, which would allow you to add and subtract NSTimeIntervals, plus subtract two NSDates to get the NSTimeInterval between them.

https://gist.github.com/brentdax/11b3275424d0833cfd99

--
Brent Royal-Gordon
Architechies


From a.michail at me.com  Sat Dec  5 17:55:30 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 18:55:30 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <7240610C-B5DA-41B8-909A-D138404C6799@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
Message-ID: <F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com>


> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:
>
> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>

Doesn’t Apple want to teach young people programming as one of its goals? If so, having a mode without type safety would be ideal for that.

> Regards,
> Adrian Kashivskyy
> iOS Developer at Netguru
>
>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>
>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/2b01c581/attachment.html>

From ndevries at apple.com  Sat Dec  5 18:00:38 2015
From: ndevries at apple.com (Nathan de Vries)
Date: Sat, 05 Dec 2015 16:00:38 -0800
Subject: [swift-evolution] Proposal: Allow willChange and didChange
observers on a property
Message-ID: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>

It's currently possible to define either or both of the following observers on a property:
willSet, called just before the value is stored
didSet, called immediately after the new value is stored
I'm finding myself using didSet extensively, but almost always guard my didSet with a clause to see if the value has changed:

class CustomView : UIView {
var state : CustomViewState = false {
didSet {
guard state != oldValue else { return }
// Act on the new state.
}
}
}

Given the frequency of use, it would be great if I could strip this boilerplate altogether and simply rewrite this as:

class CustomView : UIView {
var state : CustomViewState = false {
didChange {
// Act on the new state.
}
}
}

Property types conforming to Equatable would be checked for the implicit guard via ==, otherwise it would fall back on the identity operator (===) for value and reference types that don't conform to Equatable.

This would mean the following observers could be defined on a property:
willSet, called just before the value is stored
willChange, called just before the value is stored if the value is different to the previous value
didSet, called immediately after the new value is stored
didChange, called immediately after the new value is stored if the new value is different to the previous value
—Nathan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/43eb21ce/attachment.html>

From kevin at klundberg.com  Sat Dec  5 18:01:59 2015
From: kevin at klundberg.com (Kevin Lundberg)
Date: Sat, 5 Dec 2015 19:01:59 -0500
Subject: [swift-evolution] A mode with no type checking to compete
with	Python.
In-Reply-To: <7240610C-B5DA-41B8-909A-D138404C6799@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
Message-ID: <0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>

This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.

Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.

--
Kevin Lundberg

> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org> wrote:
>
> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>
> Regards,
> Adrian Kashivskyy
> iOS Developer at Netguru
>
>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:
>>
>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/8aec4112/attachment-0001.html>

From a.michail at me.com  Sat Dec  5 18:05:14 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 19:05:14 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
Message-ID: <8E150B28-BDE3-4289-8515-3110150B269C@me.com>


> On Dec 5, 2015, at 7:01 PM, Kevin Lundberg <kevin at klundberg.com> wrote:
>
> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>
> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>

Apple need not accept apps written in this mode for the App Store. But it would be great for educational purposes.

> --
> Kevin Lundberg
>
> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>
>> Regards,
>> Adrian Kashivskyy
>> iOS Developer at Netguru
>>
>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>
>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0c335969/attachment.html>

From brent at architechies.com  Sat Dec  5 18:05:23 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 16:05:23 -0800
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com>
Message-ID: <F648DD81-C548-4B5A-BF45-890CA34B71FE@architechies.com>

> Doesn’t Apple want to teach young people programming as one of its goals? If so, having a mode without type safety would be ideal for that.

Frankly, I can’t even imagine what Swift would look or act like without its type system. Would overloading work? What would happen if you added a String and an Int? What if you called a method that didn’t exist? Is it really better for learning to half-run the code and then crash instead of pointing out the mistake up front? Couldn’t you simulate half-running anyway by replacing syntax errors with `fatalError(“compiler error goes here”)` and running the code?

--
Brent Royal-Gordon
Architechies


From austinzheng at gmail.com  Sat Dec  5 18:05:31 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Sat, 5 Dec 2015 16:05:31 -0800
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
Message-ID: <E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>

I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.

Austin

> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>
> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>
> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>
> --
> Kevin Lundberg
>
> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>
>> Regards,
>> Adrian Kashivskyy
>> iOS Developer at Netguru
>>
>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>
>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/e751702e/attachment.html>

From a.michail at me.com  Sat Dec  5 18:09:31 2015
From: a.michail at me.com (Amir Michail)
Date: Sat, 05 Dec 2015 19:09:31 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
Message-ID: <7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>


> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:
>
> ml>
> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.

Don’t you think that Python currently provides a better introduction to programming due to its simplicity?

>
> Austin
>
>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>>
>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>>
>> --
>> Kevin Lundberg
>>
>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>>
>>> Regards,
>>> Adrian Kashivskyy
>>> iOS Developer at Netguru
>>>
>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>>
>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> --rbÚḟîẁ
> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/ma

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c55a131a/attachment.html>

From alexl.mail+swift at gmail.com  Sat Dec  5 18:12:49 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sat, 5 Dec 2015 19:12:49 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <852EF944-A503-4021-8A7F-AE6876438981@gbis.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<852EF944-A503-4021-8A7F-AE6876438981@gbis.com>
Message-ID: <CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com>

I believe the idea with switch is that it would be nice to be able to do
something like

// make sure we have different favorite colors
let myFavoriteColor =
switch yourFavoriteColor {
case .Red:
return .Blue
case .Green:
return .Red
case .Blue:
return .Green
}

This is useful and exists in other functional languages. For example, ML
has “case … of …”, Coq has “match…with…end”, etc.

This is similar to what you are proposing with if:

let x = if (condition) { return value } else { return otherValue }

because in both cases you are taking what is currently a statement in Swift
and enabling it to be used as an expression. (Of course, the syntax would
ideally be nicer — maybe we limit each case’s body to be a single
expression and get rid of the return keyword, for example.) Worth noting
that in both cases, the type-checker needs to ensure that the type of each
result is the same.

The semantics of what you’re now proposing — an if? binary operator that
evaluates a condition then evaluates to either nil (if false) or some value
(if true) — is slightly different. I’m not sure I love it — the general use
case would be something like “if __ then ___ else ___” and I don’t think it
reads that way. It also doesn’t allow for pattern matching (though to be
fair, neither does the ternary operator) — it could be cool to see
something like

let greeting = “Hello, \(name),” if let name = optionalName else “To Whom
It May Concern:”

-Alex

On Sat, Dec 5, 2015 at 6:28 PM, Jonathan Hull via swift-evolution <
swift-evolution at swift.org> wrote:

> I think I have a solution for the ternary part, but I am not sure I fully
> understand what is being asked for in the case of switch.  Could someone
> clarify?
>
> There is another thread which goes into the idea a little more, but the
> basic idea is that we replace the ternary operator with ‘if?'
>
> let x = value if? condition
>
>
> If condition is true, then x is value… otherwise it is nil.  You can
> combine with the nil-coalescing operator to get else and else if style
> behavior:
>
> let x = valueA if? conditionA ?? valueB if? conditionB ?? valueC
>
>
> Thanks,
> Jon
>
>
> On Dec 5, 2015, at 9:09 AM, Chris Lattner < clattner at apple.com> wrote:
>
>
> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez < cheyo at masters3d.com>
> wrote:
>
> I'd like some feedback from the core team to see if eliminating
> the ternary operator and replacing it with if-else is even proposal
> worthy.
>
> Some interesting code in the standard library that uses the ternary
> operator quite a bit.
>
> https://gist.github.com/masters3d/7b0c6f3653368afe4357
>
>
> FWIW, I have no love for the ternary operator (it is totally "bizarre C
> magic”), but it does solve a problem that Swift currently otherwise has no
> solution for.
>
> If you’re interested in pursuing this, then the right path forward is to
> build a holistic proposal to turn statements (like if and switch) into
> expressions.  This is subtle and requires thought, but is widely desired
> and if someone were interested in driving the design and implementation,
> then I’d be interested to see it happen.
>
> -Chris
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ca3a3a96/attachment.html>

From manav1907 at gmail.com  Sat Dec  5 18:13:50 2015
From: manav1907 at gmail.com (Manav Gabhawala)
Date: Sat, 5 Dec 2015 19:13:50 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
<7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
Message-ID: <etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local>

On December 5, 2015 at 7:09:51 PM, Amir Michail via swift-evolution (swift-evolution at swift.org) wrote:

On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:

ml>
I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.

Don’t you think that Python currently provides a better introduction to programming due to its simplicity?
I disagree. The only reason people think Python is a simpler introduction language is because so far Swift has only been used to teach iOS and OS X programming never as a programming language in itself. And if you decide to introduce someone to programming and have them jump into iOS or OS X programming they have to learn a new way of thinking (programming) as well as all the underlying complexities of building an app like the view controller lifecycle, run loops, target action, MVC, etc. If swift were taught as a pure programming language I think it would serve as a far superior introduction to programming than Python, or any other programming language that currently exists for that matter.




Austin

On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:

This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.

Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.

--
Kevin Lundberg

On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org> wrote:

I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...

Regards,
Adrian Kashivskyy
iOS Developer at Netguru

Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:

Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution




_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution

_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution


--rbÚḟîẁ
íz{CÊhĠ+bḃx§)Ŷ_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/ma

 _______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/89ff1ef6/attachment.html>

From austinzheng at gmail.com  Sat Dec  5 18:13:59 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Sat, 5 Dec 2015 16:13:59 -0800
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
<7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
Message-ID: <B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>

No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.

Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.

Austin

> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com> wrote:
>
>
>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> ml>
>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.
>
> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?
>
>>
>> Austin
>>
>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>>>
>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>>>
>>> --
>>> Kevin Lundberg
>>>
>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>>>
>>>> Regards,
>>>> Adrian Kashivskyy
>>>> iOS Developer at Netguru
>>>>
>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>>>
>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> --rbÚḟîẁ
>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/ma
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/45971435/attachment.html>

From ilya.nikokoshev at gmail.com  Sat Dec  5 18:16:20 2015
From: ilya.nikokoshev at gmail.com (ilya)
Date: Sun, 6 Dec 2015 03:16:20 +0300
Subject: [swift-evolution] Request for Discussion: Setup closures
Message-ID: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>

> PROBLEM: With many Apple-supplied classes, typical initializers fail to
fully set up an instance for use.  Here's one example: ...

FWIW, I created a configuration operator more then a year ago, and use it
in all of my Swift projects:

let task = NSTask() +=+ {
$0.launchPath = "/usr/bin/mdfind"
$0.arguments = ["kMDItemDisplayName == *.playground"]
$0.standardOutput = pipe
}

Note you can also use the configured object in the rhs:

let questionLabel = UILabel() +=+ {
$0.textAlignment = .Center
$0.font =  UIFont(name:"DnealianManuscript", size: 72)
$0.text = currentQuestion.questionText
$0.numberOfLines = 0
view.addSubview($0)
}

This $0. certainly looks ugly and it would be great to be able to simplify
this. I don't llike the following much though (dot-syntax can be ambiguos
here, and using simply a method name is even worse):

let questionLabel = UILabel() +=+ {
.textAlignment = .Center
.font =  UIFont(name:"DnealianManuscript", size: 72)
.text = currentQuestion.questionText
.numberOfLines = 0
view.addSubview($0)
}

Actually I would be happy with something like

let questionLabel = UILabel() .{
..textAlignment = .Center
..font = UIFont(name:"DnealianManuscript", size: 72)
..text = currentQuestion.questionText
..numberOfLines = 0
view.addSubview($0)
}

Other thoughts?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4e672e3a/attachment.html>

From adam at lickel.com  Sat Dec  5 18:22:39 2015
From: adam at lickel.com (Adam C. Lickel)
Date: Sat, 5 Dec 2015 16:22:39 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
Message-ID: <0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>

In that situation, the if statement could return a Void? where the else implicitly returns nil

> On Dec 5, 2015, at 3:12 PM, Ole Begemann via swift-evolution <swift-evolution at swift.org> wrote:
>
>>> This is subtle and requires thought
>>
>> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.
>
> One thing that comes to mind is that if "if" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:
>
> func doSomething() { ... }
>
> if condition {
>    doSomething()
> }
>
> Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical "imperative" code harder.
>
> – Ole
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From ole at oleb.net  Sat Dec  5 18:24:20 2015
From: ole at oleb.net (Ole Begemann)
Date: Sun, 6 Dec 2015 01:24:20 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
Message-ID: <49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>

Yeah, returning an optional is a good idea.

> On 06 Dec 2015, at 01:22, Adam C. Lickel <adam at lickel.com> wrote:
>
> In that situation, the if statement could return a Void? where the else implicitly returns nil
>
>> On Dec 5, 2015, at 3:12 PM, Ole Begemann via swift-evolution <swift-evolution at swift.org> wrote:
>>
>>>> This is subtle and requires thought
>>>
>>> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.
>>
>> One thing that comes to mind is that if "if" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:
>>
>> func doSomething() { ... }
>>
>> if condition {
>>   doSomething()
>> }
>>
>> Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical "imperative" code harder.
>>
>> – Ole

From alexl.mail+swift at gmail.com  Sat Dec  5 18:28:10 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sat, 5 Dec 2015 19:28:10 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
Message-ID: <CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>

I don't think you can just get rid of the if statement in favor of an
expression. You still want to be able to do this:

if (condition) {
funcWithSideEffectsThatReturnsInt()
} else {
funcWithSideEffectsThatReturnsString()
}

but that's not a valid expression (what is its type?).

On Sat, Dec 5, 2015 at 7:24 PM, Ole Begemann via swift-evolution <
swift-evolution at swift.org> wrote:

> Yeah, returning an optional is a good idea.
>
> > On 06 Dec 2015, at 01:22, Adam C. Lickel <adam at lickel.com> wrote:
> >
> > In that situation, the if statement could return a Void? where the else
> implicitly returns nil
> >
> >> On Dec 5, 2015, at 3:12 PM, Ole Begemann via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>
> >>>> This is subtle and requires thought
> >>>
> >>> What do you envision as the pitfalls of the design thinking behind
> if/switch expressions? I’m not a compiler programmer, but a prog-lang
> enthusiast. I wouldn’t mind a little nudge in the right direction.
> >>
> >> One thing that comes to mind is that if "if" is an expression, every if
> needs an else branch. This makes it harder to use if to conditionally
> perform side effects. For example, this is currently valid:
> >>
> >> func doSomething() { ... }
> >>
> >> if condition {
> >>   doSomething()
> >> }
> >>
> >> Should this be allowed? You could argue that this should work because
> (a) the expression result is unused and (b) the return type of doSomething
> is Void, so the compiler could conceivably implicitly construct an else
> branch that returns (). But it would be inconsistent with other
> expressions. Disallowing this style could make writing typical "imperative"
> code harder.
> >>
> >> – Ole
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/6787eefc/attachment.html>

From ahti333 at gmail.com  Sat Dec  5 18:32:51 2015
From: ahti333 at gmail.com (Lukas Stabe)
Date: Sun, 6 Dec 2015 01:32:51 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
Message-ID: <E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com>


> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>
> if (condition) {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> but that's not a valid expression (what is its type?).

An if statement with two different types could just have the closes common ancestor or Any as type.

> Yeah, returning an optional is a good idea.

This would, interestingly, make the else statement very similar to the optional-chaining operator ?? with the small difference that the second argument is a block (and does ?? autoclosure the second arg?).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/611fa694/attachment.html>

From tomas at linhart.me  Sat Dec  5 18:34:03 2015
From: tomas at linhart.me (=?UTF-8?B?VG9tw6HFoSBMaW5oYXJ0?=)
Date: Sun, 6 Dec 2015 01:34:03 +0100
Subject: [swift-evolution] Proposal: Stored properties in extensions
Message-ID: <CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com>

Hello,

very often, it is necessary to define stored properties in extensions. It
is currently only possible in Swift that has access to ObjC runtime with
associated objects (in theory it might be possible with some global
dictionary) and it requires a lot of boilerplate. Associated objects are
used in UIKit quite heavily so it is something that authors of frameworks
need.

It would be nice to able to create properties in extensions natively in
Swift without need of Objective-C and without a boilerplate. These
properties could be marked with some extra keyword/attribute so it is
obvious they are different and they have a cost (depends on their
implementation).

What do you think?
Tomáš
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8bc02cd7/attachment.html>

From loiclecrenier at icloud.com  Sat Dec  5 18:35:49 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 01:35:49 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
Message-ID: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>

Hi everyone :)

I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.

Conceptually, I had something like this:

protocol ProtA {
typealias Container : SequenceType
}
protocol ProtB {
typealias AnOtherAssocType : ProtA
func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
}

The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:

protocol ProtB {
typealias A : ProtA
typealias Element = A.Container.Generator.Element
func foo(x: Element, y: Element) -> Element
}

But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.

So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.

Ideally, I would write

protocol ProtB {
associated_type AnOtherAssocType : ProtA
typealias Element = AnOtherAssocType.Container.Generator.Element
func foo(x: Element, y: Element) -> Element
}

and it would be exactly the same as

protocol ProtB {
associated_type AnOtherAssocType : ProtA
func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
}

There are probably some problems created by this proposal, but right now I can't see any :/

Thanks,

Loïc

From jtbandes at gmail.com  Sat Dec  5 18:44:02 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sun, 06 Dec 2015 00:44:02 +0000
Subject: [swift-evolution] Proposal: Stored properties in extensions
In-Reply-To: <CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com>
References: <CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com>
Message-ID: <CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com>

Sometimes it's desirable to break up a type's implementation into multiple
files, within the same module. So for this simple case, it make sense for
stored properties to be allowed (within the same module), treating them as
continuations of the original class/struct declaration with no additional
overhead.
On Sat, Dec 5, 2015 at 4:34 PM Tomáš Linhart <swift-evolution at swift.org>
wrote:

> Hello,
>
> very often, it is necessary to define stored properties in extensions. It
> is currently only possible in Swift that has access to ObjC runtime with
> associated objects (in theory it might be possible with some global
> dictionary) and it requires a lot of boilerplate. Associated objects are
> used in UIKit quite heavily so it is something that authors of frameworks
> need.
>
> It would be nice to able to create properties in extensions natively in
> Swift without need of Objective-C and without a boilerplate. These
> properties could be marked with some extra keyword/attribute so it is
> obvious they are different and they have a cost (depends on their
> implementation).
>
> What do you think?
> Tomáš
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/dd9928aa/attachment.html>

From rjmccall at apple.com  Sat Dec  5 18:48:16 2015
From: rjmccall at apple.com (John McCall)
Date: Sat, 05 Dec 2015 16:48:16 -0800
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
Message-ID: <80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>

> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:
> Hi everyone :)
>
> I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.
>
> Conceptually, I had something like this:
>
> protocol ProtA {
>   typealias Container : SequenceType
> }
> protocol ProtB {
>   typealias AnOtherAssocType : ProtA
>   func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
> }
>
> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:
>
> protocol ProtB {
>   typealias A : ProtA
>   typealias Element = A.Container.Generator.Element
>   func foo(x: Element, y: Element) -> Element
> }
>
> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.
>
> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.

I think this is a great idea; re-using typealias for associated types was a mistake.

John.

>
> Ideally, I would write
>
> protocol ProtB {
>   associated_type AnOtherAssocType : ProtA
>   typealias Element = AnOtherAssocType.Container.Generator.Element
>   func foo(x: Element, y: Element) -> Element
> }
>
> and it would be exactly the same as
>
> protocol ProtB {
>   associated_type AnOtherAssocType : ProtA
>   func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
> }
>
> There are probably some problems created by this proposal, but right now I can't see any :/
>
> Thanks,
>
> Loïc
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From christopheramanse at gmail.com  Sat Dec  5 18:48:30 2015
From: christopheramanse at gmail.com (Chris Amanse)
Date: Sun, 06 Dec 2015 00:48:30 +0000
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Conforming
NSDate to Comparable
In-Reply-To: <BFD76E85-4D4B-41C8-8457-4C438FBF7F8E@apple.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
<BFD76E85-4D4B-41C8-8457-4C438FBF7F8E@apple.com>
Message-ID: <CAEryqgjxxcHrPeP7rHYV--77upw_KzoiJSKQVR3K8GYeSo1FPA@mail.gmail.com>

Here's a draft of the the proposal:
https://gist.github.com/chrisamanse/2ab39e31e93d5c11d0b5

On Sun, Dec 6, 2015 at 7:52 AM Philippe Hausler <phausler at apple.com> wrote:

> In all that seems like a pretty reasonable concept. Foundation is going to
> be using the same evolution template as the rest of the Swift evolution
> process; could you fill out a draft of that and I can help campion your
> proposal to the component owner for NSDate and we can see how this will
> fair with the rest of the Darwin side of things.
>
> As you can probably guess; operators are not taken lightly since they
> exist in the global scope and it is good to consider the ramifications of
> what even something as simple as comparison of dates has in general.
>
> On Dec 5, 2015, at 3:36 PM, Chris Amanse via swift-corelibs-dev <
> swift-corelibs-dev at swift.org> wrote:
>
> Hello Swift Developers,
>
> I think it's a good idea to conform NSDate to the Comparable protocol, so
> instead of using:
>
> if someDate.compare(today) == .OrderedAscending { }
>
> Developers can easily compare using compare dates using comparison
> operators:
>
> if someDate < today { }
>
> In my opinion, the code is still readable if developers use comparison
> operators on NSDates.
>
> Here's a quick implementation from my swift-corelibs-foundation fork:
> https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916
>
> Thank you.
>
> _______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c1d48c56/attachment.html>

From kevin at klundberg.com  Sat Dec  5 19:11:42 2015
From: kevin at klundberg.com (Kevin Lundberg)
Date: Sat, 5 Dec 2015 20:11:42 -0500
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
Message-ID: <BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>

Is it possible to do away with associated types and just use plain generic type declarations instead? This is one thing that kind of confuses me about the generics system. Coming from Java and c#, interfaces there are generic in the same way that classes (and structs in c#) are, and there are a lot of nice things we could get along with that if protocols were generic as part of their type declaration. Is there a compelling (technical or otherwise) reason to keep associated types as they are (to the exclusion of generic parameters) today that I'm missing?

If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
--
Kevin Lundberg

On Dec 5, 2015, at 7:48 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:

>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:
>> Hi everyone :)
>>
>> I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.
>>
>> Conceptually, I had something like this:
>>
>> protocol ProtA {
>>  typealias Container : SequenceType
>> }
>> protocol ProtB {
>>  typealias AnOtherAssocType : ProtA
>>  func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
>> }
>>
>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:
>>
>> protocol ProtB {
>>  typealias A : ProtA
>>  typealias Element = A.Container.Generator.Element
>>  func foo(x: Element, y: Element) -> Element
>> }
>>
>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.
>>
>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.
>
> I think this is a great idea; re-using typealias for associated types was a mistake.
>
> John.
>
>>
>> Ideally, I would write
>>
>> protocol ProtB {
>>  associated_type AnOtherAssocType : ProtA
>>  typealias Element = AnOtherAssocType.Container.Generator.Element
>>  func foo(x: Element, y: Element) -> Element
>> }
>>
>> and it would be exactly the same as
>>
>> protocol ProtB {
>>  associated_type AnOtherAssocType : ProtA
>>  func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
>> }
>>
>> There are probably some problems created by this proposal, but right now I can't see any :/
>>
>> Thanks,
>>
>> Loïc
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From clattner at apple.com  Sat Dec  5 19:33:21 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 05 Dec 2015 17:33:21 -0800
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
Message-ID: <8A11B43C-8FB7-417C-B251-D63812545AE4@apple.com>

On Dec 5, 2015, at 4:48 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:

>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:
>> Hi everyone :)
>>
>> I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.
>>
>> Conceptually, I had something like this:
>>
>> protocol ProtA {
>>  typealias Container : SequenceType
>> }
>> protocol ProtB {
>>  typealias AnOtherAssocType : ProtA
>>  func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
>> }
>>
>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:
>>
>> protocol ProtB {
>>  typealias A : ProtA
>>  typealias Element = A.Container.Generator.Element
>>  func foo(x: Element, y: Element) -> Element
>> }
>>
>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.
>>
>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.
>
> I think this is a great idea; re-using typealias for associated types was a mistake.

Agreed.

-Chris




> John.
>
>>
>> Ideally, I would write
>>
>> protocol ProtB {
>>  associated_type AnOtherAssocType : ProtA
>>  typealias Element = AnOtherAssocType.Container.Generator.Element
>>  func foo(x: Element, y: Element) -> Element
>> }
>>
>> and it would be exactly the same as
>>
>> protocol ProtB {
>>  associated_type AnOtherAssocType : ProtA
>>  func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
>> }
>>
>> There are probably some problems created by this proposal, but right now I can't see any :/
>>
>> Thanks,
>>
>> Loïc
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From stephen.celis at gmail.com  Sat Dec  5 19:43:49 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Sat, 5 Dec 2015 20:43:49 -0500
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
Message-ID: <6407A281-C936-40E3-B882-1E63279F4755@gmail.com>

> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>
> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"

Or merely "associated".

From austinzheng at gmail.com  Sat Dec  5 19:46:52 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Sat, 5 Dec 2015 17:46:52 -0800
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
Message-ID: <554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>

I like "associated". Or maybe "withtype". Anything clear and without underscore.

protocol Foo {
associated T
}

protocol Foo {
withtype T
}

> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:
>
>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>
> Or merely "associated".
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From paulyoungonline at gmail.com  Sat Dec  5 20:01:11 2015
From: paulyoungonline at gmail.com (Paul Young)
Date: Sat, 05 Dec 2015 18:01:11 -0800 (PST)
Subject: [swift-evolution] Proposal: Stored properties in extensions
In-Reply-To: <CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com>
References: <CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com>
Message-ID: <1449367270928.62d8b65@Nodemailer>

There was some discussion about this recently on Twitter: https://twitter.com/jckarter/status/664257829633568768

On Sun, Dec 6, 2015 at 12:44 AM, Jacob Bandes-Storch via swift-evolution
<swift-evolution at swift.org> wrote:

> Sometimes it's desirable to break up a type's implementation into multiple
> files, within the same module. So for this simple case, it make sense for
> stored properties to be allowed (within the same module), treating them as
> continuations of the original class/struct declaration with no additional
> overhead.
> On Sat, Dec 5, 2015 at 4:34 PM Tomáš Linhart <swift-evolution at swift.org>
> wrote:
>> Hello,
>>
>> very often, it is necessary to define stored properties in extensions. It
>> is currently only possible in Swift that has access to ObjC runtime with
>> associated objects (in theory it might be possible with some global
>> dictionary) and it requires a lot of boilerplate. Associated objects are
>> used in UIKit quite heavily so it is something that authors of frameworks
>> need.
>>
>> It would be nice to able to create properties in extensions natively in
>> Swift without need of Objective-C and without a boilerplate. These
>> properties could be marked with some extra keyword/attribute so it is
>> obvious they are different and they have a cost (depends on their
>> implementation).
>>
>> What do you think?
>> Tomáš
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/aeb8fdab/attachment.html>

From jgroff at apple.com  Sat Dec  5 20:00:36 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 18:00:36 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
<1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com>
Message-ID: <92C8AF30-9249-4152-A24E-86496425BD4D@apple.com>


> On Dec 5, 2015, at 12:35 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> On Sat, Dec 5, 2015, at 04:30 AM, Michel Fortin wrote:
>> Like this:
>>
>> 	view.action = "_doSomething_UniqueSelector1234_currentModuleName_blahblah"
>>
>> 	extension NSObject {
>> 		func _doSomething_UniqueSelector1234_currentModuleName_blahblah() {
>> 			let target = self
>> 			(target as! MyObject).doSomething()
>> 		}
>> 	}
>>
>> (Joe Groff suggested it first.) This simply assumes the receiver will
>> derive from NSObject. You also need to set a non-nil target. And note
>> that the closure is context-free, meaning you can't capture variables
>> with it.
>
> How is this type-safe? You're using as! in there (and silently ignoring
> the message if the receiver is wrong wouldn't be any better). If I send
> a selector to the wrong receiver, it's still going to crash.

I think this would be better emitted like a category on MyObject than on NSObject.

> This comes back to my fundamental argument, which is that
> @convention(selector) looks like it's type-safe, but there's so many
> holes and so many implicit coercions that need to be added that you can
> drive a gigantic truck full of unsafety right through it without even
> noticing.

There's plenty of useful space between "no type safety" and "perfect type safety", IMO.

-Joe

From matthew at anandabits.com  Sat Dec  5 20:08:18 2015
From: matthew at anandabits.com (Anandabits)
Date: Sat, 5 Dec 2015 20:08:18 -0600
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>
Message-ID: <64E52217-017C-437E-96BA-041FED8B923C@anandabits.com>

I like the proposal in general, but the snake case feels decidedly un-Swifty (although I like snake case personally it isn't the Swift convention and I do like strong conventions).

Sent from my iPad

> On Dec 5, 2015, at 7:46 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:
>
> I like "associated". Or maybe "withtype". Anything clear and without underscore.
>
> protocol Foo {
>   associated T
> }
>
> protocol Foo {
>  withtype T
> }
>
>>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>>
>> Or merely "associated".
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From jgroff at apple.com  Sat Dec  5 20:10:08 2015
From: jgroff at apple.com (Joe Groff)
Date: Sat, 05 Dec 2015 18:10:08 -0800
Subject: [swift-evolution] Inquiry: Improved Composability of stdlib
Collections?
In-Reply-To: <C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com>
References: <C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com>
Message-ID: <90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com>


> On Dec 5, 2015, at 11:34 AM, plx via swift-evolution <swift-evolution at swift.org> wrote:
>
> Swift’s standard library's core collections' value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set<V>], and plan to mutate the “inner" sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.
>
> Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.
>
> Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?
>

Do you have specific examples of problems you're trying to solve?

-Joe

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0a319485/attachment.html>

From loiclecrenier at icloud.com  Sat Dec  5 20:13:53 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 03:13:53 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <64E52217-017C-437E-96BA-041FED8B923C@anandabits.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>
<64E52217-017C-437E-96BA-041FED8B923C@anandabits.com>
Message-ID: <B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com>

Right. I proposed associated_type simply because that's what SIL calls them, but it is a bad name for Swift. I like associated and withtype though.

Loïc

> On Dec 6, 2015, at 3:08 AM, Anandabits <matthew at anandabits.com> wrote:
>
> I like the proposal in general, but the snake case feels decidedly un-Swifty (although I like snake case personally it isn't the Swift convention and I do like strong conventions).
>
> Sent from my iPad
>
>> On Dec 5, 2015, at 7:46 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> I like "associated". Or maybe "withtype". Anything clear and without underscore.
>>
>> protocol Foo {
>>  associated T
>> }
>>
>> protocol Foo {
>> withtype T
>> }
>>
>>>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>>>
>>> Or merely "associated".
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution

From gribozavr at gmail.com  Sat Dec  5 20:20:18 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sat, 5 Dec 2015 18:20:18 -0800
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
Message-ID: <CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>

On Sat, Dec 5, 2015 at 5:43 PM, Stephen Celis via swift-evolution
<swift-evolution at swift.org> wrote:
>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>
> Or merely "associated".

+1 to the proposal, emphasizing the distinction is important; and I
like "associated" as the keyword for this purpose, too.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From david at alkaline-solutions.com  Sat Dec  5 20:24:05 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 19:24:05 -0700
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
Message-ID: <FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>

A possible syntax, then:

init(set name:String, set score:Int) { }

set would be a fourth parameter modifier alongside let, var, and inout - only valid on initializers (not as useful and likely confusing in other contexts). The local name has to match a parameter on the type. Like let/var (but unlike inout) usage of ‘set’ on a initializer parameter does not affect the caller or prototype conformance.

-DW

> On Dec 5, 2015, at 3:31 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:
>
>> Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.
>
> I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.
>
> It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4139 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f7ed6ee1/attachment.p7s>

From me at tal.by  Sat Dec  5 20:25:58 2015
From: me at tal.by (Tal Atlas)
Date: Sun, 06 Dec 2015 02:25:58 +0000
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
<FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
Message-ID: <CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>

This syntax is confusing with that of defining the external keyword for the
parameter.

On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution <
swift-evolution at swift.org> wrote:

> A possible syntax, then:
>
>         init(set name:String, set score:Int) { }
>
> set would be a fourth parameter modifier alongside let, var, and inout -
> only valid on initializers (not as useful and likely confusing in other
> contexts). The local name has to match a parameter on the type. Like
> let/var (but unlike inout) usage of ‘set’ on a initializer parameter does
> not affect the caller or prototype conformance.
>
> -DW
>
> > On Dec 5, 2015, at 3:31 PM, Brent Royal-Gordon via swift-evolution <
> swift-evolution at swift.org> wrote:
> >
> >> Did you read through by reply to the original proposal?  I believe it
> provides the convenience you're looking for here while still allowing for
> the flexibility to avoid boilerplate in initializers that do more than just
> set properties.
> >
> > I did, and I didn’t really like it. One of the syntaxes it proposed was
> strange and ad-hoc; the other was a fairly arbitrary overloading of
> parentheses, although it doesn’t actually conflict with anything since you
> can’t overload “calling parentheses” on a non-function.
> >
> > It’s important to ensure that, when the implementation evolves, you can
> replace the initializer transparently. For instance, suppose I have a type
> which represents a player in a game. It uses a stored property called
> `points`:
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/88c0be93/attachment.html>

From loiclecrenier at icloud.com  Sat Dec  5 20:27:24 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 03:27:24 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>
Message-ID: <22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com>

Great :)

Also, this hasn't been explicitly discussed yet. But do you all agree about adding "real" typealias declarations (with the typealias keyword) inside protocols?

Loïc

> On Dec 6, 2015, at 3:20 AM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Sat, Dec 5, 2015 at 5:43 PM, Stephen Celis via swift-evolution
> <swift-evolution at swift.org> wrote:
>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>>
>> Or merely "associated".
>
> +1 to the proposal, emphasizing the distinction is important; and I
> like "associated" as the keyword for this purpose, too.
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From gribozavr at gmail.com  Sat Dec  5 20:29:30 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sat, 5 Dec 2015 18:29:30 -0800
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>
<22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com>
Message-ID: <CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com>

On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:
> Great :)
>
> Also, this hasn't been explicitly discussed yet. But do you all agree about adding "real" typealias declarations (with the typealias keyword) inside protocols?

Concrete typealieases are not requirements, so they shouldn't be
defined inside of a protocol.  Instead, they should be defined in the
protocol extension.  In fact, this has been a plan of record for some
time, but it wasn't implemented.

extension SequenceType {
typealias Element = Generator.Element
}

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From loiclecrenier at icloud.com  Sat Dec  5 20:31:41 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 03:31:41 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>
<22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com>
<CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com>
Message-ID: <A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com>

This makes sense. Thanks for the quick reply.

Loïc

> On Dec 6, 2015, at 3:29 AM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
>> On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:
>> Great :)
>>
>> Also, this hasn't been explicitly discussed yet. But do you all agree about adding "real" typealias declarations (with the typealias keyword) inside protocols?
>
> Concrete typealieases are not requirements, so they shouldn't be
> defined inside of a protocol.  Instead, they should be defined in the
> protocol extension.  In fact, this has been a plan of record for some
> time, but it wasn't implemented.
>
> extension SequenceType {
>  typealias Element = Generator.Element
> }
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From david at alkaline-solutions.com  Sat Dec  5 20:46:26 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 19:46:26 -0700
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
<FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
<CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>
Message-ID: <3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>

I don’t believe any more so than for let or var, which this effectively is a complement for.

func foo(var externalName internalName:String) { print(internalName) }

-DW

> On Dec 5, 2015, at 7:25 PM, Tal Atlas <me at tal.by> wrote:
>
> This syntax is confusing with that of defining the external keyword for the parameter.
>
> On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> A possible syntax, then:
>
>         init(set name:String, set score:Int) { }
>
> set would be a fourth parameter modifier alongside let, var, and inout - only valid on initializers (not as useful and likely confusing in other contexts). The local name has to match a parameter on the type. Like let/var (but unlike inout) usage of ‘set’ on a initializer parameter does not affect the caller or prototype conformance.
>
> -DW

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ce470d64/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4139 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ce470d64/attachment.p7s>

From david at alkaline-solutions.com  Sat Dec  5 20:49:06 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 19:49:06 -0700
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>
<22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com>
<CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com>
Message-ID: <3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com>

However, if a protocol wished to use type aliases not as part of a contract but for clarity, this would still need to be defined within the protocol in order for the associated types to be used in the typealias declarations.

-DW

> On Dec 5, 2015, at 7:29 PM, Dmitri Gribenko via swift-evolution <swift-evolution at swift.org> wrote:
>
> On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:
>> Great :)
>>
>> Also, this hasn't been explicitly discussed yet. But do you all agree about adding "real" typealias declarations (with the typealias keyword) inside protocols?
>
> Concrete typealieases are not requirements, so they shouldn't be
> defined inside of a protocol.  Instead, they should be defined in the
> protocol extension.  In fact, this has been a plan of record for some
> time, but it wasn't implemented.
>
> extension SequenceType {
>  typealias Element = Generator.Element
> }
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4139 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c16cedd6/attachment.p7s>

From jtbandes at gmail.com  Sat Dec  5 20:49:54 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 18:49:54 -0800
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
<FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
<CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>
<3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>
Message-ID: <CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com>

The ability to use `var` in parameter lists / pattern matching is being
removed:
https://github.com/apple/swift-evolution/blob/7dc4dc47c43647dd1e60fe17074959dc3f056468/proposals/0003-remove-var-parameters-patterns.md

Jacob

On Sat, Dec 5, 2015 at 6:46 PM, David Waite via swift-evolution <
swift-evolution at swift.org> wrote:

> I don’t believe any more so than for let or var, which this effectively is
> a complement for.
>
> func foo(var externalName internalName:String) { print(internalName) }
>
>
> -DW
>
> On Dec 5, 2015, at 7:25 PM, Tal Atlas <me at tal.by> wrote:
>
> This syntax is confusing with that of defining the external keyword for
> the parameter.
>
> On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> A possible syntax, then:
>>
>>         init(set name:String, set score:Int) { }
>>
>> set would be a fourth parameter modifier alongside let, var, and inout -
>> only valid on initializers (not as useful and likely confusing in other
>> contexts). The local name has to match a parameter on the type. Like
>> let/var (but unlike inout) usage of ‘set’ on a initializer parameter does
>> not affect the caller or prototype conformance.
>>
>> -DW
>>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/4da71a39/attachment.html>

From brent at architechies.com  Sat Dec  5 20:51:39 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 18:51:39 -0800
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
<FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
<CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>
<3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>
Message-ID: <DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com>

> I don’t believe any more so than for let or var, which this effectively is a complement for.

There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.

--
Brent Royal-Gordon
Architechies


From david at alkaline-solutions.com  Sat Dec  5 20:58:20 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 19:58:20 -0700
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
<FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
<CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>
<3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>
<DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com>
Message-ID: <C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com>

There is also a set keyword in the language already, although today its use is limited such that it may still be used as an identifier in non-conflicting contexts.

-DW

> On Dec 5, 2015, at 7:51 PM, Brent Royal-Gordon <brent at architechies.com> wrote:
>
>> I don’t believe any more so than for let or var, which this effectively is a complement for.
>
> There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.
>
> --
> Brent Royal-Gordon
> Architechies
>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4139 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/08428331/attachment.p7s>

From nvazquez1297 at gmail.com  Sat Dec  5 21:08:30 2015
From: nvazquez1297 at gmail.com (Nikolai Vazquez)
Date: Sat, 5 Dec 2015 22:08:30 -0500
Subject: [swift-evolution] Proposal: Allow Getters and Setters to Throw
Message-ID: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>

One of the aspects of Swift that I like is computed properties for
structures and classes. It allows for adding logic when obtaining values or
for having the returned value be dependent on another.

As of the `ErrorType` protocol introduction in Swift 2, we can throw errors
when it comes to functions and initializers. However, this does not apply
to getters and setters.

```swift
struct File<Data> {
var contents: Data {
get throws { ... }
set throws { ... }
}
}
```

A better example would be getting and setting the current working directory
of the process:

```swift
import Foundation

extension Process {
static var workingDirectory: String {
get {
let fileManager = NSFileManager.defaultManager()
return fileManager.currentDirectoryPath
}
set throws {
let fileManager = NSFileManager.defaultManager()
guard fileManager.changeCurrentDirectoryPath(newValue) else {
throw Error("...")
}
}
}
}



```
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b91b2be0/attachment.html>

From matthew at anandabits.com  Sat Dec  5 21:14:59 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 21:14:59 -0600
Subject: [swift-evolution] Proposal: floating point static min / max
properties
In-Reply-To: <76657877-5D42-4486-AD4B-79BFC8677941@architechies.com>
References: <36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com>
<9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com>
<981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com>
<76657877-5D42-4486-AD4B-79BFC8677941@architechies.com>
Message-ID: <B47BE4E1-F761-4452-8CF2-7A9CFB0D3613@anandabits.com>

> There’s a problem with that:
>
> 	 24> Int.min...Int.max
> 	fatal error: Range end index has no valid successor
>
> The problem is that Int.min … Int.max is actually represented as Int.min ..< Int.max.successor(), which is obviously not going to work.

That’s embarrassing.  I should have known better than to post code that should work without trying it out first!  Thanks for pointing that out.  It looks like ClosedInterval is indeed what I should have used.

protocol ClosedIntervalType {
static var closedInterval: ClosedInterval<Self> { get }
}

extension Int: ClosedIntervalType {
static let closedInterval: ClosedInterval <Int> = Int.min…Int.max
}

extension Float: ClosedIntervalType {
// not sure it would be better to use -Float. greatestFiniteMagnitude..Float. greatestFiniteMagnitude here or not
static let closedInterval: ClosedInterval <Float> = -Float.infinity...Float.infinity
}


I think having something like this in the standard library would be quite useful.  All numeric types could conform as could

> Floats don’t currently conform to the IndexType protocols because there’s no *natural* interval for them to use. nextUp/nextDown are rarely what you want in practice, while 1 breaks down at large sizes.

nextUp/nextDown may be rarely needed, they do seem to me to be a “natural” interval for floating point numbers.  Natural because successor and predecessor imply stepping through a discrete sequence of values one-by-one and any other interval would necessarily skip values.

I did run into a scenario where nextUp/nextDown were precisely what I needed which is what lead me to write a conformance of Float and Double to BidirectionalIndexType.  I didn’t actually need BidirectionalIndexType conformance - just the successor and predecessor (nextUp/nextDown) functions - it just seemed most natural to conform to the protocol that defined them functions that do precisely this.

I think it would be perfectly natural for floating point types to conform to BidirectionalIndexType but I admit it would probably not be used often.

From matthew at anandabits.com  Sat Dec  5 21:17:43 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 21:17:43 -0600
Subject: [swift-evolution] Proposal: Allow Getters and Setters to Throw
In-Reply-To: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>
References: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>
Message-ID: <DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>

+1 to this.  Subscripts should also be able to throw and currently cannot.


> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:
>
> One of the aspects of Swift that I like is computed properties for structures and classes. It allows for adding logic when obtaining values or for having the returned value be dependent on another.
>
> As of the `ErrorType` protocol introduction in Swift 2, we can throw errors when it comes to functions and initializers. However, this does not apply to getters and setters.
>
> ```swift
> struct File<Data> {
>     var contents: Data {
>         get throws { ... }
>         set throws { ... }
>     }
> }
> ```
>
> A better example would be getting and setting the current working directory of the process:
>
> ```swift
> import Foundation
>
> extension Process {
>     static var workingDirectory: String {
>         get {
>             let fileManager = NSFileManager.defaultManager()
>             return fileManager.currentDirectoryPath
>         }
>         set throws {
>             let fileManager = NSFileManager.defaultManager()
>             guard fileManager.changeCurrentDirectoryPath(newValue) else {
>                 throw Error("...")
>             }
>         }
>     }
> }
>
>
>
> ```
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/fd1401f0/attachment.html>

From phabouzit at apple.com  Sat Dec  5 21:10:38 2015
From: phabouzit at apple.com (Pierre Habouzit)
Date: Sat, 05 Dec 2015 19:10:38 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal:
Conforming	NSDate to Comparable
In-Reply-To: <97EB190C-895B-4698-A93E-C1050B92520B@architechies.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
<97EB190C-895B-4698-A93E-C1050B92520B@architechies.com>
Message-ID: <0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>


-Pierre

> On Dec 5, 2015, at 3:51 PM, Brent Royal-Gordon via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:
>
>> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:
>>
>> if someDate.compare(today) == .OrderedAscending { }
>>
>> Developers can easily compare using compare dates using comparison operators:
>>
>> if someDate < today { }
>
> I would also suggest we add Strideable, which would allow you to add and subtract NSTimeIntervals, plus subtract two NSDates to get the NSTimeInterval between them.
>
> https://gist.github.com/brentdax/11b3275424d0833cfd99

NSDate (and dates/timestamps in general) is a poor choice for Strideable, because, DST.
A Calendar using this interface for a repeating event would be broken using this. Or you would break anyone who really wants to iterate every fixed 86400 seconds.

-Pierre

From kevin at sb.org  Sat Dec  5 21:35:12 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 05 Dec 2015 19:35:12 -0800
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <92C8AF30-9249-4152-A24E-86496425BD4D@apple.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
<1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com>
<92C8AF30-9249-4152-A24E-86496425BD4D@apple.com>
Message-ID: <1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com>

On Sat, Dec 5, 2015, at 06:00 PM, Joe Groff wrote:
> > How is this type-safe? You're using as! in there (and silently ignoring
> > the message if the receiver is wrong wouldn't be any better). If I send
> > a selector to the wrong receiver, it's still going to crash.
>
> I think this would be better emitted like a category on MyObject than on
> NSObject.

Going back and reading your original suggestion about generating
closures, I think we're talking about this differently. If I understand
it right, your original suggestion for generating closures basically
just solves the problem of forgetting to mark a method as @objc, right?
In that case, putting the category on MyObject instead of NSObject is
absolutely the right thing to do. My arguments here are actually about
Michel Fortin's claim:

> The fact that the selector lives separately from its target object makes things difficult because the expected target type is almost always going to be AnyObject. Implicit conversions cannot happen safely in the direction SubType to BaseType for the arguments, including the target object. That makes Joe Groff's approach the only type-safe solution: make an extension of the base object and generate a method that does what you want.

Which is in the context of the fact that @convention(selector) MyObject
-> Args -> Ret encodes the receiver type, but the problem is the
selector is sent to AnyObject, so having the receiver type in there is
basically false type-safety (it looks like it's strongly-typed but it's
actually not as that type information will be thrown away before the
selector is used). I'm not really sure why Michel claimed that your
closure suggestion was a solution to this problem, because the only
reasonable behavior one can use in such a category emitted on
AnyObject/swift base class is to fatalError, which is no better than
what happens if the selector simply isn't implemented.

Ultimately, given the premise that @convention(selector) T -> Args ->
Ret exists, generating those methods on the receiver type with mangled
selector names seems like reasonable behavior. I just don't think
@convention(selector) should exist.

> There's plenty of useful space between "no type safety" and "perfect type safety", IMO.

In principle I agree. My basic argument here is that
@convention(selector) provides so little actual type safety that it's
not worth the language complexity. And I also worry that providing
functionality that appears to be strongly-typed but doesn't actually
provide any typing guarantees in practice will end up as a safety hazard
for unwary programmers.

It's also worth pointing out that my alternative suggestion of simply
providing some syntax to explicitly get a Selector from a method could
still use your closure-generating idea to work for non- at objc methods.
Heck, we don't even really need syntax for this, we could just say that
unbound method references can resolve to Selectors in addition to
function types (just as the primary suggestion here allows method
references to resolve to @convention(selector) functions in addition to
@convention(swift) functions).

-Kevin Ballard

From kevin at sb.org  Sat Dec  5 21:42:46 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 05 Dec 2015 19:42:46 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Conforming
NSDate to Comparable
In-Reply-To: <0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
<97EB190C-895B-4698-A93E-C1050B92520B@architechies.com>
<0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>
Message-ID: <1449373366.2149969.459249705.7F8B4291@webmail.messagingengine.com>

On Sat, Dec 5, 2015, at 07:10 PM, Pierre Habouzit via swift-evolution
wrote:
> NSDate (and dates/timestamps in general) is a poor choice for Strideable,
> because, DST.
> A Calendar using this interface for a repeating event would be broken
> using this. Or you would break anyone who really wants to iterate every
> fixed 86400 seconds.

That's not a problem with Strideable. Making NSDate conform to
Strideable does nothing to encourage people as treating 86400 seconds as
being equal to 1 day. NSDate already has methods for measuring and
offsetting, the only difference with conforming to Strideable is the
name.

-Kevin Ballard

From david at alkaline-solutions.com  Sat Dec  5 21:48:14 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sat, 5 Dec 2015 20:48:14 -0700
Subject: [swift-evolution] [swift-corelibs-dev] Proposal:
Conforming	NSDate to Comparable
In-Reply-To: <0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
<97EB190C-895B-4698-A93E-C1050B92520B@architechies.com>
<0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>
Message-ID: <4CF9AAE7-812C-4F95-A8D8-62B74701957D@alkaline-solutions.com>

Both NSDate nor NSTimeInterval represent instants in time, not time within a calendaring system. Assuming 86400 seconds is a calendar day is a bug, same as assuming 365 days is a calendar year. That they are using the wrong time primitive doesn’t seem to be affected by whether NSDate implements Strideable or not.

(That there isn’t a comprehensive time system is another problem)

-DW

> On Dec 5, 2015, at 8:10 PM, Pierre Habouzit via swift-evolution <swift-evolution at swift.org> wrote:
>
>
> NSDate (and dates/timestamps in general) is a poor choice for Strideable, because, DST.
> A Calendar using this interface for a repeating event would be broken using this. Or you would break anyone who really wants to iterate every fixed 86400 seconds.
>
> -Pierre

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f6e240e7/attachment.html>

From kevin at sb.org  Sat Dec  5 21:53:44 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 05 Dec 2015 19:53:44 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com>
Message-ID: <1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com>

On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-evolution wrote:
>
>> I don't think you can just get rid of the if statement in favor of an
>> expression. You still want to be able to do this:
>>
>> if (condition) {    funcWithSideEffectsThatReturnsInt() } else {
>> funcWithSideEffectsThatReturnsString() }
>>
>> but that's not a valid expression (what is its type?).
>
> An if statement with two different types could just have the closes
> common ancestor or Any as type.

That's a great way to cause confusion.

Rust has this feature (all statements are expressions), and it requires
if statements to have an else branch with the same type unless the type
is `()`. It's solution to the issue of the branches returning unwanted
values is that Rust uses semicolons, and the semicolon acts sort of like
an operator that consumes any value and returns `()`, so if you
terminate the last statement of the branch with a semicolon, the whole
branch returns `()`, and if you leave it off, the branch returns a
value. It's actually very elegant and straightforward.

That said, proposing that Swift introduce this same rule for semicolons
is probably not a good idea. We certainly could declare that an explicit
semicolon has this behavior, so you'd see people writing code like

if condition {    funcWithSideEffectsThatReturnsInt(); }

but it would be confusing because semicolons are almost never
used in Swift.

An alternative that would work today is just relying on assignment
returning Void, so you can write

if condition {    _ = funcWithSideEffectsThatReturnsInt() }

but that looks kind of weird and would probably also be confusing.
Better than the semicolon rule I think, but still not great.

Another option is to check if the return value is actually used
anywhere, and if it's not, then silently coerce it to Void. This way
you can write

if condition {    funcWithSideEffectsThatReturnsInt() } else {
funcWithSideEffectsThatReturnsString() }

and it would be fine but writing

let foo = if condition {    funcWithSideEffectsThatReturnsInt() } else {
funcWithSideEffectsThatReturnsString() }

would fail with a type error.

I suspect that this is the right approach, but it does involve a
bit of magic.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/df3334bb/attachment.html>

From matthew at anandabits.com  Sat Dec  5 22:31:04 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 22:31:04 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
Message-ID: <849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com>

As stated previously, I think a more specific solution is the best way to address the initialization / setup / configuration problem. While that is the case I did think some more about the ideas in this thread.

I believe two things are being proposed here:

1. The ability to append a trailing closure to any initializer (that doesn’t already declare one itself) that accepts a single argument of the initialized type.  If the caller supplies such a closure, the compiler performs a code transformation as follows:

let questionLabel = UILabel() {
$0.textAlignment = .Center
$0.font =  UIFont(name:"DnealianManuscript", size: 72)
$0.numberOfLines = 0
}

becomes something like this (which is valid Swift today:

let questionLabel = UILabel(); {
$0.textAlignment = .Center
$0.font =  UIFont(name:"DnealianManuscript", size: 72)
$0.numberOfLines = 0
}(questionLabel)

The code transformation doesn’t actually buy us much.  I’m a big believer in removing the need for clutter and boilerplate as much as possible, but even I must admit that the difference is really small and can be reduced a bit further using currently valid Swift code as demonstrated by the “configuration operator” mentioned in the previous post.

2. A new abbreviation of the $0 shorthand that would be valid only as the first characters on a line of code.  For consistency this shorthand should work in any closure, not just in “setup closures”.  I agree that $0 is uglier than necessary in this use case which would be relatively common in Cocoa code if this pattern becomes common.

The biggest drawback I can think of to a feature like this is that it is a feature specifically designed to make the use of var members more convenient.  It might be a good thing that “setup closures" are a little bit ugly given that they are only able to “setup" mutable members and require those members to be initialized to potentially meaningless default values (or worse, IUO members defaulted to nil!).

Ideally an instance would be configured correctly when the initializer completes and we should work to find language solutions to make this safe and convenient.  Once we have the right language solutions ideally we can use them in new types and retrofit existing types to use them over time, thus eliminating the need for “setup closures” alltogether.


> On Dec 5, 2015, at 6:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>
> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>
> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>
> let task = NSTask() +=+ {
>     $0.launchPath = "/usr/bin/mdfind"
>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>     $0.standardOutput = pipe
> }
>
> Note you can also use the configured object in the rhs:
>
> let questionLabel = UILabel() +=+ {
>     $0.textAlignment = .Center
>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>     $0.text = currentQuestion.questionText
>     $0.numberOfLines = 0
>     view.addSubview($0)
> }
>
> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>
> let questionLabel = UILabel() +=+ {
>     .textAlignment = .Center
>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>     .text = currentQuestion.questionText
>     .numberOfLines = 0
>     view.addSubview($0)
> }
>
> Actually I would be happy with something like
>
> let questionLabel = UILabel() .{
>     ..textAlignment = .Center
>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>     ..text = currentQuestion.questionText
>     ..numberOfLines = 0
>     view.addSubview($0)
> }
>
> Other thoughts?
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/639125f8/attachment.html>

From ilya at harmonicsense.com  Sat Dec  5 22:39:48 2015
From: ilya at harmonicsense.com (Ilya)
Date: Sun, 06 Dec 2015 04:39:48 +0000
Subject: [swift-evolution] access control proposal
Message-ID: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>

I think the it would help a great deal to have an access level modifier
that is really private and visible only inside the class itself. Right now,
the only way to hide implementation details for a class is to hide the
class code in a separate file, which is very inconvenient for several
reasons:

1) the meaning of the code changes depending on which file the class is in.
It's very easy to accidentally expose class internal details and then call
class elements that are meant to be used only inside the class. Having a
keyword for class internals will allow the compiler to ensure that only the
public API for the class is used from the outside world. The user can check
types on his own, but it's better that the compiler does it automatically.
Similarly, the user can check that only the proper APIs are called, but
it's better that the compiler does it automatically.

2) accessibility by file structure may cause some really short files.

3) It's impossible to group related classes in one file but still hide
implementation details inside each class

I think that it the best solution is to make private keyword do what it
states -- keep the class element private to the class. But if it's really
important to have a separate keyword for backward compatibility, it would
be the next best thing.

--
Ilya Belenkiy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/54ae4c4e/attachment.html>

From jon at jonshier.com  Sat Dec  5 22:41:18 2015
From: jon at jonshier.com (Jon Shier)
Date: Sat, 5 Dec 2015 23:41:18 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
<7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
<B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
Message-ID: <11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com>

Swift’s biggest issue preventing it from being a good teaching or learning language is its still rather poor error messaging, especially when the compiler becomes confused about types. Aside from that, type inference serves to remove the immediate need to learn about types for the beginner.


Jon Shier


> On Dec 5, 2015, at 7:13 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:
>
> No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.
>
> Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.
>
> Austin
>
>> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>
>>
>>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> ml>
>>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.
>>
>> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?
>>
>>>
>>> Austin
>>>
>>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>>>>
>>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>>>>
>>>> --
>>>> Kevin Lundberg
>>>>
>>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>>>>
>>>>> Regards,
>>>>> Adrian Kashivskyy
>>>>> iOS Developer at Netguru
>>>>>
>>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>>>>
>>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> --rbÚḟîẁ
>>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/ma <https://lists.swift.org/ma>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/21165948/attachment.html>

From jtbandes at gmail.com  Sat Dec  5 22:46:18 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sat, 5 Dec 2015 20:46:18 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com>
<1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com>
Message-ID: <CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com>

That approach seems fine to me; I don't think it seems like magic.

"if x { returnsAnInt() } else { returnsAString() }"  would have type Any,
but would only emit a warning if you actually tried to *use* the value.
Much like the current warning, "*X inferred to have type Any, which may be
unexpected*".

Jacob Bandes-Storch

On Sat, Dec 5, 2015 at 7:53 PM, Kevin Ballard via swift-evolution <
swift-evolution at swift.org> wrote:

> On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-evolution wrote:
>
>
>
> I don't think you can just get rid of the if statement in favor of an
> expression. You still want to be able to do this:
>
> if (condition) {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> but that's not a valid expression (what is its type?).
>
>
> An if statement with two different types could just have the closes common
> ancestor or Any as type.
>
>
> That's a great way to cause confusion.
>
> Rust has this feature (all statements are expressions), and it requires if
> statements to have an else branch with the same type unless the type is
> `()`. It's solution to the issue of the branches returning unwanted values
> is that Rust uses semicolons, and the semicolon acts sort of like an
> operator that consumes any value and returns `()`, so if you terminate the
> last statement of the branch with a semicolon, the whole branch returns
> `()`, and if you leave it off, the branch returns a value. It's actually
> very elegant and straightforward.
>
> That said, proposing that Swift introduce this same rule for semicolons is
> probably not a good idea. We certainly could declare that an explicit
> semicolon has this behavior, so you'd see people writing code like
>
> if condition {
>     funcWithSideEffectsThatReturnsInt();
> }
>
> but it would be confusing because semicolons are almost never used in
> Swift.
>
> An alternative that would work today is just relying on assignment
> returning Void, so you can write
>
> if condition {
>     _ = funcWithSideEffectsThatReturnsInt()
> }
>
> but that looks kind of weird and would probably also be confusing. Better
> than the semicolon rule I think, but still not great.
>
> Another option is to check if the return value is actually used anywhere,
> and if it's not, then silently coerce it to Void. This way you can write
>
> if condition {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> and it would be fine but writing
>
> let foo = if condition {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> would fail with a type error.
>
> I suspect that this is the right approach, but it does involve a bit of
> magic.
>
> -Kevin
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/57e17cdd/attachment.html>

From ahti333 at gmail.com  Sat Dec  5 22:54:52 2015
From: ahti333 at gmail.com (Lukas Stabe)
Date: Sun, 6 Dec 2015 05:54:52 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com>
<1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com>
<CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com
>
Message-ID: <D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com>

I agree.

I’m sure there are use-cases where the different branches return different types, both conforming to some protocol. Since we’d need to support these cases, this approach is also pretty clean, because Any is just another protocol.

The warning emitted should be silenceable by explicitly declaring the variable being assigned to as Any.

Lukas

> On 06 Dec 2015, at 05:46, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:
>
> That approach seems fine to me; I don't think it seems like magic.
>
> "if x { returnsAnInt() } else { returnsAString() }"  would have type Any, but would only emit a warning if you actually tried to use the value. Much like the current warning, "X inferred to have type Any, which may be unexpected".
>
> Jacob Bandes-Storch
>
> On Sat, Dec 5, 2015 at 7:53 PM, Kevin Ballard via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-evolution wrote:
>>
>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>
>>> if (condition) {
>>>     funcWithSideEffectsThatReturnsInt()
>>> } else {
>>>     funcWithSideEffectsThatReturnsString()
>>> }
>>>
>>> but that's not a valid expression (what is its type?).
>>
>> An if statement with two different types could just have the closes common ancestor or Any as type.
>
> That's a great way to cause confusion.
>
> Rust has this feature (all statements are expressions), and it requires if statements to have an else branch with the same type unless the type is `()`. It's solution to the issue of the branches returning unwanted values is that Rust uses semicolons, and the semicolon acts sort of like an operator that consumes any value and returns `()`, so if you terminate the last statement of the branch with a semicolon, the whole branch returns `()`, and if you leave it off, the branch returns a value. It's actually very elegant and straightforward.
>
> That said, proposing that Swift introduce this same rule for semicolons is probably not a good idea. We certainly could declare that an explicit semicolon has this behavior, so you'd see people writing code like
>
> if condition {
>     funcWithSideEffectsThatReturnsInt();
> }
>
> but it would be confusing because semicolons are almost never used in Swift.
>
> An alternative that would work today is just relying on assignment returning Void, so you can write
>
> if condition {
>     _ = funcWithSideEffectsThatReturnsInt()
> }
>
> but that looks kind of weird and would probably also be confusing. Better than the semicolon rule I think, but still not great.
>
> Another option is to check if the return value is actually used anywhere, and if it's not, then silently coerce it to Void. This way you can write
>
> if condition {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> and it would be fine but writing
>
> let foo = if condition {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> would fail with a type error.
>
> I suspect that this is the right approach, but it does involve a bit of magic.
>
> -Kevin
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/f838508a/attachment.html>

From kevin at sb.org  Sat Dec  5 22:55:52 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 05 Dec 2015 20:55:52 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com>
<1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com>
<CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com>
Message-ID: <1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com>

If it's defined as type Any, then we'd also need a guaranteed compiler
optimization (preferably one that happens in debug builds too) that
omits the creation of the `Any` value if it's unused.

-Kevin

On Sat, Dec 5, 2015, at 08:46 PM, Jacob Bandes-Storch wrote:
> That approach seems fine to me; I don't think it seems like magic.
>
> "if x { returnsAnInt() } else { returnsAString() }"  would have type
> Any, but would only emit a warning if you actually tried to *use* the
> value. Much like the current warning, "*X inferred to have type Any,
> which may be unexpected*".
>
> Jacob Bandes-Storch
>
> On Sat, Dec 5, 2015 at 7:53 PM, Kevin Ballard via swift-evolution <swift-
> evolution at swift.org> wrote:
>> __
>>
>> On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-
>> evolution wrote:
>>>
>>>> I don't think you can just get rid of the if statement in favor of
>>>> an expression. You still want to be able to do this:
>>>>
>>>> if (condition) {    funcWithSideEffectsThatReturnsInt() } else {
>>>> funcWithSideEffectsThatReturnsString() }
>>>>
>>>> but that's not a valid expression (what is its type?).
>>>
>>> An if statement with two different types could just have the closes
>>> common ancestor or Any as type.
>>
>>
>> That's a great way to cause confusion.
>>
>> Rust has this feature (all statements are expressions), and it
>> requires if statements to have an else branch with the same type
>> unless the type is `()`. It's solution to the issue of the branches
>> returning unwanted values is that Rust uses semicolons, and the
>> semicolon acts sort of like an operator that consumes any value and
>> returns `()`, so if you terminate the last statement of the branch
>> with a semicolon, the whole branch returns `()`, and if you leave it
>> off, the branch returns a value. It's actually very elegant and
>> straightforward.
>>
>> That said, proposing that Swift introduce this same rule for
>> semicolons is probably not a good idea. We certainly could declare
>> that an explicit semicolon has this behavior, so you'd see people
>> writing code like
>>
>> if condition {    funcWithSideEffectsThatReturnsInt(); }
>>
>> but it would be confusing because semicolons are almost never used
>> in Swift.
>>
>> An alternative that would work today is just relying on assignment
>> returning Void, so you can write
>>
>> if condition {    _ = funcWithSideEffectsThatReturnsInt() }
>>
>> but that looks kind of weird and would probably also be confusing.
>> Better than the semicolon rule I think, but still not great.
>>
>> Another option is to check if the return value is actually used
>> anywhere, and if it's not, then silently coerce it to Void. This way
>> you can write
>>
>> if condition {    funcWithSideEffectsThatReturnsInt() } else {
>> funcWithSideEffectsThatReturnsString() }
>>
>> and it would be fine but writing
>>
>> let foo = if condition {    funcWithSideEffectsThatReturnsInt() }
>> else {    funcWithSideEffectsThatReturnsString() }
>>
>> would fail with a type error.
>>
>> I suspect that this is the right approach, but it does involve a bit
>> of magic.
>>
>> -Kevin
>>
>>
>> _______________________________________________
>>
swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/2a41055a/attachment.html>

From nvazquez1297 at gmail.com  Sat Dec  5 23:04:10 2015
From: nvazquez1297 at gmail.com (Nikolai Vazquez)
Date: Sun, 06 Dec 2015 05:04:10 +0000
Subject: [swift-evolution] access control proposal
In-Reply-To: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>
References: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>
Message-ID: <CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com>

I agree that there should be an access level that hides implementation
details from other types in the same file. However, it shouldn’t replace
private, because 1) helper types might benefit from private elements and 2)
like you said, backwards compatibility.

On Sat, Dec 5, 2015 at 11:40 PM Ilya via swift-evolution <
swift-evolution at swift.org> wrote:

I think the it would help a great deal to have an access level modifier
> that is really private and visible only inside the class itself. Right now,
> the only way to hide implementation details for a class is to hide the
> class code in a separate file, which is very inconvenient for several
> reasons:
>
> 1) the meaning of the code changes depending on which file the class is
> in. It's very easy to accidentally expose class internal details and then
> call class elements that are meant to be used only inside the class. Having
> a keyword for class internals will allow the compiler to ensure that only
> the public API for the class is used from the outside world. The user can
> check types on his own, but it's better that the compiler does it
> automatically. Similarly, the user can check that only the proper APIs are
> called, but it's better that the compiler does it automatically.
>
> 2) accessibility by file structure may cause some really short files.
>
> 3) It's impossible to group related classes in one file but still hide
> implementation details inside each class
>
> I think that it the best solution is to make private keyword do what it
> states -- keep the class element private to the class. But if it's really
> important to have a separate keyword for backward compatibility, it would
> be the next best thing.
>
> --
> Ilya Belenkiy
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
​
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/eb13aee8/attachment.html>

From brent at architechies.com  Sat Dec  5 23:10:14 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sat, 5 Dec 2015 21:10:14 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Conforming
NSDate to Comparable
In-Reply-To: <0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
<97EB190C-895B-4698-A93E-C1050B92520B@architechies.com>
<0C687B3C-4916-458B-86F0-16B3A9261941@apple.com>
Message-ID: <74FC29AE-AF91-4360-BDA1-EF54AA6A74F8@architechies.com>

> NSDate (and dates/timestamps in general) is a poor choice for Strideable, because, DST.
> A Calendar using this interface for a repeating event would be broken using this. Or you would break anyone who really wants to iterate every fixed 86400 seconds.

Sometimes you want to add an interval of time according to the user’s clock; NSTimeInterval/NSDate math will do the wrong thing there. But sometimes you just want to get an NSDate thirty seconds from now, and for all you care the user can fly to Timbuktu during that time. That’s the sort of thing I’m using this for:

// Don’t add to undo manager if we’re too close to the last change
guard now - lastChangeDate > undoCoalescingTimespan else { return }

It is simply not the case that *all* arithmetic on NSDates is incorrect unless it involves NSCalendar and NSDateComponents.

--
Brent Royal-Gordon
Architechies


From matthew at anandabits.com  Sat Dec  5 23:31:50 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sat, 5 Dec 2015 23:31:50 -0600
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
Message-ID: <6935BB3A-2203-406C-9EC2-02FF7287767F@anandabits.com>

Thank you for taking the time to provide this feedback!

I was trying to focus more on the problem we need to solve and just quickly sketch something that would solve it by building on the previous proposal.  I agree the syntax (and likely semantics) left a lot to be desired and should be vastly improved.  I was primarily demonstrating that is *possible* to solve the problem, we just need to find the right solution.

I’m glad to hear you also believe it’s a problem worth solving and just didn’t like specific details of the solution.  I do think it’s worth solving the more general problem even though a good solution may be more difficult to find.  If we adopt a simpler solution like the one you propose for default initializers it is likely to significantly constrain our options for solving the more general problem (in order to play nice with the simpler solution you propose).

I also believe that this problem is intimately related to the problem addressed in the “setup closures” thread as a general solution would supersede the need for “setup closures".

I would like to try coming at this problem from a different angle and see if that solution feels any better to us.  Let’s consider an @initializable attribute for members:

@initializable members that are set by the initializer are not generated as parameters by the compiler as the body of the initializer is taking responsibility for initializing that member.  The initializer is free to manually declare the a parameter with the name of the member it is initializing and use that if desired but it is not required to do so.  This will ensure boilerplate still works as expected when a programmer provides it.

@initializable members not set in the implementation of an initializer are generated as parameters automatically by the compiler at the end of the argument list (but before any variadic or trailing closure arguments) in the order the members are declared in the type itself.  If the member declares a default value, the compiler uses that as the default value for the argument.  Ideally the caller can re-order the labeled arguments as desired.

Private members are allowed to be @initializable and may be exposed through internal or public initializers.  The member itself is still hidden outside the scope of the file but any internal or public initializers should still be able to accept an initial value from a caller if desired, just as is possible with manual boilerplate today.

The general form of an initializer with automatically generated parameters would look something like this:

init() {
// Compiler generated code to set the members for which it generated parameters.

// The initializer is now free to access the value proved by the caller by accessing the member which has now been initialized by the compiler generated code.

// The initializer sets any members it needs to directly.
// This includes all members not marked @initializable that do not have default values.
}

There are probably some additional details to work out in relative to two-phase initialization of classes, but I think this conveys the basic idea.

Here is an example:

struct S {
@initializable let i: Int
@initializable private let s: String = “s”
let f: Float = 1
let d: Double

// i must be provided by the caller
// s may be provided by the caller but is not required as there is a default value of “s”
// f may be initialized directly but does not need to be as there is a default value of 1
// d must be initialized directly by the initializer
// callers see init(i: Int, s: String = “s")
init() {
// the initializer is free to read both i and s as the compiler automatically initializes them
// with the value provided by the caller or the default value before the body of the initializer is entered
d = Double(i)
// f is initialized by the compiler to its default value
}

// s may be provided by the caller but is not required as there is a default value of “s”
// callers see init(i: Int, j: Int, d: Double, s: String = “s")
init(i: Int, j: Int, d: Double) {
// the initializer is free to read s as the compiler automatically initializes it automatically
// with the value provided by the caller or the default value before the body of the initializer is entered
// this initializer may not read the value of i because the compiler does not automatically generate
// an initializer for it as is initialized directly

// the i parameter does not need to be used to directly initialize self.i and can be used to perform computation
// if desired in order to provide backwards compatibility with existing code
self.i = i + j
self.d = d
// f is initialized by the compiler to its default value
}
}

One drawback to a solution like this is that it could result in the compiler generating parameters for an initializer that the developer did not intend but “forgot" to initialize directly.

When it does so for a member that does not contain a default value, tests and calling code should fail to compile calling attention to the problem.  In this case the problem is not too severe.

On the other hand, if the member declares a default value calling code would still compile and the member would be initialized to the default value.  This is identical to the behavior of member not marked @initializable that a developer “forgets” to initialize if it declares a default value (i.e. the correct behavior for the initializer would require a value different than the default).  The primary difference is the compiler generated parameter for the @initializable member that the implementer “forgot” to initialize, potentially allowing a caller to provide a value and initialize the instance in an incorrect way that is *different* than the default value which should not have been used by the initializer.

Another drawback to this approach is that it is not explicitly clear when reading an initializer’s parameter list.  One way to mitigate this would be to require the initializer itself to be marked with @initializable in order to opt-in to the compiler generated parameters.  This at least alerts the reader that they exist.  It provides less information than the "init default()” approach as some @initializable members might be initialized directly in the initializer body which would suppress the compiler generated parameter.  However, the semantics of @initializable are pretty straightforward so I don’t think this would cause too much confusion.

Documentation generated for the initializer, autocomplete, etc would all expose the full parameter including the parameters the compiler generated for @initializable members.

I would like to revisit the Player example to see how it would fare using this approach:

class Player {
@initializable var name: String
@initializable private(set) var points: Int

func addPoints(additionalPoints: Int) {
points += additionalPoints
}

// the previous post stated ‘Creates init(name: String, score: Int)' which does not match the members
// this has been modified to match the members as was likely intended
// Creates init(name: String, points: Int)
init() {}
}

later in Player’s life:

class Player {
let syncIdentifier = NSUUID()
var name: String
private var pointChanges: Set<PointChange>

var points: Int {
get { return pointChanges.reduce(0, combine: +) }
}

func addPoints(additionalPoints: Int) {
pointChanges.insert(PointChange(offset: additionalPoints)
}

// We can no longer use the compiler generated parameters, but we can still create an initializer with the same signature.
// Furthermore, if we do not need to be concerned about the declaration order of keyword arguments
// we can now leave off the boilerplate for “name” and allow the compiler to generate it
// without requiring any changes to call sites.
init(name: String, points: Int) {
self.name = name
pointChanges = [ PointChange(offset: points) ] // the original post had score here which did not match the parameter name
}
}

Does this solution look any better to you than the previous idea?



> On Dec 5, 2015, at 4:31 PM, Brent Royal-Gordon <brent at architechies.com> wrote:
>
>> Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.
>
> I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.
>
> It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:
>
>    class Player {
>        var name: String
>        private(set) var points: Int
>
>        func addPoints(additionalPoints: Int) {
>            points += additionalPoints
>        }
>
>        // Creates init(name: String, score: Int)
>        init default()
>    }
>
> Later, I decide to add syncing, and realize I need to change this model. I need to add a sync identifier, and I want to change `points` to be computed from a series of `PointChange` objects. (This is a common strategy to avoid sync conflicts.) However, I don’t want to disrupt any of my existing code when I do this.
>
>    class Player {
>        let syncIdentifier = NSUUID()
>        var name: String
>        private var pointChanges: Set<PointChange>
>
>        var points: Int {
>            get { return pointChanges.reduce(0, combine: +) }
>        }
>
>        func addPoints(additionalPoints: Int) {
>            pointChanges.insert(PointChange(offset: additionalPoints)
>        }
>
>        // We can no longer use init default(), but we can still create an initializer with the same signature
>        init(name: String, points: Int) {
>            self.name = name
>            pointChanges = [ PointChange(offset: score) ]
>        }
>    }
>
> By *not* separating the properties into a different syntactical construct from the constructor parameters, I can update my type’s implementation without affecting its interface. If properties were separated syntactically from constructor parameters as you proposed, it would not be possible to change this seamlessly.
>
>> If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.
>
> Honestly, I would like to fix the boilerplate issue in more sophisticated initializers, but I don’t see a clean way to do that. The other proposals I’ve seen in this thread, along the lines of:
>
> 	init(self.name, self.points) {}
>
> Frankly do too much violence to the parameter list. Swift’s declarations have a lovely feature where the declaration basically looks like the usage, except that the concrete values in the usage are replaced by types in the declaration. These proposals destroy that property—when I look at the declaration, I can no longer envision what the call site will look like.
>
> Basically, I focused on default initializers because they’re *really* easy to solve and cover a good portion of the common case. I really have no idea how to solve the larger problem, and I haven’t liked any of the other ideas in this thread, but I do know how to solve this more limited problem.
>
> --
> Brent Royal-Gordon
> Architechies
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/01673358/attachment.html>

From gribozavr at gmail.com  Sat Dec  5 23:57:05 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sat, 5 Dec 2015 21:57:05 -0800
Subject: [swift-evolution] Expanded support for numeric types in stdlib?
In-Reply-To: <028CF26F-131D-48DD-9B70-39A507E1E352@gmail.com>
References: <CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com>
<CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com>
<CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com>
<CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com>
<CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com>
<7630D974-9311-4D15-B318-631EBF3FEB47@sb.org>
<CANGnqV2RiaLCg=YLnQtH_dm58x54+9hxxCQ+=vA3c=m+qeF6iw@mail.gmail.com>
<028CF26F-131D-48DD-9B70-39A507E1E352@gmail.com>
Message-ID: <CA+Y5xYeW972FCuwPUFzT4tpADyHDjJsymqZ-a5rt7vKitDPXfw@mail.gmail.com>

On Fri, Dec 4, 2015 at 6:13 AM, Vinicius Vendramini
<vinivendra at gmail.com> wrote:
>
> If Swift’s Ints may go up to 2048 bits, I’d agree that they probably cover most cases. That’s not to say a big int would be useless, just that I think it should be separate, meant to be used by those who actually need it rather than interfering with normal Int logic, which is likely to be used more often.

Swift's 'Int's are pointer-sized.  Swift's integer literals can be up
to 2048 bits, which allows one to write types (e.g., BigInt) that can
be initialized from large literals.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From clattner at apple.com  Sun Dec  6 00:07:27 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:07:27 -0800
Subject: [swift-evolution] Proposal: Allow Getters and Setters to Throw
In-Reply-To: <DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>
References: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>
<DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>
Message-ID: <E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com>


>> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> One of the aspects of Swift that I like is computed properties for structures and classes. It allows for adding logic when obtaining values or for having the returned value be
> On Dec 5, 2015, at 7:17 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>
> +1 to this.  Subscripts should also be able to throw and currently cannot.

+1 from me as well.  Subscripts also currently cannot be generic.

I consider all of these implementation limitations, not intentional parts of the design of Swift.  Patches would be very very welcome to help improve these areas.

-Chris


>
> dependent on another.
>>
>> As of the `ErrorType` protocol introduction in Swift 2, we can throw errors when it comes to functions and initializers. However, this does not apply to getters and setters.
>>
>> ```swift
>> struct File<Data> {
>>     var contents: Data {
>>         get throws { ... }
>>         set throws { ... }
>>     }
>> }
>> ```
>>
>> A better example would be getting and setting the current working directory of the process:
>>
>> ```swift
>> import Foundation
>>
>> extension Process {
>>     static var workingDirectory: String {
>>         get {
>>             let fileManager = NSFileManager.defaultManager()
>>             return fileManager.currentDirectoryPath
>>         }
>>         set throws {
>>             let fileManager = NSFileManager.defaultManager()
>>             guard fileManager.changeCurrentDirectoryPath(newValue) else {
>>                 throw Error("...")
>>             }
>>         }
>>     }
>> }
>>
>>
>>
>> ```
>>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b565797f/attachment-0001.html>

From clattner at apple.com  Sun Dec  6 00:11:21 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:11:21 -0800
Subject: [swift-evolution] Proposal: Allow willChange and
didChange	observers on a property
In-Reply-To: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
References: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
Message-ID: <9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>


> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org> wrote:
>
> It's currently possible to define either or both of the following observers on a property:
> willSet, called just before the value is stored
> didSet, called immediately after the new value is stored
...

> This would mean the following observers could be defined on a property:
> willSet, called just before the value is stored
> willChange, called just before the value is stored if the value is different to the previous value
> didSet, called immediately after the new value is stored
> didChange, called immediately after the new value is stored if the new value is different to the previous value

I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?

-Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9d9fb9ba/attachment.html>

From clattner at apple.com  Sun Dec  6 00:15:14 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:15:14 -0800
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
<E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
<49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
Message-ID: <4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com>


> On Dec 5, 2015, at 12:54 PM, Alex Blewitt via swift-evolution <swift-evolution at swift.org> wrote:
>
>
>
> Sent from my iPhat 6
>
> On 5 Dec 2015, at 19:23, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:
>
>>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.
>>
>> That's a feature of IDE, not the language itself.
>
> Not necessarily. The existence of "go fmt" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments.
>
> Letting "the IDE" do formatting is fine provided there is a maximum of one IDE.

Just to chime in on this thread with some guidelines for thought:

1) The compiler does have some code smell warnings (e.g. unmutated var -> let).
2) It is really important that these be warnings, not errors.  Turning them into errors makes refactoring code a pain (as commonly complained about in the go community).
3) By doing these sorts of things, the compiler needs to be conservative in its policies - the policies that it enforces has to be unquestionably the right thing to do.

Separate from compiler-enforced policies, I’d *love* to see someone tackle implementing a "go fmt” analog that reformats Swift code into a standard style, as well as a “clang format”  tool that could be used by IDEs for on-the-fly editing of code, as well as a “linter” / static analysis tool which can flag potential issues while having a higher tolerance for false positives.  These should be separate from the “always on” compiler diagnostics though.

-Chris


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/02214089/attachment.html>

From clattner at apple.com  Sun Dec  6 00:20:05 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:20:05 -0800
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
Message-ID: <B13A0695-75A2-445C-858F-7D854C19C326@apple.com>


> On Dec 5, 2015, at 11:24 AM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:
>
> Hi everyone,
>
> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.
>
> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.
>
> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.
>
> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.

Hi Alex,

At this point, we’d prefer that major new features like these be explored and developed as independent projects outside the official Swift repos.  There are a *ton* of really interesting library features that we could add, but for now at least, we’re keeping the Swift standard library laser focused on its “language features + core data structures & algorithms” focus, and keeping the CoreLibs work focused on achieving parity with the Apple implementations of these libraries.

We simply don’t have bandwidth to review and design higher level features at this time.  One of the goals of the Swift package manager is to make it super easy to reuse people’s code, even if it isn’t part of the swift distro.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1fa169b4/attachment.html>

From clattner at apple.com  Sun Dec  6 00:21:57 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:21:57 -0800
Subject: [swift-evolution] A mode with no type checking to compete
with	Python.
In-Reply-To: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
Message-ID: <8FB8385B-F55C-4DB0-B4F8-626D3FAB9AF6@apple.com>


> On Dec 5, 2015, at 11:51 AM, Amir Michail via swift-evolution <swift-evolution at swift.org> wrote:
>
> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also?
>
Hi Amir,

We’re not interested in fragmenting Swift into related-but-different dialects.

-Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0e78296d/attachment.html>

From clattner at apple.com  Sun Dec  6 00:22:45 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:22:45 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
Message-ID: <4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com>


> On Dec 5, 2015, at 11:40 AM, David Hart <david at hartbit.com> wrote:
>
>> This is subtle and requires thought
>
> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.

I responded with some concerns and thoughts on the "Control Flow Expressions” thread.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/3a2215c6/attachment.html>

From clattner at apple.com  Sun Dec  6 00:34:23 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:34:23 -0800
Subject: [swift-evolution] Proposal: helpers for initializing
properties	of same name as parameters
In-Reply-To: <4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
Message-ID: <819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>

On Dec 5, 2015, at 1:03 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:
>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.

As a general comment, at this point, I’d personally prefer to stay away from purely syntactic sugar syntax optimizations, unless they are very broadly applicable across the language.  There are a ton of core things still missing from the swift language and type system, and I’d prefer that we stay focused on that.  Post-Swift 3 we can consider adding a hygienic macro system, and the baking out of other language features may lead to the eliminate for some of the sugar that would otherwise be added.

> I’d like to propose an alternative approach.
>
> Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.

Yes, this is really unfortunate.  The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):

1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.
2) Access control + the memberwise init often requires you to implement it yourself.
3) We don’t get memberwise inits for classes.
4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.
5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).

One of the things missing is the ability to “utter” the memberwise initializer, I’d suggest syntax along the lines of:

memberwise init()    // memberwise is a "decl modifier"

So you could say:

public memberwise init()

to specifically say you want the default one given public access control (for example).


It would be really great for someone to tackle these problems holistically!

-Chris


From clattner at apple.com  Sun Dec  6 00:34:55 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:34:55 -0800
Subject: [swift-evolution] Proposal: helpers for initializing
properties	of same name as parameters
In-Reply-To: <C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com>
<63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com>
<FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com>
<CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com>
<3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com>
<DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com>
<C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com>
Message-ID: <E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com>


> On Dec 5, 2015, at 6:58 PM, David Waite via swift-evolution <swift-evolution at swift.org> wrote:
>
> There is also a set keyword in the language already, although today its use is limited such that it may still be used as an identifier in non-conflicting contexts.

FWIW, “set” is a context sensitive keyword, not an actual keyword.  You can see the list of actual keywords here:

https://github.com/apple/swift/blob/master/include/swift/Parse/Tokens.def

-Chris

>
> -DW
>
>> On Dec 5, 2015, at 7:51 PM, Brent Royal-Gordon <brent at architechies.com> wrote:
>>
>>> I don’t believe any more so than for let or var, which this effectively is a complement for.
>>
>> There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.
>>
>> --
>> Brent Royal-Gordon
>> Architechies
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From 286224043 at qq.com  Sun Dec  6 00:42:43 2015
From: 286224043 at qq.com (QQ Mail)
Date: Sun, 6 Dec 2015 15:42:43 +0900
Subject: [swift-evolution] Proposal: External variable in extension
Message-ID: <C18D130A-F4B5-42A0-8CAA-9B5137B69DB7@qq.com>

Currently possible to add extension to class, so we can separate the implementation to different class files. In some situation this still have some limitations,
For example:

public class Racer {

public var name:String

public init(name:String) {
self.name = name
}
}

public extension Racer {

public var winTimes:Int {
// requires access local variable
}

public func win() {
// need to update local variable
}
}

the method in the extension sometimes need add another variable to store values, if you are extending the system class, that will be very hard to make this happen

So I am thinking, can we add another namespace “external” besides “public, private, internal”, with this we can define a “external var” inside the extension scope.
the variable needs a default value, and only can accessed in the extension scope, the implementation for the example will like this:


public class Racer {

public var name:String

public init(name:String) {
self.name = name
}
}

public extension Racer {

external var _winTimes:Int = 0

public var winTimes:Int {
return _winTimes
}

public func win() {
_winTimes++
}
}
<https://github.com/chenyunguiMilook/swift-evolution#impact-on-existing-code>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c91d6fee/attachment.html>

From elagha2 at illinois.edu  Sun Dec  6 00:42:47 2015
From: elagha2 at illinois.edu (Mosab Elagha)
Date: Sun, 6 Dec 2015 00:42:47 -0600
Subject: [swift-evolution] Proposal: Allow willChange and didChange
observers on a property
In-Reply-To: <9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
References: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
<9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
Message-ID: <CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com>

+1. This feature would allow for a more clean approach in checking the
existing state of a value.

> Also, can a property have these observers as well as the existing ones?

I'm not really familiar with the implementation of the observers, but why
wouldn't it be able to? Maybe didSet can precede didChange in order of
execution if both are implemented, so you can have default behavior when
accessing a value but certain other behavior if it has changed. Or maybe
have willChange/didChange be a property that can be accessed within
willSet/didSet (like oldValue).



-Mosab Elagha

On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <
swift-evolution at swift.org> wrote:

>
> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> It's currently possible to define either or both of the following
> observers on a property:
>
>    - *willSet*, called just before the value is stored
>    - *didSet*, called immediately after the new value is stored
>
> ...
>
> This would mean the following observers could be defined on a property:
>
>    - *willSet*, called just before the value is stored
>    - *willChange*, called just before the value is stored if the value is
>    different to the previous value
>    - *didSet*, called immediately after the new value is stored
>    - *didChange*, called immediately after the new value is stored if the
>    new value is different to the previous value
>
> I’m open to consider a change along these lines, but the proposal would
> have to be fleshed out more.  Presumably it would only work for equatable
> types, right?  Also, can a property have these observers as well as the
> existing ones?  Would it be possible to add *one of* didChange or
> willChange - since less is better?
>
> -Chris
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/bea982b4/attachment.html>

From bee.ography at gmail.com  Sun Dec  6 00:49:19 2015
From: bee.ography at gmail.com (Bee)
Date: Sun, 6 Dec 2015 13:49:19 +0700
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com>
Message-ID: <CAL-BAQv_62_FfxbD2f3jmvz=fMVFKT7z1_T-Epe=TGgyyNhOew@mail.gmail.com>

On Sun, Dec 6, 2015 at 6:55 AM, Amir Michail via swift-evolution <
swift-evolution at swift.org> wrote:

>
> Doesn’t Apple want to teach young people programming as one of its goals?
> If so, having a mode without type safety would be ideal for that.
>

Apple want to teach young people programming, properly. There, I fix it for
you. :)

--
-Bee-
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3fa10892/attachment.html>

From clattner at apple.com  Sun Dec  6 00:52:17 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 22:52:17 -0800
Subject: [swift-evolution] Proposal: Allow willChange and didChange
observers on a property
In-Reply-To: <CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com>
References: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
<9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
<CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com>
Message-ID: <9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com>


> On Dec 5, 2015, at 10:42 PM, Mosab Elagha <elagha2 at illinois.edu> wrote:
>
> +1. This feature would allow for a more clean approach in checking the existing state of a value.
>
> > Also, can a property have these observers as well as the existing ones?
>
> I'm not really familiar with the implementation of the observers, but why wouldn't it be able to? Maybe didSet can precede didChange in order of execution if both are implemented, so you can have default behavior when accessing a value but certain other behavior if it has changed. Or maybe have willChange/didChange be a property that can be accessed within willSet/didSet (like oldValue).

I believe it is possible to implement, I’m just trying to give guidance on the sorts of things a formal proposal should address.

-Chris

>
>
>
> -Mosab Elagha
>
> On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> It's currently possible to define either or both of the following observers on a property:
>> willSet, called just before the value is stored
>> didSet, called immediately after the new value is stored
>
> ...
>
>> This would mean the following observers could be defined on a property:
>> willSet, called just before the value is stored
>> willChange, called just before the value is stored if the value is different to the previous value
>> didSet, called immediately after the new value is stored
>> didChange, called immediately after the new value is stored if the new value is different to the previous value
>
> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?
>
> -Chris
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/39a8e489/attachment.html>

From david at owensd.io  Sun Dec  6 00:59:18 2015
From: david at owensd.io (David Owens II)
Date: Sat, 5 Dec 2015 22:59:18 -0800
Subject: [swift-evolution] access control proposal
In-Reply-To: <CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com>
References: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>
<CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com>
Message-ID: <B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io>

I tend to disagree with this whole concept of access modifiers; what we have today is at least somewhat sane and consistent across all constructs.

As for your example, if other code within your file is leveraging these “private” pieces, doesn’t that suggest that your API model is already wrong? After all, those pieces wouldn’t be used if they weren’t needed. I’m also hard pressed to believe that this is solving a problem that isn’t purely academic.

I’d actually prefer the opposite extreme: I want everything public unless it’s prefixed with an _. To me, the _ prefix adds significantly more contextual awareness that I’m venturing into parts of the construct that are not intended for general use. It has the add benefit that it makes these types of uses grepable within the codebase so audits are quite trivial.

struct F {
func _privateUsage() {}
func publicUsage() {}
}

Right now, I find having to prefix nearly everything with public is extremely annoying.

Humorously enough, I’m actually running into issues with this right now. I’m looking into fixing some of the NSNumber functionality in corelib and the fact that some of the internal state is marked as private means it’s not readably testable nor easy to inspect to validate is doing the right thing.

-David

> On Dec 5, 2015, at 9:04 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:
>
> I agree that there should be an access level that hides implementation details from other types in the same file. However, it shouldn’t replace private, because 1) helper types might benefit from private elements and 2) like you said, backwards compatibility.
>
> On Sat, Dec 5, 2015 at 11:40 PM Ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>
>
> I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:
>
> 1) the meaning of the code changes depending on which file the class is in. It's very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it's better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it's better that the compiler does it automatically.
>
> 2) accessibility by file structure may cause some really short files.
>
> 3) It's impossible to group related classes in one file but still hide implementation details inside each class
>
> I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it's really important to have a separate keyword for backward compatibility, it would be the next best thing.
>
> --
> Ilya Belenkiy
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/57430d82/attachment.html>

From clattner at apple.com  Sun Dec  6 01:02:47 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 23:02:47 -0800
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
In-Reply-To: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
References: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
Message-ID: <B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>

On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:
> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.
>
> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).
>
>
> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).
>
> For example:
> • If an Int is casting to a larger size (Int16 -> Int32)
> • Float -> Double
> • Float -> CGFloat
> • Int -> Float, Double, or CGFloat (but not the other way)
>
> I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?

I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms).  I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.

The problem with doing this today is that there are a lot of dependencies we need to get resolved first.

1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions.  We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions.  We have thoughts on this, but should be discussed in a separate thread if you’re interested.

2. These promotions should be expressible in the library, not hard coded into the compiler.  This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs.  Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.

3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.

There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats.  These issues are separable, and blocked on things like generic properties not being in place.

It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.

-Chris


From clattner at apple.com  Sun Dec  6 01:11:41 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 23:11:41 -0800
Subject: [swift-evolution] fcntl() should be added to the standard
library.
In-Reply-To: <BFC1C4B7-37FE-4C60-A169-793F48823609@me.com>
References: <BFC1C4B7-37FE-4C60-A169-793F48823609@me.com>
Message-ID: <1165FC40-5573-48E9-AD8B-894A2D699693@apple.com>


> On Dec 4, 2015, at 8:36 PM, Bill Abt <babt at me.com> wrote:
>
> The fcntl() API is a variadic standard “C” library and as such not supported currently by Swift.  Any visit to GitHub looking for a socket implementation will invariably find a .c or .mm file included that exposes fcntl() to Swift via a shim.  There are only 3 forms of this API, all returning int.  The first takes 2 integers and sets the 3rd to 0.  The second takes 3 integers.  The last and final form take 2 integers and a void pointer.  Looking at the standard library source, it’s trivial to implement.  It’ll take longer to write the tests than it will to write the functions.  Once implemented, it would eliminate the need for shims for this API.
>
> This seems like one of those obvious things that just haven’t been implemented yet, no?

Hi Bill,

The Swift standard library doesn’t provide this sort of functionality, but I agree that it makes sense for the Darwin/Glibc modules to provide this interface.  We have a system of “overlays” to provide functionality that the clang importer can’t do automatically.  For example, the Glibc overlay is here:
https://github.com/apple/swift/blob/master/stdlib/public/Glibc/Glibc.swift <https://github.com/apple/swift/blob/master/stdlib/public/Glibc/Glibc.swift>

The darwin overlay is more filled out:
https://github.com/apple/swift/blob/master/stdlib/public/SDK/Darwin/Darwin.swift <https://github.com/apple/swift/blob/master/stdlib/public/SDK/Darwin/Darwin.swift>

It doesn’t look like it provides fcntl specifically, but it does provide open, which has the same varargs sort of implementation issues.  Adding support for fcntl to the overlays makes sense in principle to me.

-Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1b6f6211/attachment.html>

From 286224043 at qq.com  Sun Dec  6 01:17:34 2015
From: 286224043 at qq.com (QQ Mail)
Date: Sun, 6 Dec 2015 16:17:34 +0900
Subject: [swift-evolution] Proposal: typealias support protocol constraint
Message-ID: <78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com>

If typealias support protocol constraint, I think we can reuse a lot of code, also more readable

For Example:

typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>

public extension PointCollection {



}



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/bb03e781/attachment.html>

From manav1907 at gmail.com  Sun Dec  6 01:21:00 2015
From: manav1907 at gmail.com (Manav Gabhawala)
Date: Sun, 6 Dec 2015 02:21:00 -0500
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
In-Reply-To: <B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>
References: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
<B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>
<B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>
Message-ID: <etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local>

One suggestion of a way to get around the problem of promotions could be implicit initializers. So you could have one parameter initializers that can be marked with a keyword/attribute like implicit and the compiler can automatically insert the right the initializer in place (kind of like C++ does it except the keyword implicit would be an antonym to the explicit keyword in C++). This could potentially solve the type checker speed and also allow you to move this implementation to the stdlib. It could also potentially have some interesting use cases outside of the std library too. We would also have to consider whether implicit initializers could throw errors and whether they could be failable or not.
IMO implicit initializers should not be able to throw but should be allowed to be failable. For instance, one could have an implicit initializer from a String to NSURL but have it failable too and use a guard let/if let to bind to it (see example later)

So something along the lines of:


class Double {
implicit init(_ f: Float) {
// initializes a double from a float.
}
}

// For the String -> NSURL
class NSURL {
implicit init?(_ str: String) {
// initializes the usual way.
}
}
// And then in at the call site
guard let URL : NSURL = someString
else { return  }
// Do something with someString.


However, because of how Swift is structured and its emphasis on being explicit (which is a great thing), this should only be used sparingly and should be discouraged unless it absolutely makes sense.

Regards,
Manav Gabhawala

On December 6, 2015 at 2:02:51 AM, Chris Lattner via swift-evolution (swift-evolution at swift.org) wrote:

On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:
> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8. It is good that we have to add the cast explicitly and think though the implications.
>
> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).
>
>
> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).
>
> For example:
> • If an Int is casting to a larger size (Int16 -> Int32)
> • Float -> Double
> • Float -> CGFloat
> • Int -> Float, Double, or CGFloat (but not the other way)
>
> I don’t see why these aren’t allowed. The forced casts make my code much less readable. Are the casts above dangerous in a way I am not aware of?

I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms). I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.

The problem with doing this today is that there are a lot of dependencies we need to get resolved first.

1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions. We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions. We have thoughts on this, but should be discussed in a separate thread if you’re interested.

2. These promotions should be expressible in the library, not hard coded into the compiler. This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs. Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.

3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.

There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats. These issues are separable, and blocked on things like generic properties not being in place.

It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.

-Chris

_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ecb33bfa/attachment.html>

From kevin at sb.org  Sun Dec  6 01:23:02 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 05 Dec 2015 23:23:02 -0800
Subject: [swift-evolution] access control proposal
In-Reply-To: <B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io>
References: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>
<CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com>
<B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io>
Message-ID: <1449386582.2217334.459315937.637FDF9A@webmail.messagingengine.com>

On Sat, Dec 5, 2015, at 10:59 PM, David Owens II via swift-evolution wrote:
> I’d actually prefer the opposite extreme: I want everything public unless it’s prefixed with an _. To me, the _ prefix adds significantly more contextual awareness that I’m venturing into parts of the construct that are not intended for general use. It has the add benefit that it makes these types of uses grepable within the codebase so audits are quite trivial.

You can already use a _ prefix today to mark any function/property that
is not meant for general use, even within the confines of the file.
That's what I do; private methods/properties are fair game (if
accessible), but anything that's considered an implementation detail
gets a _ prefix. Applying your proposed rule would actually remove the
ability to use _ to distinguish things like this (and you'd start seeing
__ instead, which is even uglier).

-Kevin Ballard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/a01a6420/attachment.html>

From clattner at apple.com  Sun Dec  6 01:27:20 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 23:27:20 -0800
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
References: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
Message-ID: <C7B2EEB8-0B36-4930-B011-034548511656@apple.com>


> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:
>
> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
>
> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
> I want your opinion on three alternatives:
>
> 1- Do nothing, and use the slightly uglier Swift example when using a cache.
> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
> 3- Add a cache modifier that re-calcualtes when nil.

Hi David,

My preference is:
4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.

The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).

In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.

The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)

A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).

We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.

-Chris



From clattner at apple.com  Sun Dec  6 01:30:37 2015
From: clattner at apple.com (Chris Lattner)
Date: Sat, 5 Dec 2015 23:30:37 -0800
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
In-Reply-To: <etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local>
References: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
<B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>
<B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>
<etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local>
Message-ID: <45715663-0EFA-45BA-8738-3085413B89CD@apple.com>


> On Dec 5, 2015, at 11:21 PM, Manav Gabhawala <manav1907 at gmail.com> wrote:
>
> One suggestion of a way to get around the problem of promotions could be implicit initializers.

Swift has already had a feature to support arbitrary implicit conversion between types: it was madness and got ripped out :-)

I’m not opposed to allowing user-defined implicit conversions, but IMO they need to be limited to a DAG of subtype relationships.

-Chris


> So you could have one parameter initializers that can be marked with a keyword/attribute like implicit and the compiler can automatically insert the right the initializer in place (kind of like C++ does it except the keyword implicit would be an antonym to the explicit keyword in C++). This could potentially solve the type checker speed and also allow you to move this implementation to the stdlib. It could also potentially have some interesting use cases outside of the std library too. We would also have to consider whether implicit initializers could throw errors and whether they could be failable or not.
> IMO implicit initializers should not be able to throw but should be allowed to be failable. For instance, one could have an implicit initializer from a String to NSURL but have it failable too and use a guard let/if let to bind to it (see example later)
>
> So something along the lines of:
>
>
> class Double {
> 	implicit init(_ f: Float) {
> 		// initializes a double from a float.
> 	}
> }
>
> // For the String -> NSURL
> class NSURL {
> 	implicit init?(_ str: String) {
> 		// initializes the usual way.
> 	}
> }
> // And then in at the call site
> guard let URL : NSURL = someString
> else { return  }
> // Do something with someString.
>
>
> However, because of how Swift is structured and its emphasis on being explicit (which is a great thing), this should only be used sparingly and should be discouraged unless it absolutely makes sense.
>
> Regards,
> Manav Gabhawala
>
> On December 6, 2015 at 2:02:51 AM, Chris Lattner via swift-evolution (swift-evolution at swift.org <mailto:swift-evolution at swift.org>) wrote:
>
>> On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com <mailto:jhull at gbis.com>> wrote:
>> > I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8. It is good that we have to add the cast explicitly and think though the implications.
>> >
>> > …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).
>> >
>> >
>> > I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).
>> >
>> > For example:
>> > • If an Int is casting to a larger size (Int16 -> Int32)
>> > • Float -> Double
>> > • Float -> CGFloat
>> > • Int -> Float, Double, or CGFloat (but not the other way)
>> >
>> > I don’t see why these aren’t allowed. The forced casts make my code much less readable. Are the casts above dangerous in a way I am not aware of?
>>
>> I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms). I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.
>>
>> The problem with doing this today is that there are a lot of dependencies we need to get resolved first.
>>
>> 1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions. We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions. We have thoughts on this, but should be discussed in a separate thread if you’re interested.
>>
>> 2. These promotions should be expressible in the library, not hard coded into the compiler. This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs. Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.
>>
>> 3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.
>>
>> There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats. These issues are separable, and blocked on things like generic properties not being in place.
>>
>> It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.
>>
>> -Chris
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f96f8409/attachment.html>

From rvojta at me.com  Sun Dec  6 01:46:18 2015
From: rvojta at me.com (Robert Vojta)
Date: Sun, 06 Dec 2015 08:46:18 +0100
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
<CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
<CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com>
<CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com>
Message-ID: <DCEF9750-F5E0-4639-8D78-8CC37F5A60A3@me.com>



> On 05 Dec 2015, at 22:36, Jacob Bandes-Storch <jtbandes at gmail.com> wrote:
>
> When you use "weak self", self becomes Optional inside the closure, and indeed it *can* become nil partway through. This is the same as __weak in Objective-C, and there's actually a clang warning for it (search for "repeated-use-of-weak" or see http://devstreaming.apple.com/videos/wwdc/2013/404xbx2xvp1eaaqonr8zokm/404/404.pdf).

Yep, that's correct.

> That's why "guard let strongSelf = self" is important, and I think "guard let self = self" would add value without adding confusion.

Agree that weakStrong can be confusing and there's maybe better way to do it. But at least, "guard let self = self" would be enough and we can avoid ugly and long strongSel with it.

Robert
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/53b54f9c/attachment.html>

From kevin at sb.org  Sun Dec  6 02:19:45 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 06 Dec 2015 00:19:45 -0800
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
Message-ID: <1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com>

How would weakStrong work if the closure has a non-Void return type?

Personally, I just use

guard let this = self else { return }

in this scenario. It's not much trouble to type `this.foo` instead of
`self.foo` (it's even the same number of letters).

-Kevin Ballrd

On Sat, Dec 5, 2015, at 03:48 AM, Robert Vojta wrote:
> Hi all,
>
> let’s say we have a completion handler closure for some function
> (networking, …) and we have [weak self] there. Example …
>
> doSomething() { [weak self] result in
>   …
> }
>
> … then we can use self?.whatever to access self properties, methods. Or
> we can try to check if self exists ...
>
> guard let strongSelf = self else { return }
>
> … and use strongSelf.
>
> Can we introduce [weakStrong self] with following behavior:
>
>  - self is a weak reference
>  - when the closure is going to be executed, all weakStrong weak
>  references are checked if they do exist
>  - if they do exist, they’re strong referenced for the closure and the
>  closure is executed
>  - if they don’t exist, closure is not executed
>
> doSomething() { [weakStrong self] result in
>   // Closure code is not executed if self no longer exists
>   // self is a strong reference now
> }
>
> What do you think? Does it make sense?
>
> My motivation is to get rid off of the repetitive code like this one:
>
> doSomething() { [weak self] result in
>   guard let strongSelf = self else { return }
>   strongSelf.doSomethingWithResult(result)
> }
>
> Robert
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From gribozavr at gmail.com  Sun Dec  6 03:11:19 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 01:11:19 -0800
Subject: [swift-evolution] Lazy flatMap for Optionals
In-Reply-To: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>
References: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>
Message-ID: <CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com>

On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney <
oisin.kidney at gmail.com> wrote:

> Currently, several of the methods on SequenceType in the standard library
> have lazy variants. flatMap, though, (seems) to have a version missing:
> while there’s a lazy version for nested sequences, there’s no lazy version
> for sequences of Optionals. Is there maybe a reason for this that I
> haven’t thought of? At any rate, here’s what I had in mind:
>
> public struct FlatMapOptionalGenerator<G: GeneratorType, Element>:
> GeneratorType {
>   private let f: G.Element -> Element?
>   private var g: G
>   public mutating func next() -> Element? {
>     while let x = g.next() {
>       if let y = f(x) {
>         return y
>       }
>     }
>     return nil
>   }
> }
>
> public struct FlatMapOptionalSequence<S: LazySequenceType, Element>:
> LazySequenceType {
>   private let f: S.Generator.Element -> Element?
>   private let s: S
>   public func generate() -> FlatMapOptionalGenerator<S.Generator, Element>
> {
>     return FlatMapOptionalGenerator(f: f, g: s.generate())
>   }
> }
>
> extension LazySequenceType {
>   public func flatMap<T>(transform: Generator.Element -> T?) ->
> FlatMapOptionalSequence<Self, T> {
>     return FlatMapOptionalSequence(f: transform, s: self)
>   }
> }
>
>
Hi,

Thank you for the proposal.

Defining only one overload would cause the collection-ness of the input to
be lost.  Please take a look at the current flatMap() overloads in
stdlib/public/core/FlatMap.swift: there's one in LazySequenceType, another
one in LazyCollectionType, and one more in LazyCollectionType with
bidirectional indices.

I'm also not a fan of introducing a specialized result type for this
operation: given that we need three overloads, this approach would add six
more types to the library (three sequences and three generators).  Current
flatMap() overloads compose existing types, but they rely on intermediate
data structure being a sequence or a collection.  Optional is not a
sequence, so that exact approach won't work here.  Can you think of another
way we could combine existing types to express the result of this operation?

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8a2a6b1a/attachment.html>

From kevin at sb.org  Sun Dec  6 03:21:36 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 06 Dec 2015 01:21:36 -0800
Subject: [swift-evolution] Proposal: Add StaticString.UnicodeScalarView
Message-ID: <1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com>

There's no way to create a substring of `StaticString` that's still
typed as `StaticString`. This is occasionally desirable, for example if
you want to extract the filename from `__FILE__` to pass to another API
that requires a `StaticString`.

I believe the best solution to this is to add a type
`StaticString.UnicodeScalarView`, similar to `String.UnicodeScalarView`.
`StaticString` would also be extended with a property `unicodeScalars`
and two initializers to construct a `StaticString` from a
`String.UnicodeScalarView`. The full proposed API looks like:

extension StaticString {  /// The value of `self` as a collection of
[Unicode scalar values]
(http://www.unicode.org/glossary/#unicode_scalar_value).  public var
unicodeScalars: UnicodeScalarView

/// Construct the `StaticString` corresponding to the given  ///
`UnicodeScalarView`.  public init(_: UnicodeScalarView)

/// Construct the `StaticString` corresponding to the given  ///
`UnicodeScalarView` slice.  public init(_: Slice<UnicodeScalarView>)

/// A collection of [Unicode scalar values]
(http://www.unicode.org/glossary/#unicode_scalar_value) that  /// encode
a `StaticString`.  public struct UnicodeScalarView : CollectionType {

init(_: StaticString)

/// A position in a `StaticString.UnicodeScalarView`.    public struct
Index : BidirectionalIndexType, Comparable {      /// Returns the next
consecutive value after `self`.      ///      /// - Requires: The next
value is representable.      @warn_unused_result      public func
successor() -> Index

/// Returns the previous consecutive value before `self`.      ///
/// - Requires: The previous value is representable.
@warn_unused_result      public func predecessor() -> Index    }

/// The position of the first `UnicodeScalar` if the `StaticString` is
/// non-empty; identical to `endIndex` otherwise.    public var
startIndex: Index

/// The "past the end" position.    ///    /// `endIndex` is not a valid
argument to `subscript`, and is always    /// reachable from
`startIndex` by zero or more applications of    /// `successor()`.
public var endIndex: Index

/// Returns `true` iff `self` is empty.    public var isEmpty: Bool

public subscript(position: Index) -> UnicodeScalar  } }

An alternative would be to make StaticString itself conform to
CollectionType, but this is a bad idea for the same reasons that String
doesn't conform to CollectionType.

-Kevin Ballard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2f52b014/attachment.html>

From lingoerer at gmail.com  Sun Dec  6 03:21:15 2015
From: lingoerer at gmail.com (Roy Fu)
Date: Sun, 6 Dec 2015 17:21:15 +0800
Subject: [swift-evolution] Proposal: Syntax sugar for cps or async functions
similar to the "do try catch" for error handling.
Message-ID: <78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com>

Hi all,

Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:

func someFutureWrappedFunc(input: Int) future-> String{
doSomeStaffInBackground{ (result:String) in
fulfil result
}
}

do{
let resultX = perform someFutureWrappedFunc(param)
let resultY = perform anotherFutureWrappedFunc(resultX)
let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)
self.someLabel.text = final
} timeout let context {
//maybe some additional information
}

the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:

doSomeStaffInBackground { (resultX) -> Void in

doSomeOtherStaff { (resultY) -> Void in

if resultY.someCondition(resultX) {

evenMakesItMadness(resultY) { (final) -> Void in

//finally
}
}
}
}




For more context comparing this async syntax to the ‘do try catch’:

do try catch:
enum Result<T> {
case Success(T)
case Failure(ErrorType)
}

func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{
switch result{
case .Success(let v): return f(v)
case .Failure(let e): return .Failure(e)
}
}

func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {
return {
do{
return try .Success(f($0))
}catch let e{
return .Failure(e)
}
}
}

func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{
return{
switch f($0){
case .Success(let v): return v
case .Failure(let e): throw e
}
}
}

async:

func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {
return{ cont in
async{ f($0)(cont) }
}
}

func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {
return {input in
{cont in
do{
cont(perform f(input))
}catch _{

}
}
}
}

func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{
return{
f(input)({
fulfil $0
})
}
}




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/28d5ed01/attachment.html>

From kevin at sb.org  Sun Dec  6 03:23:56 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 06 Dec 2015 01:23:56 -0800
Subject: [swift-evolution] Proposal: Add StaticString.UnicodeScalarView
In-Reply-To: <1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com>
References: <1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com>
Message-ID: <1449393836.2237188.459355225.09DD7F67@webmail.messagingengine.com>

I've submitted a proposal for this as

https://github.com/apple/swift-evolution/pull/32

I also have an implementation written as

https://github.com/apple/swift/pull/277

-Kevin Ballard

On Sun, Dec 6, 2015, at 01:21 AM, Kevin Ballard wrote:
> There's no way to create a substring of `StaticString` that's still
> typed as `StaticString`. This is occasionally desirable, for example
> if you want to extract the filename from `__FILE__` to pass to another
> API that requires a `StaticString`.
>
> I believe the best solution to this is to add a type
> `StaticString.UnicodeScalarView`, similar to
> `String.UnicodeScalarView`. `StaticString` would also be extended with
> a property `unicodeScalars` and two initializers to construct a
> `StaticString` from a `String.UnicodeScalarView`. The full proposed
> API looks like:
>
> extension StaticString {  /// The value of `self` as a collection of
> [Unicode scalar values]
> (http://www.unicode.org/glossary/#unicode_scalar_value).  public var
> unicodeScalars: UnicodeScalarView
>
> /// Construct the `StaticString` corresponding to the given  ///
> `UnicodeScalarView`.  public init(_: UnicodeScalarView)
>
> /// Construct the `StaticString` corresponding to the given  ///
> `UnicodeScalarView` slice.  public init(_: Slice<UnicodeScalarView>)
>
> /// A collection of [Unicode scalar values]
> (http://www.unicode.org/glossary/#unicode_scalar_value) that  ///
> encode a `StaticString`.  public struct UnicodeScalarView :
> CollectionType {
>
> init(_: StaticString)
>
> /// A position in a `StaticString.UnicodeScalarView`.    public struct
> Index : BidirectionalIndexType, Comparable {      /// Returns the next
> consecutive value after `self`.      ///      /// - Requires: The next
> value is representable.      @warn_unused_result      public func
> successor() -> Index
>
> /// Returns the previous consecutive value before `self`.      ///
> /// - Requires: The previous value is representable.
> @warn_unused_result      public func predecessor() -> Index    }
>
> /// The position of the first `UnicodeScalar` if the `StaticString` is
> /// non-empty; identical to `endIndex` otherwise.    public var
> startIndex: Index
>
> /// The "past the end" position.    ///    /// `endIndex` is not a
> valid argument to `subscript`, and is always    /// reachable from
> `startIndex` by zero or more applications of    /// `successor()`.
> public var endIndex: Index
>
> /// Returns `true` iff `self` is empty.    public var isEmpty: Bool
>
> public subscript(position: Index) -> UnicodeScalar  } }
>
> An alternative would be to make StaticString itself conform to
> CollectionType, but this is a bad idea for the same reasons that
> String doesn't conform to CollectionType.
>
> -Kevin Ballard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/103dd1b8/attachment.html>

From rvojta at me.com  Sun Dec  6 03:30:11 2015
From: rvojta at me.com (Robert Vojta)
Date: Sun, 06 Dec 2015 10:30:11 +0100
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
<1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com>
Message-ID: <D24B0DD2-C149-4DD7-9755-6E5B5BD7F20B@me.com>



> On 06 Dec 2015, at 09:19, Kevin Ballard via swift-evolution <swift-evolution at swift.org> wrote:
>
> How would weakStrong work if the closure has a non-Void return type?

Allowed only for optional (closure) parameters?

doSmth(handler: (() -> Bool)?) { [weakStrong self] in
}

weakStrong makes sense for async only where self (or anything else) can disappear. It does not make sense for @noescape, ...

> Personally, I just use
>
> guard let this = self else { return }
>
> in this scenario. It's not much trouble to type `this.foo` instead of
> `self.foo` (it's even the same number of letters).

Way to do. But if you decide to move code outside the closure you're forced to replace this. with self. or delete this. The code shouldn't differ (this vs self vs strongSelf) if it's in the closure or outside of it.

Robert

From swift-evolution at jacopo.giola.org  Sun Dec  6 03:52:09 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 10:52:09 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
Message-ID: <D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>

+1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.

If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.

Sent from my iPad

> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:
>
> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>
> I very much like specifying what case to fall through into, no matter how we spell it.
>
> - Steve
>
>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>
>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:
>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>
>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>
>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>
>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>
>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>
>> John.
>>
>>>
>>> John.
>>>
>>>>
>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>
>>>> switch op {
>>>> case LOAD_INDIRECT:
>>>>    in0 = memory[in1]
>>>>    fallthrough
>>>> case LOAD:
>>>>    out0 = memory[in0]
>>>> //...
>>>> }
>>>>
>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>
>>>> Cheers,
>>>> John
>>>>
>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:
>>>>>>
>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>
>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>
>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>
>>>>> John.
>>>>>
>>>>>>
>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>
>>>>>> -Kevin Ballard
>>>>>>
>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>
>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>>
>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>
>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>> case .Enum1, .Enum2:
>>>>>>>> expressed as
>>>>>>>> case .Enum1: fallthrough
>>>>>>>> case .Enum2:
>>>>>>>>
>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
>>>>>>>>>
>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>
>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>
>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>
>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>
>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>
>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>
>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>
>>>>>>>>> Thoughts?
>>>>>>>>>
>>>>>>>>> Daniel
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e23f6cd5/attachment.html>

From david at hartbit.com  Sun Dec  6 04:00:45 2015
From: david at hartbit.com (David Hart)
Date: Sun, 6 Dec 2015 11:00:45 +0100
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <C7B2EEB8-0B36-4930-B011-034548511656@apple.com>
References: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
<C7B2EEB8-0B36-4930-B011-034548511656@apple.com>
Message-ID: <99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com>

This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D

This has just become my #1 feature proposal!

Super excited David!

> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:
>>
>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
>>
>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
>> I want your opinion on three alternatives:
>>
>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.
>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
>> 3- Add a cache modifier that re-calcualtes when nil.
>
> Hi David,
>
> My preference is:
> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.
>
> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).
>
> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.
>
> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)
>
> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).
>
> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.
>
> -Chris
>
>

From defrenz98 at hotmail.com  Sun Dec  6 04:01:53 2015
From: defrenz98 at hotmail.com (Davide De Franceschi)
Date: Sun, 6 Dec 2015 10:01:53 +0000
Subject: [swift-evolution] Proposal: weakStrong self in completion
handler closures
In-Reply-To: <CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
<CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
Message-ID: <BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl>

I agree that "weak-strong" is a commonly used (and correct) pattern, and I also wish that there were an easier way to do that. I also did file a radar myself about that.

But I don't have any idea of the correct way of implementing it because the actually desired behaviour in the "failing" case can change depending on your use-case.

Most of the times you just want to `guard let strongSelf = self else { return }`, but that works when you return `Void` and you don't want to manage this "failure" in any other way...
Should `weak-strong` be allowed only for closures that `-> Void`?
What if you want to fire a "completionBlock" anyway?

While the need to remove this common boilerplate feels strong, I'm not certain this would be the right way. Can't really suggest a better alternative though.


> On 5 Dec 2015, at 19:21, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:
>
> Another approach would be to simply allow
>
> guard let self = self else { return }
> On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com <mailto:rvojta at me.com>> wrote:
> Hi all,
>
> let’s say we have a completion handler closure for some function (networking, …) and we have [weak self] there. Example …
>
> doSomething() { [weak self] result in
>   …
> }
>
> … then we can use self?.whatever to access self properties, methods. Or we can try to check if self exists ...
>
> guard let strongSelf = self else { return }
>
> … and use strongSelf.
>
> Can we introduce [weakStrong self] with following behavior:
>
>  - self is a weak reference
>  - when the closure is going to be executed, all weakStrong weak references are checked if they do exist
>  - if they do exist, they’re strong referenced for the closure and the closure is executed
>  - if they don’t exist, closure is not executed
>
> doSomething() { [weakStrong self] result in
>   // Closure code is not executed if self no longer exists
>   // self is a strong reference now
> }
>
> What do you think? Does it make sense?
>
> My motivation is to get rid off of the repetitive code like this one:
>
> doSomething() { [weak self] result in
>   guard let strongSelf = self else { return }
>   strongSelf.doSomethingWithResult(result)
> }
>
> Robert
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/adf18456/attachment.html>

From gribozavr at gmail.com  Sun Dec  6 04:02:51 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 02:02:51 -0800
Subject: [swift-evolution] Proposal: Add StaticString.UnicodeScalarView
In-Reply-To: <1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com>
References: <1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com>
Message-ID: <CA+Y5xYcNsj4qOp5h_Uiz2ysjwj3zS_OwngF0dkQy-EOfPRmEAg@mail.gmail.com>

Hi Kevin,

Thank you for the proposal.  This is in line with the current design of
String.  One of the Swift 3 goals is a redesign of String, to make the API
easier to use.  I don't think that should block this improvement, since
whatever the new design is, it should provide the UnicodeScalar view
functionality for String, and the same API should be exposed on
StaticString.

On Sun, Dec 6, 2015 at 1:21 AM, Kevin Ballard via swift-evolution <
swift-evolution at swift.org> wrote:

> There's no way to create a substring of `StaticString` that's still typed
> as `StaticString`. This is occasionally desirable, for example if you want
> to extract the filename from `__FILE__` to pass to another API that
> requires a `StaticString`.
>
> I believe the best solution to this is to add a type
> `StaticString.UnicodeScalarView`, similar to `String.UnicodeScalarView`.
> `StaticString` would also be extended with a property `unicodeScalars` and
> two initializers to construct a `StaticString` from a
> `String.UnicodeScalarView`. The full proposed API looks like:
>
> extension StaticString {
>   /// The value of `self` as a collection of [Unicode scalar values](
> http://www.unicode.org/glossary/#unicode_scalar_value).
>   public var unicodeScalars: UnicodeScalarView
>
>   /// Construct the `StaticString` corresponding to the given
>   /// `UnicodeScalarView`.
>   public init(_: UnicodeScalarView)
>
>   /// Construct the `StaticString` corresponding to the given
>   /// `UnicodeScalarView` slice.
>   public init(_: Slice<UnicodeScalarView>)
>
>   /// A collection of [Unicode scalar values](
> http://www.unicode.org/glossary/#unicode_scalar_value) that
>   /// encode a `StaticString`.
>   public struct UnicodeScalarView : CollectionType {
>

UnicodeScalarView should be a slice type, that is,
UnicodeScalarView.SubSequence == UnicodeScalarView.

Then, you will be able to remove the
StaticString.init(Slice<UnicodeScalarView>) initializer.

It should also be CustomStringConvertible, CustomDebugStringConvertible,
with the same behavior as String.

Please also add a CustomReflectable conformance, that extracts the string
value and reflects that.

init(_: StaticString)
>
>     /// A position in a `StaticString.UnicodeScalarView`.
>     public struct Index : BidirectionalIndexType, Comparable {
>       /// Returns the next consecutive value after `self`.
>       ///
>       /// - Requires: The next value is representable.
>       @warn_unused_result
>       public func successor() -> Index
>
>       /// Returns the previous consecutive value before `self`.
>       ///
>       /// - Requires: The previous value is representable.
>       @warn_unused_result
>       public func predecessor() -> Index
>     }
>
>     /// The position of the first `UnicodeScalar` if the `StaticString` is
>     /// non-empty; identical to `endIndex` otherwise.
>     public var startIndex: Index
>
>     /// The "past the end" position.
>     ///
>     /// `endIndex` is not a valid argument to `subscript`, and is always
>     /// reachable from `startIndex` by zero or more applications of
>     /// `successor()`.
>     public var endIndex: Index
>
>     /// Returns `true` iff `self` is empty.
>     public var isEmpty: Bool
>
>     public subscript(position: Index) -> UnicodeScalar
>   }
> }
>

You omitted == and < APIs for indices.


> An alternative would be to make StaticString itself conform to
> CollectionType, but this is a bad idea for the same reasons that String
> doesn't conform to CollectionType.
>

Agreed.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3a6a427d/attachment.html>

From macmoonshine at gmx.de  Sun Dec  6 04:03:41 2015
From: macmoonshine at gmx.de (Clemens Wagner)
Date: Sun, 6 Dec 2015 11:03:41 +0100
Subject: [swift-evolution] C-style For Loops
Message-ID: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>

> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.

But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?

I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.

Cheers
Clemens

From possen at gmail.com  Sun Dec  6 04:14:10 2015
From: possen at gmail.com (possen p)
Date: Sun, 6 Dec 2015 02:14:10 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com>
Message-ID: <B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com>

(I originally posted as possen p and since hopefully fixed that)

So, As Kevin Ballard and Ole Bergman pointed out, making a regular “if” an expression has some major complications. Having the potential to return different object types in a strictly typed language will not be easy. Also what to do if the if does not have an else. The ternary operator does not allow the if/else results of different types. In Python doing an expression with if/else is not a problem because it will let you return different types, this is legal, (which makes sense for Python):

val = 10 if p == 5 else “abc"

it will not however let you omit the else part:

val = 10 if False  // produces an error.

so it appears if you assign to an expression in Python it will require the else part. So it is different than a regular if.

So I ask, is making the regular “if" an expression truly desired for Swift? I do see other languages doing it, but it does seem a bit odd to assign from any “if”. In my original proposal I was suggesting that assignment is done like this:

let val = 10 else 40 if p == 5

In this it is very similar to the ternary expression in that else part is required and both types must match, and has improved readability. This is overloading the if/else keywords to provide essentially the same thing as ternary operators..

The following from Kevin Ballard's email:

> let foo = if condition {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }


I find it is hard to tell that the two results are returning a value. To me it looks like it is either ignoring the return value or is returning void.

Maybe emphasizing the assignment would help as below does not have return values in the method names:

let foo if condition {
= dosomething()
} else {
= dosomethingelse()
}

putting the = after the else shows that it is returning a value for the let clause. It also helps emphasize that the return types must match and I think looks better.

Going back to my proposal with the = suggestion:

let foo = dosomething() else = dosomethingelse() if condition

this really shows that the let variable is being assigned.

Note that these are still chainable expressions:

var foo = ((10 else = 40 if p == 5) else = (15 else = 14 if p == 10) if p == 4)

It may be good to make the space optional after the else:

var foo = ((10 else= 40 if p == 5) else= (15 else= 14 if p == 10) if p == 4)

- Paul
















-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7a405aed/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 04:18:24 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 11:18:24 +0100
Subject: [swift-evolution] swift tool project init command
In-Reply-To: <193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com>
References: <193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com>
Message-ID: <D1CFC4EF-BA8D-424A-AD42-83E252C40206@jacopo.giola.org>

+1 to this, but I'm not sure that this mailing list is the right place to discuss evolution of the package manager.
I think you can directly send a pull request to the repository to be evaluated.

Sent from my iPad

> On 05 Dec 2015, at 21:25, Lander Brandt via swift-evolution <swift-evolution at swift.org> wrote:
>
> On the Swift package manager page on swift.org (https://swift.org/package-manager/#example-usage) the requirements for creating a package/application are clearly outlined, but why not include a command in the swift tool for autogenerating the require? I did a quick look and didn’t see any existing discussion, so I apologize if this has already been discussed.
>
> Example of the tool command: `swift init foo --type=(lib|app)`
>
> Would create a new directory called “foo” with the following tree structure for a project of type app:
>
> foo
> ├── Package.swift
> ├── Packages
> ├── README.md
> └── main.swift
>
> And for project of type lib:
>
> foo
> ├── Package.swift
> ├── README.md
> └── Sources
>     └── Foo.swift
>
> In both cases Package.swift would contain something basic like:
>
> import PackageDescription
>
> let package = Package(
>     name: “Foo",
>     dependencies: [
>     ]
> )
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/54d5e5de/attachment.html>

From possen at gmail.com  Sun Dec  6 04:26:26 2015
From: possen at gmail.com (possen p)
Date: Sun, 6 Dec 2015 02:26:26 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com>
<B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com>
Message-ID: <A8D2920B-554C-4495-A6E1-B797802C42A3@gmail.com>

Another idea is put the conditional at the beginning:

let foo if conditional then = 10 else = 20

But that requires an additional keyword to separate out the conditional but might read better.



> On Dec 6, 2015, at 2:14 AM, possen p <possen at gmail.com> wrote:
>
> (I originally posted as possen p and since hopefully fixed that)
>
> So, As Kevin Ballard and Ole Bergman pointed out, making a regular “if” an expression has some major complications. Having the potential to return different object types in a strictly typed language will not be easy. Also what to do if the if does not have an else. The ternary operator does not allow the if/else results of different types. In Python doing an expression with if/else is not a problem because it will let you return different types, this is legal, (which makes sense for Python):
>
> val = 10 if p == 5 else “abc"
>
> it will not however let you omit the else part:
>
> val = 10 if False  // produces an error.
>
> so it appears if you assign to an expression in Python it will require the else part. So it is different than a regular if.
>
> So I ask, is making the regular “if" an expression truly desired for Swift? I do see other languages doing it, but it does seem a bit odd to assign from any “if”. In my original proposal I was suggesting that assignment is done like this:
>
> let val = 10 else 40 if p == 5
>
> In this it is very similar to the ternary expression in that else part is required and both types must match, and has improved readability. This is overloading the if/else keywords to provide essentially the same thing as ternary operators..
>
> The following from Kevin Ballard's email:
>
>> let foo = if condition {
>>     funcWithSideEffectsThatReturnsInt()
>> } else {
>>     funcWithSideEffectsThatReturnsString()
>> }
>
>
> I find it is hard to tell that the two results are returning a value. To me it looks like it is either ignoring the return value or is returning void.
>
> Maybe emphasizing the assignment would help as below does not have return values in the method names:
>
> let foo if condition {
>     = dosomething()
> } else {
>     = dosomethingelse()
> }
>
> putting the = after the else shows that it is returning a value for the let clause. It also helps emphasize that the return types must match and I think looks better.
>
> Going back to my proposal with the = suggestion:
>
> let foo = dosomething() else = dosomethingelse() if condition
>
> this really shows that the let variable is being assigned.
>
> Note that these are still chainable expressions:
>
> var foo = ((10 else = 40 if p == 5) else = (15 else = 14 if p == 10) if p == 4)
>
> It may be good to make the space optional after the else:
>
> var foo = ((10 else= 40 if p == 5) else= (15 else= 14 if p == 10) if p == 4)
>
> - Paul
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/53976f9b/attachment.html>

From adrian.kashivskyy at me.com  Sun Dec  6 04:28:51 2015
From: adrian.kashivskyy at me.com (Adrian Kashivskyy)
Date: Sun, 06 Dec 2015 11:28:51 +0100
Subject: [swift-evolution] Proposal: typealias support protocol
constraint
In-Reply-To: <78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com>
References: <78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com>
Message-ID: <F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com>

I believe this could be achieved using generic typealiases, proposed here: https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html

Pozdrawiam – Regards,
Adrian Kashivskyy

> Wiadomość napisana przez QQ Mail via swift-evolution <swift-evolution at swift.org> w dniu 06.12.2015, o godz. 08:17:
>
> If typealias support protocol constraint, I think we can reuse a lot of code, also more readable
>
> For Example:
>
> typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>
>
> public extension PointCollection {
>
>
>
> }
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/15b6664b/attachment.html>

From rvojta at me.com  Sun Dec  6 05:20:51 2015
From: rvojta at me.com (Robert Vojta)
Date: Sun, 06 Dec 2015 12:20:51 +0100
Subject: [swift-evolution] Proposal: weakStrong self in
completion	handler closures
In-Reply-To: <BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl>
References: <6B853E77-1E06-4246-A823-1D055689FE22@me.com>
<CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com>
<BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl>
Message-ID: <242D65BB-3319-468D-A259-DA1AC28FB5C7@me.com>

> On 6. 12. 2015, at 11:01, Davide De Franceschi via swift-evolution <swift-evolution at swift.org> wrote:
>
> Most of the times you just want to `guard let strongSelf = self else { return }`, but that works when you return `Void` and you don't want to manage this "failure" in any other way...
> Should `weak-strong` be allowed only for closures that `-> Void`?

Can be and result will be optional. But it complicates things and makes it unclear. Which is not good.

> What if you want to fire a "completionBlock" anyway?

Then don't use weakStrong and use weak strong dance.

> While the need to remove this common boilerplate feels strong, I'm not certain this would be the right way. Can't really suggest a better alternative though.

Agree with you. I just wanted to start discussion about it, but not convinced about weakStrong as well.

Probably what Jacob proposed would be enough. Just allow "guard let self = self ..." at least to remove strongSelf, this, ...

Robert

From david at hartbit.com  Sun Dec  6 05:27:06 2015
From: david at hartbit.com (David Hart)
Date: Sun, 6 Dec 2015 12:27:06 +0100
Subject: [swift-evolution] Proposal: Allow willChange and didChange
observers on a property
In-Reply-To: <9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com>
References: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
<9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
<CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com>
<9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com>
Message-ID: <014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com>

Chris, wouldn't that be better designed/implemented with the property delegate functionality Joe Groff is working on?

> On 06 Dec 2015, at 07:52, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>
>
>> On Dec 5, 2015, at 10:42 PM, Mosab Elagha <elagha2 at illinois.edu> wrote:
>>
>> +1. This feature would allow for a more clean approach in checking the existing state of a value.
>>
>> > Also, can a property have these observers as well as the existing ones?
>>
>> I'm not really familiar with the implementation of the observers, but why wouldn't it be able to? Maybe didSet can precede didChange in order of execution if both are implemented, so you can have default behavior when accessing a value but certain other behavior if it has changed. Or maybe have willChange/didChange be a property that can be accessed within willSet/didSet (like oldValue).
>
> I believe it is possible to implement, I’m just trying to give guidance on the sorts of things a formal proposal should address.
>
> -Chris
>
>>
>>
>>
>> -Mosab Elagha
>>
>>> On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> It's currently possible to define either or both of the following observers on a property:
>>>> willSet, called just before the value is stored
>>>> didSet, called immediately after the new value is stored
>>>
>>> ...
>>>
>>>> This would mean the following observers could be defined on a property:
>>>> willSet, called just before the value is stored
>>>> willChange, called just before the value is stored if the value is different to the previous value
>>>> didSet, called immediately after the new value is stored
>>>> didChange, called immediately after the new value is stored if the new value is different to the previous value
>>>
>>> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?
>>>
>>> -Chris
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/764dcf2e/attachment.html>

From me at alexkolov.com  Sun Dec  6 05:56:05 2015
From: me at alexkolov.com (Alexander Kolov)
Date: Sun, 6 Dec 2015 12:56:05 +0100
Subject: [swift-evolution] Proposal: standard logging facility
In-Reply-To: <B13A0695-75A2-445C-858F-7D854C19C326@apple.com>
References: <BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com>
<B13A0695-75A2-445C-858F-7D854C19C326@apple.com>
Message-ID: <A1E5FCF7-C4EF-4126-BB2A-C39028773A18@alexkolov.com>

Thank you for the input, Chris!

I'll do my best to kickstart this project with the spirit of the core library standards and distributive it with package manager. Then maybe we could revisit closer dependency at some later date.

PS. If anyone is interested in participating, please feel free to contact me directly.

Alex

Sent from my iPhone

> On Dec 6, 2015, at 7:20 AM, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 5, 2015, at 11:24 AM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> Hi everyone,
>>
>> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.
>>
>> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.
>> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.
>>
>> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.
>>
>> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.
>
> Hi Alex,
>
> At this point, we’d prefer that major new features like these be explored and developed as independent projects outside the official Swift repos.  There are a *ton* of really interesting library features that we could add, but for now at least, we’re keeping the Swift standard library laser focused on its “language features + core data structures & algorithms” focus, and keeping the CoreLibs work focused on achieving parity with the Apple implementations of these libraries.
>
> We simply don’t have bandwidth to review and design higher level features at this time.  One of the goals of the Swift package manager is to make it super easy to reuse people’s code, even if it isn’t part of the swift distro.
>
> -Chris
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8618ee3b/attachment.html>

From adrian.zubarev at devandartist.com  Sun Dec  6 05:59:16 2015
From: adrian.zubarev at devandartist.com (Adrian Zubarev)
Date: Sun, 6 Dec 2015 12:59:16 +0100
Subject: [swift-evolution]  Request for Discussion: Setup closures
In-Reply-To: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
Message-ID: <etPan.56642314.20830c9b.1f6@mscience.fritz.box>

I come across this topic and I instantly was overwhelmed by this idea of the Setup Closures. I build a little extension just to test it with UIKit. I thought adding this keyword for Setup Closures was a good idea. If we also could remove this in from the closure it would look good on my opinion.

protocol SettableType {

init() // designated initializer
}

extension SettableType {

init(@noescape setup: (this: Self) -> Void) {

self.init()
setup(this: self)
}
}

extension UIView: SettableType {}

let view = UIView()

let questionLabel = UILabel() { this in /// <- REMOVE

this.textAlignment = .Center
this.font = UIFont(name:"SomeFontName", size: 72)
this.text = "Hello World"
this.numberOfLines = 0
view.addSubview(this)
}

—
Regards Adrian

Am 6. Dezember 2015 bei 01:16:31, ilya via swift-evolution (swift-evolution at swift.org) schrieb:

> PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...

FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:

let task = NSTask() +=+ {
    $0.launchPath = "/usr/bin/mdfind"
    $0.arguments = ["kMDItemDisplayName == *.playground"]
    $0.standardOutput = pipe
}

Note you can also use the configured object in the rhs:

let questionLabel = UILabel() +=+ {
    $0.textAlignment = .Center
    $0.font =  UIFont(name:"DnealianManuscript", size: 72)
    $0.text = currentQuestion.questionText
    $0.numberOfLines = 0
    view.addSubview($0)
}

This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):

let questionLabel = UILabel() +=+ {
    .textAlignment = .Center
    .font =  UIFont(name:"DnealianManuscript", size: 72)
    .text = currentQuestion.questionText
    .numberOfLines = 0
    view.addSubview($0)
}

Actually I would be happy with something like

let questionLabel = UILabel() .{
    ..textAlignment = .Center
    ..font = UIFont(name:"DnealianManuscript", size: 72)
    ..text = currentQuestion.questionText
    ..numberOfLines = 0
    view.addSubview($0)
}

Other thoughts?

  
_______________________________________________
swift-evolution mailing list
swift-evolution at swift.org
https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8af1d99d/attachment.html>

From loiclecrenier at icloud.com  Sun Dec  6 06:12:44 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 13:12:44 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
Message-ID: <6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com>

I have drafted a formal proposal here: https://gist.github.com/loiclec/22459d230a21dbcb81fc
Would love to receive feedback from the community on it, I am particularly worried about the correctness of the terms I used.
Should I make a pull request to swift-evolution now, or should we continue the conversation here?

Thanks,

Loïc

(and sorry about emailing you on Sunday 😇 )

> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com> wrote:
>
>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:
>> Hi everyone :)
>>
>> I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.
>>
>> Conceptually, I had something like this:
>>
>> protocol ProtA {
>>  typealias Container : SequenceType
>> }
>> protocol ProtB {
>>  typealias AnOtherAssocType : ProtA
>>  func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
>> }
>>
>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:
>>
>> protocol ProtB {
>>  typealias A : ProtA
>>  typealias Element = A.Container.Generator.Element
>>  func foo(x: Element, y: Element) -> Element
>> }
>>
>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.
>>
>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.
>
> I think this is a great idea; re-using typealias for associated types was a mistake.
>
> John.
>
>>
>> Ideally, I would write
>>
>> protocol ProtB {
>>  associated_type AnOtherAssocType : ProtA
>>  typealias Element = AnOtherAssocType.Container.Generator.Element
>>  func foo(x: Element, y: Element) -> Element
>> }
>>
>> and it would be exactly the same as
>>
>> protocol ProtB {
>>  associated_type AnOtherAssocType : ProtA
>>  func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
>> }
>>
>> There are probably some problems created by this proposal, but right now I can't see any :/
>>
>> Thanks,
>>
>> Loïc
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution


From jhull at gbis.com  Sun Dec  6 06:13:42 2015
From: jhull at gbis.com (Jonathan Hull)
Date: Sun, 6 Dec 2015 04:13:42 -0800
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <etPan.56642314.20830c9b.1f6@mscience.fritz.box>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<etPan.56642314.20830c9b.1f6@mscience.fritz.box>
Message-ID: <F77586E8-94BF-48F3-A379-0088A02C135D@gbis.com>

I often do the following:

let questionLabel:UILabel = {
let label = UILabel()
label.textAlignment = .Center
label.font = UIFont(name:"DnealianManuscript", size: 72)
label.text = currentQuestion.questionText
label.numberOfLines = 0
view.addSubview(label)
return label
}()


> On Dec 6, 2015, at 3:59 AM, Adrian Zubarev via swift-evolution <swift-evolution at swift.org> wrote:
>
>> let questionLabel = UILabel() .{
>>     ..textAlignment = .Center
>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>     ..text = currentQuestion.questionText
>>     ..numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> Other thoughts?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/cf916268/attachment.html>

From thorsten.seitz at web.de  Sun Dec  6 06:32:34 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 13:32:34 +0100
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com>
References: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
<C7B2EEB8-0B36-4930-B011-034548511656@apple.com>
<99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com>
Message-ID: <57598505-6076-4C78-8D09-7F7C01B0D18B@web.de>

Hi all,

I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):

var x : T by Delayed()

with

class Delayed<T> {
var value : T!
func getValue(this: Any?, property: Property<T>) -> T { return value }
func setValue(this: Any?, property: Property<T>, value: T) {
guard x == nil else { abort(„Property \(property) of \(this) has already been initialized when trying to initialize with value \(value)“) }
self.value = value
}
}

Some remarks
* I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error
* Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.
* Is the compiler able to optimize away the overhead of going through getValue on each access?
* I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow

-Thorsten

> Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution <swift-evolution at swift.org>:
>
> This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D
>
> This has just become my #1 feature proposal!
>
> Super excited David!
>
>> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:
>>
>>
>>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:
>>>
>>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
>>>
>>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
>>> I want your opinion on three alternatives:
>>>
>>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.
>>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
>>> 3- Add a cache modifier that re-calcualtes when nil.
>>
>> Hi David,
>>
>> My preference is:
>> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.
>>
>> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).
>>
>> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.
>>
>> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)
>>
>> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).
>>
>> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.
>>
>> -Chris
>>
>>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From matthew at anandabits.com  Sun Dec  6 07:15:12 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 07:15:12 -0600
Subject: [swift-evolution] Proposal: Allow Getters and Setters to Throw
In-Reply-To: <E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com>
References: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>
<DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>
<E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com>
Message-ID: <E3A71685-F75F-46A5-8A35-3ACF38B1C791@anandabits.com>

Great to hear Chris and thanks for mentioning generic subscripts as well.  I have a use case for a generic throwing subscript so I hope patches will be forthcoming.

Sent from my iPad

> On Dec 6, 2015, at 12:07 AM, Chris Lattner <clattner at apple.com> wrote:
>
>
>>> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> One of the aspects of Swift that I like is computed properties for structures and classes. It allows for adding logic when obtaining values or for having the returned value be
>> On Dec 5, 2015, at 7:17 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> +1 to this.  Subscripts should also be able to throw and currently cannot.
>
> +1 from me as well.  Subscripts also currently cannot be generic.
>
> I consider all of these implementation limitations, not intentional parts of the design of Swift.  Patches would be very very welcome to help improve these areas.
>
> -Chris
>
>
>>
>> dependent on another.
>>>
>>> As of the `ErrorType` protocol introduction in Swift 2, we can throw errors when it comes to functions and initializers. However, this does not apply to getters and setters.
>>>
>>> ```swift
>>> struct File<Data> {
>>>     var contents: Data {
>>>         get throws { ... }
>>>         set throws { ... }
>>>     }
>>> }
>>> ```
>>>
>>> A better example would be getting and setting the current working directory of the process:
>>>
>>> ```swift
>>> import Foundation
>>>
>>> extension Process {
>>>     static var workingDirectory: String {
>>>         get {
>>>             let fileManager = NSFileManager.defaultManager()
>>>             return fileManager.currentDirectoryPath
>>>         }
>>>         set throws {
>>>             let fileManager = NSFileManager.defaultManager()
>>>             guard fileManager.changeCurrentDirectoryPath(newValue) else {
>>>                 throw Error("...")
>>>             }
>>>         }
>>>     }
>>> }
>>>
>>>
>>>
>>> ```
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/12f9f69b/attachment-0001.html>

From don.wills at portablesoftware.com  Sun Dec  6 07:44:39 2015
From: don.wills at portablesoftware.com (Don Wills)
Date: Sun, 6 Dec 2015 06:44:39 -0700
Subject: [swift-evolution] Overloading assignment operator
Message-ID: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>

The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded?

Don Wills

From thorsten.seitz at web.de  Sun Dec  6 07:47:23 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 14:47:23 +0100
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <etPan.56642314.20830c9b.1f6@mscience.fritz.box>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<etPan.56642314.20830c9b.1f6@mscience.fritz.box>
Message-ID: <CDAFBA7E-E9E9-443F-BB82-B76ACEBF54E6@web.de>

Nice!
Actually I don’t mind the argument of the closure at all and would probably just name it after the class, i.e. „label“ in the example:

let questionLabel = UILabel() { label in

label.textAlignment = .Center
label.font = UIFont(name:"SomeFontName", size: 72)
label.text = "Hello World"
label.numberOfLines = 0
view.addSubview(label)
}

-Thorsten



> Am 06.12.2015 um 12:59 schrieb Adrian Zubarev via swift-evolution <swift-evolution at swift.org>:
>
> let questionLabel = UILabel() { this in /// <- REMOVE
>
>     this.textAlignment = .Center
>     this.font = UIFont(name:"SomeFontName", size: 72)
>     this.text = "Hello World"
>     this.numberOfLines = 0
>     view.addSubview(this)
> }

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/fb2366f7/attachment.html>

From thorsten.seitz at web.de  Sun Dec  6 07:51:36 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 14:51:36 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>
Message-ID: <FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de>

Why not just „type“?

protocol Foo {
type T
}

-Thorsten



> Am 06.12.2015 um 02:46 schrieb Austin Zheng via swift-evolution <swift-evolution at swift.org>:
>
> I like "associated". Or maybe "withtype". Anything clear and without underscore.
>
> protocol Foo {
>   associated T
> }
>
> protocol Foo {
>  withtype T
> }
>
>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:
>>
>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>>
>> Or merely "associated".
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From a.michail at me.com  Sun Dec  6 08:16:00 2015
From: a.michail at me.com (Amir Michail)
Date: Sun, 06 Dec 2015 09:16:00 -0500
Subject: [swift-evolution] Swift support for automatically sharing small
code fragments with other iOS developers.
Message-ID: <58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com>

With Swift, the programming language is no longer a difficult part of iOS programming. That difficulty now shifts to the iOS frameworks. Although very powerful, these frameworks take time to learn.

So why not allow iOS developers to easily and automatically share small code fragments with each other and have the compiler automatically use them to provide warnings as to how to code various tasks better?

Recommended rewrites by the compiler would only involve small code fragments seen from multiple independent sources and so are unlikely to contain any sensitive code.




From thorsten.seitz at web.de  Sun Dec  6 08:22:06 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 15:22:06 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
Message-ID: <D14076A5-FF22-4708-BFB2-516699EC4520@web.de>

Wouldn’t it be possible to still have if-statements?

When used as expression an if-expression would of course require an else-part, but when used as statement we would still have an if-statement (not an if-expression) and the else-part would be optional just like now.

-Thorsten

> Am 06.12.2015 um 00:12 schrieb Ole Begemann via swift-evolution <swift-evolution at swift.org>:
>
>>> This is subtle and requires thought
>>
>> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.
>
> One thing that comes to mind is that if "if" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:
>
> func doSomething() { ... }
>
> if condition {
>    doSomething()
> }
>
> Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical "imperative" code harder.
>
> – Ole
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From zarzycki at icloud.com  Sun Dec  6 08:22:49 2015
From: zarzycki at icloud.com (David Zarzycki)
Date: Sun, 06 Dec 2015 09:22:49 -0500
Subject: [swift-evolution] Feedback for SE-0004: Remove the ++ and --
operators
In-Reply-To: <F9C56B7C-34E8-40A8-B232-1FA9CC0C1FB6@apple.com>
References: <A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com>
<F9C56B7C-34E8-40A8-B232-1FA9CC0C1FB6@apple.com>
Message-ID: <7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com>


> On Dec 6, 2015, at 00:04, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 5, 2015, at 11:26 AM, David Zarzycki <zarzycki at icloud.com> wrote:
>>
>> Hi Chris,
>>
>> An observation about SE-0004: Remove the ++ and — operators:
>>
>> Given that the above is accepted, the only remaining postfix operator in the language is ‘!’ — and that is implemented by the compiler. Please consider just removing user-defined postfix operators entirely.
>
> Hi Dave!
>
> That is definitely an interesting idea.  In practice, we won’t be able to remove ++/— from the compiler until the ~Spring 2017 release, since Swift 3 will want to parse the old code and reject it with a fixit hint.
>
>> Doing so would define away a type checking ambiguity where “let f = T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.
>
> Besides the general simplification potential for the language, is this a theoretical concern or an actual one?  You can currently do something like “let f = T->T = {$0^}” or “{^$0}” to disambiguate the prefix/postfix forms.

It is just simplification that opens the door to further simplicity and self-consistency within the language. In addition to not needing the above workaround, one could remove the fixity keywords/attributes altogether, because they’d be inferable from context.

If one wants to go deep down the rabbit hole, one could let developers avoid nested parenthesis and the “spiral call syntax problem” by allowing the language to use the same unary operator in either prefix or postfix positions. For example, instead of “(^(-(~x).a).b).c”, one could write “x~.a-.b^.c” to accomplish the same goal.

Dave

From lists at maven.de  Sun Dec  6 08:23:39 2015
From: lists at maven.de (Daniel Vollmer)
Date: Sun, 6 Dec 2015 15:23:39 +0100
Subject: [swift-evolution] Swift support for automatically sharing small
code fragments with other iOS developers.
In-Reply-To: <58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com>
References: <58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com>
Message-ID: <E0E41589-90D2-494D-84D0-D94CCE5A43A3@maven.de>

Hi Amir,

> So why not allow iOS developers to easily and automatically share small code fragments with each other and have the compiler automatically use them to provide warnings as to how to code various tasks better?

As I understand it, this is very much out of scope for *this* project. Swift aims to (eventually) be a general purpose programming language.

What you’re talking about is more relevant to an IDE or development aid for a specific narrowed purpose. You might be better off filing a radar against Xcode for example.

Daniel.


From thorsten.seitz at web.de  Sun Dec  6 08:25:22 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 15:25:22 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<852EF944-A503-4021-8A7F-AE6876438981@gbis.com>
<CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com>
Message-ID: <1FDCAD5A-9937-4464-BD6A-ABECAE2BB853@web.de>

I’d prefer if-expressions to have the same form as if-statements, i.e.

let greeting = if let name = optionalName { "Hello, \(name),“ } else { “To Whom It May Concern:” }

-Thorsten


PS: As an aside this could also be written without an if-expression as follows:

let greeting = name.map(„Hello, \($0),“) ?? “To Whom It May Concern:”


With regards to the question about the required else part:
> Am 06.12.2015 um 01:12 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:
>
> let greeting = “Hello, \(name),” if let name = optionalName else “To Whom It May Concern:”
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/eb3fc4ad/attachment.html>

From don.wills at portablesoftware.com  Sun Dec  6 08:26:55 2015
From: don.wills at portablesoftware.com (Don Wills)
Date: Sun, 6 Dec 2015 07:26:55 -0700
Subject: [swift-evolution] Overloading assignment operator
In-Reply-To: <D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com>
References: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
<D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com>
Message-ID: <93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com>

Silvan,

Yes, I understand the concern you raise.  I too have held that general opinion of overloading operators in other languages for many years.  That said, overloading arithmetic and other operators causes the same opportunity for abuse.  For example, overloading + for integers to do something different (like rounding instead of truncation) would make maintenance of existing programs into a giant guessing game.

That said, once the cat is out of the bag to overload operators, I don't see how adding support for = makes things any worse.

FYI, the reason for my suggestion is to add support for fixed decimal arithmetic just like that available in COBOL.  Yeh I can hear the groans now.  However, for business applications, fixed decimal arithmetic is a basic feature that has been tossed away in new languages by language designers who don't actually labor in the trenches.  I've built a simple class to do just that - here is some sample code that uses my Number class that gives an idea of what the code does:

var amount = Number(left: 6, right: 2);
var result = Number(left: 9, right: 2);
amount <- 3.9;
amount += 1;
result <- amount * 4;
print(result)

Note that <- is the assignment operator.  I am sure all would agree that = is superior in this situation.  Such code would be far more readable and the Number values would act just like and interoperate with Float and Int in all regards *except* that currently the = operator is not available for assignment.

Don Wills

PS.  FWIW, the  IEEE 754-2008 d128 alternative that Chris Lattner mentioned to me is inferior to the kind of support for fixed decimal arithmetic that I believe would help make Swift superior to C# for business applications.


> On Dec 6, 2015, at 6:58 AM, Silvan Mosberger <kametrixom at icloud.com> wrote:
>
> Hi Don
>
> I think this is a terrible idea! Imagine what you’d be able to do with that:
>
> let x : String = 3
>
> This would lead to the same problems already discussed with implicit initialisers: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html <https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html>, just worse. Also assignment is something more fundamental than other operators, I doubt it’s even possible to do that.
>
>> On 06 Dec 2015, at 14:44, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded?
>>
>> Don Wills
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/081dac9b/attachment.html>

From thisisroshansmail at gmail.com  Sun Dec  6 08:29:15 2015
From: thisisroshansmail at gmail.com (Roshan)
Date: Sun, 6 Dec 2015 19:59:15 +0530
Subject: [swift-evolution] Swift support for automatically sharing small
code fragments with other iOS developers.
In-Reply-To: <CAGUyf_Huv+ZFwgOUEJ0xMGY_J66NGyWLJW_TvJyqm43dY3fnWQ@mail.gmail.com>
References: <58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com>
<CAGUyf_Huv+ZFwgOUEJ0xMGY_J66NGyWLJW_TvJyqm43dY3fnWQ@mail.gmail.com>
Message-ID: <CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com>

Correct me if I am wrong, but what you want is to share code fragments from
a given codebase which wouldn't compile on their own(say, because they
depend on parts of the codebase you don't want to share) but do contain
compiler annotations as if they were compiled as part of the original
codebase.

To me this looks like more of a development tool thing than a language
thing.

On Sun, Dec 6, 2015 at 7:56 PM, Roshan <thisisroshansmail at gmail.com> wrote:

> Correct me if I am wrong, but what you want is to share code fragments
> from a given codebase which wouldn't compile on their own(say, because they
> depend on parts of the codebase you don't want to share) but do contain
> compiler annotations as if they were compiled as part of the original
> codebase.
>
> To me this looks like more of a development tool thing than a language
> thing.
>
> On Sun, Dec 6, 2015 at 7:46 PM, Amir Michail via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> With Swift, the programming language is no longer a difficult part of iOS
>> programming. That difficulty now shifts to the iOS frameworks. Although
>> very powerful, these frameworks take time to learn.
>>
>> So why not allow iOS developers to easily and automatically share small
>> code fragments with each other and have the compiler automatically use them
>> to provide warnings as to how to code various tasks better?
>>
>> Recommended rewrites by the compiler would only involve small code
>> fragments seen from multiple independent sources and so are unlikely to
>> contain any sensitive code.
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>
>
>
> --
> Warm regards
> Roshan
>



--
Warm regards
Roshan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/1ad229db/attachment.html>

From a.michail at me.com  Sun Dec  6 08:32:40 2015
From: a.michail at me.com (Amir Michail)
Date: Sun, 06 Dec 2015 09:32:40 -0500
Subject: [swift-evolution] Swift support for automatically sharing small
code fragments with other iOS developers.
In-Reply-To: <CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com>
References: <58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com>
<CAGUyf_Huv+ZFwgOUEJ0xMGY_J66NGyWLJW_TvJyqm43dY3fnWQ@mail.gmail.com>
<CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com>
Message-ID: <FE19364D-CD51-4B20-BF08-681BB7C529FB@me.com>


> On Dec 6, 2015, at 9:29 AM, Roshan <thisisroshansmail at gmail.com> wrote:
>
> Correct me if I am wrong, but what you want is to share code fragments from a given codebase which wouldn't compile on their own(say, because they depend on parts of the codebase you don't want to share) but do contain compiler annotations as if they were compiled as part of the original codebase.
>
> To me this looks like more of a development tool thing than a language thing.

I think the lines between languages, their frameworks, and their tools can be arbitrary sometimes.

In any case, making automatic code fragment sharing part of the language would result in a lot more sharing.

>
> On Sun, Dec 6, 2015 at 7:56 PM, Roshan <thisisroshansmail at gmail.com <mailto:thisisroshansmail at gmail.com>> wrote:
> Correct me if I am wrong, but what you want is to share code fragments from a given codebase which wouldn't compile on their own(say, because they depend on parts of the codebase you don't want to share) but do contain compiler annotations as if they were compiled as part of the original codebase.
>
> To me this looks like more of a development tool thing than a language thing.
>
> On Sun, Dec 6, 2015 at 7:46 PM, Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> With Swift, the programming language is no longer a difficult part of iOS programming. That difficulty now shifts to the iOS frameworks. Although very powerful, these frameworks take time to learn.
>
> So why not allow iOS developers to easily and automatically share small code fragments with each other and have the compiler automatically use them to provide warnings as to how to code various tasks better?
>
> Recommended rewrites by the compiler would only involve small code fragments seen from multiple independent sources and so are unlikely to contain any sensitive code.
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>
> --
> Warm regards
> Roshan
>
>
>
> --
> Warm regards
> Roshan

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c46f84b5/attachment.html>

From matthew at anandabits.com  Sun Dec  6 08:36:22 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 08:36:22 -0600
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <57598505-6076-4C78-8D09-7F7C01B0D18B@web.de>
References: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
<C7B2EEB8-0B36-4930-B011-034548511656@apple.com>
<99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com>
<57598505-6076-4C78-8D09-7F7C01B0D18B@web.de>
Message-ID: <543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com>

Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.

I would really like to see something like `delayed let x : T` to handle the second phase of initialization problem, although I would add the requirement that it *must* be initialized in the second phase and it *cannot* be read until it is set (as far as the compiler can detect this through control flow analysis).  This would behave quite similarly to a simple `let x : T` member but with the caveat that it is possible to blow up if you attempt to read before setting it in the second phase and the compiler cannot detect the read attempt when performing control flow analysis.

If Swift’s property delegates were able to both support let members and require initialization during the second phase (so the instance is guaranteed to be fully initialized and work correctly after initialization completes) then they would be a great solution.  I just can’t imagine how they could enforce this semantic.  I’m looking forward to reading Joe’s proposal and will be delighted if his design is able to support the desired semantics.

Chris, do you agree that this semantic is desirable to support one way or another?

Thorsten’s attempt to implement something like this using a property delegate looks really dangerous to me.  A var member that blows up when somebody attempts to set it a second time seems extremely fragile.  It’s like an IUO but rather than blowing up when read it also blows up when set more than once.

Matthew


> On Dec 6, 2015, at 6:32 AM, Thorsten Seitz via swift-evolution <swift-evolution at swift.org> wrote:
>
> Hi all,
>
> I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):
>
> var x : T by Delayed()
>
> with
>
> class Delayed<T> {
> 	var value : T!
> 	func getValue(this: Any?, property: Property<T>) -> T { return value }
> 	func setValue(this: Any?, property: Property<T>, value: T) {
> 		guard x == nil else { abort(„Property \(property) of \(this) has already been initialized when trying to initialize with value \(value)“) }
> 		self.value = value
> 	}
> }
>
> Some remarks
> * I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error
> * Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.
> * Is the compiler able to optimize away the overhead of going through getValue on each access?
> * I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow
>
> -Thorsten
>
>> Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution <swift-evolution at swift.org>:
>>
>> This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D
>>
>> This has just become my #1 feature proposal!
>>
>> Super excited David!
>>
>>> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:
>>>
>>>
>>>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:
>>>>
>>>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
>>>>
>>>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
>>>> I want your opinion on three alternatives:
>>>>
>>>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.
>>>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
>>>> 3- Add a cache modifier that re-calcualtes when nil.
>>>
>>> Hi David,
>>>
>>> My preference is:
>>> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.
>>>
>>> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).
>>>
>>> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.
>>>
>>> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)
>>>
>>> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).
>>>
>>> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.
>>>
>>> -Chris
>>>
>>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From daniel at dimsumthinking.com  Sun Dec  6 08:40:37 2015
From: daniel at dimsumthinking.com (Daniel Steinberg)
Date: Sun, 6 Dec 2015 09:40:37 -0500
Subject: [swift-evolution] Proposal: Update the API Design Guidelines to
reflect current Standard Library method naming conventions
Message-ID: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>

I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.

Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.

I think the x(), xInPlace() pairs are easier to use than the previous pairs. the inPlace variant is clearly the mutating implementation as the name tells me that the operation is going to be performed in place on the reciever.

Previously the sort methods were named sort() and sorted(). I never could remember which is which. The API Guidelines currently recommend this sort/sorted practice as opposed to  sort/sortInPlace.

I know this is a small issue - given the many important tasks you have before you, but I’d love to see the section “Be Grammatical” revised to update the following advice to match current practice. The following two are not consistent with library practices.

Uses of mutating methods should read as imperative verb phrases, e.g., x.reverse(), x.sort(), x.append(y).

and

When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).

The Swift Programming Language Guide 2.1 reflects the actual use of sort()

For example, the Swift standard library provides both the mutating method sortInPlace() and the nonmutating method sort() to collections whose generator element conforms to the Comparableprotocol.

Note that in the API Guidelines sort() should be mutating and in actuality (and in the Language Guide) sort() is non-mutating.




Thank you,

Daniel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7b277522/attachment.html>

From stephen.celis at gmail.com  Sun Dec  6 08:44:05 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Sun, 6 Dec 2015 09:44:05 -0500
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com>
<FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de>
Message-ID: <9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com>

“type” feels more ambiguous to me with the existence of Foo.Type.

Stephen

> On Dec 6, 2015, at 8:51 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>
> Why not just „type“?
>
> protocol Foo {
>    type T
> }
>
> -Thorsten
>
>
>
>> Am 06.12.2015 um 02:46 schrieb Austin Zheng via swift-evolution <swift-evolution at swift.org>:
>>
>> I like "associated". Or maybe "withtype". Anything clear and without underscore.
>>
>> protocol Foo {
>>  associated T
>> }
>>
>> protocol Foo {
>> withtype T
>> }
>>
>>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like "associatedtype" or perhaps "typeassociation"
>>>
>>> Or merely "associated".
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From cheyo at masters3d.com  Sun Dec  6 08:47:27 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Sun, 6 Dec 2015 08:47:27 -0600
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
Message-ID: <CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>

https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1

On Sunday, December 6, 2015, Clemens Wagner via swift-evolution <
swift-evolution at swift.org> wrote:

> > We’ve developed a number of Swift apps for various clients over the past
> year and have not needed C style for loops either.
>
> But I think this is a very weak reason for *removing* any portion like
> C-loops and increment or decrement operators of a programming language. How
> about the developers and the productive code which used C-style loops
> already?
>
> I understand the reasons why you, Erica and the others don’t like C-style
> loops. But changing the philosophy of a productive programming language is
> a very bad idea.
>
> Cheers
> Clemens
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ac5c649c/attachment.html>

From macmoonshine at gmx.de  Sun Dec  6 08:56:04 2015
From: macmoonshine at gmx.de (Clemens Wagner)
Date: Sun, 6 Dec 2015 15:56:04 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
Message-ID: <B655E20A-3F9D-4B07-B6F1-80A0D81C93F2@gmx.de>

Hi,

a little bit more explanation would be very helpful and welcome.

Cheers
Clemens

> Am 06.12.2015 um 15:47 schrieb J. Cheyo Jimenez <cheyo at masters3d.com>:
>
>
> https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1
>
> On Sunday, December 6, 2015, Clemens Wagner via swift-evolution <swift-evolution at swift.org> wrote:
> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>
> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>
> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>
> Cheers
> Clemens
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From matthew at anandabits.com  Sun Dec  6 09:07:19 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 09:07:19 -0600
Subject: [swift-evolution] Proposal: typealias support protocol
constraint
In-Reply-To: <F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com>
References: <78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com>
<F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com>
Message-ID: <C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com>

This request isn’t really about typealias at all.  It has two elements.

First, it’s about the ability to bind Self and / or associated types in a protocol and use the result as a type.  This is highly desirable and is similar to features in the ML module system.

First is the ability to use a protocol with self or associated types as a type, not just a generic constraint:

protocol<CollectionType where CollectionType.Generator.Element == CGPoint>

I don’t think the `T:` label is necessary here as the protocol name serves as a good identifier in this context.  Although the protocol name could probably be omitted when there is only one protocol here as it is implicit:

protocol<CollectionType where Generator.Element == CGPoint>

The general form of this would look like:

protocol<P1, P2, P3 where *list of constraints*>

In this case the protocol name would be required, at least when more than one protocol in the list have an associated type with the same name (and possibly in all cases).  The list of constraints could identify associated types, bind them to concrete types, constrain Self to a specific superclass, etc.  The Self constraint might look like this:

protocol<P1, P2, P3 where Self: UIViewController>

Ideally we would not need to bind all associated types in the protocol in order to use it at a type, but would only be allowed to use members that do not mention the unbound associated type in their signature.

Once we have the ability to bind associated types and use the result as a type, the typealias use falls out automatically.

Second, it’s about the ability to extend a typealias where some generic constraints are specified in the typealias.  This would allow us to re-use the binding of generic constraints, but could be confusing if the extension is far removed in source from the typealias.  I’m not sure how I feel about this part of the proposal.

Matthew

> On Dec 6, 2015, at 4:28 AM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org> wrote:
>
> I believe this could be achieved using generic typealiases, proposed here: https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html>
>
> Pozdrawiam – Regards,
> Adrian Kashivskyy
>
>> Wiadomość napisana przez QQ Mail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 06.12.2015, o godz. 08:17:
>>
>> If typealias support protocol constraint, I think we can reuse a lot of code, also more readable
>>
>> For Example:
>>
>> typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>
>>
>> public extension PointCollection {
>>
>>
>>
>> }
>>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/09c0f92a/attachment.html>

From michel.fortin at michelf.ca  Sun Dec  6 09:26:33 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sun, 6 Dec 2015 10:26:33 -0500
Subject: [swift-evolution] Type-safe selectors
In-Reply-To: <1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com>
References: <B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca>
<2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com>
<1449271642.2877123.458487961.609100F1@webmail.messagingengine.com>
<B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com>
<1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com>
<8508E135-791E-4B88-A758-9208388DA878@michelf.ca>
<1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com>
<92C8AF30-9249-4152-A24E-86496425BD4D@apple.com>
<1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com>
Message-ID: <1A62EBA8-4AC4-4F05-B486-F90194FE5740@michelf.ca>

Le 5 déc. 2015 à 22:35, Kevin Ballard <kevin at sb.org> a écrit :

> Which is in the context of the fact that @convention(selector) MyObject
> -> Args -> Ret encodes the receiver type, but the problem is the
> selector is sent to AnyObject, so having the receiver type in there is
> basically false type-safety (it looks like it's strongly-typed but it's
> actually not as that type information will be thrown away before the
> selector is used). I'm not really sure why Michel claimed that your
> closure suggestion was a solution to this problem, because the only
> reasonable behavior one can use in such a category emitted on
> AnyObject/swift base class is to fatalError, which is no better than
> what happens if the selector simply isn't implemented.

Somehow in the thinking process I forgot that the category could have been put on MyObject instead of NSObject. I agree it's better to set the category on MyObject.

As for why a category at all? The risk is that another class implements "doSomething:" with a different argument type or return type than the "doSomething:" referring to, and that somehow an object of this other class becomes the target. In that case you want to halt the program to avoid the other "doSomething:" method from being called. That's why I suggested using a unique selector. And that idea came from Joe's suggestion of creating unique selectors from context-free closures.


>> There's plenty of useful space between "no type safety" and "perfect type safety", IMO.
>
> In principle I agree. My basic argument here is that
> @convention(selector) provides so little actual type safety that it's
> not worth the language complexity. And I also worry that providing
> functionality that appears to be strongly-typed but doesn't actually
> provide any typing guarantees in practice will end up as a safety hazard
> for unwary programmers.

This is a reasonable concern. My opinion is that for @convention(selector) to be worthwhile, it needs to be safe.. If it can't be made safe, then maybe the idea probably should be abandoned. I think we are on the same page here, except that I'm more optimistic about type-safety.


> It's also worth pointing out that my alternative suggestion of simply
> providing some syntax to explicitly get a Selector from a method could
> still use your closure-generating idea to work for non- at objc methods.
> Heck, we don't even really need syntax for this, we could just say that
> unbound method references can resolve to Selectors in addition to
> function types (just as the primary suggestion here allows method
> references to resolve to @convention(selector) functions in addition to
> @convention(swift) functions).

Most ideas floating in this thread are actually not mutually exclusive. I wouldn't qualify them as "alternatives" really since they can easily combine. We should look at the tradeoff of each and keep the good ones.


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From loiclecrenier at icloud.com  Sun Dec  6 09:32:05 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 16:32:05 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com>
Message-ID: <3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com>

Well, I went ahead and created a pull request :)

I also included a “proposed approach” section, where I propose to deprecate
the `typealias` keyword for Swift 2.2, and replace it entirely for Swift 3.0.

Does anyone have any thought on that? This is a bit aggressive, but I think it’s worth it.
It is actually the same approach Erica proposed for removing C for-loops.

Loïc

> On Dec 6, 2015, at 1:12 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:
>
> I have drafted a formal proposal here: https://gist.github.com/loiclec/22459d230a21dbcb81fc
> Would love to receive feedback from the community on it, I am particularly worried about the correctness of the terms I used.
> Should I make a pull request to swift-evolution now, or should we continue the conversation here?
>
> Thanks,
>
> Loïc
>
> (and sorry about emailing you on Sunday 😇 )
>
>> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com> wrote:
>>
>>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:
>>> Hi everyone :)
>>>
>>> I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
>>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
>>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
>>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.
>>>
>>> Conceptually, I had something like this:
>>>
>>> protocol ProtA {
>>> typealias Container : SequenceType
>>> }
>>> protocol ProtB {
>>> typealias AnOtherAssocType : ProtA
>>> func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
>>> }
>>>
>>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:
>>>
>>> protocol ProtB {
>>> typealias A : ProtA
>>> typealias Element = A.Container.Generator.Element
>>> func foo(x: Element, y: Element) -> Element
>>> }
>>>
>>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
>>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.
>>>
>>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.
>>
>> I think this is a great idea; re-using typealias for associated types was a mistake.
>>
>> John.
>>
>>>
>>> Ideally, I would write
>>>
>>> protocol ProtB {
>>> associated_type AnOtherAssocType : ProtA
>>> typealias Element = AnOtherAssocType.Container.Generator.Element
>>> func foo(x: Element, y: Element) -> Element
>>> }
>>>
>>> and it would be exactly the same as
>>>
>>> protocol ProtB {
>>> associated_type AnOtherAssocType : ProtA
>>> func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
>>> }
>>>
>>> There are probably some problems created by this proposal, but right now I can't see any :/
>>>
>>> Thanks,
>>>
>>> Loïc
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>


From inboxonly4 at gmail.com  Sun Dec  6 09:33:14 2015
From: inboxonly4 at gmail.com (inbox only)
Date: Sun, 6 Dec 2015 17:33:14 +0200
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
Message-ID: <CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>

True,even that a feature isn't used doesn't mean that you need to remove
that feature.
I hope that the proposal will be rejected.

2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <
swift-evolution at swift.org>:

> > We’ve developed a number of Swift apps for various clients over the past
> year and have not needed C style for loops either.
>
> But I think this is a very weak reason for *removing* any portion like
> C-loops and increment or decrement operators of a programming language. How
> about the developers and the productive code which used C-style loops
> already?
>
> I understand the reasons why you, Erica and the others don’t like C-style
> loops. But changing the philosophy of a productive programming language is
> a very bad idea.
>
> Cheers
> Clemens
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ce1e33b8/attachment.html>

From matthew at anandabits.com  Sun Dec  6 09:41:51 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 09:41:51 -0600
Subject: [swift-evolution] Proposal: helpers for initializing
properties	of same name as parameters
In-Reply-To: <819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>
Message-ID: <475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com>

Thanks for chiming in on this thread.  I definitely understand the desire to wait on features like this until post-Swfit 3 and possibly post-hygienic macros as well.

I would add to your list of memberwise initializer deficiencies the fact that it is “all or nothing”.  I’m wondering what you think of generalizing our “utterance” of the memberwise initializer in a way that allows the flexibility for the initializer itself to handle initialization of some of the members while allowing the compiler to generate the implementation for other members.  I described one idea for doing this in a post last night where I described an @initializable member attribute.  I’m not tied to that specific solution, but I do think it is highly desirable to have complier-generated memberwise initialization that is more flexible than an “all or nothing” solution.  What are your thoughts?

Matthew

> On Dec 6, 2015, at 12:34 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>
> On Dec 5, 2015, at 1:03 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:
>>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.
>
> As a general comment, at this point, I’d personally prefer to stay away from purely syntactic sugar syntax optimizations, unless they are very broadly applicable across the language.  There are a ton of core things still missing from the swift language and type system, and I’d prefer that we stay focused on that.  Post-Swift 3 we can consider adding a hygienic macro system, and the baking out of other language features may lead to the eliminate for some of the sugar that would otherwise be added.
>
>> I’d like to propose an alternative approach.
>>
>> Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.
>
> Yes, this is really unfortunate.  The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):
>
> 1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.
> 2) Access control + the memberwise init often requires you to implement it yourself.
> 3) We don’t get memberwise inits for classes.
> 4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.
> 5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).
>
> One of the things missing is the ability to “utter” the memberwise initializer, I’d suggest syntax along the lines of:
>
>  memberwise init()    // memberwise is a "decl modifier"
>
> So you could say:
>
>  public memberwise init()
>
> to specifically say you want the default one given public access control (for example).
>
>
> It would be really great for someone to tackle these problems holistically!
>
> -Chris
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From thorsten.seitz at web.de  Sun Dec  6 09:57:57 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 16:57:57 +0100
Subject: [swift-evolution] lazy keyword vs lazy initialization pattern
In-Reply-To: <543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com>
References: <C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com>
<C7B2EEB8-0B36-4930-B011-034548511656@apple.com>
<99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com>
<57598505-6076-4C78-8D09-7F7C01B0D18B@web.de>
<543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com>
Message-ID: <87303129-BC13-487E-908D-7D2CC498CDF0@web.de>

Absolutely correct. I’d prefer a statically checked solution, too :-)

-Thorsten


> Am 06.12.2015 um 15:36 schrieb Matthew Johnson via swift-evolution <swift-evolution at swift.org>:
>
> Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.
>
> I would really like to see something like `delayed let x : T` to handle the second phase of initialization problem, although I would add the requirement that it *must* be initialized in the second phase and it *cannot* be read until it is set (as far as the compiler can detect this through control flow analysis).  This would behave quite similarly to a simple `let x : T` member but with the caveat that it is possible to blow up if you attempt to read before setting it in the second phase and the compiler cannot detect the read attempt when performing control flow analysis.
>
> If Swift’s property delegates were able to both support let members and require initialization during the second phase (so the instance is guaranteed to be fully initialized and work correctly after initialization completes) then they would be a great solution.  I just can’t imagine how they could enforce this semantic.  I’m looking forward to reading Joe’s proposal and will be delighted if his design is able to support the desired semantics.
>
> Chris, do you agree that this semantic is desirable to support one way or another?
>
> Thorsten’s attempt to implement something like this using a property delegate looks really dangerous to me.  A var member that blows up when somebody attempts to set it a second time seems extremely fragile.  It’s like an IUO but rather than blowing up when read it also blows up when set more than once.
>
> Matthew
>
>
>> On Dec 6, 2015, at 6:32 AM, Thorsten Seitz via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> Hi all,
>>
>> I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):
>>
>> var x : T by Delayed()
>>
>> with
>>
>> class Delayed<T> {
>> 	var value : T!
>> 	func getValue(this: Any?, property: Property<T>) -> T { return value }
>> 	func setValue(this: Any?, property: Property<T>, value: T) {
>> 		guard x == nil else { abort(„Property \(property) of \(this) has already been initialized when trying to initialize with value \(value)“) }
>> 		self.value = value
>> 	}
>> }
>>
>> Some remarks
>> * I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error
>> * Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.
>> * Is the compiler able to optimize away the overhead of going through getValue on each access?
>> * I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow
>>
>> -Thorsten
>>
>>> Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution <swift-evolution at swift.org>:
>>>
>>> This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D
>>>
>>> This has just become my #1 feature proposal!
>>>
>>> Super excited David!
>>>
>>>> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:
>>>>
>>>>
>>>>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:
>>>>>
>>>>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:
>>>>>
>>>>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.
>>>>> I want your opinion on three alternatives:
>>>>>
>>>>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.
>>>>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).
>>>>> 3- Add a cache modifier that re-calcualtes when nil.
>>>>
>>>> Hi David,
>>>>
>>>> My preference is:
>>>> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.
>>>>
>>>> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).
>>>>
>>>> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.
>>>>
>>>> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)
>>>>
>>>> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).
>>>>
>>>> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.
>>>>
>>>> -Chris
>>>>
>>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From daniel at dimsumthinking.com  Sun Dec  6 10:01:53 2015
From: daniel at dimsumthinking.com (Daniel Steinberg)
Date: Sun, 6 Dec 2015 11:01:53 -0500
Subject: [swift-evolution] Proposal: helpers for initializing
properties	of same name as parameters
In-Reply-To: <819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>
Message-ID: <5B57FA0A-C205-4937-8005-94DD2F69806A@dimsumthinking.com>

Yes! It feels silly to have to re-implement the default initializer just to make it public. I would love to see this.

Daniel
> On Dec 6, 2015, at 1:34 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>
> So you could say:
>
>  public memberwise init()
>
> to specifically say you want the default one given public access control (for example).

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/678e1b5b/attachment.html>

From don.wills at portablesoftware.com  Sun Dec  6 10:03:23 2015
From: don.wills at portablesoftware.com (Don Wills)
Date: Sun, 6 Dec 2015 09:03:23 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
Message-ID: <B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com>

I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.

I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.

Don Wills

> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org> wrote:
>
> True,even that a feature isn't used doesn't mean that you need to remove that feature.
> I hope that the proposal will be rejected.
>
> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>
> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>
> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>
> Cheers
> Clemens
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a4f5d4d1/attachment.html>

From oisin.kidney at gmail.com  Sun Dec  6 10:06:27 2015
From: oisin.kidney at gmail.com (=?utf-8?Q?Donnacha_Ois=C3=ADn_Kidney?=)
Date: Sun, 6 Dec 2015 16:06:27 +0000
Subject: [swift-evolution] Lazy flatMap for Optionals
In-Reply-To: <CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com>
References: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>
<CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com>
Message-ID: <C3D6E59B-95E6-4A39-86C3-7FF7F33C38B5@gmail.com>

(forgot to cc the mailing list)

You can define it in terms of a map-filter-map chain, like this:

extension LazySequenceType {

@warn_unused_result
public func flatMap<T>(transform: Elements.Generator.Element -> T?)
-> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Elements, T?>>, T> {
return self
.map(transform)
.filter { opt in opt != nil }
.map { notNil in notNil! }
}
}

The version for LazyCollectionType can be done similarly:

extension LazyCollectionType {

@warn_unused_result
public func flatMap<T>(transform: Elements.Generator.Element -> T?)
-> LazyMapCollection<LazyFilterCollection<LazyMapCollection<Elements, T?>>, T> {
return self
.map(transform)
.filter { opt in opt != nil }
.map { notNil in notNil! }
}
}

There seems to be no performance overhead vs the custom struct version in my (very preliminary) testing.

The version for a LazyCollectionType with a BidirectionalIndexType would rely on a similar LazyFilterCollection, but a BidirectionalFilterCollection doesn’t exist (I think). Is that something that might be included in this proposal?

Oisin.

> On 6 Dec 2015, at 09:11, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney <oisin.kidney at gmail.com <mailto:oisin.kidney at gmail.com>> wrote:
> Currently, several of the methods on SequenceType in the standard library have lazy variants. flatMap, though, (seems) to have a version missing: while there’s a lazy version for nested sequences, there’s no lazy version for sequences of Optionals. Is there maybe a reason for this that I haven’t thought of? At any rate, here’s what I had in mind:
>
> public struct FlatMapOptionalGenerator<G: GeneratorType, Element>: GeneratorType {
>   private let f: G.Element -> Element?
>   private var g: G
>   public mutating func next() -> Element? {
>     while let x = g.next() {
>       if let y = f(x) {
>         return y
>       }
>     }
>     return nil
>   }
> }
>
> public struct FlatMapOptionalSequence<S: LazySequenceType, Element>: LazySequenceType {
>   private let f: S.Generator.Element -> Element?
>   private let s: S
>   public func generate() -> FlatMapOptionalGenerator<S.Generator, Element> {
>     return FlatMapOptionalGenerator(f: f, g: s.generate())
>   }
> }
>
> extension LazySequenceType {
>   public func flatMap<T>(transform: Generator.Element -> T?) -> FlatMapOptionalSequence<Self, T> {
>     return FlatMapOptionalSequence(f: transform, s: self)
>   }
> }
>
>
> Hi,
>
> Thank you for the proposal.
>
> Defining only one overload would cause the collection-ness of the input to be lost.  Please take a look at the current flatMap() overloads in stdlib/public/core/FlatMap.swift: there's one in LazySequenceType, another one in LazyCollectionType, and one more in LazyCollectionType with bidirectional indices.
>
> I'm also not a fan of introducing a specialized result type for this operation: given that we need three overloads, this approach would add six more types to the library (three sequences and three generators).  Current flatMap() overloads compose existing types, but they rely on intermediate data structure being a sequence or a collection.  Optional is not a sequence, so that exact approach won't work here.  Can you think of another way we could combine existing types to express the result of this operation?
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>>*/

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/50da7034/attachment.html>

From plxswift at icloud.com  Sun Dec  6 10:07:38 2015
From: plxswift at icloud.com (plx)
Date: Sun, 06 Dec 2015 10:07:38 -0600
Subject: [swift-evolution] Inquiry: Improved Composability of stdlib
Collections?
In-Reply-To: <90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com>
References: <C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com>
<90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com>
Message-ID: <A3773EB7-8ED6-4576-97BE-329A3BFB5CF4@icloud.com>


> On Dec 5, 2015, at 8:10 PM, Joe Groff <jgroff at apple.com> wrote:
>
>
>> On Dec 5, 2015, at 11:34 AM, plx via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> Swift’s standard library's core collections' value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set<V>], and plan to mutate the “inner" sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.
>>
>> Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.
>>
>> Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?
>>
>
> Do you have specific examples of problems you're trying to solve?

I'm not entirely sure if you're asking:

1. what are some specific problems with the standard library collections' composability?
2. what are some specific problems with available solutions to the problems in (1)?
3. what are some specific problems for which *performant* nested collections would be useful?

...so I'll answer (1) and (2) quickly, then provide some context for (3).

Before I'll begin, I'll preface this by re-stating what I wanted to know:

- whether or not the problems I see for (1) and (2) are seen as such
- whether or not anything is already on the roadmap to address (1) and (2)

...and in case, thanks for your time and consideration.

For (1), the problem is simply that when you nest Swift's collections -- at least within a `Dictionary`, e.g. `[K:Set<V>]` -- there's currently no direct way to do efficient, in-place mutations of the inner `Set<V>` values; performance here is essentially quadratic (see Appendix A).

That you get ~quadratic performance in this context isn't surprising, given the collections' design; the aspect I see as problematic is the lack of any straightforward way to do any better.

For (2), if you want e.g. all of the following:

- a collection `DictionaryOfSets` behaving ~ [K:Set<V>]
- re-using the basic collection types
- with value-like semantics (e.g. to fit in with the rest of the language)
- with better-than-quadratic performance on updates

...then the following outline seems to be the minimal amount of work to achieve all of the above:

- a class like `class Box<T> { var storage: T }` (etc.)
- a struct like `struct _DictionaryOfSets<K,V> { var storage: [K:Box<Set<V>>] }`
- best if this implements all-or-most of the public API on `DictionaryOfSets`
- knows how to perform a deep copy of `storage`
- a struct like `struct DictionaryOfSets<K,V> { var buffer: ManagedBuffer<_DictionaryOfSets<K,V>,Void> }`
- takes care of checking `isUniquelyReferenced` and making deep-copies when needed
- with ownership now assured, forwards all calls to the buffer's `_DictionaryOfSets`

...which is certainly tractable, but also feels rather disproportionate: to make it work we've now added 2 additional levels of indirection -- one due to the outer `ManagedBuffer`, and one more due to `Box` -- which we only need because we have no other way to manipulate the essentially-equivalent ownership-and-copying-(...etc.) behavior of `Dictionary` and `Set`.

This all feels like it could -- and should! -- be unnecessary, with e.g. some way of indicating an intent to do an in-place update if possible.

As for (3), a surprising amount of application-infrastructure code amounts to babysitting a nested collection of some kind.

As one example, if you want a generic solution to the "pool-and-reuse a bunch of expensive-to-create elements" (consider e.g. `UITableView` or `UICollectionView`), a `[Key:Set<V>]`-like collection is extremely handy:

protocol ReusableComponentType: Equatable, Hashable {
func prepareForPooling()
func prepareForReuse()
var reuseIdentifier: String { get }
}

protocol ComponentFactoryType {
typealias Component: ReusableComponentType
func instantiateComponent(reuseIdentifier: String) -> Component
}

class ReusableComponentPool<Component:ReusableComponentType> {
private var factories: [String:AnyComponentFactory<Component>]
private var poolSizeLimits: [String:Int]
private var reusePool: DictionaryOfSets<String,Component>
// ^ NESTED COLLECTION HERE, ~ [String:Set<Component>]

func dequeueComponentForReuseIdentifier(identifier: String) -> Component {
if let existing = self.reusePool.popFirstElementForKey(identifier) {
existing.prepareForReuse()
} else if let created = self.factories[identifier]?.instantiateComponent(reuseIdentifier: identifier) {
return created
} else {
fatalError("No registered factory for identifier '\(identifier)'!")
}
}

func poolComponentForPotentialReuse(component: Component) {
self.reusePool.insertElement(
component,
forKey: component.identifier
)
}

func drainOverfullPoolsIfNecessary() {
for (identifier,sizeLimit) in self.poolSizeLimits {
self.reusePool.shrinkSetForKey(
identifier,
ifAboveCount: sizeLimit
)
}
}

}

...but it's also a handy thing in other places (tracking active-transfers-by-host as ~`[String:Set<NSURL>]`, tracking discovered characteristics-of-services in `CoreBluetooth` as ~`[CBUUID:Set<CBUUID>]`, tracking invalidated layout attributes by supplementary-element-kind as ~`[String:Set<NSIndexPath>]`, organizing equivalence-classes for certain types of unit tests, and so on).

Note that it's not just `[K:Set<V>]`, either; sometimes `[K:[V]]` is handy, sometimes `[K:[Q:V]]` is handy (and ~ `[(K,Q):V]` isn't right); if Swift's stdlib gets an `OrderedSet` or `OrderedDictionary` there would be uses for those, as well.

Note that although in any specific use-case, you are arguably better off with a specific solution, e.g.:

private class SingleComponentPool<Component:ReusableComponentType> {
let factory: AnyComponentFactory<Component>
let sizeLimit: Int?
var pool: Set<Component>
}

class ReusableComponentPool<Component:ReusableComponentType> {
private var pools: [String:SingleComponentPool<Component>]
}

...instead of the earlier above, there's still arguably a utility to having a fancy collection that can be used in various contexts, with a rich supporting API.

In closing, thanks again for taking the time to read and thanks in advance for any consideration or response.

## Appendix: Concrete Benchmarks

To make the sure the performance implications are clear:

func test10BareInserts() {
self.measureBlock() {
var target = Set<Int>()
for index in 0..<10 {
target.insert(index)
}
}
}

func test10NestedInserts() {
self.measureBlock() {
var target = [Int:Set<Int>]()
var target[0] = Set<Int>()
for index in 0..<10 {
target[0]?.insert(index)
}
}
}

...and so on, for e.g. `test100*`, `test1000*`, ...etc. Here's how this performs:

- 10 inserts:
- bare:   *0.000003
- nested: *0.000008
- 100 inserts:
- bare:   *0.000012
- nested: *0.000073
- 1000 inserts:
- bare:  *0.000081
- nested: 0.003
- 10000 inserts:
- bare:   0.001
- nested: 0.431
- 100000 inserts:
- bare:   0.009
- nested: 41.937
- 1000000 inserts:
- bare:   0.112
- nested: ????? (didn't run, but > 1 hr if trend continues...)

...(where the un-marked values are average times, and those marked `*` are eyeballed modes over the runs, since XCTest seemingly rounds averages < 0.001 to 0.000). Tested under a Release build, FWIW.

As always whether this matters depends on problem-size and context.

> -Joe
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/52b25439/attachment.html>

From zarzycki at icloud.com  Sun Dec  6 10:20:04 2015
From: zarzycki at icloud.com (David Zarzycki)
Date: Sun, 06 Dec 2015 11:20:04 -0500
Subject: [swift-evolution] Feedback for SE-0004: Remove the ++ and --
operators
In-Reply-To: <2A7A8B2A-97F2-4364-9817-B28B0FA687C4@gbis.com>
References: <A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com>
<2A7A8B2A-97F2-4364-9817-B28B0FA687C4@gbis.com>
Message-ID: <B6FE292E-AD5C-417D-8F79-96EF7AECCF35@icloud.com>

Hi Jonathan,

This is really cool. Thanks for sharing! As I responded to Chris later in the thread (and to use different words), I do agree that postfix syntax is really useful, and arguably better than prefix syntax. What I was ultimately suggesting was that if Swift only had “unary” operators, then one can freely use them in either postfix or prefix positions. Just use whatever is natural for your code. The only downside of what I was suggesting is that one cannot have *different* behavior for a given operator just based on its prefix or postfix position.

Cheers,
Dave

> On Dec 6, 2015, at 10:40, Jonathan Hull <jhull at gbis.com> wrote:
>
> TL;DR: Please don’t remove custom postfix operators.
>
> I actually rely on the custom postfix operators a great deal.
>
> My first real swift project was to write a PEG parser where you define the grammar rules in swift itself (which allows the rules and code to be intermixed freely… which is super useful). I can call functions or execute a block upon a match.
>
> The grammar uses a bunch of custom operators including several postfix ones.  Here is a snippet of rules for a grammar which allows complex math equations (This is swift code in a rules() method)
>
> rule("mathFunc")        <- word & ( %"mathFuncParams" | %"mathEmptyParams")
> rule("mathFuncParams")  <~ "("¡ ~ %"mathExpr" ~ (","¡ ~ %"mathExpr")* ~ ")"¡
> rule("mathEmptyParams") <~ "("¡ ~ ")"¡
>
> The only reason this works at all is that there are several overloaded operators
> <-		Define rule
> <~		Define rule ignoring whitespace
> &   		Sequence
> ~ 		Same as &, but ignore whitespace
> |		Ordered Choice
> postfix *	Repeat 0 or more times
> postfix ¡	Discard token
> prefix %	Reference to rule
>
> As mentioned above, this is useful because I can intermix swift code and PEG rules:
>
> rule("boolCompare") <~ %"mathExpr" ~ %"boolCompareType" ~ %"mathExpr"=^{s in
>     let rhs = s.stack.popMath()!
>     let comp = s.stack.popStr()!
>     let lhs = s.stack.popMath()!
>     s.stack.push(Token.boolExpr(ComparisonExpr(lhs:lhs,rhs:rhs,comparison:comp)))
> }
>
> (Above: Whenever the rhs mathExpr matches, it runs code which pops the tokens off the stack and replaces them with a token representing the comparison)
>
> I have several projects which depend on this code, which I wouldn’t be able to do without custom operators (and postfix operators make it a lot closer to the standard PEG notation)
>
> Please don’t remove custom postfix operators.
>
> Thanks,
> Jon
>
>
>
>> On Dec 5, 2015, at 11:26 AM, David Zarzycki via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> Hi Chris,
>>
>> An observation about SE-0004: Remove the ++ and — operators:
>>
>> Given that the above is accepted, the only remaining postfix operator in the language is ‘!’ — and that is implemented by the compiler. Please consider just removing user-defined postfix operators entirely. Doing so would define away a type checking ambiguity where “let f : T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.
>>
>> Cheers, Dave _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7a869ecf/attachment.html>

From thorsten.seitz at web.de  Sun Dec  6 10:25:07 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 17:25:07 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
Message-ID: <49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>

> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:
>
> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>
> if (condition) {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> but that's not a valid expression (what is its type?).

That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/).

In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.

-Thorsten

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/6a725920/attachment.html>

From david at alkaline-solutions.com  Sun Dec  6 10:31:30 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sun, 6 Dec 2015 09:31:30 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
<B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com>
Message-ID: <112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com>

Nearly every for loop I’ve written in other languages has used pre or post increment (depending on the language), which is being removed in Swift 3.0. It makes sense for 'for loops' to go if pre/post increment goes away.

-DW

> On Dec 6, 2015, at 9:03 AM, Don Wills via swift-evolution <swift-evolution at swift.org> wrote:
>
> I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.
>
> I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.
>
> Don Wills
>
>> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> True,even that a feature isn't used doesn't mean that you need to remove that feature.
>> I hope that the proposal will be rejected.
>>
>> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>
>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>>
>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>>
>> Cheers
>> Clemens
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/d1636ae1/attachment.html>

From thorsten.seitz at web.de  Sun Dec  6 10:36:00 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 17:36:00 +0100
Subject: [swift-evolution] Proposal: Syntax sugar for cps or async
functions similar to the "do try catch" for error handling.
In-Reply-To: <78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com>
References: <78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com>
Message-ID: <51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de>

Hi Roy,

I’d prefer if such special syntax would not be reserved for just async computations but used for monadic computations in general (with the async case just being a monad implementation).

-Thorsten

> Am 06.12.2015 um 10:21 schrieb Roy Fu via swift-evolution <swift-evolution at swift.org>:
>
> Hi all,
>
> Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:
>
> func someFutureWrappedFunc(input: Int) future-> String{
>     doSomeStaffInBackground{ (result:String) in
>         fulfil result
>     }
> }
>
> do{
>     let resultX = perform someFutureWrappedFunc(param)
>     let resultY = perform anotherFutureWrappedFunc(resultX)
>     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)
>     self.someLabel.text = final
> } timeout let context {
>     //maybe some additional information
> }
>
> the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:
>
> doSomeStaffInBackground { (resultX) -> Void in
>
>     doSomeOtherStaff { (resultY) -> Void in
>
>         if resultY.someCondition(resultX) {
>
>             evenMakesItMadness(resultY) { (final) -> Void in
>
>                 //finally
>             }
>         }
>     }
> }
>
>
>
>
> For more context comparing this async syntax to the ‘do try catch’:
>
> do try catch:
> enum Result<T> {
>     case Success(T)
>     case Failure(ErrorType)
> }
>
> func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{
>     switch result{
>     case .Success(let v): return f(v)
>     case .Failure(let e): return .Failure(e)
>     }
> }
>
> func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {
>     return {
>         do{
>             return try .Success(f($0))
>         }catch let e{
>             return .Failure(e)
>         }
>     }
> }
>
> func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{
>     return{
>         switch f($0){
>         case .Success(let v): return v
>         case .Failure(let e): throw e
>         }
>     }
> }
>
> async:
>
> func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {
>     return{ cont in
>         async{ f($0)(cont) }
>     }
> }
>
> func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {
>     return {input in
>         {cont in
>             do{
>                 cont(perform f(input))
>             }catch _{
>
>             }
>         }
>     }
> }
>
> func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{
>     return{
>         f(input)({
>             fulfil $0
>         })
>     }
> }
>
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e5669d6f/attachment.html>

From vinivendra at gmail.com  Sun Dec  6 10:36:35 2015
From: vinivendra at gmail.com (Vinicius Vendramini)
Date: Sun, 6 Dec 2015 11:36:35 -0500
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com>
Message-ID: <0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com>

While I understand the motivation behind this change, I think it’s pretty far from paying the addition of a new language feature. Is this

let questionLabel = UILabel() {
$0.textAlignment = .Center
$0.font =  UIFont(name:"DnealianManuscript", size: 72)
$0.text = currentQuestion.questionText
$0.numberOfLines = 0
view.addSubview($0)
}

really that much better than this?

let label = UILabel()

label.textAlignment = .Center
label.font =  UIFont(name:"DnealianManuscript", size: 72)
label.text = currentQuestion.questionText
label.numberOfLines = 0
view.addSubview(label)

To be honest, the second looks much more readable to me. I like the indentation of the first one, but that doesn’t sound like enough of a reason: one could easily re-indent the lines to one’s liking (which actually looks kinda good with 4-spaces indentation, since `var` or `let` plus a space equals 4 characters:)

let label = UILabel()
label.textAlignment = .Center
label.font =  UIFont(name:"DnealianManuscript", size: 72)
label.text = currentQuestion.questionText
label.numberOfLines = 0
view.addSubview(label)

As far as I understand the proposals so far, this approach only changes the way we’d write the initialization, but doesn’t actually allow us to do something that couldn’t be done earlier (e.g. access internal members, change immutable variables…) right?


> On Dec 5, 2015, at 11:31 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>
> As stated previously, I think a more specific solution is the best way to address the initialization / setup / configuration problem. While that is the case I did think some more about the ideas in this thread.
>
> I believe two things are being proposed here:
>
> 1. The ability to append a trailing closure to any initializer (that doesn’t already declare one itself) that accepts a single argument of the initialized type.  If the caller supplies such a closure, the compiler performs a code transformation as follows:
>
> let questionLabel = UILabel() {
> 	$0.textAlignment = .Center
> 	$0.font =  UIFont(name:"DnealianManuscript", size: 72)
> 	$0.numberOfLines = 0
> }
>
> becomes something like this (which is valid Swift today:
>
> let questionLabel = UILabel(); {
> 	$0.textAlignment = .Center
> 	$0.font =  UIFont(name:"DnealianManuscript", size: 72)
> 	$0.numberOfLines = 0
> }(questionLabel)
>
> The code transformation doesn’t actually buy us much.  I’m a big believer in removing the need for clutter and boilerplate as much as possible, but even I must admit that the difference is really small and can be reduced a bit further using currently valid Swift code as demonstrated by the “configuration operator” mentioned in the previous post.
>
> 2. A new abbreviation of the $0 shorthand that would be valid only as the first characters on a line of code.  For consistency this shorthand should work in any closure, not just in “setup closures”.  I agree that $0 is uglier than necessary in this use case which would be relatively common in Cocoa code if this pattern becomes common.
>
> The biggest drawback I can think of to a feature like this is that it is a feature specifically designed to make the use of var members more convenient.  It might be a good thing that “setup closures" are a little bit ugly given that they are only able to “setup" mutable members and require those members to be initialized to potentially meaningless default values (or worse, IUO members defaulted to nil!).
>
> Ideally an instance would be configured correctly when the initializer completes and we should work to find language solutions to make this safe and convenient.  Once we have the right language solutions ideally we can use them in new types and retrofit existing types to use them over time, thus eliminating the need for “setup closures” alltogether.
>
>
>> On Dec 5, 2015, at 6:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>
>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>
>> let task = NSTask() +=+ {
>>     $0.launchPath = "/usr/bin/mdfind"
>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>     $0.standardOutput = pipe
>> }
>>
>> Note you can also use the configured object in the rhs:
>>
>> let questionLabel = UILabel() +=+ {
>>     $0.textAlignment = .Center
>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>     $0.text = currentQuestion.questionText
>>     $0.numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>
>> let questionLabel = UILabel() +=+ {
>>     .textAlignment = .Center
>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>     .text = currentQuestion.questionText
>>     .numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> Actually I would be happy with something like
>>
>> let questionLabel = UILabel() .{
>>     ..textAlignment = .Center
>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>     ..text = currentQuestion.questionText
>>     ..numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> Other thoughts?
>>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7966251b/attachment.html>

From clattner at apple.com  Sun Dec  6 10:42:45 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 06 Dec 2015 08:42:45 -0800
Subject: [swift-evolution] Proposal: Allow willChange and didChange
observers on a property
In-Reply-To: <014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com>
References: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
<9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
<CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com>
<9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com>
<014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com>
Message-ID: <6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com>

Yes, it that proposal is capable of expressing this, then that is how I would prefer property observers in general to work.

-Chris

> On Dec 6, 2015, at 3:27 AM, David Hart <david at hartbit.com> wrote:
>
> Chris, wouldn't that be better designed/implemented with the property delegate functionality Joe Groff is working on?
>
>> On 06 Dec 2015, at 07:52, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>>
>>
>>> On Dec 5, 2015, at 10:42 PM, Mosab Elagha <elagha2 at illinois.edu> wrote:
>>>
>>> +1. This feature would allow for a more clean approach in checking the existing state of a value.
>>>
>>> > Also, can a property have these observers as well as the existing ones?
>>>
>>> I'm not really familiar with the implementation of the observers, but why wouldn't it be able to? Maybe didSet can precede didChange in order of execution if both are implemented, so you can have default behavior when accessing a value but certain other behavior if it has changed. Or maybe have willChange/didChange be a property that can be accessed within willSet/didSet (like oldValue).
>>
>> I believe it is possible to implement, I’m just trying to give guidance on the sorts of things a formal proposal should address.
>>
>> -Chris
>>
>>>
>>>
>>>
>>> -Mosab Elagha
>>>
>>>> On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>
>>>>> It's currently possible to define either or both of the following observers on a property:
>>>>> willSet, called just before the value is stored
>>>>> didSet, called immediately after the new value is stored
>>>>
>>>> ...
>>>>
>>>>> This would mean the following observers could be defined on a property:
>>>>> willSet, called just before the value is stored
>>>>> willChange, called just before the value is stored if the value is different to the previous value
>>>>> didSet, called immediately after the new value is stored
>>>>> didChange, called immediately after the new value is stored if the new value is different to the previous value
>>>>
>>>> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?
>>>>
>>>> -Chris
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/fbde7bda/attachment.html>

From anthony.parker at apple.com  Sun Dec  6 10:47:37 2015
From: anthony.parker at apple.com (Tony Parker)
Date: Sun, 06 Dec 2015 08:47:37 -0800
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Conforming
NSDate to Comparable
In-Reply-To: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
Message-ID: <CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com>

Hi Chris,

Thanks for bringing this idea to the list.

Is NSDate really the only thing that we want to conform to comparable, or is there a set of classes which should do so? I’d like to think about the larger set of consequences here (and if possible, deal with one coherent answer for all of Foundation rather than do these classes one at a time).

- Tony

> On Dec 5, 2015, at 3:36 PM, Chris Amanse via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:
>
> Hello Swift Developers,
>
> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:
>
> if someDate.compare(today) == .OrderedAscending { }
>
> Developers can easily compare using compare dates using comparison operators:
>
> if someDate < today { }
>
> In my opinion, the code is still readable if developers use comparison operators on NSDates.
>
> Here's a quick implementation from my swift-corelibs-foundation fork: https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916 <https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916>
>
> Thank you.
>  _______________________________________________
> swift-corelibs-dev mailing list
> swift-corelibs-dev at swift.org
> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/0e12d731/attachment.html>

From thorsten.seitz at web.de  Sun Dec  6 10:52:03 2015
From: thorsten.seitz at web.de (Thorsten Seitz)
Date: Sun, 6 Dec 2015 17:52:03 +0100
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
<7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
<B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
Message-ID: <9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de>

+1

-Thorsten

> Am 06.12.2015 um 01:13 schrieb Austin Zheng via swift-evolution <swift-evolution at swift.org>:
>
> No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.
>
> Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.
>
> Austin
>
>> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>
>>
>>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> ml>
>>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.
>>
>> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?
>>
>>>
>>> Austin
>>>
>>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>>>>
>>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>>>>
>>>> --
>>>> Kevin Lundberg
>>>>
>>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>>>>
>>>>> Regards,
>>>>> Adrian Kashivskyy
>>>>> iOS Developer at Netguru
>>>>>
>>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>>>>
>>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> --rbÚḟîẁ
>>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/ma <https://lists.swift.org/ma>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a74e56ac/attachment.html>

From matthew at anandabits.com  Sun Dec  6 10:59:05 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 10:59:05 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com>
<0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com>
Message-ID: <AA0220E6-BD02-4B04-98DF-C73C00F8FB0C@anandabits.com>

I agree that this is pretty far from paying for a language feature.  I much prefer the ideas we are discussing in the "helpers for initializing properties of same name as parameters" thread for reasons already stated.

Sent from my iPad

> On Dec 6, 2015, at 10:36 AM, Vinicius Vendramini <vinivendra at gmail.com> wrote:
>
> While I understand the motivation behind this change, I think it’s pretty far from paying the addition of a new language feature. Is this
>
> let questionLabel = UILabel() {
>     $0.textAlignment = .Center
>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>     $0.text = currentQuestion.questionText
>     $0.numberOfLines = 0
>     view.addSubview($0)
> }
>
> really that much better than this?
>
> let label = UILabel()
>
> label.textAlignment = .Center
> label.font =  UIFont(name:"DnealianManuscript", size: 72)
> label.text = currentQuestion.questionText
> label.numberOfLines = 0
> view.addSubview(label)
>
> To be honest, the second looks much more readable to me. I like the indentation of the first one, but that doesn’t sound like enough of a reason: one could easily re-indent the lines to one’s liking (which actually looks kinda good with 4-spaces indentation, since `var` or `let` plus a space equals 4 characters:)
>
> let label = UILabel()
>     label.textAlignment = .Center
>     label.font =  UIFont(name:"DnealianManuscript", size: 72)
>     label.text = currentQuestion.questionText
>     label.numberOfLines = 0
>     view.addSubview(label)
>
> As far as I understand the proposals so far, this approach only changes the way we’d write the initialization, but doesn’t actually allow us to do something that couldn’t be done earlier (e.g. access internal members, change immutable variables…) right?
>
>
>> On Dec 5, 2015, at 11:31 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> As stated previously, I think a more specific solution is the best way to address the initialization / setup / configuration problem. While that is the case I did think some more about the ideas in this thread.
>>
>> I believe two things are being proposed here:
>>
>> 1. The ability to append a trailing closure to any initializer (that doesn’t already declare one itself) that accepts a single argument of the initialized type.  If the caller supplies such a closure, the compiler performs a code transformation as follows:
>>
>> let questionLabel = UILabel() {
>> 	$0.textAlignment = .Center
>> 	$0.font =  UIFont(name:"DnealianManuscript", size: 72)
>> 	$0.numberOfLines = 0
>> }
>>
>> becomes something like this (which is valid Swift today:
>>
>> let questionLabel = UILabel(); {
>> 	$0.textAlignment = .Center
>> 	$0.font =  UIFont(name:"DnealianManuscript", size: 72)
>> 	$0.numberOfLines = 0
>> }(questionLabel)
>>
>> The code transformation doesn’t actually buy us much.  I’m a big believer in removing the need for clutter and boilerplate as much as possible, but even I must admit that the difference is really small and can be reduced a bit further using currently valid Swift code as demonstrated by the “configuration operator” mentioned in the previous post.
>>
>> 2. A new abbreviation of the $0 shorthand that would be valid only as the first characters on a line of code.  For consistency this shorthand should work in any closure, not just in “setup closures”.  I agree that $0 is uglier than necessary in this use case which would be relatively common in Cocoa code if this pattern becomes common.
>>
>> The biggest drawback I can think of to a feature like this is that it is a feature specifically designed to make the use of var members more convenient.  It might be a good thing that “setup closures" are a little bit ugly given that they are only able to “setup" mutable members and require those members to be initialized to potentially meaningless default values (or worse, IUO members defaulted to nil!).
>>
>> Ideally an instance would be configured correctly when the initializer completes and we should work to find language solutions to make this safe and convenient.  Once we have the right language solutions ideally we can use them in new types and retrofit existing types to use them over time, thus eliminating the need for “setup closures” alltogether.
>>
>>
>>> On Dec 5, 2015, at 6:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>
>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>
>>> let task = NSTask() +=+ {
>>>     $0.launchPath = "/usr/bin/mdfind"
>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>     $0.standardOutput = pipe
>>> }
>>>
>>> Note you can also use the configured object in the rhs:
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     $0.textAlignment = .Center
>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     $0.text = currentQuestion.questionText
>>>     $0.numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     .textAlignment = .Center
>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     .text = currentQuestion.questionText
>>>     .numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Actually I would be happy with something like
>>>
>>> let questionLabel = UILabel() .{
>>>     ..textAlignment = .Center
>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>     ..text = currentQuestion.questionText
>>>     ..numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Other thoughts?
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/dbd3ca02/attachment.html>

From erica at ericasadun.com  Sun Dec  6 10:59:14 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 09:59:14 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
Message-ID: <40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>

Last week, I made the following proposal for Swift:

The C-style for-loop appears to be a mechanical carry-over from C rather than a genuinely Swift-specific construct. It is rarely used and not very Swift-like.

More Swift-typical construction is already available with for-in statements and stride. Removing for loops would simplify the language and starve the most common use-points for -- and ++, which are already due to be eliminated from the language.

The value of this construct is limited and I believe its removal should be seriously considered.

Yesterday, I was on family time. Today, I am grabbing a little Swift-break to respond to the discussion I otherwise missed on-list. Please forgive the lateness of this response.

Lack of Language Necessity

Clemens writes:
> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.


But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?

I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.

I don't think the C-style loop was ever really part of the language philosophy. It feels like a vestigial feature that no one ever got around to cleaning up. Its entire functionality is easily replaced by other, existing Swift constructs. While Swift design deliberately held onto C-like features for familiarity, I see no special benefit to retaining the for-loop.

In contrast, consider fallthrough. There was a discussion on Friday about fallthrough, and it quickly became apparent that losing this language feature would have a significant impact on a few key algorithms. Several list participant were able to pop forward and say "without this feature, I would not be able to do X, Y or Z". I see no parallel case to be made for for-loops.

Lowered Readability and Maintainability

I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged.

For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:
Roland King writes:

for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
{
// more than a few lines of code with early escape continues
}

shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.

Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.

Another complaint regarded a loss of succinctness. Per Melin wrote:

Another example from the same LinkedList class. It finds the right place to insert a new node:

for next = head; next != nil && index > 0; prev = next, next = next!.next, --index { }

Extreme? Probably, but I like it better than the same thing done in five lines of while loop.

I'd argue that readability and maintainability are core API goals. Clarity is always to be preferred to brevity. Let me point you to Justin Etheredge's essay "Don't be clever" (http://www.codethinked.com/dont-be-clever).

So next time you go to write a super clever line of code, think to yourself "Will the benefits of this super cleverness be outweighed by the future issues in maintaining and understanding the code?" And if there is anyhesitation at all, then you better not be clever, because 3 months from now you will come across that code and say "What the hell was I thinking?" Then you’ll end up rewriting it anyway.

Incrementor Challenges

Another complaint involved forgetting or misplacing the incrementor when transforming items to while loops. There are two cases being glommed together here, and I'd like to separate them.

First, there's a collection case, in which the collection provides its own indices. In such implementations, there's simply no need to manually declare and manage an index. You can use for-in.

Second, there's what I'm going to call the bitmap case, where an index may refer to geometrically-related indices, which happens often in image processing. (I'm going to repress any "Just use Accelerate" rant. This is a significant area of programming).  Here's some pseudocode that demonstrates how this might look in a for-loop-less Swift implementation:

for row in 0..<height {
for column in 0..<width {
var sum: UInt = 0
for rowOffset in -1...1 {
for columnOffset in -1...1 {
let index = pixelOffsetAt(row + rowOffset, column + columnOffset) + redChannelOffset
sum += pixels[index]
}
}
let currentRedPixelBlurredAverage = sum / 9
// blah blah other stuff
}
}

Again, I don't see anything that would limit relative indexing  with this proposal.

The Skip Case

Matthijs Hollemans writes,

Another benefit of a C-style for loop is that it simply ignores the loop when n <= i, as in the following example,

for var i = 100; i < n; ++i { ...

while the Swifty version gives an error because it cannot create a range where the end is smaller than the start:

for i in 100..<n { ...

Of course, you can add an if-statement to catch this but in the C-style loop this is implicit. Hence, it is more expressive.

I may be in the minority but I rather like that this becomes an error. The "skip" behavior reads to me as an unintended side-effect rather than a purposeful design goal. I prefer a philosophy that minimizes such possibilities in a safe modern language.

Issues of Type

Roland King writes,

I must be the only person who still likes C-style for loops on occasion. eg a loop with something floating point

I counter that stride addresses this for all conforming strideable types, not just floating point values.

Training Costs and Migration Benefits

The main argument against losing the feature seems to be the higher training costs for C-style coders and the higher porting costs for existing C-code.  I'd argue that the training costs to a new language are significant and whether there's a C-style for loop will not materially change those overall costs, especially for those moving from Objective-C where the for-in loop is common. Second, porting to Swift should be motivated by an enhancement of safety and maintainability. Swift already supports external calls to C routines. If you want to keep your code in C, there's nothing stopping you from doing so. (Or to put it in American Politician-speak, "If you like your C-code, you can keep your C-code")

More Direct Swift Replacements

After all this discussion, let me end with a suggestion proposed by Joe Groff for anyone who would still miss the for-loop by approximating the same control flow in native Swift:


func cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {
// left as an exercise
}

var i = 0
cStyleFor(init: i = 0, test: i < 10, inc: ++i) {
print(i)
}

-Joe

The only feature this does not include, as pointed out by list members, is a co-declared variable binding. In a C-style for-loop, the "i" is bound as part of the declaration. In this implementation, it requires a separate declaration line and remains in the scope for its lifetime.

Wrap-up

I hope I have addressed the concerns brought up on-list. If I missed one of yours please feel free to reply. The voting and review period will be between 7 Dec and 10 Dec. Here is the master schedule: https://github.com/apple/swift-evolution/blob/master/schedule.md

Best regards,

-- Erica



> On Dec 6, 2015, at 7:47 AM, J. Cheyo Jimenez via swift-evolution <swift-evolution at swift.org> wrote:
>
>
> https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1 <https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1>
>
> On Sunday, December 6, 2015, Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>
> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>
> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>
> Cheers
> Clemens
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <javascript:;>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/1b756a86/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 11:02:33 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 12:02:33 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
Message-ID: <CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>

What if we left the if { ...} else { ... } syntax alone (as a statement),
and updated the ternary expression to be a more general pattern matching
expression (closer to "switch")? Something like

let x = condition ?
true: "Hello"
false: "Goodbye"

let x = optionalValue ?
.Some(let unwrapped): "Hello, \(unwrapped)"
.None: "To Whom It May Concern"

let myFavoriteColor = yourFavoriteColor ?
.Blue: .Red
.Green: .Blue
.Red: .Green

let quadrant = (x, y) ?
let (x, y) where x < 50 && y < 50: "top left"
let (x, y) where x < 50 && y > 50: "bottom left"
let (x, y) where x > 50 && y < 50: "top right"
default: "bottom right"

The colon comes from the fact that this is sort of a light-weight
expression-based "switch" statement, where each branch can only contain an
expression, not a series of statements.

This is very similar to pattern matching expressions in languages like
Haskell, ML, and Coq.

On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de>
wrote:

> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
> swift-evolution at swift.org>:
>
> I don't think you can just get rid of the if statement in favor of an
> expression. You still want to be able to do this:
>
> if (condition) {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> but that's not a valid expression (what is its type?).
>
>
> That would actually be no problem if Swift’s type system would have union
> types (Ceylon has union and intersection types which are quite awesome and
> enable lots of nice things quite naturally, see
> http://ceylon-lang.org/documentation/1.2/tour/types/).
>
> In that case the type of such an expression would just be the union of
> both types, which is written Int | String in Ceylon.
>
> -Thorsten
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/1de1f743/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 11:06:40 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 12:06:40 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
Message-ID: <CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com>

To elaborate, the reason I like this is that I think it fits with Swift's
general pattern (no pun intended) of extending familiar C syntactic forms
to work with functional features. C's enums become Algebraic Datatypes; C's
switch statements become pattern-matching statements; C's if and for and
while statements are also updated with pattern-matching abilities.

The ternary operator is C's answer to the "if-as-an-expression" question.
So why can't a modified version be our answer to the
"pattern-matching-as-an-expression" question?

It also has the advantage of being more explicit than the original ternary
operator -- having to label the true: and false: cases makes it clearer
what you're trying to achieve.

On Sun, Dec 6, 2015 at 12:02 PM, Alex Lew <alexl.mail+swift at gmail.com>
wrote:

> What if we left the if { ...} else { ... } syntax alone (as a statement),
> and updated the ternary expression to be a more general pattern matching
> expression (closer to "switch")? Something like
>
> let x = condition ?
>    true: "Hello"
>    false: "Goodbye"
>
> let x = optionalValue ?
>    .Some(let unwrapped): "Hello, \(unwrapped)"
>    .None: "To Whom It May Concern"
>
> let myFavoriteColor = yourFavoriteColor ?
>     .Blue: .Red
>     .Green: .Blue
>     .Red: .Green
>
> let quadrant = (x, y) ?
>     let (x, y) where x < 50 && y < 50: "top left"
>     let (x, y) where x < 50 && y > 50: "bottom left"
>     let (x, y) where x > 50 && y < 50: "top right"
>     default: "bottom right"
>
> The colon comes from the fact that this is sort of a light-weight
> expression-based "switch" statement, where each branch can only contain an
> expression, not a series of statements.
>
> This is very similar to pattern matching expressions in languages like
> Haskell, ML, and Coq.
>
> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de>
> wrote:
>
>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
>> swift-evolution at swift.org>:
>>
>> I don't think you can just get rid of the if statement in favor of an
>> expression. You still want to be able to do this:
>>
>> if (condition) {
>>     funcWithSideEffectsThatReturnsInt()
>> } else {
>>     funcWithSideEffectsThatReturnsString()
>> }
>>
>> but that's not a valid expression (what is its type?).
>>
>>
>> That would actually be no problem if Swift’s type system would have union
>> types (Ceylon has union and intersection types which are quite awesome and
>> enable lots of nice things quite naturally, see
>> http://ceylon-lang.org/documentation/1.2/tour/types/).
>>
>> In that case the type of such an expression would just be the union of
>> both types, which is written Int | String in Ceylon.
>>
>> -Thorsten
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/6d869248/attachment.html>

From erica at ericasadun.com  Sun Dec  6 11:07:35 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 10:07:35 -0700
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
<E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
<49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
<4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com>
Message-ID: <9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com>

On Dec 5, 2015, at 11:15 PM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
> Separate from compiler-enforced policies, I’d *love* to see someone tackle implementing a "go fmt” analog that reformats Swift code into a standard style, as well as a “clang format”  tool that could be used by IDEs for on-the-fly editing of code, as well as a “linter” / static analysis tool which can flag potential issues while having a higher tolerance for false positives.  These should be separate from the “always on” compiler diagnostics though.
>
> -Chris

I have a fairly minimal held-together-by-bandaids linter I put together:

https://github.com/erica/testlint

I have hesitated to develop it much further because I didn't want to be committed to inter-process SourceKit hacking and did not yet have access to a reliable parse tree. In its current state, it's a regex-based line-by-line scan.

The rules it follows are here: https://github.com/erica/testlint/blob/master/testlint/sources/Linter.m
with fairly copious commenting


-- Erica


From macmoonshine at gmx.de  Sun Dec  6 11:08:21 2015
From: macmoonshine at gmx.de (Clemens Wagner)
Date: Sun, 6 Dec 2015 18:08:21 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
<B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com>
<112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com>
Message-ID: <9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de>

I think removing the increment and decrement operators is just another bad idea. They are well known and frequently used by many developers. But discussing an approved proposal would be pointless. :( In my opinion Swift will be unusable if fundamental features will change every year. Some kind of stability in the language would be highly appreciated by Swift users.

Clemens

> Am 06.12.2015 um 17:31 schrieb David Waite via swift-evolution <swift-evolution at swift.org>:
>
> Nearly every for loop I’ve written in other languages has used pre or post increment (depending on the language), which is being removed in Swift 3.0. It makes sense for 'for loops' to go if pre/post increment goes away.
>
> -DW
>
>> On Dec 6, 2015, at 9:03 AM, Don Wills via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.
>>
>> I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.
>>
>> Don Wills
>>
>>> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> True,even that a feature isn't used doesn't mean that you need to remove that feature.
>>> I hope that the proposal will be rejected.
>>>
>>> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org>:
>>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>>
>>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>>>
>>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>>>
>>> Cheers
>>> Clemens
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From erica at ericasadun.com  Sun Dec  6 11:10:46 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 10:10:46 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
Message-ID: <8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>

I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/).

Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.

-- E


> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>
> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>
> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>
> let task = NSTask() +=+ {
>     $0.launchPath = "/usr/bin/mdfind"
>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>     $0.standardOutput = pipe
> }
>
> Note you can also use the configured object in the rhs:
>
> let questionLabel = UILabel() +=+ {
>     $0.textAlignment = .Center
>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>     $0.text = currentQuestion.questionText
>     $0.numberOfLines = 0
>     view.addSubview($0)
> }
>
> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>
> let questionLabel = UILabel() +=+ {
>     .textAlignment = .Center
>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>     .text = currentQuestion.questionText
>     .numberOfLines = 0
>     view.addSubview($0)
> }
>
> Actually I would be happy with something like
>
> let questionLabel = UILabel() .{
>     ..textAlignment = .Center
>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>     ..text = currentQuestion.questionText
>     ..numberOfLines = 0
>     view.addSubview($0)
> }
>
> Other thoughts?
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/444bab91/attachment.html>

From sean at fifthace.com  Sun Dec  6 11:11:43 2015
From: sean at fifthace.com (Sean Heber)
Date: Sun, 6 Dec 2015 11:11:43 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
Message-ID: <4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>

I really like this train of thought. +1

l8r
Sean


> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:
>
> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>
> let x = condition ?
>    true: "Hello"
>    false: "Goodbye"
>
> let x = optionalValue ?
>    .Some(let unwrapped): "Hello, \(unwrapped)"
>    .None: "To Whom It May Concern"
>
> let myFavoriteColor = yourFavoriteColor ?
>     .Blue: .Red
>     .Green: .Blue
>     .Red: .Green
>
> let quadrant = (x, y) ?
>     let (x, y) where x < 50 && y < 50: "top left"
>     let (x, y) where x < 50 && y > 50: "bottom left"
>     let (x, y) where x > 50 && y < 50: "top right"
>     default: "bottom right"
>
> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>
> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>
> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:
>>>
>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>
>>> if (condition) {
>>>     funcWithSideEffectsThatReturnsInt()
>>> } else {
>>>     funcWithSideEffectsThatReturnsString()
>>> }
>>>
>>> but that's not a valid expression (what is its type?).
>>
>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/).
>>
>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.
>>
>> -Thorsten
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/d5ad25da/attachment.html>

From scanon at apple.com  Sun Dec  6 11:16:27 2015
From: scanon at apple.com (Steve Canon)
Date: Sun, 06 Dec 2015 12:16:27 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
Message-ID: <0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com>


> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org>
>
> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.

Detecting this in general is solving the halting problem, so such a check isn't actually feasible.  One could warn when termination can't be proved, but making it a hard error would remove much of the usefulness for implementing interpreters.

- Steve

From erica at ericasadun.com  Sun Dec  6 11:26:08 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 10:26:08 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <94756ED2-71C9-4FF3-B3BA-2CB35975B5C4@anandabits.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<94756ED2-71C9-4FF3-B3BA-2CB35975B5C4@anandabits.com>
Message-ID: <4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com>

Matthew, I'll look for it and see what's there. More and more I'm thinking there are in fact two distinct problems to be solved: one that maintains self in a cascade of operations, and another that extends initializers, even for constants.

I'm hesitant to coalesce and summarize all this discussion yet because I'm already committed to championing the for-loop proposal but it seems that it would be really valuable right now to lay out the two side-by-side and discuss that plus your helpers-for-initializing-peroperties-of-same-name-as-parameters.

-- E
p.s. In my head, I'm thinking that the compiler must check in setup closures or self-specific-closures for potential overlaps between properties and existing symbols


> On Dec 6, 2015, at 10:22 AM, Matthew Johnson <matthew at anandabits.com> wrote:
>
> Hi Erica,
>
> You might be interested in a possible language feature I described in the "helpers for initializing properties of same name as parameters" thread last night.  It is intended to address the desire for concise, safe and flexible initialization without needing to sacrifice immutability.   I would love to hear your thoughts on the list if you have a chance to read through it.
>
> Thanks,
> Matthew
>
> Sent from my iPad
>
> On Dec 6, 2015, at 11:10 AM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>
>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>
>> -- E
>>
>>
>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>
>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>
>>> let task = NSTask() +=+ {
>>>     $0.launchPath = "/usr/bin/mdfind"
>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>     $0.standardOutput = pipe
>>> }
>>>
>>> Note you can also use the configured object in the rhs:
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     $0.textAlignment = .Center
>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     $0.text = currentQuestion.questionText
>>>     $0.numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     .textAlignment = .Center
>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     .text = currentQuestion.questionText
>>>     .numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Actually I would be happy with something like
>>>
>>> let questionLabel = UILabel() .{
>>>     ..textAlignment = .Center
>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>     ..text = currentQuestion.questionText
>>>     ..numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Other thoughts?
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/760e1ca1/attachment-0001.html>

From rainer at brockerhoff.net  Sun Dec  6 11:32:46 2015
From: rainer at brockerhoff.net (Rainer Brockerhoff)
Date: Sun, 6 Dec 2015 15:32:46 -0200
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <mailman.517.1449360158.15739.swift-evolution@swift.org>
References: <mailman.517.1449360158.15739.swift-evolution@swift.org>
Message-ID: <5664713E.1050702@brockerhoff.net>

On 12/5/15 22:02, swift-evolution-request at swift.org wrote:
> Date: Sat, 05 Dec 2015 18:23:28 -0500
> From: Steve Canon <scanon at apple.com>
> To: John McCall <rjmccall at apple.com>
> Message-ID: <CA6BFF82-A212-41B6-8104-A0527E84D31C at apple.com>
>
> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>
> I very much like specifying what case to fall through into, no matter how we spell it.

It's somewhat funny seeing you guys all avoiding the word "goto"... :-)
Hey, it's just a unconditional branch!

Now seriously, in a past incarnation I used C in very resource-limited
contexts (both in execution time and code size) and goto-ing around
inside a switch statement was often the only solution.

Not that porting Swift to a Raspberry Zero should be a short-term goal,
but if the current "fallthrough" stays in whatever incarnation, I'd be
happy.

Typing this in reminded me of a possible way to allow common code to be
executed at the end of some cases, but not others: before the switch,
set up a closure (or an array or dict of closures, whatever) and call
that as the case's last statement; no doubt you-all would have
suggestions about properly scoping such a thing.

--
Rainer Brockerhoff  <rainer at brockerhoff.net>
Belo Horizonte, Brazil
"In the affairs of others even fools are wise
In their own business even sages err."
http://brockerhoff.net/blog/

From swift-evolution at jacopo.giola.org  Sun Dec  6 11:46:16 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 18:46:16 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com>
Message-ID: <6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org>

Well, you caught me, I was thinking of a static analyzer check but for whatever reason my hands typed compiler check. Go figure.

In the static analyzer this check can be feasible? I know is not a memory leak, but at least he can see if the code flow inside a switch with reswitch statements will continue to go around on the same cases.
But this is only my wild guess, without a clue on what a static analyzer can do :)

- Jacopo

> On 06 Dec 2015, at 18:16, Steve Canon <scanon at apple.com> wrote:
>
>
>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org>
>>
>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>
> Detecting this in general is solving the halting problem, so such a check isn't actually feasible.  One could warn when termination can't be proved, but making it a hard error would remove much of the usefulness for implementing interpreters.
>
> - Steve


From stephen.celis at gmail.com  Sun Dec  6 11:48:21 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Sun, 6 Dec 2015 12:48:21 -0500
Subject: [swift-evolution] [swift-corelibs-dev] Proposal: Conforming
NSDate to Comparable
In-Reply-To: <CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com>
References: <CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com>
<CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com>
Message-ID: <90204A78-4C14-4A1E-9F99-4FFF1FDDFCC2@gmail.com>

Seems to me that anything with `-compare:` could conform to Comparable. The list, however, is surprisingly short, and half bridge over to native Swift types that are already Comparable:

- [NSDate compare:]
- [NSIndexPath compare:]
- [NSNumber compare:]
- [NSString compare:]

Looks like NSIndexPath may be the only other contender.

Stephen

> On Dec 6, 2015, at 11:47 AM, Tony Parker via swift-evolution <swift-evolution at swift.org> wrote:
>
> Hi Chris,
>
> Thanks for bringing this idea to the list.
>
> Is NSDate really the only thing that we want to conform to comparable, or is there a set of classes which should do so? I’d like to think about the larger set of consequences here (and if possible, deal with one coherent answer for all of Foundation rather than do these classes one at a time).
>
> - Tony
>
>> On Dec 5, 2015, at 3:36 PM, Chris Amanse via swift-corelibs-dev <swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>> wrote:
>>
>> Hello Swift Developers,
>>
>> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:
>>
>> if someDate.compare(today) == .OrderedAscending { }
>>
>> Developers can easily compare using compare dates using comparison operators:
>>
>> if someDate < today { }
>>
>> In my opinion, the code is still readable if developers use comparison operators on NSDates.
>>
>> Here's a quick implementation from my swift-corelibs-foundation fork: https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916 <https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916>
>>
>> Thank you.
>>  _______________________________________________
>> swift-corelibs-dev mailing list
>> swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev <https://lists.swift.org/mailman/listinfo/swift-corelibs-dev>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/763ce37d/attachment.html>

From p at greendale.se  Sun Dec  6 12:08:43 2015
From: p at greendale.se (Per Melin)
Date: Sun, 6 Dec 2015 19:08:43 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
Message-ID: <CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com>

On Sun, Dec 6, 2015 at 5:59 PM, Erica Sadun via swift-evolution <
swift-evolution at swift.org> wrote:

> Another complaint regarded a loss of succinctness. Per Melin wrote:
>
> Another example from the same LinkedList class. It finds the right place
> to insert a new node:
>
>   for next = head; next != nil && index > 0; prev = next, next = next!.
> next, --index { }
>
> Extreme? Probably, but I like it better than the same thing done in five
> lines of while loop.
>
>
>
No worries, but for the record, I did absolutely not write that. I *quoted*
that. I think that C-style 'for' is a horrible mess that should be killed
with fire.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/5413cf2e/attachment.html>

From erica at ericasadun.com  Sun Dec  6 12:10:36 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 11:10:36 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com>
Message-ID: <3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com>

On Dec 6, 2015, at 11:08 AM, Per Melin <p at greendale.se> wrote:
>
> On Sun, Dec 6, 2015 at 5:59 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> Another complaint regarded a loss of succinctness. Per Melin wrote:
>
> Another example from the same LinkedList class. It finds the right place to insert a new node:
>
>   for next = head; next != nil && index > 0; prev = next, next = next!.next, --index { }
>
> Extreme? Probably, but I like it better than the same thing done in five lines of while loop.
>
>
> No worries, but for the record, I did absolutely not write that. I *quoted* that. I think that C-style 'for' is a horrible mess that should be killed with fire.
>
>

My apologies! -- E

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c06e5e38/attachment.html>

From lingoerer at gmail.com  Sun Dec  6 12:16:19 2015
From: lingoerer at gmail.com (Roy Fu)
Date: Mon, 7 Dec 2015 02:16:19 +0800
Subject: [swift-evolution] Proposal: Syntax sugar for cps or async
functions similar to the "do try catch" for error handling.
In-Reply-To: <51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de>
References: <78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com>
<51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de>
Message-ID: <339C6733-8C92-4616-A6A8-46FBF476923B@gmail.com>

I personally do prefer that too, but, it's still not that clear for the attitude of core team on introducing too much functional paradigms. More importantly we had to consider if this would add on learning curve for new programmers.

> On Dec 7, 2015, at 12:36 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>
> Hi Roy,
>
> I’d prefer if such special syntax would not be reserved for just async computations but used for monadic computations in general (with the async case just being a monad implementation).
>
> -Thorsten
>
>> Am 06.12.2015 um 10:21 schrieb Roy Fu via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>
>> Hi all,
>>
>> Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:
>>
>> func someFutureWrappedFunc(input: Int) future-> String{
>>     doSomeStaffInBackground{ (result:String) in
>>         fulfil result
>>     }
>> }
>>
>> do{
>>     let resultX = perform someFutureWrappedFunc(param)
>>     let resultY = perform anotherFutureWrappedFunc(resultX)
>>     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)
>>     self.someLabel.text = final
>> } timeout let context {
>>     //maybe some additional information
>> }
>>
>> the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:
>>
>> doSomeStaffInBackground { (resultX) -> Void in
>>
>>     doSomeOtherStaff { (resultY) -> Void in
>>
>>         if resultY.someCondition(resultX) {
>>
>>             evenMakesItMadness(resultY) { (final) -> Void in
>>
>>                 //finally
>>             }
>>         }
>>     }
>> }
>>
>>
>>
>>
>> For more context comparing this async syntax to the ‘do try catch’:
>>
>> do try catch:
>> enum Result<T> {
>>     case Success(T)
>>     case Failure(ErrorType)
>> }
>>
>> func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{
>>     switch result{
>>     case .Success(let v): return f(v)
>>     case .Failure(let e): return .Failure(e)
>>     }
>> }
>>
>> func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {
>>     return {
>>         do{
>>             return try .Success(f($0))
>>         }catch let e{
>>             return .Failure(e)
>>         }
>>     }
>> }
>>
>> func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{
>>     return{
>>         switch f($0){
>>         case .Success(let v): return v
>>         case .Failure(let e): throw e
>>         }
>>     }
>> }
>>
>> async:
>>
>> func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {
>>     return{ cont in
>>         async{ f($0)(cont) }
>>     }
>> }
>>
>> func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {
>>     return {input in
>>         {cont in
>>             do{
>>                 cont(perform f(input))
>>             }catch _{
>>
>>             }
>>         }
>>     }
>> }
>>
>> func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{
>>     return{
>>         f(input)({
>>             fulfil $0
>>         })
>>     }
>> }
>>
>>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/3f8e5e80/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 12:34:16 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 13:34:16 -0500
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com>
<3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com>
Message-ID: <CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com>

Commented on the proposal but realize that it might be better to reply
here.

For clarification: when you say "deprecate typealias" do you mean only in
the context of associated types or in the language as a whole?

I also thought it might make sense to add to the proposal a disabling of
the "default" behavior that is currently allowed for type aliases in
protocols:

protocol Prot {
associated Container: SequenceType
associated Element = Container.Generator.Element // should be illegal
}

Instead, if you actually want the semantics of an additional associated
type with a default (but overridable) value, you should use a protocol
extension. (Which means that associated ____ = ____ would be allowed in
protocol extensions, but not associated ____ : _____  or associated ____ :
____ = _____.) Does that sound right?


On Sun, Dec 6, 2015 at 10:32 AM, Loïc Lecrenier <swift-evolution at swift.org>
wrote:

> Well, I went ahead and created a pull request :)
>
> I also included a “proposed approach” section, where I propose to deprecate
> the `typealias` keyword for Swift 2.2, and replace it entirely for Swift
> 3.0.
>
> Does anyone have any thought on that? This is a bit aggressive, but I
> think it’s worth it.
> It is actually the same approach Erica proposed for removing C for-loops.
>
> Loïc
>
> > On Dec 6, 2015, at 1:12 PM, Loïc Lecrenier <loiclecrenier at icloud.com>
> wrote:
> >
> > I have drafted a formal proposal here:
> https://gist.github.com/loiclec/22459d230a21dbcb81fc
> > Would love to receive feedback from the community on it, I am
> particularly worried about the correctness of the terms I used.
> > Should I make a pull request to swift-evolution now, or should we
> continue the conversation here?
> >
> > Thanks,
> >
> > Loïc
> >
> > (and sorry about emailing you on Sunday 😇 )
> >
> >> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com> wrote:
> >>
> >>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>> Hi everyone :)
> >>>
> >>> I propose introducing a new "associated_type" keyword that will
> replace "typealias" for declaring associated types in protocols.
> >>> I remember being confused by associated types when I started using
> Swift, and I think one reason why was the use of the typealias keyword to
> define them.
> >>> One reason was that I thought I knew what typealias did, and so I
> didn't stop to learn what it did inside a protocol. An other reason was the
> difficulty of finding help when searching for "typealias" instead of
> "associated types".
> >>> Then, when I thought I understood it, I started building an
> excessively protocol-oriented program as an exercise. And I still lost a
> lot of time fighting Swift by trying to use "real" typealias-es inside of
> protocols.
> >>>
> >>> Conceptually, I had something like this:
> >>>
> >>> protocol ProtA {
> >>> typealias Container : SequenceType
> >>> }
> >>> protocol ProtB {
> >>> typealias AnOtherAssocType : ProtA
> >>> func foo(x: AnOtherAssocType.Container.Generator.Element, y:
> AnOtherAssocType.Container.Generator.Element) ->
> AnOtherAssocType.Container.Generator.Element
> >>> }
> >>>
> >>> The function foo is very difficult to read, so I wanted to use a
> shortcut to Element by doing this:
> >>>
> >>> protocol ProtB {
> >>> typealias A : ProtA
> >>> typealias Element = A.Container.Generator.Element
> >>> func foo(x: Element, y: Element) -> Element
> >>> }
> >>>
> >>> But by doing so, I didn't create a shortcut to Element, but an
> associated type with a default value of Element. (right?)
> >>> Then I tried to write extensions to ProtB where Element conforms to,
> say, Equatable, and couldn't make it work because
> A.Container.Generator.Element didn't conform to Equatable.
> >>>
> >>> So, that was a rather long explanation of the reasons I think we
> should replace the typealias keyword by associated_type, and allow "real"
> typealias-es inside protocols.
> >>
> >> I think this is a great idea; re-using typealias for associated types
> was a mistake.
> >>
> >> John.
> >>
> >>>
> >>> Ideally, I would write
> >>>
> >>> protocol ProtB {
> >>> associated_type AnOtherAssocType : ProtA
> >>> typealias Element = AnOtherAssocType.Container.Generator.Element
> >>> func foo(x: Element, y: Element) -> Element
> >>> }
> >>>
> >>> and it would be exactly the same as
> >>>
> >>> protocol ProtB {
> >>> associated_type AnOtherAssocType : ProtA
> >>> func foo(x: A.Container.Generator.Element, y:
> A.Container.Generator.Element) -> A.Container.Generator.Element
> >>> }
> >>>
> >>> There are probably some problems created by this proposal, but right
> now I can't see any :/
> >>>
> >>> Thanks,
> >>>
> >>> Loïc
> >>> _______________________________________________
> >>> swift-evolution mailing list
> >>> swift-evolution at swift.org
> >>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/33c3a364/attachment.html>

From cantrell at pobox.com  Sun Dec  6 12:42:39 2015
From: cantrell at pobox.com (Paul Cantrell)
Date: Sun, 6 Dec 2015 12:42:39 -0600
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
<7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
<B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
Message-ID: <75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com>

> I think Python's biggest appeal to new programmers is the fact that it has such a great standard library

This is not the case, at least in my teaching experience.

One of the largest hurdles for new programmers, and the one that differentiates beginning languages more than any other, is compiler strictness. This includes both syntax and static type checking.

We easily forget how hard learning syntax is: to see every piece of punctuation as significant, to read code as a parse tree, to think inside the box of the language’s type system. Programmers in their first months easily spend 50% of the time getting their code to compile, usually more like 80%.

The problem with compile-time strictness of any kind is that the compiler won’t do _anything_ until _everything_ compiles. I’ve seen this drive beginners to burnout, even drive them away from CS altogether. (To help calibrate your thinking about just how much we’ve forgotten that we learned: eons and eons ago, when my department taught its intro courses in Pascal and C++, the main first-year hurdle was not dealing with unsafe pointers, but knowing where to put the semicolons. Semicolons!)

When you don’t understand what a failure looks like, it’s tremendously helpful to be able to actually run the code and see the failure happen. Having the language say “this can’t possibly work so I won’t run it” is not helpful to beginners; it’s just bottled frustration. Having the language say “it worked until I got here, at which point this happened” is infinitely more helpful.

The biggest hurdle to a beginning programmer is how _stupid_ programming makes one feel. We experience programmers are all used to this. Beginners are not. Their successes are rarer, the obstacles more daunting. Every stumble feels intensely personal. Anything that makes success more incremental and more self-discoverable helps.

• • •

You might think at this point that I’m arguing in favor of the “no types to compete with Python” mode, but I’d vote against it.

The ideal beginner language has a flexible, forgiving syntax that rewards guessing; the least compile-time type checking possible; and very clear error messages (both compiler and runtime). On all three counts, this sounds very far from Swift today. Better error messages would be good for all of us, but the other two just don’t sound like Swift.

Good beginner languages reward exploration by empirical experimentation. Good professional development languages reward clarity of intent. Those two things are often in tension, and Swift’s core aesthetic clearly lands on the side of the second.

Is making it a good language for new beginners truly a design goal of Swift? I don’t think it should be. It _does_ seem like an excellent design goal to keep the language as simple, approachable, and learnable as it can be within its aesthetic.

Cheers,

Paul

P.S. The Bret Victor article that describes the thinking behind playgrounds has some oustanding ideas on making languages more learnable: http://worrydream.com/#!/LearnableProgramming <http://worrydream.com/#!/LearnableProgramming>

–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
https://innig.net • @inthehands • http://siestaframework.com/


> On Dec 5, 2015, at 6:13 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:
>
> No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.
>
> Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.
>
> Austin
>
>> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:
>>
>>
>>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> ml>
>>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.
>>
>> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?
>>
>>>
>>> Austin
>>>
>>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.
>>>>
>>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code.
>>>>
>>>> --
>>>> Kevin Lundberg
>>>>
>>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...
>>>>>
>>>>> Regards,
>>>>> Adrian Kashivskyy
>>>>> iOS Developer at Netguru
>>>>>
>>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:
>>>>>>
>>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> --rbÚḟîẁ
>>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/ma <https://lists.swift.org/ma>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7e04d6c0/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 12:43:03 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 13:43:03 -0500
Subject: [swift-evolution] Overloading assignment operator
In-Reply-To: <93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com>
References: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
<D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com>
<93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com>
Message-ID: <CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com>

Don, have you considered making your Number type FloatLiteralConvertible?
This would allow you not just to *let number: Number = 4.9*, but also pass
in 4.9 to a function that expected a *Number*. It would not let you set
Number variables to be equal to other variables of type Float, it seems
your main use case here is literals anyway.

http://swiftdoc.org/v2.0/protocol/FloatLiteralConvertible/

On Sun, Dec 6, 2015 at 9:26 AM, Don Wills via swift-evolution <
swift-evolution at swift.org> wrote:

> Silvan,
>
> Yes, I understand the concern you raise.  I too have held that general
> opinion of overloading operators in other languages for many years.  That
> said, overloading arithmetic and other operators causes the same
> opportunity for abuse.  For example, overloading + for integers to do
> something different (like rounding instead of truncation) would make
> maintenance of existing programs into a giant guessing game.
>
> That said, once the cat is out of the bag to overload operators, I don't
> see how adding support for = makes things any worse.
>
> FYI, the reason for my suggestion is to add support for fixed decimal
> arithmetic just like that available in COBOL.  Yeh I can hear the groans
> now.  However, for business applications, fixed decimal arithmetic is a
> basic feature that has been tossed away in new languages by language
> designers who don't actually labor in the trenches.  I've built a simple
> class to do just that - here is some sample code that uses my Number class
> that gives an idea of what the code does:
>
> var amount = Number(left: 6, right: 2);
> var result = Number(left: 9, right: 2);
> amount <- 3.9;
> amount += 1;
> result <- amount * 4;
> print(result)
>
> Note that <- is the assignment operator.  I am sure all would agree that =
> is superior in this situation.  Such code would be far more readable and
> the Number values would act just like and interoperate with Float and Int
> in all regards *except* that currently the = operator is not available for
> assignment.
>
> Don Wills
>
> PS.  FWIW, the  IEEE 754-2008 d128 alternative that Chris Lattner
> mentioned to me is inferior to the kind of support for fixed decimal
> arithmetic that I believe would help make Swift superior to C# for business
> applications.
>
>
> On Dec 6, 2015, at 6:58 AM, Silvan Mosberger < kametrixom at icloud.com>
> wrote:
>
> Hi Don
>
> I think this is a terrible idea! Imagine what you’d be able to do with
> that:
>
> let x : String = 3
>
> This would lead to the same problems already discussed with implicit
> initialisers:
> https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html,
> just worse. Also assignment is something more fundamental than other
> operators, I doubt it’s even possible to do that.
>
> On 06 Dec 2015, at 14:44, Don Wills via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> The ability to overload operators is very useful.  However, that utility
> is diminished without the ability to overload the simple assignment
> operator ( = ).  I vaguely recall reading somewhere that there is a reason
> for this having to do with syntax ambiguity.  Can this problem be solved so
> that = can be overloaded?
>
> Don Wills
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/810dbab9/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 12:56:21 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 13:56:21 -0500
Subject: [swift-evolution] A mode with no type checking to compete with
Python.
In-Reply-To: <75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com>
References: <5E968E10-2DBD-4999-978C-B398BC446A21@me.com>
<7240610C-B5DA-41B8-909A-D138404C6799@me.com>
<0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com>
<E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com>
<7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com>
<B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com>
<75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com>
Message-ID: <CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com>

Yes! As a high school CS teacher, agreed 100%. This is what makes Racket /
Scheme such a great introductory language: there is really only one type of
syntax mistake you can make, and it's having mismatched parens (something
that the IDE makes it easy for students to see). When students move on to
Java for AP, in come the errors. I've seen students give up on CS because
they can never compile their code -- in one case, for example, a student
was putting semicolons after every if statement, for loop, while loop, and
method definition, before the opening curly brace. (In my experience,
syntax presents a bigger hurdle than type errors.)

Swift is not, primarily, a teaching language *for beginners*. (It makes a
great teaching language for intermediate and advanced students, or students
who want to learn about fancy type systems.) Its type system is extremely
powerful but also beyond the scope of an introductory programming course.
That said, playgrounds *are* very cool and help alleviate some of the
frustration of writing a long program and having it not compile.

On Sun, Dec 6, 2015 at 1:42 PM, Paul Cantrell via swift-evolution <
swift-evolution at swift.org> wrote:

> I think Python's biggest appeal to new programmers is the fact that it has
> such a great standard library
>
>
> This is not the case, at least in my teaching experience.
>
> One of the largest hurdles for new programmers, and the one that
> differentiates beginning languages more than any other, is compiler
> strictness. This includes both syntax and static type checking.
>
> We easily forget how hard learning syntax is: to see every piece of
> punctuation as significant, to read code as a parse tree, to think inside
> the box of the language’s type system. Programmers in their first months
> easily spend 50% of the time getting their code to compile, usually more
> like 80%.
>
> The problem with compile-time strictness of any kind is that the compiler
> won’t do _anything_ until _everything_ compiles. I’ve seen this drive
> beginners to burnout, even drive them away from CS altogether. (To help
> calibrate your thinking about just how much we’ve forgotten that we
> learned: eons and eons ago, when my department taught its intro courses in
> Pascal and C++, the main first-year hurdle was not dealing with unsafe
> pointers, but knowing where to put the semicolons. Semicolons!)
>
> When you don’t understand what a failure looks like, it’s tremendously
> helpful to be able to actually run the code and see the failure happen.
> Having the language say “this can’t possibly work so I won’t run it” is not
> helpful to beginners; it’s just bottled frustration. Having the language
> say “it worked until I got here, at which point this happened” is
> infinitely more helpful.
>
> The biggest hurdle to a beginning programmer is how _stupid_ programming
> makes one feel. We experience programmers are all used to this. Beginners
> are not. Their successes are rarer, the obstacles more daunting. Every
> stumble feels intensely personal. Anything that makes success more
> incremental and more self-discoverable helps.
>
> • • •
>
> You might think at this point that I’m arguing in favor of the “no types
> to compete with Python” mode, but I’d vote against it.
>
> The ideal beginner language has a flexible, forgiving syntax that rewards
> guessing; the least compile-time type checking possible; and very clear
> error messages (both compiler and runtime). On all three counts, this
> sounds very far from Swift today. Better error messages would be good for
> all of us, but the other two just don’t sound like Swift.
>
> Good beginner languages reward exploration by empirical experimentation.
> Good professional development languages reward clarity of intent. Those two
> things are often in tension, and Swift’s core aesthetic clearly lands on
> the side of the second.
>
> Is making it a good language for new beginners truly a design goal of
> Swift? I don’t think it should be. It _does_ seem like an excellent design
> goal to keep the language as simple, approachable, and learnable as it can
> be within its aesthetic.
>
> Cheers,
>
> Paul
>
> P.S. The Bret Victor article that describes the thinking behind
> playgrounds has some oustanding ideas on making languages more learnable:
> http://worrydream.com/#!/LearnableProgramming
>
> –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
> https://innig.net • @inthehands • http://siestaframework.com/
>
>
> On Dec 5, 2015, at 6:13 PM, Austin Zheng via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> No, I don't. I think Python's biggest appeal to new programmers is the
> fact that it has such a great standard library, making it really easy to do
> whatever you want to do without figuring out how to find or add in external
> dependencies.
>
> Anyways, mistyped Python code still breaks, it just breaks at runtime
> instead of compile time. In fact, I'd argue that this is even less beginner
> friendly, since you might write a function that works with some inputs and
> then inexplicably breaks with others.
>
> Austin
>
> On Dec 5, 2015, at 4:09 PM, Amir Michail < a.michail at me.com> wrote:
>
>
> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> ml>
> I disagree with the idea that a type system is too much of a hurdle for
> beginner programmers to overcome.
>
>
> Don’t you think that Python currently provides a better introduction to
> programming due to its simplicity?
>
>
> Austin
>
> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> This is somewhat possible today on Apple platforms with AnyObject. You can
> call any objc-visible method on AnyObject and it will compile, and the
> return type will also be AnyObject (I don't recall if the return type is
> optional as well or not). This doesn't work with value types, but neither
> does id in objc.
>
> Having a more complete lax typed mode similar to Python or php I think is
> of limited usefulness, would add too much complexity to the language, and
> yield too much uncertainty about any given piece of swift code.
>
> --
> Kevin Lundberg
>
> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I can't believe I'm seeing a proposal to remove type safety, one of the
> fundamental features of Swift...
>
> Regards,
> Adrian Kashivskyy
> iOS Developer at Netguru
>
> Wiadomość napisana przez Amir Michail via swift-evolution <
> swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:
>
> Python is still easier than Swift for beginning programmers. But maybe
> such a mode can allow Swift to be used by beginners also?
> *____________________________________________*_ swift-evolution mailing
> list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> --r‡bž Úḟîẁ
> ‰íz{CŠÊhĠ+bḃx§–)Ŷ_______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/ma
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c86e2160/attachment.html>

From possen at gmail.com  Sun Dec  6 12:57:02 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 10:57:02 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
Message-ID: <7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com>

I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:

let myFavoriteColor = yourFavoriteColor ?
case .Blue: .Red
case .Green: .Blue
case .Red: .Green
default: .Yellow


> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-evolution at swift.org> wrote:
>
> I really like this train of thought. +1
>
> l8r
> Sean
>
>
> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>>
>> let x = condition ?
>>    true: "Hello"
>>    false: "Goodbye"
>>
>> let x = optionalValue ?
>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>    .None: "To Whom It May Concern"
>>
>> let myFavoriteColor = yourFavoriteColor ?
>>     .Blue: .Red
>>     .Green: .Blue
>>     .Red: .Green
>>
>> let quadrant = (x, y) ?
>>     let (x, y) where x < 50 && y < 50: "top left"
>>     let (x, y) where x < 50 && y > 50: "bottom left"
>>     let (x, y) where x > 50 && y < 50: "top right"
>>     default: "bottom right"
>>
>> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>>
>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>>
>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>> wrote:
>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>>
>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>
>>> if (condition) {
>>>     funcWithSideEffectsThatReturnsInt()
>>> } else {
>>>     funcWithSideEffectsThatReturnsString()
>>> }
>>>
>>> but that's not a valid expression (what is its type?).
>>
>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).
>>
>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.
>>
>> -Thorsten
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2eb87105/attachment.html>

From colin at springsandstruts.com  Sun Dec  6 12:57:56 2015
From: colin at springsandstruts.com (Colin Barrett)
Date: Sun, 6 Dec 2015 13:57:56 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
Message-ID: <071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>

tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.

Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.

I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)

Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:

https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>

This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.

Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.

Thanks,
-Colin

> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
>
> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>
> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>
> Sent from my iPad
>
> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>
>> I very much like specifying what case to fall through into, no matter how we spell it.
>>
>> - Steve
>>
>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>
>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>
>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>
>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>
>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>
>>> John.
>>>
>>>>
>>>> John.
>>>>
>>>>>
>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>
>>>>> switch op {
>>>>> case LOAD_INDIRECT:
>>>>>    in0 = memory[in1]
>>>>>    fallthrough
>>>>> case LOAD:
>>>>>    out0 = memory[in0]
>>>>> //...
>>>>> }
>>>>>
>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>
>>>>> Cheers,
>>>>> John
>>>>>
>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>
>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>
>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>
>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>
>>>>>> John.
>>>>>>
>>>>>>>
>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>
>>>>>>> -Kevin Ballard
>>>>>>>
>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>
>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>
>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>
>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>> expressed as
>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>> case .Enum2:
>>>>>>>>>
>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>>>>
>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>
>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>
>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>
>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>
>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>
>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>
>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>
>>>>>>>>>> Thoughts?
>>>>>>>>>>
>>>>>>>>>> Daniel
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>>  _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c64c1b4c/attachment.html>

From stephen.celis at gmail.com  Sun Dec  6 12:59:31 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Sun, 6 Dec 2015 13:59:31 -0500
Subject: [swift-evolution] Overloading assignment operator
In-Reply-To: <CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com>
References: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
<D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com>
<93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com>
<CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com>
Message-ID: <DB00FFEF-B61E-4294-9891-8A64B2584289@gmail.com>

I think that his number assignment (via `<~`) depends on the current state of `amount`, and that using FloatLiteralConvertible does not provide enough information at the call site (since the current value is not available in the initializer).

Stephen

> On Dec 6, 2015, at 1:43 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:
>
> Don, have you considered making your Number type FloatLiteralConvertible? This would allow you not just to let number: Number = 4.9, but also pass in 4.9 to a function that expected a Number. It would not let you set Number variables to be equal to other variables of type Float, it seems your main use case here is literals anyway.
>
> http://swiftdoc.org/v2.0/protocol/FloatLiteralConvertible/ <http://swiftdoc.org/v2.0/protocol/FloatLiteralConvertible/>
>
> On Sun, Dec 6, 2015 at 9:26 AM, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> Silvan,
>
> Yes, I understand the concern you raise.  I too have held that general opinion of overloading operators in other languages for many years.  That said, overloading arithmetic and other operators causes the same opportunity for abuse.  For example, overloading + for integers to do something different (like rounding instead of truncation) would make maintenance of existing programs into a giant guessing game.
>
> That said, once the cat is out of the bag to overload operators, I don't see how adding support for = makes things any worse.
>
> FYI, the reason for my suggestion is to add support for fixed decimal arithmetic just like that available in COBOL.  Yeh I can hear the groans now.  However, for business applications, fixed decimal arithmetic is a basic feature that has been tossed away in new languages by language designers who don't actually labor in the trenches.  I've built a simple class to do just that - here is some sample code that uses my Number class that gives an idea of what the code does:
>
> var amount = Number(left: 6, right: 2);
> var result = Number(left: 9, right: 2);
> amount <- 3.9;
> amount += 1;
> result <- amount * 4;
> print(result)
>
> Note that <- is the assignment operator.  I am sure all would agree that = is superior in this situation.  Such code would be far more readable and the Number values would act just like and interoperate with Float and Int in all regards *except* that currently the = operator is not available for assignment.
>
> Don Wills
>
> PS.  FWIW, the  IEEE 754-2008 d128 alternative that Chris Lattner mentioned to me is inferior to the kind of support for fixed decimal arithmetic that I believe would help make Swift superior to C# for business applications.
>
>
>> On Dec 6, 2015, at 6:58 AM, Silvan Mosberger < kametrixom at icloud.com <mailto:kametrixom at icloud.com>> wrote:
>>
>> Hi Don
>>
>> I think this is a terrible idea! Imagine what you’d be able to do with that:
>>
>> let x : String = 3
>>
>> This would lead to the same problems already discussed with implicit initialisers: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html <https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html>, just worse. Also assignment is something more fundamental than other operators, I doubt it’s even possible to do that.
>>
>>> On 06 Dec 2015, at 14:44, Don Wills via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded?
>>>
>>> Don Wills
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/889fcc3e/attachment.html>

From kellygerber22 at yahoo.com  Sun Dec  6 13:03:33 2015
From: kellygerber22 at yahoo.com (Kelly Gerber)
Date: Sun, 6 Dec 2015 11:03:33 -0800
Subject: [swift-evolution] C-style For Loops
Message-ID: <9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com>

I think that the C-style for loop should be removed from Swift. The scope rules for this for loop are wrong. Every loop sees the same scope. This is a source of bugs if you export the loop variable name outside the scope of the for statement, for example in a closure. The following code illustrates the problem:

var handlers: [() -> ()] = []

for i in 0..<5 {
handlers.append { print(i) }
}

for handler in handlers {
handler()  // "0 1 2 3 4"
}

handlers = []

for var i = 0; i < 5; i += 1 {
handlers.append { print(i) }
}

for handler in handlers {
handler()  // "5 5 5 5 5"
}

The Swift for-in loop does the right thing naturally. The C-style for loop does the wrong thing naturally. Removing the C-style for loop from Swift will eliminate one more class of possible errors from the language.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a3fd4836/attachment.html>

From cheyo at masters3d.com  Sun Dec  6 13:03:35 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Sun, 6 Dec 2015 13:03:35 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
Message-ID: <CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com>

I do like the idea of leaving the if else as an statement because it
may simplify things. Ideally the new ternary syntax would exclude the
question mark and colon. Without introducing new keywords, it could work
something like the following.

let result = where condition switch x else y

let result2 = where x < y switch 1 else where y == x switch 2 else 3






On Sunday, December 6, 2015, Alex Lew via swift-evolution <
swift-evolution at swift.org> wrote:

> What if we left the if { ...} else { ... } syntax alone (as a statement),
> and updated the ternary expression to be a more general pattern matching
> expression (closer to "switch")? Something like
>
> let x = condition ?
>    true: "Hello"
>    false: "Goodbye"
>
> let x = optionalValue ?
>    .Some(let unwrapped): "Hello, \(unwrapped)"
>    .None: "To Whom It May Concern"
>
> let myFavoriteColor = yourFavoriteColor ?
>     .Blue: .Red
>     .Green: .Blue
>     .Red: .Green
>
> let quadrant = (x, y) ?
>     let (x, y) where x < 50 && y < 50: "top left"
>     let (x, y) where x < 50 && y > 50: "bottom left"
>     let (x, y) where x > 50 && y < 50: "top right"
>     default: "bottom right"
>
> The colon comes from the fact that this is sort of a light-weight
> expression-based "switch" statement, where each branch can only contain an
> expression, not a series of statements.
>
> This is very similar to pattern matching expressions in languages like
> Haskell, ML, and Coq.
>
> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de
> <javascript:_e(%7B%7D,'cvml','thorsten.seitz at web.de');>> wrote:
>
>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
>> swift-evolution at swift.org
>> <javascript:_e(%7B%7D,'cvml','swift-evolution at swift.org');>>:
>>
>> I don't think you can just get rid of the if statement in favor of an
>> expression. You still want to be able to do this:
>>
>> if (condition) {
>>     funcWithSideEffectsThatReturnsInt()
>> } else {
>>     funcWithSideEffectsThatReturnsString()
>> }
>>
>> but that's not a valid expression (what is its type?).
>>
>>
>> That would actually be no problem if Swift’s type system would have union
>> types (Ceylon has union and intersection types which are quite awesome and
>> enable lots of nice things quite naturally, see
>> http://ceylon-lang.org/documentation/1.2/tour/types/).
>>
>> In that case the type of such an expression would just be the union of
>> both types, which is written Int | String in Ceylon.
>>
>> -Thorsten
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2a70ecc7/attachment.html>

From matthew at anandabits.com  Sun Dec  6 13:04:16 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 13:04:16 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<94756ED2-71C9-4FF3-B3BA-2CB35975B5C4@anandabits.com>
<4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com>
Message-ID: <F3860C6E-19F2-4E01-AF30-1CC813893B1C@anandabits.com>

Thanks Erica. I agree that there are two distinct, but related problems being discussed here as well as several ideas for solutions.

I will try to provide a side-by-side summary of the problems and proposed solutions in the next day or so when I have a chance to pull it together.


> On Dec 6, 2015, at 11:26 AM, Erica Sadun <erica at ericasadun.com> wrote:
>
> Matthew, I'll look for it and see what's there. More and more I'm thinking there are in fact two distinct problems to be solved: one that maintains self in a cascade of operations, and another that extends initializers, even for constants.
>
> I'm hesitant to coalesce and summarize all this discussion yet because I'm already committed to championing the for-loop proposal but it seems that it would be really valuable right now to lay out the two side-by-side and discuss that plus your helpers-for-initializing-peroperties-of-same-name-as-parameters.
>
> -- E
> p.s. In my head, I'm thinking that the compiler must check in setup closures or self-specific-closures for potential overlaps between properties and existing symbols
>
>
>> On Dec 6, 2015, at 10:22 AM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>
>> Hi Erica,
>>
>> You might be interested in a possible language feature I described in the "helpers for initializing properties of same name as parameters" thread last night.  It is intended to address the desire for concise, safe and flexible initialization without needing to sacrifice immutability.   I would love to hear your thoughts on the list if you have a chance to read through it.
>>
>> Thanks,
>> Matthew
>>
>> Sent from my iPad
>>
>> On Dec 6, 2015, at 11:10 AM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>
>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>
>>> -- E
>>>
>>>
>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>
>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>
>>>> let task = NSTask() +=+ {
>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>     $0.standardOutput = pipe
>>>> }
>>>>
>>>> Note you can also use the configured object in the rhs:
>>>>
>>>> let questionLabel = UILabel() +=+ {
>>>>     $0.textAlignment = .Center
>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>     $0.text = currentQuestion.questionText
>>>>     $0.numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>
>>>> let questionLabel = UILabel() +=+ {
>>>>     .textAlignment = .Center
>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>     .text = currentQuestion.questionText
>>>>     .numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> Actually I would be happy with something like
>>>>
>>>> let questionLabel = UILabel() .{
>>>>     ..textAlignment = .Center
>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>     ..text = currentQuestion.questionText
>>>>     ..numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> Other thoughts?
>>>>
>>>>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/00f42000/attachment.html>

From cantrell at pobox.com  Sun Dec  6 13:08:00 2015
From: cantrell at pobox.com (Paul Cantrell)
Date: Sun, 6 Dec 2015 13:08:00 -0600
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
Message-ID: <8808357C-0780-423E-B028-1299CBCD2382@pobox.com>

I’d like to express my pure joy at a proposal to _remove_ a feature from a popular language.

My favorite Swift feature? Its brilliant insights that optionality should be a characteristic of _types_ but mutability should be a characteristic of _variables_ are right up there. But no, my favorite feature of Swift so far is its willingness to make breaking language changes. Hallelujiah!

Fear of removing features and making breaking changes is what doomed Java to its current status of “most used, most sneered at.” It’s what’s turned C++ into the world’s largest ball of twine. Swift is wise to set the early precedent of carefully considered breaking language changes.

>> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>
> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language.

I cannot imagine a better case for removing a language feature.

We have a feature that is:

1. not widely used,
2. easily replaced with other languages features where it is used, and
3. inconsistent with the language’s general aesthetic.

Theory, observation, and taste agree. If this isn’t a feature to remove for the health of the language, then what is?

Cheers,

Paul

–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
https://innig.net • @inthehands • http://siestaframework.com/



From colin at springsandstruts.com  Sun Dec  6 13:11:22 2015
From: colin at springsandstruts.com (Colin Barrett)
Date: Sun, 6 Dec 2015 14:11:22 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
<B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com>
<112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com>
Message-ID: <B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com>


> On Dec 6, 2015, at 11:31 AM, David Waite via swift-evolution <swift-evolution at swift.org> wrote:
>
> Nearly every for loop I’ve written in other languages has used pre or post increment (depending on the language), which is being removed in Swift 3.0. It makes sense for 'for loops' to go if pre/post increment goes away.

I’m not 100% convinced by this line of reasoning (using the += form or successor() isn’t THAT clunky) but it is awfully poetic.

Fun fact, you write (albiet with different syntax) C-style for-loops as library code:

> for i in CStyle(0, {$0 < 20}, {$0 += 1}) {
>  // do something 20 times
> }

Where CStyle is just a straightforward implementation of SequenceType. (Tuples allow for simultaneous iteration, which is usually when I end up with C-style for-loops)

(Apologies if this was mentioned up thread, I’ve only just recently joined the list)

-Colin

> -DW
>
>> On Dec 6, 2015, at 9:03 AM, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.
>>
>> I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.
>>
>> Don Wills
>>
>>> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> True,even that a feature isn't used doesn't mean that you need to remove that feature.
>>> I hope that the proposal will be rejected.
>>>
>>> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>>
>>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>>>
>>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>>>
>>> Cheers
>>> Clemens
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/b9e3b559/attachment.html>

From erica at ericasadun.com  Sun Dec  6 13:14:32 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 12:14:32 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <8808357C-0780-423E-B028-1299CBCD2382@pobox.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<8808357C-0780-423E-B028-1299CBCD2382@pobox.com>
Message-ID: <AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com>

That is very odd indeed.

If you add explicit capture, the issue goes away:

var handlers: [() -> Void] = []

for i in 0..<5 {
handlers.append {[i] in print(i, terminator:",") }
}

for handler in handlers {
handler()  // "0 1 2 3 4"
}

handlers = []

for var i = 0; i < 5; i += 1 {
handlers.append {[i] in print(i, terminator:",") }
}

print("")
for handler in handlers {
handler()  // was "5 5 5 5 5", now 1, 2, 3, 4, 5
}

It really seems like a bug to me rather than a feature of the for-loop

-- Erica


> On Dec 6, 2015, at 12:03 PM, Kelly Gerber via swift-evolution <swift-evolution at swift.org> wrote:
>
> I think that the C-style for loop should be removed from Swift. The scope rules for this for loop are wrong. Every loop sees the same scope. This is a source of bugs if you export the loop variable name outside the scope of the for statement, for example in a closure. The following code illustrates the problem:
>
> var handlers: [() -> ()] = []
>
> for i in 0..<5 {
>     handlers.append { print(i) }
> }
>
> for handler in handlers {
>     handler()  // "0 1 2 3 4"
> }
>
> handlers = []
>
> for var i = 0; i < 5; i += 1 {
>     handlers.append { print(i) }
> }
>
> for handler in handlers {
>     handler()  // "5 5 5 5 5"
> }
>
> The Swift for-in loop does the right thing naturally. The C-style for loop does the wrong thing naturally. Removing the C-style for loop from Swift will eliminate one more class of possible errors from the language.
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c0d7c9bf/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: open.gif
Type: image/gif
Size: 43 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c0d7c9bf/attachment.gif>

From kevin at klundberg.com  Sun Dec  6 13:19:29 2015
From: kevin at klundberg.com (Kevin Lundberg)
Date: Sun, 06 Dec 2015 14:19:29 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com>
Message-ID: <1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>

Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):

let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,
default: .Yellow

On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:
> I like this too, seems more powerful.  Also, would single line
> expressions be allowed?  If not would case be required for example:
>
> let myFavoriteColor = yourFavoriteColor ?    case .Blue: .Red    case
> .Green: .Blue    case .Red: .Green    default: .Yellow
>
>
>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-
>> evolution at swift.org> wrote:
>>
>> I really like this train of thought. +1
>>
>> l8r Sean
>>
>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-
>> evolution at swift.org> wrote:
>>> What if we left the if { ...} else { ... } syntax alone (as a
>>> statement), and updated the ternary expression to be a more general
>>> pattern matching expression (closer to "switch")? Something like
>>>
>>> let x = condition ?   true: "Hello"   false: "Goodbye"
>>>
>>> let x = optionalValue ?   .Some(let unwrapped): "Hello,
>>> \(unwrapped)"   .None: "To Whom It May Concern"
>>>
>>> let myFavoriteColor = yourFavoriteColor ?    .Blue: .Red    .Green:
>>> .Blue    .Red: .Green
>>>
>>> let quadrant = (x, y) ?    let (x, y) where x < 50 && y < 50: "top
>>> left"    let (x, y) where x < 50 && y > 50: "bottom left"    let (x,
>>> y) where x > 50 && y < 50: "top right"    default: "bottom right"
>>>
>>> The colon comes from the fact that this is sort of a light-weight
>>> expression-based "switch" statement, where each branch can only
>>> contain an expression, not a series of statements.
>>>
>>> This is very similar to pattern matching expressions in languages
>>> like Haskell, ML, and Coq.
>>>
>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten
>>> Seitz<thorsten.seitz at web.de>wrote:
>>>>
>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-
>>>>> evolution at swift.org>:
>>>>>
>>>>> I don't think you can just get rid of the if statement in favor of
>>>>> an expression. You still want to be able to do this:
>>>>>
>>>>> if (condition) {    funcWithSideEffectsThatReturnsInt() } else {
>>>>> funcWithSideEffectsThatReturnsString() }
>>>>>
>>>>> but that's not a valid expression (what is its type?).
>>>>
>>>>
>>>> That would actually be no problem if Swift’s type system would have
>>>> union types (Ceylon has union and intersection types which are
>>>> quite awesome and enable lots of nice things quite naturally, see
>>>> http://ceylon-lang.org/documentation/1.2/tour/types/).
>>>>
>>>> In that case the type of such an expression would just be the union
>>>> of both types, which is writtenInt | Stringin Ceylon.
>>>>
>>>>
>>>> -Thorsten
>>>>
>>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>  _______________________________________________
>> swift-evolution mailing list swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _________________________________________________
> swift-evolution mailing list swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3001e7b2/attachment.html>

From matthew at anandabits.com  Sun Dec  6 13:23:00 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 13:23:00 -0600
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <8808357C-0780-423E-B028-1299CBCD2382@pobox.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<8808357C-0780-423E-B028-1299CBCD2382@pobox.com>
Message-ID: <E35181B4-9142-4677-809C-84E9F8EA4301@anandabits.com>

+1 on embracing breaking change as necessary for moving the language forward!

> On Dec 6, 2015, at 1:08 PM, Paul Cantrell via swift-evolution <swift-evolution at swift.org> wrote:
>
> I’d like to express my pure joy at a proposal to _remove_ a feature from a popular language.
>
> My favorite Swift feature? Its brilliant insights that optionality should be a characteristic of _types_ but mutability should be a characteristic of _variables_ are right up there. But no, my favorite feature of Swift so far is its willingness to make breaking language changes. Hallelujiah!
>
> Fear of removing features and making breaking changes is what doomed Java to its current status of “most used, most sneered at.” It’s what’s turned C++ into the world’s largest ball of twine. Swift is wise to set the early precedent of carefully considered breaking language changes.
>
>>> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>
>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language.
>
> I cannot imagine a better case for removing a language feature.
>
> We have a feature that is:
>
> 1. not widely used,
> 2. easily replaced with other languages features where it is used, and
> 3. inconsistent with the language’s general aesthetic.
>
> Theory, observation, and taste agree. If this isn’t a feature to remove for the health of the language, then what is?
>
> Cheers,
>
> Paul
>
> –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
> https://innig.net • @inthehands • http://siestaframework.com/
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From loiclecrenier at icloud.com  Sun Dec  6 13:25:54 2015
From: loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)
Date: Sun, 06 Dec 2015 20:25:54 +0100
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com>
<3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com>
<CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com>
Message-ID: <2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com>

Yes, I mean “deprecate typealias” only in the context of associated types. Will clarify, thanks :)

As for forbidding the default behavior, I don’t think I’m qualified enough to answer that.
At first glance, it seems to make sense.

However, I feel like this deserves to be an other proposal, after this one is (hopefully!) accepted.
Because currently the proposal is extremely simple: it is about replacing one keyword
with another one, in order to improve the clarity of the grammar. Moreover, the transition
from the previous grammar to the proposed one is immediate.

Changes to the places where (associated types / type aliases) are allowed will involve more
technical discussions, may be more controversial, and may complicate the review of the proposal.

So, unless someone familiar with the inner workings of Swift tells me that allowing
“associated ___ = ___” in protocol extensions is an obvious consequence of adding the
`associated` keyword, I would rather not include it in the proposal.

Happy to hear any counter-argument, though :)

Loïc

> On Dec 6, 2015, at 7:34 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> Commented on the proposal but realize that it might be better to reply here.
>
> For clarification: when you say "deprecate typealias" do you mean only in the context of associated types or in the language as a whole?
>
> I also thought it might make sense to add to the proposal a disabling of the "default" behavior that is currently allowed for type aliases in protocols:
>
> protocol Prot {
>     associated Container: SequenceType
>     associated Element = Container.Generator.Element // should be illegal
> }
>
> Instead, if you actually want the semantics of an additional associated type with a default (but overridable) value, you should use a protocol extension. (Which means that associated ____ = ____ would be allowed in protocol extensions, but not associated ____ : _____  or associated ____ : ____ = _____.) Does that sound right?
>
>
> On Sun, Dec 6, 2015 at 10:32 AM, Loïc Lecrenier <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> Well, I went ahead and created a pull request :)
>
> I also included a “proposed approach” section, where I propose to deprecate
> the `typealias` keyword for Swift 2.2, and replace it entirely for Swift 3.0.
>
> Does anyone have any thought on that? This is a bit aggressive, but I think it’s worth it.
> It is actually the same approach Erica proposed for removing C for-loops.
>
> Loïc
>
> > On Dec 6, 2015, at 1:12 PM, Loïc Lecrenier <loiclecrenier at icloud.com <mailto:loiclecrenier at icloud.com>> wrote:
> >
> > I have drafted a formal proposal here: https://gist.github.com/loiclec/22459d230a21dbcb81fc <https://gist.github.com/loiclec/22459d230a21dbcb81fc>
> > Would love to receive feedback from the community on it, I am particularly worried about the correctness of the terms I used.
> > Should I make a pull request to swift-evolution now, or should we continue the conversation here?
> >
> > Thanks,
> >
> > Loïc
> >
> > (and sorry about emailing you on Sunday 😇 )
> >
> >> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
> >>
> >>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> >>> Hi everyone :)
> >>>
> >>> I propose introducing a new "associated_type" keyword that will replace "typealias" for declaring associated types in protocols.
> >>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.
> >>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for "typealias" instead of "associated types".
> >>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use "real" typealias-es inside of protocols.
> >>>
> >>> Conceptually, I had something like this:
> >>>
> >>> protocol ProtA {
> >>> typealias Container : SequenceType
> >>> }
> >>> protocol ProtB {
> >>> typealias AnOtherAssocType : ProtA
> >>> func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element
> >>> }
> >>>
> >>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:
> >>>
> >>> protocol ProtB {
> >>> typealias A : ProtA
> >>> typealias Element = A.Container.Generator.Element
> >>> func foo(x: Element, y: Element) -> Element
> >>> }
> >>>
> >>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)
> >>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.
> >>>
> >>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow "real" typealias-es inside protocols.
> >>
> >> I think this is a great idea; re-using typealias for associated types was a mistake.
> >>
> >> John.
> >>
> >>>
> >>> Ideally, I would write
> >>>
> >>> protocol ProtB {
> >>> associated_type AnOtherAssocType : ProtA
> >>> typealias Element = AnOtherAssocType.Container.Generator.Element
> >>> func foo(x: Element, y: Element) -> Element
> >>> }
> >>>
> >>> and it would be exactly the same as
> >>>
> >>> protocol ProtB {
> >>> associated_type AnOtherAssocType : ProtA
> >>> func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element
> >>> }
> >>>
> >>> There are probably some problems created by this proposal, but right now I can't see any :/
> >>>
> >>> Thanks,
> >>>
> >>> Loïc
> >>> _______________________________________________
> >>> swift-evolution mailing list
> >>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>


From matthew at anandabits.com  Sun Dec  6 13:27:46 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 13:27:46 -0600
Subject: [swift-evolution] Proposal: typealias support protocol
constraint
In-Reply-To: <CF5B84C6-7EE1-43D2-AA08-E7A3FEF91023@pobox.com>
References: <78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com>
<F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com>
<C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com>
<CF5B84C6-7EE1-43D2-AA08-E7A3FEF91023@pobox.com>
Message-ID: <FE41B04C-014E-43E7-9F5E-4826380542F9@anandabits.com>

Yes, the idea is that this protocol type with partially or totally bound associated types would be valid anywhere you could use a type.

I’m not a compiler developer and I’m sure there are implementation complexities and a lot of subtleties to work through.  But I believe it is possible as Swift’s protocols share many similarities with ML’s module system and ML is able to do this.

Hopefully someone from the core team can chime in on feasibility, desirability, and priority of a feature like this.


> On Dec 6, 2015, at 1:22 PM, Paul Cantrell <cantrell at pobox.com> wrote:
>
>> The general form of this would look like:
>>
>> protocol<P1, P2, P3 where *list of constraints*>
>
>
> I’m very interested in this. Would this also extend to variables & parameters with generic types that are only constrained, or not specified at all? For example:
>
>     let heterogeneousCollections: protocol<CollectionType where Generator.Element: CollectionType> = whatever
>
> …or even:
>
>     let heterogeneousCollections: [CollectionType] = whatever
>
> …because we don’t need to know the element types to get the max count:
>
>     let maxSize = heterogenousCollections.map { $0.count }.maxElement()
>
> If so, I’m desperate for this. The lack of it forced some ugly compromises in Siesta’s API.
>
> Cheers, P
>
>
>> On Dec 6, 2015, at 9:07 AM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> This request isn’t really about typealias at all.  It has two elements.
>>
>> First, it’s about the ability to bind Self and / or associated types in a protocol and use the result as a type.  This is highly desirable and is similar to features in the ML module system.
>>
>> First is the ability to use a protocol with self or associated types as a type, not just a generic constraint:
>>
>> protocol<CollectionType where CollectionType.Generator.Element == CGPoint>
>>
>> I don’t think the `T:` label is necessary here as the protocol name serves as a good identifier in this context.  Although the protocol name could probably be omitted when there is only one protocol here as it is implicit:
>>
>> protocol<CollectionType where Generator.Element == CGPoint>
>>
>> The general form of this would look like:
>>
>> protocol<P1, P2, P3 where *list of constraints*>
>>
>> In this case the protocol name would be required, at least when more than one protocol in the list have an associated type with the same name (and possibly in all cases).  The list of constraints could identify associated types, bind them to concrete types, constrain Self to a specific superclass, etc.  The Self constraint might look like this:
>>
>> protocol<P1, P2, P3 where Self: UIViewController>
>>
>> Ideally we would not need to bind all associated types in the protocol in order to use it at a type, but would only be allowed to use members that do not mention the unbound associated type in their signature.
>>
>> Once we have the ability to bind associated types and use the result as a type, the typealias use falls out automatically.
>>
>> Second, it’s about the ability to extend a typealias where some generic constraints are specified in the typealias.  This would allow us to re-use the binding of generic constraints, but could be confusing if the extension is far removed in source from the typealias.  I’m not sure how I feel about this part of the proposal.
>>
>> Matthew
>>
>>> On Dec 6, 2015, at 4:28 AM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> I believe this could be achieved using generic typealiases, proposed here: https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html>
>>>
>>> Pozdrawiam – Regards,
>>> Adrian Kashivskyy
>>>
>>>> Wiadomość napisana przez QQ Mail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 06.12.2015, o godz. 08:17:
>>>>
>>>> If typealias support protocol constraint, I think we can reuse a lot of code, also more readable
>>>>
>>>> For Example:
>>>>
>>>> typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>
>>>>
>>>> public extension PointCollection {
>>>>
>>>>
>>>>
>>>> }
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3e761f2d/attachment.html>

From matthew at anandabits.com  Sun Dec  6 13:28:37 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 13:28:37 -0600
Subject: [swift-evolution] Proposal: failable numeric conversion initializers
Message-ID: <70E0CB06-BF3D-41D5-8902-FA64A1FA7BE2@anandabits.com>

Problem:
Swift numeric types all currently have a family of conversion initializers.  In many use cases they leave a lot to be desired.  Initializing an integer type with a floating point value will truncate any fractional portion of the number.  Initializing with an out-of-range value traps.

Solution:

Sometimes it would be more desirable to convert the runtime value if it can be done without losing information (or possibly with only minimal loss of precision when initializing a floating point type).  This could be easily accomplished if the standard library had a family of failable initializers for all numeric types, either returning an Optional or throwing when the initialization was not successful.

I prefer the throwing version because failure can be automatically propagated up the call stack and the error could capture value that was provided and the type that failed to initialize which may be useful when debugging.  Also, `try?` allows callers to throw away the error if the detail isn’t necessary.  However, the Optional version would provide the basic functionality that is desired and would be sufficient if the community likes it better.

//  Conversions from all integer types.
init?(_ value: Int8)
init?(_ value: Int16)
init?(_ value: Int32)
init?(_ value: Int64)
init?(_ value: Int)
init?(_ value: UInt8)
init?(_ value: UInt16)
init?(_ value: UInt32)
init?(_ value: UInt64)
init?(_ value: UInt)

//  Conversions from all floating-point types.
init?(_ value: Float)
init?(_ value: Double)
#if arch(i386) || arch(x86_64)
init?(_ value: Float80)
#endif

OR

//  Conversions from all integer types.
init(_ value: Int8) throws
init(_ value: Int16) throws
init(_ value: Int32) throws
init(_ value: Int64) throws
init(_ value: Int) throws
init(_ value: UInt8) throws
init(_ value: UInt16) throws
init(_ value: UInt32) throws
init(_ value: UInt64) throws
init(_ value: UInt) throws

//  Conversions from all floating-point types.
init(_ value: Float) throws
init(_ value: Double) throws
#if arch(i386) || arch(x86_64)
init(_ value: Float80) throws
#endif

From alexl.mail+swift at gmail.com  Sun Dec  6 13:40:28 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 14:40:28 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com>
<1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
Message-ID: <CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com>

Yes, I'm of two minds about adding *case*.

On the one hand, it is much more consistent with the rest of the
language. *case
*is used everywhere else in Swift that pattern matching is allowed. (if
case..., for case..., while case...) I think this is a strong argument that
it should be used in pattern matching expressions too.

On the other hand, what is the point of pattern matching expressions if not
to be brief? They don't enable you to do anything you couldn't do before
with a switch and assignment, right? So it seems like a priority should be
getting them to look nice and readable, which the comma syntax does. It
actually doesn't look too bad with both case and comma:

let thisColor = thatColor ? case .Blue: .Red, case .Green: .Blue, default:
.Yellow

And on the third hand, it still does save you a good amount of space even
if you're not all on one line. Compare

let thisColor: Color
switch thatColor {
case .Blue:
thisColor = .Red
case .Green
thisColor = .Blue
default:
thisColor = .Yellow
}

with

let thisColor = thatColor ?
case .Blue: .Red
case .Green: .Blue
default: .Yellow





On Sun, Dec 6, 2015 at 2:19 PM, Kevin Lundberg via swift-evolution <
swift-evolution at swift.org> wrote:

> Ostensibly, case may not be necessary if you could delimit each case on
> one line with something (perhaps a comma, or something else if that would
> not fit well within the grammar):
>
> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,
> default: .Yellow
>
> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution
> wrote:
>
> I like this too, seems more powerful.  Also, would single line expressions
> be allowed?  If not would case be required for example:
>
> let myFavoriteColor = yourFavoriteColor ?
>     case .Blue: .Red
>     case .Green: .Blue
>     case .Red: .Green
>     default: .Yellow
>
>
>
> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I really like this train of thought. +1
>
> l8r
> Sean
>
> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> What if we left the if { ...} else { ... } syntax alone (as a statement),
> and updated the ternary expression to be a more general pattern matching
> expression (closer to "switch")? Something like
>
> let x = condition ?
>    true: "Hello"
>    false: "Goodbye"
>
> let x = optionalValue ?
>    .Some(let unwrapped): "Hello, \(unwrapped)"
>    .None: "To Whom It May Concern"
>
> let myFavoriteColor = yourFavoriteColor ?
>     .Blue: .Red
>     .Green: .Blue
>     .Red: .Green
>
> let quadrant = (x, y) ?
>     let (x, y) where x < 50 && y < 50: "top left"
>     let (x, y) where x < 50 && y > 50: "bottom left"
>     let (x, y) where x > 50 && y < 50: "top right"
>     default: "bottom right"
>
> The colon comes from the fact that this is sort of a light-weight
> expression-based "switch" statement, where each branch can only contain an
> expression, not a series of statements.
>
> This is very similar to pattern matching expressions in languages like
> Haskell, ML, and Coq.
>
> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>
>
>
>
> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
> swift-evolution at swift.org>:
>
> I don't think you can just get rid of the if statement in favor of an
> expression. You still want to be able to do this:
>
> if (condition) {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> but that's not a valid expression (what is its type?).
>
>
>
> That would actually be no problem if Swift’s type system would have union
> types (Ceylon has union and intersection types which are quite awesome and
> enable lots of nice things quite naturally, see
> http://ceylon-lang.org/documentation/1.2/tour/types/).
>
> In that case the type of such an expression would just be the union of
> both types, which is written Int | String in Ceylon.
>
>
> -Thorsten
>
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> *_______________________________________________*
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2b983bcd/attachment.html>

From erica at ericasadun.com  Sun Dec  6 13:43:34 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 12:43:34 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
Message-ID: <F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>

I was specifically referring to value types. I apologize for not being clearer.

-- E


> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>
> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>
> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>
> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>
> -- E
>
>
>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>
>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>
>> let task = NSTask() +=+ {
>>     $0.launchPath = "/usr/bin/mdfind"
>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>     $0.standardOutput = pipe
>> }
>>
>> Note you can also use the configured object in the rhs:
>>
>> let questionLabel = UILabel() +=+ {
>>     $0.textAlignment = .Center
>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>     $0.text = currentQuestion.questionText
>>     $0.numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>
>> let questionLabel = UILabel() +=+ {
>>     .textAlignment = .Center
>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>     .text = currentQuestion.questionText
>>     .numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> Actually I would be happy with something like
>>
>> let questionLabel = UILabel() .{
>>     ..textAlignment = .Center
>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>     ..text = currentQuestion.questionText
>>     ..numberOfLines = 0
>>     view.addSubview($0)
>> }
>>
>> Other thoughts?
>>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/6f8e901a/attachment.html>

From matthew at anandabits.com  Sun Dec  6 13:48:27 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 13:48:27 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<7D68F57E-C847-4E 0D-AF3A- FD1F2DC928A9@icloud.com>
<1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
Message-ID: <11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>

I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).

I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.

Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.


> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:
>
> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):
>
> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow
>
> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:
>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:
>>
>> let myFavoriteColor = yourFavoriteColor ?
>>     case .Blue: .Red
>>     case .Green: .Blue
>>     case .Red: .Green
>>     default: .Yellow
>>
>>
>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> I really like this train of thought. +1
>>>
>>> l8r
>>> Sean
>>>
>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>>>>
>>>> let x = condition ?
>>>>    true: "Hello"
>>>>    false: "Goodbye"
>>>>
>>>> let x = optionalValue ?
>>>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>>>    .None: "To Whom It May Concern"
>>>>
>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>     .Blue: .Red
>>>>     .Green: .Blue
>>>>     .Red: .Green
>>>>
>>>> let quadrant = (x, y) ?
>>>>     let (x, y) where x < 50 && y < 50: "top left"
>>>>     let (x, y) where x < 50 && y > 50: "bottom left"
>>>>     let (x, y) where x > 50 && y < 50: "top right"
>>>>     default: "bottom right"
>>>>
>>>> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>>>>
>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>>>>
>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz<thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>>wrote:
>>>>
>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>>>>
>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>>>
>>>>> if (condition) {
>>>>>     funcWithSideEffectsThatReturnsInt()
>>>>> } else {
>>>>>     funcWithSideEffectsThatReturnsString()
>>>>> }
>>>>>
>>>>> but that's not a valid expression (what is its type?).
>>>>
>>>>
>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, seehttp://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).
>>>>
>>>> In that case the type of such an expression would just be the union of both types, which is writtenInt | Stringin Ceylon.
>>>>
>>>>
>>>> -Thorsten
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7ffd123c/attachment.html>

From ilya.nikokoshev at gmail.com  Sun Dec  6 13:54:31 2015
From: ilya.nikokoshev at gmail.com (ilya)
Date: Sun, 6 Dec 2015 22:54:31 +0300
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<8808357C-0780-423E-B028-1299CBCD2382@pobox.com>
<AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com>
Message-ID: <CAPh90aFdMXExnTgdaOiO_9xtYvHREW3mwC_VJQHOEbZ+qns8rQ@mail.gmail.com>

I think this is indeed an (anti-)feature of C-style loop.

`for var i = 0; i < 5; i += 1` is supposed to actually create a variable i;
in particular you can change this variable yourself or pass the reference
to it, so the implementation must work as follows:

var i = 0;
while( ...

Naturally, the closures are able to capture and modify i as well.

Or, in other words, by the definition of what C-style loop is, `for let i =
0; i < 5; i += 1` is impossible.

This magic behavior is in fact the best argument for the removal of C-style
loop, imho.



On Sun, Dec 6, 2015 at 10:14 PM, Erica Sadun via swift-evolution <
swift-evolution at swift.org> wrote:

> That is very odd indeed.
>
> If you add explicit capture, the issue goes away:
>
> var handlers: [() -> Void] = []
>
> for i in 0..<5 {
>     handlers.append {[i] in print(i, terminator:",") }
> }
>
> for handler in handlers {
>     handler()  // "0 1 2 3 4"
> }
>
> handlers = []
>
> for var i = 0; i < 5; i += 1 {
>     handlers.append {[i] in print(i, terminator:",") }
> }
>
> print("")
> for handler in handlers {
>     handler()  // was "5 5 5 5 5", now 1, 2, 3, 4, 5
> }
>
> It really seems like a bug to me rather than a feature of the for-loop
>
> -- Erica
>
>
> On Dec 6, 2015, at 12:03 PM, Kelly Gerber via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I think that the C-style *for* loop should be removed from Swift. The
> scope rules for this *for* loop are wrong. Every loop sees the same
> scope. This is a source of bugs if you export the loop variable name
> outside the scope of the *for* statement, for example in a closure. The
> following code illustrates the problem:
>
> var handlers: [() -> ()] = []
>
> for i in 0..<5 {
>     handlers.append { print(i) }
> }
>
> for handler in handlers {
>     handler()  // "0 1 2 3 4"
> }
>
> handlers = []
>
> for var i = 0; i < 5; i += 1 {
>     handlers.append { print(i) }
> }
>
> for handler in handlers {
>     handler()  // "5 5 5 5 5"
> }
>
> The Swift *for-in* loop does the right thing naturally. The C-style *for* loop
> does the wrong thing naturally. Removing the C-style *for* loop from
> Swift will eliminate one more class of possible errors from the language.
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a6f87478/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: open.gif
Type: image/gif
Size: 43 bytes
Desc: not available
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a6f87478/attachment.gif>

From liamdunn at me.com  Sun Dec  6 13:56:55 2015
From: liamdunn at me.com (Liam Butler-Lawrence)
Date: Sun, 06 Dec 2015 14:56:55 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com>
Message-ID: <CC1BC37C-FBA3-4D17-9ADA-379FA69A8078@me.com>

I’m going to add a +1 for Erica’s proposal. Here’s why:

1. For every situation in which the for loop could be used, a for…in (either with ranges or strides) or while loop could achieve the same goals.

2. For the vast majority of these cases, the for…in or while version is much cleaner and easier to read than for(init;test;inc). More extensive refactoring might be necessary in some cases, but in my opinion that effort would be worthwhile to improve readability and consistency.

3. For new programmers learning the language, the for…in is much easier to learn. To my understanding, this is a major goal of Swift. For those coming to Swift that have some experience with other languages, we should be guiding them towards the optimal Swift way of doing things. Letting those programmers use an inelegant, legacy feature “just because” does not seem to me to fit the goals of Swift. In addition, the for…in loop is not even a new Swift concept; many languages (including C++, and Objective-C, and Python) already have for..in style loops available.

4. To the comment that said "even that a feature isn't used doesn't mean that you need to remove that feature": I don’t agree. If a given feature is inferior to its alternatives and is not actually in common use, why not simplify the language and just remove it? I think many of us would agree that for(init;test;inc) loops fail the smell test we should be using: would we add this in Swift 3 if it didn’t already exist?

Lastly, I’d like to point out that I, too, had a knee-jerk negative reaction when I saw the already accepted proposal for removing ++ and --. After reading the rationale and discussion regarding that change, I completely changed my mind. I believe this proposal should accepted for similar reasons.

Thanks,
Liam

> On Dec 6, 2015, at 10:33 AM, inbox only via swift-evolution <swift-evolution at swift.org> wrote:
>
> True,even that a feature isn't used doesn't mean that you need to remove that feature.
> I hope that the proposal will be rejected.
>
> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org>:
>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.
>>
>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?
>>
>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.
>>
>> Cheers
>> Clemens
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/0035dafb/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 14:06:37 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 21:06:37 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
Message-ID: <CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>

Hi Colin,

the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.

The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
So something like this:

switch (enum) {
case .One:
// do something
reswitch .Two
case .Two:
// do something else
default:
// and so one
}

This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.

switch (enum) {
case .One:
// do something
reswitch .Two
case .OneAndAHalf
// maybe this change is not made by you but by a messed up merge
case .Two:
// do something else
default:
// and so one
}

In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.

Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other

switch (enum) {
case .One:
// do something
reswitch .Two
case .OneAndAHalf
// so something that you don’t want to do for .One
reswitch .Two
case .Two:
// do something else that you may want to do for .One and .Two
default:
// and so one
}

I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.

The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.

switch (enum) {
case .One:
// do something
x = 0;
reswitch .Two
case .OneAndAHalf
// so something that you don’t want to do for .One
reswitch .Two
case .Two where x > 0:
// do something else that you may want to do for .One and .Two
element = array[x]
default:
// and so one
}
(I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).

In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.

Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.

I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.

- Jacopo
Sent from my iPad

On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:

> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>
> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>
> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>
> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>
> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
>
> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>
> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>
> Thanks,
> -Colin
>
>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>
>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>
>> Sent from my iPad
>>
>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>
>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>
>>> - Steve
>>>
>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>
>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>
>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>
>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>
>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>
>>>> John.
>>>>
>>>>>
>>>>> John.
>>>>>
>>>>>>
>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>
>>>>>> switch op {
>>>>>> case LOAD_INDIRECT:
>>>>>>    in0 = memory[in1]
>>>>>>    fallthrough
>>>>>> case LOAD:
>>>>>>    out0 = memory[in0]
>>>>>> //...
>>>>>> }
>>>>>>
>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>
>>>>>> Cheers,
>>>>>> John
>>>>>>
>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>>
>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>
>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>
>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>
>>>>>>> John.
>>>>>>>
>>>>>>>>
>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>
>>>>>>>> -Kevin Ballard
>>>>>>>>
>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>
>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>>
>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>
>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>> expressed as
>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>> case .Enum2:
>>>>>>>>>>
>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>>>>>
>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>
>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>
>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>
>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>
>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>
>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>
>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>
>>>>>>>>>>> Thoughts?
>>>>>>>>>>>
>>>>>>>>>>> Daniel
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>>  _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8883dc87/attachment-0001.html>

From p at greendale.se  Sun Dec  6 14:17:54 2015
From: p at greendale.se (Per Melin)
Date: Sun, 6 Dec 2015 21:17:54 +0100
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com>
Message-ID: <CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com>

On Sat, Dec 5, 2015 at 7:15 PM, Chris Lattner <clattner at apple.com> wrote:

> Further, it is important to consider whether the code written using this
> will actually be *better* than the code written with these things as
> statements.  For example, the “switch” blocks tend to be very large, and
> turning them into expressions encourages additional indentation.


If you give functions implicit return at the same time – as in Haskell,
Erlang, Scala, Rust, Ruby, Lisp/Scheme/Clojure, etc –  there would be no
need for additional indentation half of the time.

I really, really like it in many of the mentioned languages, but I expect
that the C crowd will vehemently disagree. And maybe Swift is sufficiently
different from those languages that it makes less sense here. For example,
regardless of project, my average function body size in Erlang hovers
around two lines. Not even Slava Pestov would factor Swift that
aggressively.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/97e28d5f/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 14:24:29 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 15:24:29 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
Message-ID: <CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>

Thanks for the feedback, Matthew. It's sensible to me to consider dropping
the ternary operator. I like it because the analogy "C's if is to Swift's
if as C's ternary operator is to Swift's ternary operator" is (sort of)
satisfied. But it is also confusing, both for the reasons you mention, and
because ? has other meanings in Swift:

// compiler error without space betw thatColor and ?
let thisColor = thatColor?
case .Red: .Green
default: .Blue

On the other hand, is it really worth it to have control flow expressions
if they don't let your code look nicer?

let thisColor = switch thatColor {
case .Red:
return .Green;
default:
return .Yellow;
}

really isn't much nicer than

let thisColor: Color
switch thatColor {
case .Red:
thisColor = .Green
default:
thisColor = .Yellow
}

Maybe we could do a compromise, something like

let thisColor = switch thatColor
case .Red: .Green // must be an expression
default: .Yellow      // must be an expression

Or we could introduce a new keyword? Like *match*:

let thisColor = match thatColor
case .Red: .Green    // must be an expression
default: .Yellow         // must be an expression


I sort of like the new-keyword approach, because even though this is
similar to a switch, it's not a switch: there's no fallthrough, you can't
put statements inside, etc.

The problem with all these proposals:

let thisColor = match thatColor
case .Red: match thatOtherColor
case .Blue: .Green
case .Pink: .Yellow
default: .Orange
default: .Orange

is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can
know because of exhaustiveness checking, but this won't always work.) You
could solve this problem either by using parentheses around the whole
expression when necessary

let thisColor = match thatColor
case .Red: (match thatOtherColor
case .Blue: .Green
case .Pink: .Yellow
default: .Orange)
default: .Orange

or by adding curly braces in again

let thisColor = match thatColor {
case .Red: match thatOtherColor {
case .Blue: .Green
case .Pink: .Yellow
default: .Orange
}
default: .Orange
}

But that starts to look like switch again. (Of course, the best way to
handle this is as a programmer is to just switch on the tuple (thatColor,
thatOtherColor), but the language should allow for nested control
expressions.)


On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <
swift-evolution at swift.org> wrote:

> I am not a fan of this approach based on the ternary operator.  The
> ternary operator is already a bit of an anomaly in that all other operators
> are unary or binary and do not perform any control flow (beyond possibly
> short circuiting an autoclosure argument).
>
> I would much rather features that perform control flow continue to use
> keywords, but allow them to be expressions.
>
> Once we have control flow expressions I would like to see the ternary
> operator removed from the language as it would no longer server a purpose.
> Removing the ternary operator seems to fit nicely with the direction to
> remove some features that are carried over from C-based languages but don’t
> necessarily fit with the direction Swift is heading.
>
>
> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> Ostensibly, case may not be necessary if you could delimit each case on
> one line with something (perhaps a comma, or something else if that would
> not fit well within the grammar):
>
> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,
> default: .Yellow
>
> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution
> wrote:
>
> I like this too, seems more powerful.  Also, would single line expressions
> be allowed?  If not would case be required for example:
>
> let myFavoriteColor = yourFavoriteColor ?
>     case .Blue: .Red
>     case .Green: .Blue
>     case .Red: .Green
>     default: .Yellow
>
>
>
> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I really like this train of thought. +1
>
> l8r
> Sean
>
> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> What if we left the if { ...} else { ... } syntax alone (as a statement),
> and updated the ternary expression to be a more general pattern matching
> expression (closer to "switch")? Something like
>
> let x = condition ?
>    true: "Hello"
>    false: "Goodbye"
>
> let x = optionalValue ?
>    .Some(let unwrapped): "Hello, \(unwrapped)"
>    .None: "To Whom It May Concern"
>
> let myFavoriteColor = yourFavoriteColor ?
>     .Blue: .Red
>     .Green: .Blue
>     .Red: .Green
>
> let quadrant = (x, y) ?
>     let (x, y) where x < 50 && y < 50: "top left"
>     let (x, y) where x < 50 && y > 50: "bottom left"
>     let (x, y) where x > 50 && y < 50: "top right"
>     default: "bottom right"
>
> The colon comes from the fact that this is sort of a light-weight
> expression-based "switch" statement, where each branch can only contain an
> expression, not a series of statements.
>
> This is very similar to pattern matching expressions in languages like
> Haskell, ML, and Coq.
>
> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:
>
>
>
>
> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
> swift-evolution at swift.org>:
>
> I don't think you can just get rid of the if statement in favor of an
> expression. You still want to be able to do this:
>
> if (condition) {
>     funcWithSideEffectsThatReturnsInt()
> } else {
>     funcWithSideEffectsThatReturnsString()
> }
>
> but that's not a valid expression (what is its type?).
>
>
>
> That would actually be no problem if Swift’s type system would have union
> types (Ceylon has union and intersection types which are quite awesome and
> enable lots of nice things quite naturally, see
> http://ceylon-lang.org/documentation/1.2/tour/types/).
>
> In that case the type of such an expression would just be the union of
> both types, which is written Int | String in Ceylon.
>
>
> -Thorsten
>
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> *_______________________________________________*
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/aa4516e4/attachment.html>

From erica at ericasadun.com  Sun Dec  6 14:30:43 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 13:30:43 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
Message-ID: <DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>

It's probably better at this point for me to collect my thoughts and summarize where I am at.

https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>

Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
then I will start a new list thread as a Proposal rather than as a Request for Discussion.

Best,

-- E


> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>
> Sorry, did I misunderstand the question?
>
> Did you asked whether my definition will work for immutable value types?
> If that's the question, the answer is still yes, the link has an example :)
>
> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
> I was specifically referring to value types. I apologize for not being clearer.
>
> -- E
>
>
>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>
>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>
>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>
>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>
>> -- E
>>
>>
>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>
>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>
>>> let task = NSTask() +=+ {
>>>     $0.launchPath = "/usr/bin/mdfind"
>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>     $0.standardOutput = pipe
>>> }
>>>
>>> Note you can also use the configured object in the rhs:
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     $0.textAlignment = .Center
>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     $0.text = currentQuestion.questionText
>>>     $0.numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     .textAlignment = .Center
>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     .text = currentQuestion.questionText
>>>     .numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Actually I would be happy with something like
>>>
>>> let questionLabel = UILabel() .{
>>>     ..textAlignment = .Center
>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>     ..text = currentQuestion.questionText
>>>     ..numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Other thoughts?
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7c063b3c/attachment.html>

From possen at gmail.com  Sun Dec  6 14:30:42 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 12:30:42 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com> <7D68F57E-C847-4E
0D-AF3A- FD1F2DC928A9@icloud.com>
<1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
Message-ID: <4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com>

I prefer making “case” optional if it can be accommodated, for compactness on a single line but maybe can be provided for those doing multiline so it is more explicit.

if not ? how about expression “switch?” to separate expression switch, from the switch statement? One issue is if is if ? is reserved for optionals.  So:

let myColor = yourColor switch? .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow

or could be optionally with case with semicolons to separate, as a line continuation:

let myColor = yourColor switch? case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow

But “case" would be mostly for multiline:

let myColor = yourColor switch?
case .Blue :  .Reds
case .Green: .Blue
case .Red: .Green
default: .Yellow

could also be written as:

let myColor = yourColor switch?
.Blue :  .Reds
.Green: .Blue
.Red: .Green
default: .Yellow

Also, ”if" could be expressionized:

let myColor = condition if?  .Blue; .Red


> On Dec 6, 2015, at 11:48 AM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>
> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).
>
> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.
>
> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.
>
>
>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):
>>
>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow
>>
>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:
>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:
>>>
>>> let myFavoriteColor = yourFavoriteColor ?
>>>     case .Blue: .Red
>>>     case .Green: .Blue
>>>     case .Red: .Green
>>>     default: .Yellow
>>>
>>>
>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> I really like this train of thought. +1
>>>>
>>>> l8r
>>>> Sean
>>>>
>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>>>>>
>>>>> let x = condition ?
>>>>>    true: "Hello"
>>>>>    false: "Goodbye"
>>>>>
>>>>> let x = optionalValue ?
>>>>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>>>>    .None: "To Whom It May Concern"
>>>>>
>>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>>     .Blue: .Red
>>>>>     .Green: .Blue
>>>>>     .Red: .Green
>>>>>
>>>>> let quadrant = (x, y) ?
>>>>>     let (x, y) where x < 50 && y < 50: "top left"
>>>>>     let (x, y) where x < 50 && y > 50: "bottom left"
>>>>>     let (x, y) where x > 50 && y < 50: "top right"
>>>>>     default: "bottom right"
>>>>>
>>>>> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>>>>>
>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>>>>>
>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz<thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>>wrote:
>>>>>
>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>>>>>
>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>>>>
>>>>>> if (condition) {
>>>>>>     funcWithSideEffectsThatReturnsInt()
>>>>>> } else {
>>>>>>     funcWithSideEffectsThatReturnsString()
>>>>>> }
>>>>>>
>>>>>> but that's not a valid expression (what is its type?).
>>>>>
>>>>>
>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, seehttp://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).
>>>>>
>>>>> In that case the type of such an expression would just be the union of both types, which is writtenInt | Stringin Ceylon.
>>>>>
>>>>>
>>>>> -Thorsten
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/564c57b5/attachment.html>

From michel.fortin at michelf.ca  Sun Dec  6 14:37:57 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sun, 6 Dec 2015 15:37:57 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
Message-ID: <9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>

There is actually one good reason I see in favor of keeping the C-style for loop, and only one: ease of porting existing code to Swift.

If you are porting code from another language that uses C-style for loops, currently you can keep the loop as is while you translate all the syntactic differences everywhere. If Swift didn't had a C-style for loop, then you'd need to rethink the control flow at the same time you are converting everything else, increasing the risk of errors during what is already a delicate operation.

C-style for loops are very common in code you can find everywhere because many languages have it, and therefore there is a lot of algorithms, sometime tricky algorithms you don't want to mess up, that rely on such loops. Even if you had the desire to convert all of them to for-in loops in your port, rewriting the control flow *at the same time* you are addressing all the other porting issues is much worse than doing it in a separate step *after* the crude port has been tested to work.

In other words: you should avoid refactoring everything in one step. The C-style for loop enables that.

--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From tomas at linhart.me  Sat Dec  5 17:19:52 2015
From: tomas at linhart.me (=?UTF-8?B?VG9tw6HFoSBMaW5oYXJ0?=)
Date: Sun, 6 Dec 2015 00:19:52 +0100
Subject: [swift-evolution] Proposal: Stored properties in extensions
Message-ID: <CAM4NbbywZMv2OkxJQvTKheUHV4LipUHUh-V4FSd58raNSsoqqw@mail.gmail.com>

Hello,

very often, it is necessary to define stored properties in extensions. It
is currently only possible in Swift that has access to ObjC runtime with
associated objects (in theory it might be possible with some global
dictionary) and it requires a lot of boilerplate. Associated objects are
used in UIKit quite heavily so it is something that authors of frameworks
need.

It would be nice to able to create properties in extensions natively in
Swift without need of Objective-C and without a boilerplate. These
properties could be marked with some extra keyword/attribute so it is
obvious they are different and they have a cost (depends on their
implementation).

What do you think?

Tomáš
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/9a93f633/attachment.html>

From alexl.mail at gmail.com  Sat Dec  5 18:09:46 2015
From: alexl.mail at gmail.com (Alex Lew)
Date: Sat, 5 Dec 2015 19:09:46 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <852EF944-A503-4021-8A7F-AE6876438981@gbis.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<852EF944-A503-4021-8A7F-AE6876438981@gbis.com>
Message-ID: <C3E05739-7629-4A8D-9C51-DBE6F87833EA@gmail.com>

I believe the idea with switch is that it would be nice to be able to do something like

// make sure we have different favorite colors
let myFavoriteColor =
switch yourFavoriteColor {
case .Red:
return .Blue
case .Green:
return .Red
case .Blue:
return .Green
}

This is useful and exists in other functional languages. For example, ML has “case … of …”, Coq has “match…with…end”, etc.

This is similar to what you are proposing with if:

let x = if (condition) { return value } else { return otherValue }

because in both cases you are taking what is currently a statement in Swift and enabling it to be used as an expression. (Of course, the syntax would ideally be nicer — maybe we limit each case’s body to be a single expression and get rid of the return keyword, for example.) Worth noting that in both cases, the type-checker needs to ensure that the type of each result is the same.

The semantics of what you’re now proposing — an if? binary operator that evaluates a condition then evaluates to either nil (if false) or some value (if true) — is slightly different. I’m not sure I love it — the general use case would be something like “if __ then ___ else ___” and I don’t think it reads that way. It also doesn’t allow for pattern matching (though to be fair, neither does the ternary operator) — it could be cool to see something like

let greeting = “Hello, \(name),” if let name = optionalName else “To Whom It May Concern:”

-Alex

> On Dec 5, 2015, at 6:28 PM, Jonathan Hull via swift-evolution <swift-evolution at swift.org> wrote:
>
> I think I have a solution for the ternary part, but I am not sure I fully understand what is being asked for in the case of switch.  Could someone clarify?
>
> There is another thread which goes into the idea a little more, but the basic idea is that we replace the ternary operator with ‘if?'
>
> let x = value if? condition
>
>
> If condition is true, then x is value… otherwise it is nil.  You can combine with the nil-coalescing operator to get else and else if style behavior:
>
> let x = valueA if? conditionA ?? valueB if? conditionB ?? valueC
>
>
> Thanks,
> Jon
>
>
>> On Dec 5, 2015, at 9:09 AM, Chris Lattner < clattner at apple.com <mailto:clattner at apple.com>> wrote:
>>
>>
>>> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez < cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:
>>>
>>> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy.
>>>
>>> Some interesting code in the standard library that uses the ternary operator quite a bit.
>>>
>>> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357>
>>
>> FWIW, I have no love for the ternary operator (it is totally "bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.
>>
>> If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.
>>
>> -Chris
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>_______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1cd0d176/attachment.html>

From ilya.belenkiy at gmail.com  Sat Dec  5 21:40:24 2015
From: ilya.belenkiy at gmail.com (Ilya Belenkiy)
Date: Sun, 06 Dec 2015 03:40:24 +0000
Subject: [swift-evolution] Introduce "associated_type" keyword
In-Reply-To: <3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com>
References: <C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com>
<80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com>
<BD192734-066B-4907-887C-0286D799CBE1@klundberg.com>
<6407A281-C936-40E3-B882-1E63279F4755@gmail.com>
<CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com>
<22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com>
<CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com>
<3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com>
Message-ID: <CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com>

+1 for using a distinct keyword for associated types

On Sat, Dec 5, 2015 at 9:49 PM David Waite via swift-evolution <
swift-evolution at swift.org> wrote:

> However, if a protocol wished to use type aliases not as part of a
> contract but for clarity, this would still need to be defined within the
> protocol in order for the associated types to be used in the typealias
> declarations.
>
> -DW
>
> > On Dec 5, 2015, at 7:29 PM, Dmitri Gribenko via swift-evolution <
> swift-evolution at swift.org> wrote:
> >
> > On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com>
> wrote:
> >> Great :)
> >>
> >> Also, this hasn't been explicitly discussed yet. But do you all agree
> about adding "real" typealias declarations (with the typealias keyword)
> inside protocols?
> >
> > Concrete typealieases are not requirements, so they shouldn't be
> > defined inside of a protocol.  Instead, they should be defined in the
> > protocol extension.  In fact, this has been a plan of record for some
> > time, but it wasn't implemented.
> >
> > extension SequenceType {
> >  typealias Element = Generator.Element
> > }
> >
> > Dmitri
> >
> > --
> > main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> > (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/34fa5eff/attachment.html>

From ilya.belenkiy at gmail.com  Sat Dec  5 21:43:22 2015
From: ilya.belenkiy at gmail.com (Ilya Belenkiy)
Date: Sun, 06 Dec 2015 03:43:22 +0000
Subject: [swift-evolution] Proposal: Allow Getters and Setters to Throw
In-Reply-To: <DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>
References: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>
<DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>
Message-ID: <CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com>

+1

On Sat, Dec 5, 2015 at 10:17 PM Matthew Johnson via swift-evolution <
swift-evolution at swift.org> wrote:

> +1 to this.  Subscripts should also be able to throw and currently cannot.
>
>
> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> One of the aspects of Swift that I like is computed properties for
> structures and classes. It allows for adding logic when obtaining values or
> for having the returned value be dependent on another.
>
> As of the `ErrorType` protocol introduction in Swift 2, we can throw
> errors when it comes to functions and initializers. However, this does not
> apply to getters and setters.
>
> ```swift
> struct File<Data> {
>     var contents: Data {
>         get throws { ... }
>         set throws { ... }
>     }
> }
> ```
>
> A better example would be getting and setting the current working
> directory of the process:
>
> ```swift
> import Foundation
>
> extension Process {
>     static var workingDirectory: String {
>         get {
>             let fileManager = NSFileManager.defaultManager()
>             return fileManager.currentDirectoryPath
>         }
>         set throws {
>             let fileManager = NSFileManager.defaultManager()
>             guard fileManager.changeCurrentDirectoryPath(newValue) else {
>                 throw Error("...")
>             }
>         }
>     }
> }
>
>
>
> ```
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/af72ee95/attachment.html>

From clemens.wagner.2 at gmx.de  Sun Dec  6 04:02:23 2015
From: clemens.wagner.2 at gmx.de (Clemens Wagner)
Date: Sun, 6 Dec 2015 11:02:23 +0100
Subject: [swift-evolution] C-style For Loops
Message-ID: <55E6FBE9-E818-4240-8D74-37B7C98FDE9A@gmx.de>

> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.

But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?

I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.

Cheers
Clemens

From possen at gmail.com  Sun Dec  6 14:46:50 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 12:46:50 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
Message-ID: <0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com>

Yep probably does need braces: So for switch? if? suggestion i just made.

let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }

let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }

let myColor = yourColor switch? {
case .Blue :  .Reds
case .Green: .Blue
case .Red: .Green
default: .Yellow
}

let myColor = yourColor switch? {
.Blue :  .Reds
.Green: .Blue
.Red: .Green
default: .Yellow
}

let myColor = condition if?  { .Blue; .Red }

I don’t find that looks bad.

- Paul


> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:
>
> Thanks for the feedback, Matthew. It's sensible to me to consider dropping the ternary operator. I like it because the analogy "C's if is to Swift's if as C's ternary operator is to Swift's ternary operator" is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:
>
>  // compiler error without space betw thatColor and ?
> let thisColor = thatColor?
>      case .Red: .Green
>      default: .Blue
>
> On the other hand, is it really worth it to have control flow expressions if they don't let your code look nicer?
>
> let thisColor = switch thatColor {
>      case .Red:
>           return .Green;
>      default:
>           return .Yellow;
> }
>
> really isn't much nicer than
>
> let thisColor: Color
> switch thatColor {
>      case .Red:
>           thisColor = .Green
>      default:
>           thisColor = .Yellow
> }
>
> Maybe we could do a compromise, something like
>
> let thisColor = switch thatColor
>      case .Red: .Green // must be an expression
>      default: .Yellow      // must be an expression
>
> Or we could introduce a new keyword? Like match:
>
> let thisColor = match thatColor
>       case .Red: .Green    // must be an expression
>       default: .Yellow         // must be an expression
>
>
> I sort of like the new-keyword approach, because even though this is similar to a switch, it's not a switch: there's no fallthrough, you can't put statements inside, etc.
>
> The problem with all these proposals:
>
> let thisColor = match thatColor
>      case .Red: match thatOtherColor
>                            case .Blue: .Green
>                            case .Pink: .Yellow
>                            default: .Orange
>      default: .Orange
>
> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won't always work.) You could solve this problem either by using parentheses around the whole expression when necessary
>
> let thisColor = match thatColor
>      case .Red: (match thatOtherColor
>                            case .Blue: .Green
>                            case .Pink: .Yellow
>                            default: .Orange)
>      default: .Orange
>
> or by adding curly braces in again
>
> let thisColor = match thatColor {
>      case .Red: match thatOtherColor {
>                            case .Blue: .Green
>                            case .Pink: .Yellow
>                            default: .Orange
>                         }
>      default: .Orange
> }
>
> But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)
>
>
> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).
>
> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.
>
> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.
>
>
>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):
>>
>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow
>>
>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:
>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:
>>>
>>> let myFavoriteColor = yourFavoriteColor ?
>>>     case .Blue: .Red
>>>     case .Green: .Blue
>>>     case .Red: .Green
>>>     default: .Yellow
>>>
>>>
>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> I really like this train of thought. +1
>>>>
>>>> l8r
>>>> Sean
>>>>
>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>>>>>
>>>>> let x = condition ?
>>>>>    true: "Hello"
>>>>>    false: "Goodbye"
>>>>>
>>>>> let x = optionalValue ?
>>>>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>>>>    .None: "To Whom It May Concern"
>>>>>
>>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>>     .Blue: .Red
>>>>>     .Green: .Blue
>>>>>     .Red: .Green
>>>>>
>>>>> let quadrant = (x, y) ?
>>>>>     let (x, y) where x < 50 && y < 50: "top left"
>>>>>     let (x, y) where x < 50 && y > 50: "bottom left"
>>>>>     let (x, y) where x > 50 && y < 50: "top right"
>>>>>     default: "bottom right"
>>>>>
>>>>> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>>>>>
>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>>>>>
>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>> wrote:
>>>>>
>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>>>>>
>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>>>>
>>>>>> if (condition) {
>>>>>>     funcWithSideEffectsThatReturnsInt()
>>>>>> } else {
>>>>>>     funcWithSideEffectsThatReturnsString()
>>>>>> }
>>>>>>
>>>>>> but that's not a valid expression (what is its type?).
>>>>>
>>>>>
>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).
>>>>>
>>>>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.
>>>>>
>>>>>
>>>>> -Thorsten
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/f4001071/attachment.html>

From david at alkaline-solutions.com  Sun Dec  6 14:48:05 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sun, 6 Dec 2015 13:48:05 -0700
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
Message-ID: <C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com>

To cope with the pattern matching cases, I would say that reswitch either has to:
1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns
2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:

switch(optionalThing) {
case .None:
print(“assuming default value”)
reswitch “default”
case .Some(let str):
print(“processing value \(str)”);
}

This does however have non-intuitive behavior - when the second case statement is hit, “str" is no longer equal to "optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop:

switch(optionalThing) {
case .None:
print(“assuming default value”)
optionalThing = “default”
reswitch
case .Some(let str):
print(“processing value \(str)”);
}

The existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch"

-DW

> On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
>
>  Hi Colin,
>
> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>
> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
> So something like this:
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		reswitch .Two
> 	case .Two:
> 		// do something else
> 	default:
> 		// and so one
> }
>
> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		reswitch .Two
> 	case .OneAndAHalf
> 		// maybe this change is not made by you but by a messed up merge
> 	case .Two:
> 		// do something else
> 	default:
> 		// and so one
> }
>
> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>
> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		reswitch .Two
> 	case .OneAndAHalf
> 		// so something that you don’t want to do for .One
> 		reswitch .Two
> 	case .Two:
> 		// do something else that you may want to do for .One and .Two
> 	default:
> 		// and so one
> }
>
> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>
> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		x = 0;
> 		reswitch .Two
> 	case .OneAndAHalf
> 		// so something that you don’t want to do for .One
> 		reswitch .Two
> 	case .Two where x > 0:
> 		// do something else that you may want to do for .One and .Two
> 		element = array[x]
> 	default:
> 		// and so one
> }
> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>
> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>
> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>
> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>
> - Jacopo
> Sent from my iPad
>
> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>
>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>
>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>
>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>
>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
>>
>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>
>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>
>> Thanks,
>> -Colin
>>
>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>
>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>
>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>
>>>> - Steve
>>>>
>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>
>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>
>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>
>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>
>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>
>>>>> John.
>>>>>
>>>>>>
>>>>>> John.
>>>>>>
>>>>>>>
>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>
>>>>>>> switch op {
>>>>>>> case LOAD_INDIRECT:
>>>>>>>    in0 = memory[in1]
>>>>>>>    fallthrough
>>>>>>> case LOAD:
>>>>>>>    out0 = memory[in0]
>>>>>>> //...
>>>>>>> }
>>>>>>>
>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>
>>>>>>> Cheers,
>>>>>>> John
>>>>>>>
>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>>>
>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>
>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>
>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>
>>>>>>>> John.
>>>>>>>>
>>>>>>>>>
>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>
>>>>>>>>> -Kevin Ballard
>>>>>>>>>
>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>
>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>>>
>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>
>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>> expressed as
>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>
>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>>>>>>
>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>
>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>
>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>
>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>
>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>
>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>
>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>
>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>
>>>>>>>>>>>> Daniel
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>>  _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/862072e7/attachment.html>

From ilya.nikokoshev at gmail.com  Sun Dec  6 14:48:46 2015
From: ilya.nikokoshev at gmail.com (ilya)
Date: Sun, 06 Dec 2015 20:48:46 +0000
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
Message-ID: <CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>

I applaud honest description of drawbacks in the proposal :)

There examples given, I think, demonstrate that using self without any
special access leads to unresolvable ambiguities.

If one wants to work "inside" the configured object, this seems like a good
job for a private initializer. All of the ambiguities will be resolved,
because extracting the init away removes its ability to capture names from
the local context.

Alternatively, I think it makes sense to continue working on configuration
syntax, with "default" access to local context and "explicit" access to the
object. Let's just replace $0 with something else.

Hopefully I don't sounds too pessimistic. Erica's proposal looks going in
the right direction to me.
On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <
swift-evolution at swift.org> wrote:

> It's probably better at this point for me to collect my thoughts and
> summarize where I am at.
>
> https://gist.github.com/erica/eb32feb22ba99629285a
>
> Please feel free to comment on-list about this proposal (github does not
> forward comment alerts) and
> then I will start a new list thread as a Proposal rather than as a Request
> for Discussion.
>
> Best,
>
> -- E
>
>
> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>
> Sorry, did I misunderstand the question?
>
> Did you asked whether my definition will work for immutable value types?
> If that's the question, the answer is still yes, the link has an example
> :)
>
> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com> wrote:
>
>> I was specifically referring to value types. I apologize for not being
>> clearer.
>>
>> -- E
>>
>>
>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>
>> Yes, it works for immutable objects with the correct definition, see the
>> playground contents at
>> https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift
>>
>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>
>>> I have developed something similar as well (
>>> http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/
>>> ).
>>>
>>> Is yours capable of handling enums and structs that would otherwise be
>>> let after declaration because mine is not.
>>>
>>> -- E
>>>
>>>
>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail
>>> to fully set up an instance for use.  Here's one example: ...
>>>
>>> FWIW, I created a configuration operator more then a year ago, and use
>>> it in all of my Swift projects:
>>>
>>> let task = NSTask() +=+ {
>>>     $0.launchPath = "/usr/bin/mdfind"
>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>     $0.standardOutput = pipe
>>> }
>>>
>>> Note you can also use the configured object in the rhs:
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     $0.textAlignment = .Center
>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     $0.text = currentQuestion.questionText
>>>     $0.numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> This $0. certainly looks ugly and it would be great to be able to
>>> simplify this. I don't llike the following much though (dot-syntax can be
>>> ambiguos here, and using simply a method name is even worse):
>>>
>>> let questionLabel = UILabel() +=+ {
>>>     .textAlignment = .Center
>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>     .text = currentQuestion.questionText
>>>     .numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Actually I would be happy with something like
>>>
>>> let questionLabel = UILabel() .{
>>>     ..textAlignment = .Center
>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>     ..text = currentQuestion.questionText
>>>     ..numberOfLines = 0
>>>     view.addSubview($0)
>>> }
>>>
>>> Other thoughts?
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4bb27359/attachment.html>

From colin at springsandstruts.com  Sun Dec  6 14:52:52 2015
From: colin at springsandstruts.com (Colin Barrett)
Date: Sun, 6 Dec 2015 15:52:52 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
Message-ID: <6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>

Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.

I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.

I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...

I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.

Thanks,
-Colin

> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
>
>  Hi Colin,
>
> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>
> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
> So something like this:
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		reswitch .Two
> 	case .Two:
> 		// do something else
> 	default:
> 		// and so one
> }
>
> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		reswitch .Two
> 	case .OneAndAHalf
> 		// maybe this change is not made by you but by a messed up merge
> 	case .Two:
> 		// do something else
> 	default:
> 		// and so one
> }
>
> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>
> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		reswitch .Two
> 	case .OneAndAHalf
> 		// so something that you don’t want to do for .One
> 		reswitch .Two
> 	case .Two:
> 		// do something else that you may want to do for .One and .Two
> 	default:
> 		// and so one
> }
>
> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>
> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>
> switch (enum) {
> 	case .One:
> 		// do something
> 		x = 0;
> 		reswitch .Two
> 	case .OneAndAHalf
> 		// so something that you don’t want to do for .One
> 		reswitch .Two
> 	case .Two where x > 0:
> 		// do something else that you may want to do for .One and .Two
> 		element = array[x]
> 	default:
> 		// and so one
> }
> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>
> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>
> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>
> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>
> - Jacopo
> Sent from my iPad
>
> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>
>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>
>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>
>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>
>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
>>
>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>
>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>
>> Thanks,
>> -Colin
>>
>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>
>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>
>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>
>>>> - Steve
>>>>
>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>
>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>
>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>
>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>
>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>
>>>>> John.
>>>>>
>>>>>>
>>>>>> John.
>>>>>>
>>>>>>>
>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>
>>>>>>> switch op {
>>>>>>> case LOAD_INDIRECT:
>>>>>>>    in0 = memory[in1]
>>>>>>>    fallthrough
>>>>>>> case LOAD:
>>>>>>>    out0 = memory[in0]
>>>>>>> //...
>>>>>>> }
>>>>>>>
>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>
>>>>>>> Cheers,
>>>>>>> John
>>>>>>>
>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>>>
>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>
>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>
>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>
>>>>>>>> John.
>>>>>>>>
>>>>>>>>>
>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>
>>>>>>>>> -Kevin Ballard
>>>>>>>>>
>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>
>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>>>
>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>
>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>> expressed as
>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>
>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>>>>>>
>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>
>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>
>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>
>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>
>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>
>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>
>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>
>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>
>>>>>>>>>>>> Daniel
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>>  _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/892e7f01/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 14:54:35 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 15:54:35 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
Message-ID: <CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com>

Hmm. Something about braces inside expressions just feels wrong to me.

I also read switch? and if? as being some optional-related versions of
switch and if. And I don't love putting the condition /
value-to-switch-on *before
*the keyword, if we're going to use a keyword.

(Also: exhaustiveness checking *could *theoretically allow resolution of
ambiguity in nested switch expressions. We would just have to require that
as soon as you've exhausted all possibilities, you don't add more cases and
the expression is over.)

On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com> wrote:

> Yep probably does need braces: So for switch? if? suggestion i just made.
>
> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red:
> .Green, default: .Yellow }
>
> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;
>  case .Red: .Green; default: .Yellow }
>
> let myColor = yourColor switch? {
> case .Blue :  .Reds
> case .Green: .Blue
> case .Red: .Green
> default: .Yellow
> }
>
> let myColor = yourColor switch? {
> .Blue :  .Reds
> .Green: .Blue
> .Red: .Green
> default: .Yellow
> }
>
> let myColor = condition if?  { .Blue; .Red }
>
> I don’t find that looks bad.
>
> - Paul
>
>
> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> Thanks for the feedback, Matthew. It's sensible to me to consider dropping
> the ternary operator. I like it because the analogy "C's if is to Swift's
> if as C's ternary operator is to Swift's ternary operator" is (sort of)
> satisfied. But it is also confusing, both for the reasons you mention, and
> because ? has other meanings in Swift:
>
>  // compiler error without space betw thatColor and ?
> let thisColor = thatColor?
>      case .Red: .Green
>      default: .Blue
>
> On the other hand, is it really worth it to have control flow expressions
> if they don't let your code look nicer?
>
> let thisColor = switch thatColor {
>      case .Red:
>           return .Green;
>      default:
>           return .Yellow;
> }
>
> really isn't much nicer than
>
> let thisColor: Color
> switch thatColor {
>      case .Red:
>           thisColor = .Green
>      default:
>           thisColor = .Yellow
> }
>
> Maybe we could do a compromise, something like
>
> let thisColor = switch thatColor
>      case .Red: .Green // must be an expression
>      default: .Yellow      // must be an expression
>
> Or we could introduce a new keyword? Like *match*:
>
> let thisColor = match thatColor
>       case .Red: .Green    // must be an expression
>       default: .Yellow         // must be an expression
>
>
> I sort of like the new-keyword approach, because even though this is
> similar to a switch, it's not a switch: there's no fallthrough, you can't
> put statements inside, etc.
>
> The problem with all these proposals:
>
> let thisColor = match thatColor
>      case .Red: match thatOtherColor
>                            case .Blue: .Green
>                            case .Pink: .Yellow
>                            default: .Orange
>      default: .Orange
>
> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can
> know because of exhaustiveness checking, but this won't always work.) You
> could solve this problem either by using parentheses around the whole
> expression when necessary
>
> let thisColor = match thatColor
>      case .Red: (match thatOtherColor
>                            case .Blue: .Green
>                            case .Pink: .Yellow
>                            default: .Orange)
>      default: .Orange
>
> or by adding curly braces in again
>
> let thisColor = match thatColor {
>      case .Red: match thatOtherColor {
>                            case .Blue: .Green
>                            case .Pink: .Yellow
>                            default: .Orange
>                         }
>      default: .Orange
> }
>
> But that starts to look like switch again. (Of course, the best way to
> handle this is as a programmer is to just switch on the tuple (thatColor,
> thatOtherColor), but the language should allow for nested control
> expressions.)
>
>
> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> I am not a fan of this approach based on the ternary operator.  The
>> ternary operator is already a bit of an anomaly in that all other operators
>> are unary or binary and do not perform any control flow (beyond possibly
>> short circuiting an autoclosure argument).
>>
>> I would much rather features that perform control flow continue to use
>> keywords, but allow them to be expressions.
>>
>> Once we have control flow expressions I would like to see the ternary
>> operator removed from the language as it would no longer server a purpose.
>> Removing the ternary operator seems to fit nicely with the direction to
>> remove some features that are carried over from C-based languages but don’t
>> necessarily fit with the direction Swift is heading.
>>
>>
>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> Ostensibly, case may not be necessary if you could delimit each case on
>> one line with something (perhaps a comma, or something else if that would
>> not fit well within the grammar):
>>
>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,
>> default: .Yellow
>>
>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution
>> wrote:
>>
>> I like this too, seems more powerful.  Also, would single line
>> expressions be allowed?  If not would case be required for example:
>>
>> let myFavoriteColor = yourFavoriteColor ?
>>     case .Blue: .Red
>>     case .Green: .Blue
>>     case .Red: .Green
>>     default: .Yellow
>>
>>
>>
>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> I really like this train of thought. +1
>>
>> l8r
>> Sean
>>
>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> What if we left the if { ...} else { ... } syntax alone (as a statement),
>> and updated the ternary expression to be a more general pattern matching
>> expression (closer to "switch")? Something like
>>
>> let x = condition ?
>>    true: "Hello"
>>    false: "Goodbye"
>>
>> let x = optionalValue ?
>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>    .None: "To Whom It May Concern"
>>
>> let myFavoriteColor = yourFavoriteColor ?
>>     .Blue: .Red
>>     .Green: .Blue
>>     .Red: .Green
>>
>> let quadrant = (x, y) ?
>>     let (x, y) where x < 50 && y < 50: "top left"
>>     let (x, y) where x < 50 && y > 50: "bottom left"
>>     let (x, y) where x > 50 && y < 50: "top right"
>>     default: "bottom right"
>>
>> The colon comes from the fact that this is sort of a light-weight
>> expression-based "switch" statement, where each branch can only contain an
>> expression, not a series of statements.
>>
>> This is very similar to pattern matching expressions in languages like
>> Haskell, ML, and Coq.
>>
>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de>
>> wrote:
>>
>>
>>
>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
>> swift-evolution at swift.org>:
>>
>> I don't think you can just get rid of the if statement in favor of an
>> expression. You still want to be able to do this:
>>
>> if (condition) {
>>     funcWithSideEffectsThatReturnsInt()
>> } else {
>>     funcWithSideEffectsThatReturnsString()
>> }
>>
>> but that's not a valid expression (what is its type?).
>>
>>
>>
>> That would actually be no problem if Swift’s type system would have union
>> types (Ceylon has union and intersection types which are quite awesome and
>> enable lots of nice things quite naturally, see
>> http://ceylon-lang.org/documentation/1.2/tour/types/).
>>
>> In that case the type of such an expression would just be the union of
>> both types, which is written Int | String in Ceylon.
>>
>>
>> -Thorsten
>>
>>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> *_______________________________________________*
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> Untracked with Trackbuster <https://trackbuster.com/?sig>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/331515fd/attachment.html>

From sean at fifthace.com  Sun Dec  6 15:04:10 2015
From: sean at fifthace.com (Sean Heber)
Date: Sun, 6 Dec 2015 15:04:10 -0600
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
Message-ID: <2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com>

This is the exact scenario that lead to my own code base having a few cases of C-style (all of which I've now trivially removed). Even so, I do not believe it is worth keeping it around for this reason.

l8r
Sean

> On Dec 6, 2015, at 2:37 PM, Michel Fortin via swift-evolution <swift-evolution at swift.org> wrote:
>
> There is actually one good reason I see in favor of keeping the C-style for loop, and only one: ease of porting existing code to Swift.
>
> If you are porting code from another language that uses C-style for loops, currently you can keep the loop as is while you translate all the syntactic differences everywhere. If Swift didn't had a C-style for loop, then you'd need to rethink the control flow at the same time you are converting everything else, increasing the risk of errors during what is already a delicate operation.
>
> C-style for loops are very common in code you can find everywhere because many languages have it, and therefore there is a lot of algorithms, sometime tricky algorithms you don't want to mess up, that rely on such loops. Even if you had the desire to convert all of them to for-in loops in your port, rewriting the control flow *at the same time* you are addressing all the other porting issues is much worse than doing it in a separate step *after* the crude port has been tested to work.
>
> In other words: you should avoid refactoring everything in one step. The C-style for loop enables that.
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From bek at termestrup.dk  Sun Dec  6 15:04:15 2015
From: bek at termestrup.dk (Morten Bek Ditlevsen)
Date: Sun, 06 Dec 2015 21:04:15 +0000
Subject: [swift-evolution] Proposal: Allow Getters and Setters to Throw
In-Reply-To: <CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com>
References: <CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com>
<DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com>
<CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com>
Message-ID: <CAAdsSdrj_WW_h4nDOct-CquOY-ae8Nm40r-DqjV0wpYfAcq84A@mail.gmail.com>

+1 from here too!
søn. 6. dec. 2015 kl. 21.43 skrev Ilya Belenkiy via swift-evolution <
swift-evolution at swift.org>:

> +1
>
> On Sat, Dec 5, 2015 at 10:17 PM Matthew Johnson via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> +1 to this.  Subscripts should also be able to throw and currently cannot.
>>
>>
>> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> One of the aspects of Swift that I like is computed properties for
>> structures and classes. It allows for adding logic when obtaining values or
>> for having the returned value be dependent on another.
>>
>> As of the `ErrorType` protocol introduction in Swift 2, we can throw
>> errors when it comes to functions and initializers. However, this does not
>> apply to getters and setters.
>>
>> ```swift
>> struct File<Data> {
>>     var contents: Data {
>>         get throws { ... }
>>         set throws { ... }
>>     }
>> }
>> ```
>>
>> A better example would be getting and setting the current working
>> directory of the process:
>>
>> ```swift
>> import Foundation
>>
>> extension Process {
>>     static var workingDirectory: String {
>>         get {
>>             let fileManager = NSFileManager.defaultManager()
>>             return fileManager.currentDirectoryPath
>>         }
>>         set throws {
>>             let fileManager = NSFileManager.defaultManager()
>>             guard fileManager.changeCurrentDirectoryPath(newValue) else {
>>                 throw Error("...")
>>             }
>>         }
>>     }
>> }
>>
>>
>>
>> ```
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/47ab4879/attachment.html>

From david at alkaline-solutions.com  Sun Dec  6 15:04:37 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sun, 6 Dec 2015 14:04:37 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
Message-ID: <ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>

I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.

I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.

To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.

-DW

> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>
> I applaud honest description of drawbacks in the proposal :)
>
> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>
> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>
> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>
> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>
> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>
> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>
> Best,
>
> -- E
>
>
>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>
>> Sorry, did I misunderstand the question?
>>
>> Did you asked whether my definition will work for immutable value types?
>> If that's the question, the answer is still yes, the link has an example :)
>>
>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>> I was specifically referring to value types. I apologize for not being clearer.
>>
>> -- E
>>
>>
>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>
>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>>
>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>
>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>
>>> -- E
>>>
>>>
>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>
>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>
>>>> let task = NSTask() +=+ {
>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>     $0.standardOutput = pipe
>>>> }
>>>>
>>>> Note you can also use the configured object in the rhs:
>>>>
>>>> let questionLabel = UILabel() +=+ {
>>>>     $0.textAlignment = .Center
>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>     $0.text = currentQuestion.questionText
>>>>     $0.numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>
>>>> let questionLabel = UILabel() +=+ {
>>>>     .textAlignment = .Center
>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>     .text = currentQuestion.questionText
>>>>     .numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> Actually I would be happy with something like
>>>>
>>>> let questionLabel = UILabel() .{
>>>>     ..textAlignment = .Center
>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>     ..text = currentQuestion.questionText
>>>>     ..numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> Other thoughts?
>>>>
>>>>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/b724b01a/attachment.html>

From erica at ericasadun.com  Sun Dec  6 15:06:04 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 14:06:04 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
Message-ID: <512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>

Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well

> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com> wrote:
>
> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>
> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>
> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>
> -DW
>
>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> I applaud honest description of drawbacks in the proposal :)
>>
>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>
>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>
>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>
>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>
>> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>>
>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>
>> Best,
>>
>> -- E
>>
>>
>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>
>>> Sorry, did I misunderstand the question?
>>>
>>> Did you asked whether my definition will work for immutable value types?
>>> If that's the question, the answer is still yes, the link has an example :)
>>>
>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>> I was specifically referring to value types. I apologize for not being clearer.
>>>
>>> -- E
>>>
>>>
>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>
>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>>>
>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>>
>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>
>>>> -- E
>>>>
>>>>
>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>
>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>
>>>>> let task = NSTask() +=+ {
>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>     $0.standardOutput = pipe
>>>>> }
>>>>>
>>>>> Note you can also use the configured object in the rhs:
>>>>>
>>>>> let questionLabel = UILabel() +=+ {
>>>>>     $0.textAlignment = .Center
>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>     $0.text = currentQuestion.questionText
>>>>>     $0.numberOfLines = 0
>>>>>     view.addSubview($0)
>>>>> }
>>>>>
>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>
>>>>> let questionLabel = UILabel() +=+ {
>>>>>     .textAlignment = .Center
>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>     .text = currentQuestion.questionText
>>>>>     .numberOfLines = 0
>>>>>     view.addSubview($0)
>>>>> }
>>>>>
>>>>> Actually I would be happy with something like
>>>>>
>>>>> let questionLabel = UILabel() .{
>>>>>     ..textAlignment = .Center
>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>     ..text = currentQuestion.questionText
>>>>>     ..numberOfLines = 0
>>>>>     view.addSubview($0)
>>>>> }
>>>>>
>>>>> Other thoughts?
>>>>>
>>>>>
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>
>>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/f637e589/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 15:08:14 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 22:08:14 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com>
Message-ID: <DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org>

Hi David,

sorry but I don’t understand what do you mean in your first point can you elaborate further?

2. your reswitch will throw a compile error, because you are try to call the switch with a different type, I imagine that to reswitch you can only pass a valid match to optionalThins so you have to pass a `String?` and yes, the proposal is to re execute the switch on the new value.

3. Your second example can’t be always valid because optionalThing can be a constant, I’m imagining that in the new switch execution optionalThing is being shadowed by the new value, but at the end of the execution optionalThing is the old value again.


> On 06 Dec 2015, at 21:48, David Waite <david at alkaline-solutions.com> wrote:
>
> To cope with the pattern matching cases, I would say that reswitch either has to:
> 1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns
> 2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:
>
> switch(optionalThing) {
> case .None:
> 	print(“assuming default value”)
> 	reswitch “default”
> case .Some(let str):
> 	print(“processing value \(str)”);
> }
>
> This does however have non-intuitive behavior - when the second case statement is hit, “str" is no longer equal to "optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop:
>
> switch(optionalThing) {
> case .None:
> 	print(“assuming default value”)
> 	optionalThing = “default”
> 	reswitch
> case .Some(let str):
> 	print(“processing value \(str)”);
> }
>
> The existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch"
>
> -DW
>
>> On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>  Hi Colin,
>>
>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>>
>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
>> So something like this:
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		reswitch .Two
>> 	case .Two:
>> 		// do something else
>> 	default:
>> 		// and so one
>> }
>>
>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		reswitch .Two
>> 	case .OneAndAHalf
>> 		// maybe this change is not made by you but by a messed up merge
>> 	case .Two:
>> 		// do something else
>> 	default:
>> 		// and so one
>> }
>>
>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>>
>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		reswitch .Two
>> 	case .OneAndAHalf
>> 		// so something that you don’t want to do for .One
>> 		reswitch .Two
>> 	case .Two:
>> 		// do something else that you may want to do for .One and .Two
>> 	default:
>> 		// and so one
>> }
>>
>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>>
>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		x = 0;
>> 		reswitch .Two
>> 	case .OneAndAHalf
>> 		// so something that you don’t want to do for .One
>> 		reswitch .Two
>> 	case .Two where x > 0:
>> 		// do something else that you may want to do for .One and .Two
>> 		element = array[x]
>> 	default:
>> 		// and so one
>> }
>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>>
>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>>
>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>>
>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>>
>> - Jacopo
>> Sent from my iPad
>>
>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>>
>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>>
>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>>
>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>>
>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
>>>
>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>>
>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>>
>>> Thanks,
>>> -Colin
>>>
>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>>
>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>>
>>>> Sent from my iPad
>>>>
>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>>
>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>>
>>>>> - Steve
>>>>>
>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>>
>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>>
>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>>
>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>>
>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>>
>>>>>> John.
>>>>>>
>>>>>>>
>>>>>>> John.
>>>>>>>
>>>>>>>>
>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>>
>>>>>>>> switch op {
>>>>>>>> case LOAD_INDIRECT:
>>>>>>>>    in0 = memory[in1]
>>>>>>>>    fallthrough
>>>>>>>> case LOAD:
>>>>>>>>    out0 = memory[in0]
>>>>>>>> //...
>>>>>>>> }
>>>>>>>>
>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>>
>>>>>>>> Cheers,
>>>>>>>> John
>>>>>>>>
>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>>>>
>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>>
>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>>
>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>>
>>>>>>>>> John.
>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>>
>>>>>>>>>> -Kevin Ballard
>>>>>>>>>>
>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>>
>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>>>>
>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>>
>>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>>> expressed as
>>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>>
>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>>
>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>>
>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>>
>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>>
>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>>
>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>>
>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>>
>>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>>
>>>>>>>>>>>>> Daniel
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>  _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ff2c188d/attachment-0001.html>

From ilya.nikokoshev at gmail.com  Sun Dec  6 15:08:32 2015
From: ilya.nikokoshev at gmail.com (ilya)
Date: Sun, 06 Dec 2015 21:08:32 +0000
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
<2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com>
Message-ID: <CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com>

There are a couple of ways of solving this issue:

1 refactor to where loop first, then convert to Swift
2 leave a fixit in Xcode that will perform while loop conversion
On Mon, Dec 7, 2015 at 00:04 Sean Heber via swift-evolution <
swift-evolution at swift.org> wrote:

> This is the exact scenario that lead to my own code base having a few
> cases of C-style (all of which I've now trivially removed). Even so, I do
> not believe it is worth keeping it around for this reason.
>
> l8r
> Sean
>
> > On Dec 6, 2015, at 2:37 PM, Michel Fortin via swift-evolution <
> swift-evolution at swift.org> wrote:
> >
> > There is actually one good reason I see in favor of keeping the C-style
> for loop, and only one: ease of porting existing code to Swift.
> >
> > If you are porting code from another language that uses C-style for
> loops, currently you can keep the loop as is while you translate all the
> syntactic differences everywhere. If Swift didn't had a C-style for loop,
> then you'd need to rethink the control flow at the same time you are
> converting everything else, increasing the risk of errors during what is
> already a delicate operation.
> >
> > C-style for loops are very common in code you can find everywhere
> because many languages have it, and therefore there is a lot of algorithms,
> sometime tricky algorithms you don't want to mess up, that rely on such
> loops. Even if you had the desire to convert all of them to for-in loops in
> your port, rewriting the control flow *at the same time* you are addressing
> all the other porting issues is much worse than doing it in a separate step
> *after* the crude port has been tested to work.
> >
> > In other words: you should avoid refactoring everything in one step. The
> C-style for loop enables that.
> >
> > --
> > Michel Fortin
> > michel.fortin at michelf.ca
> > https://michelf.ca
> >
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/dd03f446/attachment.html>

From cloutiertyler at aol.com  Sun Dec  6 15:13:43 2015
From: cloutiertyler at aol.com (Tyler Fleming Cloutier)
Date: Sun, 6 Dec 2015 13:13:43 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
Message-ID: <AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>


> Lowered Readability and Maintainability
>
> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged.
>
> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:
> Roland King writes:
>
> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
> {
> 	// more than a few lines of code with early escape continues
> }
>
> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.
>
> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.
>

Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.

The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.

Something like the following might be nice to scope the variable exclusively to the loop.

for var x = 0 while (someCondition()) {
// code
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/01429aab/attachment.html>

From jtbandes at gmail.com  Sun Dec  6 15:13:58 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sun, 6 Dec 2015 13:13:58 -0800
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
Message-ID: <CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>

It seems like setting properties just after init is the main use case here.

I'm not against this idea, but I want to point out that this doesn't *need*
to be solved by a change to the language. You can easily define a convenience
init for UILabel that takes textAlignment, font, text, and numberOfLines as
parameters. They could have default values so you can specify just the ones
you need.

I like the idea of being able to do configure objects/values conveniently,
but I'm not sure how to justify a language change for it. Perhaps we just
need better autogeneration of initializers during Obj-C header import.

Jacob Bandes-Storch

On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <
swift-evolution at swift.org> wrote:

> Do you want me to tweak that? Or remove it entirely? Also, I think I
> forgot to name-drop you slightly earlier as well
>
> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com>
> wrote:
>
> I’m leaning away from “self in” style syntax - I think there are too many
> cases where you still want to be able to bind and access the self of the
> object your closure was declared within.
>
> I’m not sure you have to establish a new “self” however - have the type of
> object given to with is known, so the methods/functions available to it can
> be exposed as lexical scope.
>
> To keep code clarity, use of methods/functions which shadow something in
> higher lexical scope should likely result in compiler errors.
>
> -DW
>
> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I applaud honest description of drawbacks in the proposal :)
>
> There examples given, I think, demonstrate that using self without any
> special access leads to unresolvable ambiguities.
>
> If one wants to work "inside" the configured object, this seems like a
> good job for a private initializer. All of the ambiguities will be
> resolved, because extracting the init away removes its ability to capture
> names from the local context.
>
> Alternatively, I think it makes sense to continue working on configuration
> syntax, with "default" access to local context and "explicit" access to the
> object. Let's just replace $0 with something else.
>
> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in
> the right direction to me.
> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> It's probably better at this point for me to collect my thoughts and
>> summarize where I am at.
>>
>> https://gist.github.com/erica/eb32feb22ba99629285a
>>
>> Please feel free to comment on-list about this proposal (github does not
>> forward comment alerts) and
>> then I will start a new list thread as a Proposal rather than as a
>> Request for Discussion.
>>
>> Best,
>>
>> -- E
>>
>>
>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>
>> Sorry, did I misunderstand the question?
>>
>> Did you asked whether my definition will work for immutable value types?
>> If that's the question, the answer is still yes, the link has an example
>> :)
>>
>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com>
>> wrote:
>>
>>> I was specifically referring to value types. I apologize for not being
>>> clearer.
>>>
>>> -- E
>>>
>>>
>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>>
>>> Yes, it works for immutable objects with the correct definition, see the
>>> playground contents at
>>> https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift
>>>
>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com>
>>> wrote:
>>>
>>>> I have developed something similar as well (
>>>> http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/
>>>> ).
>>>>
>>>> Is yours capable of handling enums and structs that would otherwise be
>>>> let after declaration because mine is not.
>>>>
>>>> -- E
>>>>
>>>>
>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <
>>>> swift-evolution at swift.org> wrote:
>>>>
>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail
>>>> to fully set up an instance for use.  Here's one example: ...
>>>>
>>>> FWIW, I created a configuration operator more then a year ago, and use
>>>> it in all of my Swift projects:
>>>>
>>>> let task = NSTask() +=+ {
>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>     $0.standardOutput = pipe
>>>> }
>>>>
>>>> Note you can also use the configured object in the rhs:
>>>>
>>>> let questionLabel = UILabel() +=+ {
>>>>     $0.textAlignment = .Center
>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>     $0.text = currentQuestion.questionText
>>>>     $0.numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> This $0. certainly looks ugly and it would be great to be able to
>>>> simplify this. I don't llike the following much though (dot-syntax can be
>>>> ambiguos here, and using simply a method name is even worse):
>>>>
>>>> let questionLabel = UILabel() +=+ {
>>>>     .textAlignment = .Center
>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>     .text = currentQuestion.questionText
>>>>     .numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> Actually I would be happy with something like
>>>>
>>>> let questionLabel = UILabel() .{
>>>>     ..textAlignment = .Center
>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>     ..text = currentQuestion.questionText
>>>>     ..numberOfLines = 0
>>>>     view.addSubview($0)
>>>> }
>>>>
>>>> Other thoughts?
>>>>
>>>>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>
>>>>
>>>
>>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/42b7f011/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 15:14:41 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 22:14:41 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
Message-ID: <6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>

Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.

Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.

I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 <https://gist.github.com/JGiola/f735212789bf2f697847>
If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.

And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)

- Jacopo

> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:
>
> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
>
> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
>
> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
>
> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
>
> Thanks,
> -Colin
>
>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:
>>
>>  Hi Colin,
>>
>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>>
>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
>> So something like this:
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		reswitch .Two
>> 	case .Two:
>> 		// do something else
>> 	default:
>> 		// and so one
>> }
>>
>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		reswitch .Two
>> 	case .OneAndAHalf
>> 		// maybe this change is not made by you but by a messed up merge
>> 	case .Two:
>> 		// do something else
>> 	default:
>> 		// and so one
>> }
>>
>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>>
>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		reswitch .Two
>> 	case .OneAndAHalf
>> 		// so something that you don’t want to do for .One
>> 		reswitch .Two
>> 	case .Two:
>> 		// do something else that you may want to do for .One and .Two
>> 	default:
>> 		// and so one
>> }
>>
>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>>
>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>>
>> switch (enum) {
>> 	case .One:
>> 		// do something
>> 		x = 0;
>> 		reswitch .Two
>> 	case .OneAndAHalf
>> 		// so something that you don’t want to do for .One
>> 		reswitch .Two
>> 	case .Two where x > 0:
>> 		// do something else that you may want to do for .One and .Two
>> 		element = array[x]
>> 	default:
>> 		// and so one
>> }
>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>>
>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>>
>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>>
>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>>
>> - Jacopo
>> Sent from my iPad
>>
>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>>
>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>>
>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>>
>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>>
>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
>>>
>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>>
>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>>
>>> Thanks,
>>> -Colin
>>>
>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>>
>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>>
>>>> Sent from my iPad
>>>>
>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>>
>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>>
>>>>> - Steve
>>>>>
>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>>
>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>>
>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>>
>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>>
>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>>
>>>>>> John.
>>>>>>
>>>>>>>
>>>>>>> John.
>>>>>>>
>>>>>>>>
>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>>
>>>>>>>> switch op {
>>>>>>>> case LOAD_INDIRECT:
>>>>>>>>    in0 = memory[in1]
>>>>>>>>    fallthrough
>>>>>>>> case LOAD:
>>>>>>>>    out0 = memory[in0]
>>>>>>>> //...
>>>>>>>> }
>>>>>>>>
>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>>
>>>>>>>> Cheers,
>>>>>>>> John
>>>>>>>>
>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>>>>
>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>>
>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>>
>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>>
>>>>>>>>> John.
>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>>
>>>>>>>>>> -Kevin Ballard
>>>>>>>>>>
>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>>
>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>>>>
>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>>
>>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>>> expressed as
>>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>>
>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>>
>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>>
>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>>
>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>>
>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>>
>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>>
>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>>
>>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>>
>>>>>>>>>>>>> Daniel
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>  _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/1b433a50/attachment.html>

From possen at gmail.com  Sun Dec  6 15:17:20 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 13:17:20 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com>
References: <CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com>
Message-ID: <1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com>

I agree that ? may imply optional, this may be similar to what you suggested, just filling in the example: Not sure parenthesis are better than braces though:

et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow )

let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow )

let myColor = match yourColor (
case .Blue :  .Reds
case .Green: .Blue
case .Red: .Green
default: .Yellow
)

let myColor = match yourColor (
.Blue :  .Reds
.Green: .Blue
.Red: .Green
default: .Yellow
)

let myColor = match boollCondition ( .Blue, .Red )



> On Dec 6, 2015, at 12:54 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> Hmm. Something about braces inside expressions just feels wrong to me.
>
> I also read switch? and if? as being some optional-related versions of switch and if. And I don't love putting the condition / value-to-switch-on before the keyword, if we're going to use a keyword.
>
> (Also: exhaustiveness checking could theoretically allow resolution of ambiguity in nested switch expressions. We would just have to require that as soon as you've exhausted all possibilities, you don't add more cases and the expression is over.)
>
> On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote:
> Yep probably does need braces: So for switch? if? suggestion i just made.
>
> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }
>
> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }
>
> let myColor = yourColor switch? {
> 	case .Blue :  .Reds
> 	case .Green: .Blue
> 	case .Red: .Green
> 	default: .Yellow
> }
>
> let myColor = yourColor switch? {
> 	.Blue :  .Reds
> 	.Green: .Blue
> 	.Red: .Green
> 	default: .Yellow
> }
>
> let myColor = condition if?  { .Blue; .Red }
>
> I don’t find that looks bad.
>
> - Paul
>
>
>> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> Thanks for the feedback, Matthew. It's sensible to me to consider dropping the ternary operator. I like it because the analogy "C's if is to Swift's if as C's ternary operator is to Swift's ternary operator" is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:
>>
>>  // compiler error without space betw thatColor and ?
>> let thisColor = thatColor?
>>      case .Red: .Green
>>      default: .Blue
>>
>> On the other hand, is it really worth it to have control flow expressions if they don't let your code look nicer?
>>
>> let thisColor = switch thatColor {
>>      case .Red:
>>           return .Green;
>>      default:
>>           return .Yellow;
>> }
>>
>> really isn't much nicer than
>>
>> let thisColor: Color
>> switch thatColor {
>>      case .Red:
>>           thisColor = .Green
>>      default:
>>           thisColor = .Yellow
>> }
>>
>> Maybe we could do a compromise, something like
>>
>> let thisColor = switch thatColor
>>      case .Red: .Green // must be an expression
>>      default: .Yellow      // must be an expression
>>
>> Or we could introduce a new keyword? Like match:
>>
>> let thisColor = match thatColor
>>       case .Red: .Green    // must be an expression
>>       default: .Yellow         // must be an expression
>>
>>
>> I sort of like the new-keyword approach, because even though this is similar to a switch, it's not a switch: there's no fallthrough, you can't put statements inside, etc.
>>
>> The problem with all these proposals:
>>
>> let thisColor = match thatColor
>>      case .Red: match thatOtherColor
>>                            case .Blue: .Green
>>                            case .Pink: .Yellow
>>                            default: .Orange
>>      default: .Orange
>>
>> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won't always work.) You could solve this problem either by using parentheses around the whole expression when necessary
>>
>> let thisColor = match thatColor
>>      case .Red: (match thatOtherColor
>>                            case .Blue: .Green
>>                            case .Pink: .Yellow
>>                            default: .Orange)
>>      default: .Orange
>>
>> or by adding curly braces in again
>>
>> let thisColor = match thatColor {
>>      case .Red: match thatOtherColor {
>>                            case .Blue: .Green
>>                            case .Pink: .Yellow
>>                            default: .Orange
>>                         }
>>      default: .Orange
>> }
>>
>> But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)
>>
>>
>> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).
>>
>> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.
>>
>> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.
>>
>>
>>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):
>>>
>>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow
>>>
>>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:
>>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:
>>>>
>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>     case .Blue: .Red
>>>>     case .Green: .Blue
>>>>     case .Red: .Green
>>>>     default: .Yellow
>>>>
>>>>
>>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>> I really like this train of thought. +1
>>>>>
>>>>> l8r
>>>>> Sean
>>>>>
>>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>>>>>>
>>>>>> let x = condition ?
>>>>>>    true: "Hello"
>>>>>>    false: "Goodbye"
>>>>>>
>>>>>> let x = optionalValue ?
>>>>>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>>>>>    .None: "To Whom It May Concern"
>>>>>>
>>>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>>>     .Blue: .Red
>>>>>>     .Green: .Blue
>>>>>>     .Red: .Green
>>>>>>
>>>>>> let quadrant = (x, y) ?
>>>>>>     let (x, y) where x < 50 && y < 50: "top left"
>>>>>>     let (x, y) where x < 50 && y > 50: "bottom left"
>>>>>>     let (x, y) where x > 50 && y < 50: "top right"
>>>>>>     default: "bottom right"
>>>>>>
>>>>>> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>>>>>>
>>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>>>>>>
>>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>> wrote:
>>>>>>
>>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>>>>>>
>>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>>>>>
>>>>>>> if (condition) {
>>>>>>>     funcWithSideEffectsThatReturnsInt()
>>>>>>> } else {
>>>>>>>     funcWithSideEffectsThatReturnsString()
>>>>>>> }
>>>>>>>
>>>>>>> but that's not a valid expression (what is its type?).
>>>>>>
>>>>>>
>>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).
>>>>>>
>>>>>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.
>>>>>>
>>>>>>
>>>>>> -Thorsten
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> Untracked with Trackbuster <https://trackbuster.com/?sig>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/6b2fadb6/attachment.html>

From colin at springsandstruts.com  Sun Dec  6 15:23:04 2015
From: colin at springsandstruts.com (Colin Barrett)
Date: Sun, 6 Dec 2015 16:23:04 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
Message-ID: <A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>


> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
>
> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.

I’m curious, how do you propose to do this?

> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.

In your document you give the example:

> case .Three where x > 0:

Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:

> case .Four(x) where x > 0:

In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.

In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.

-Colin

> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847
> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.
>
> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
>
> - Jacopo
>
>> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:
>>
>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
>>
>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
>>
>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
>>
>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
>>
>> Thanks,
>> -Colin
>>
>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
>>>
>>>  Hi Colin,
>>>
>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>>>
>>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
>>> So something like this:
>>>
>>> switch (enum) {
>>> 	case .One:
>>> 		// do something
>>> 		reswitch .Two
>>> 	case .Two:
>>> 		// do something else
>>> 	default:
>>> 		// and so one
>>> }
>>>
>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>>>
>>> switch (enum) {
>>> 	case .One:
>>> 		// do something
>>> 		reswitch .Two
>>> 	case .OneAndAHalf
>>> 		// maybe this change is not made by you but by a messed up merge
>>> 	case .Two:
>>> 		// do something else
>>> 	default:
>>> 		// and so one
>>> }
>>>
>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>>>
>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>>>
>>> switch (enum) {
>>> 	case .One:
>>> 		// do something
>>> 		reswitch .Two
>>> 	case .OneAndAHalf
>>> 		// so something that you don’t want to do for .One
>>> 		reswitch .Two
>>> 	case .Two:
>>> 		// do something else that you may want to do for .One and .Two
>>> 	default:
>>> 		// and so one
>>> }
>>>
>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>>>
>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>>>
>>> switch (enum) {
>>> 	case .One:
>>> 		// do something
>>> 		x = 0;
>>> 		reswitch .Two
>>> 	case .OneAndAHalf
>>> 		// so something that you don’t want to do for .One
>>> 		reswitch .Two
>>> 	case .Two where x > 0:
>>> 		// do something else that you may want to do for .One and .Two
>>> 		element = array[x]
>>> 	default:
>>> 		// and so one
>>> }
>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>>>
>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>>>
>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>>>
>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>>>
>>> - Jacopo
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>>>
>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>>>
>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>>>
>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>>>
>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>>>>
>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>>>
>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>>>
>>>> Thanks,
>>>> -Colin
>>>>
>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>
>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>>>
>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>>>
>>>>> Sent from my iPad
>>>>>
>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>
>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>>>
>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>>>
>>>>>> - Steve
>>>>>>
>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>
>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:
>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>>>
>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>>>
>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>>>
>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>>>
>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>>>
>>>>>>> John.
>>>>>>>
>>>>>>>>
>>>>>>>> John.
>>>>>>>>
>>>>>>>>>
>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>>>
>>>>>>>>> switch op {
>>>>>>>>> case LOAD_INDIRECT:
>>>>>>>>>    in0 = memory[in1]
>>>>>>>>>    fallthrough
>>>>>>>>> case LOAD:
>>>>>>>>>    out0 = memory[in0]
>>>>>>>>> //...
>>>>>>>>> }
>>>>>>>>>
>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>>>
>>>>>>>>> Cheers,
>>>>>>>>> John
>>>>>>>>>
>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:
>>>>>>>>>>
>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>>>
>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>>>
>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>>>
>>>>>>>>>> John.
>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>>>
>>>>>>>>>>> -Kevin Ballard
>>>>>>>>>>>
>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>>>
>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>>>
>>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>>>> expressed as
>>>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>>>
>>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Daniel
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>
>>>>>>>>>>  _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>


From dan.appel00 at gmail.com  Sun Dec  6 15:26:02 2015
From: dan.appel00 at gmail.com (Dan Appel)
Date: Sun, 06 Dec 2015 21:26:02 +0000
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>
Message-ID: <CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com>

For better or worse, I would like to note that `reswitch` is essentially a
safer `goto`, so keep in mind all the bad things that can be done with it.

On Sun, Dec 6, 2015 at 1:23 PM Colin Barrett via swift-evolution <
swift-evolution at swift.org> wrote:

>
> > On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <
> swift-evolution at jacopo.giola.org> wrote:
> >
> > Yes, I’m aware that at this time the reswitch can be abused and maybe
> can be better refined to disallow such cases.
>
> I’m curious, how do you propose to do this?
>
> > Checking the case statement is not a problem by itself, but can be a
> problem if is coupled with a where clause that is not true when you
> fallthrought.
>
> In your document you give the example:
>
> > case .Three where x > 0:
>
> Now I may be wrong but I feel as though most of the uses of where clauses
> are also ones that reference variables bound in a `case let`. For instance:
>
> > case .Four(x) where x > 0:
>
> In that case, fallthrough would required to evaluating the case part
> anyway, as per my postulated rules below.
>
> In any case, I appreciate you taking the time to discuss your proposal,
> even if I didn’t end up convinced. Thanks.
>
> -Colin
>
> > I’ve written a really bad draft here
> https://gist.github.com/JGiola/f735212789bf2f697847
> > If anyone wants to jump in and elaborate further is welcome. I will try
> to stay on par with this thread but I’m really bad at writing so every help
> is welcome.
> >
> > And if I remember correctly Daniel Jakult was the first one to made this
> proposal so if he wants to take on and then made the official proposal has
> every right to do so and I will be very glad if my gist can be a first
> reference :)
> >
> > - Jacopo
> >
> >> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com>
> wrote:
> >>
> >> Apologies, Jacopo, for missing the updated proposal, and thank you for
> your patience in summarizing it again.
> >>
> >> I’ve only glanced through it but my concern here is that it introduces
> a whole class of new and creative “foot-guns" :) In particular, it allows
> this construction to loop arbitrarily and creatively, particularly in the
> case of associated values.
> >>
> >> I’m not sure why not checking the case statement is considered a
> problem for the fallthrough keyword. Assuming it’s impossible to
> fallthrough to a case that introduces binders (what would they be bound
> to?), and that this is statically checked (both of which seem reasonable
> assumptions to me, although if I’m wrong feel free to correct me), isn’t it
> the entire point of the fallthrough keyword that it skips checking the case
> statement? I can understand how that might be somewhat confusing (and
> perhaps it should be documented less prominently) but I’m not sure how it’s
> a *problem*, exactly...
> >>
> >> I think I’m still on the side of keeping fallthrough. What’s the
> downside of doing nothing? For instance in the case of ++ and -- those
> features complicate the design of a numerics library.
> >>
> >> Thanks,
> >> -Colin
> >>
> >>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <
> swift-evolution at jacopo.giola.org> wrote:
> >>>
> >>>  Hi Colin,
> >>>
> >>> the initial proposal was indeed to remove entirely the `fallthrough`
> keyword but many people expressed your similar concern and from that point
> the discussion was steered through an "enhancement" and better refinement
> of the keyword.
> >>>
> >>> The new idea is to substitute the old keyword with "reswitch" passing
> the desired new value on which the switch is applied.
> >>> So something like this:
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             reswitch .Two
> >>>     case .Two:
> >>>             // do something else
> >>>     default:
> >>>             // and so one
> >>> }
> >>>
> >>> This new behaviour, IMO, is better suited for Swift because is more
> declarative of the developer intent and doesn't carry over unintentional
> misbehaviour.
> >>> Is more declarative because you are forced to state in which case you
> want to go, and even if the order of the switch’ cases will change in the
> future, you don't fall in the wrong case by mistake.
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             reswitch .Two
> >>>     case .OneAndAHalf
> >>>             // maybe this change is not made by you but by a messed up
> merge
> >>>     case .Two:
> >>>             // do something else
> >>>     default:
> >>>             // and so one
> >>> }
> >>>
> >>> In this case if you are using the fallthrough keyboard your code is
> now broken by accident, and depending on what are you trying to do inside
> the cases you can have a hidden bug that your tests are not seeing right
> away.
> >>>
> >>> Another advantage is that in this way you can made more cases
> fallthrough in the same one even if they are not one over each other
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             reswitch .Two
> >>>     case .OneAndAHalf
> >>>             // so something that you don’t want to do for .One
> >>>             reswitch .Two
> >>>     case .Two:
> >>>             // do something else that you may want to do for .One and
> .Two
> >>>     default:
> >>>             // and so one
> >>> }
> >>>
> >>> I must say that this is a side effect that can be used to messed up
> the code flow in a way that is not intended, but is a new behaviour that
> gives more power to the switch statement.
> >>>
> >>> The reswitch keyword in addition is not a mere fallthrough on the new
> case without doing the optional checking attached to it, but is intended to
> be a new call and all the check are executed.
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             x = 0;
> >>>             reswitch .Two
> >>>     case .OneAndAHalf
> >>>             // so something that you don’t want to do for .One
> >>>             reswitch .Two
> >>>     case .Two where x > 0:
> >>>             // do something else that you may want to do for .One and
> .Two
> >>>             element = array[x]
> >>>     default:
> >>>             // and so one
> >>> }
> >>> (I’m going by memory and by writing this snippets in the mail app
> directly, so the code must be incorrect in the syntax and for this I’m
> sorry).
> >>>
> >>> In this case if enum is .One the only case that is executed is case
> .One and the code doesn’t fallthrough in the .Two case because we are made
> the where invalid by changing the x to a value less than 1.
> >>>
> >>> Now I don’t remember who was the first one who mede this proposal, and
> I don’t know if he is working on a first draft to lay down the things
> better, but for me this can be a nice improvement and a neat break with the
> C-switch behaviour that Swift has trying to change from the very first beta
> disallowing the implicit fallthrough.
> >>>
> >>> I can be completely wrong but I see the `fallthrough`keyword as a
> “temporary” implementation for ease the transition from Obj-C to Swift and
> is time to improve it and made the switch statement even more powerful.
> >>>
> >>> - Jacopo
> >>> Sent from my iPad
> >>>
> >>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>>
> >>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us
> anything; and has at least minimal utility, as I try to demonstrate.
> >>>>
> >>>> Apologies for jumping into this thread at an awkward point, but I’ve
> only just now subscribed to this list.
> >>>>
> >>>> I think the fallthrough keyword is useful in certain circumstances.
> I’ve also yet to see an example of where it creates a negative impact,
> either in code, optimization, or what have you. Other than “It’s like
> something in C, and C is old and busted” I’m unsure of the rationale for
> removing it. (Feel free to point me in the right direction.)
> >>>>
> >>>> Consider the Planet enum from the documentation. One of the simplest
> way to define the number of a planet (i.e. its 1-based index in the
> ordering of planets wrt. distance from the sun) is using a switch and
> fall-through:
> >>>>
> >>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
> >>>>
> >>>> This technique is very extensible — for instance imagine computing
> the force induced by the gravity of the other planets on a particular
> planet. All that would need to change is the case statements.
> >>>>
> >>>> Yes, you could write this by putting the planets into a list and
> mapping or folding (or looping) over that, but unless the compiler can
> “unroll” that construct, you’re paying for an allocation simply bc of your
> choice of control flow. But in fact, you could imagine generalizing this
> construct into the implementation of fold for the Planet type —
> low-overhead folds for monomorphic types seems like a pretty compelling an
> natural use case for fallthrough to me.
> >>>>
> >>>> Thanks,
> >>>> -Colin
> >>>>
> >>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>>>>
> >>>>> +1 for this idea, but I will prefer the reswitch keyword instead of
> overloading continue with a new syntax.
> >>>>>
> >>>>> If this proposal is accepted, it must be coupled with a compiler
> check that the reswitch statements don't introduce an infinite "switch"
> loop.
> >>>>>
> >>>>> Sent from my iPad
> >>>>>
> >>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>>>>
> >>>>>> Very much thinking out loud and not really the implications, I
> wonder if we might just use "continue" instead of "reswitch".
> >>>>>>
> >>>>>> I very much like specifying what case to fall through into, no
> matter how we spell it.
> >>>>>>
> >>>>>> - Steve
> >>>>>>
> >>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>>>>>
> >>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <
> swift-evolution at swift.org> wrote:
> >>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <
> john.calsbeek+lists at gmail.com> wrote:
> >>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both
> allow natural expression of concepts that exist at the instruction level
> but are otherwise difficult to express with nested control structures.
> `fallthrough` is perhaps slightly less objectionable because control flow
> remains local, but it has a similar role.
> >>>>>>>>>
> >>>>>>>>> It is not particularly natural to write `switch` statements with
> `fallthrough` in the reverse order that can be seen in Duff’s Device and
> similar constructs (case 7 falls through to 6 which falls through to 5,
> etc.). It’s just because you know for certain that all the code in case 6
> would be duplicated in case 7, so 7 can transfer into 6 without a jump
> instruction. Communicating that to the compiler without `fallthrough`
> requires deeply nested `if`s.
> >>>>>>>>
> >>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that
> we might parameterize it in the future; parameterized it would mean “repeat
> the switch with this new value”, so that unparameterized fallthrough would
> mean “repeat the switch with a notional value that ends up in the next
> case”.  There’s a very common pattern in switches of deferring to another
> case that I’ve always found very awkward to write in C, and while sometimes
> there’s no choice but to extract a helper function, there’s a
> still-fairly-structural code pattern here that I think we can sensibly
> support.
> >>>>>>>>
> >>>>>>>> On the other hand, there’s an argument that this is an
> inappropriate extension for “fallthrough” specifically, which is one reason
> we’ve never pursued it.
> >>>>>>>
> >>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
> >>>>>>>
> >>>>>>> John.
> >>>>>>>
> >>>>>>>>
> >>>>>>>> John.
> >>>>>>>>
> >>>>>>>>>
> >>>>>>>>> One defense comes to mind: there is talk of Swift aiming at
> systems programming. Is writing a threaded interpreter loop within the
> potential scope of Swift? That’s a use case that could make use of both
> `fallthrough` and `goto` (computed goto, really).
> >>>>>>>>>
> >>>>>>>>> switch op {
> >>>>>>>>> case LOAD_INDIRECT:
> >>>>>>>>>    in0 = memory[in1]
> >>>>>>>>>    fallthrough
> >>>>>>>>> case LOAD:
> >>>>>>>>>    out0 = memory[in0]
> >>>>>>>>> //...
> >>>>>>>>> }
> >>>>>>>>>
> >>>>>>>>> I am personally interested in the prospect of a language that
> can scale up to high-level concepts and down to “portable assembler,” but I
> don’t know if that is the right direction for Swift’s evolution.
> >>>>>>>>>
> >>>>>>>>> Cheers,
> >>>>>>>>> John
> >>>>>>>>>
> >>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com>
> wrote:
> >>>>>>>>>>
> >>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org>
> wrote:
> >>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the
> fact that C switch statements don't actually introduce a new scope, and so
> it overlaps a switch with a do-while loop. This lets it only test the
> number of bytes once, to jump into the middle of the loop, and then it
> switches over to a while loop that decrements a counter every 8
> instructions. Basically, it's a trick for manual loop unrolling that deals
> with non-multiple-of-8 counts efficiently.
> >>>>>>>>>>
> >>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.
> What Duff’s Device exploits is that switch is allowed to jump into (almost)
> arbitrary scopes, and cases can appear anywhere recursively inside a switch.
> >>>>>>>>>>
> >>>>>>>>>> But your point that Swift’s switch requires cases to be at the
> top level within a switch and thus prevents the use of Duff’s Device is
> 100% correct.
> >>>>>>>>>>
> >>>>>>>>>> John.
> >>>>>>>>>>
> >>>>>>>>>>>
> >>>>>>>>>>> Steve's code is also an example of manual loop unrolling that
> deals with non-multiple-of-8 counts, but it has calculate the number of
> bytes on every iteration instead of once. It's a good example of one of the
> uses of `fallthrough`, it's just not Duff's Device. It's impossible to use
> Duff's Device in Swift.
> >>>>>>>>>>>
> >>>>>>>>>>> -Kevin Ballard
> >>>>>>>>>>>
> >>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
> >>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is
> a big place where switch fallthrough is arguably the cleanest way to do
> things and the reason why I’d personally prefer to keep it as part of the
> language.
> >>>>>>>>>>>>
> >>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <
> erica at ericasadun.com> wrote:
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find
> myself re-factoring to stop using it.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22
> gist results for "fallthrough language:swift".
> >>>>>>>>>>>>> Half of those are people just testing out the feature. Most
> of the remaining ones are just complex cases:
> >>>>>>>>>>>>> case .Enum1, .Enum2:
> >>>>>>>>>>>>> expressed as
> >>>>>>>>>>>>> case .Enum1: fallthrough
> >>>>>>>>>>>>> case .Enum2:
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> And then there's streza:
> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty
> sure that ponies were harmed in the production of whatever that last bit is.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++
> style artifacts, what do folks think about the possibility of removing the
> "fallthrough" keyword from the language?
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> My understanding is this keyword is only used for the
> archaic seeming purpose of perpetuating C-style fallthrough from one switch
> statement to the subsequent one. The documentation hedges the use of this
> keyword in forbidding terms that make it clear its use is not encouraged.
> The presence of the keyword, while an improvement over C’s implicit
> fallthrough, is a mark of inelegance on an otherwise well-designed,
> opinionated implementation of swtich statements.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands
> a caveat in the documentation:
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions
> for the switch case that it causes execution to fall into. The fallthrough
> keyword simply causes code execution to move directly to the statements
> inside the next case (or default case) block, as in C’s standard switch
> statement behavior."
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with
> fallthrough, both in C or Swift: coded that is clearly labeled with
> deliberate conditions can nonetheless be reached.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> I quipped about this on Twitter, and the most common
> pushback I got seemed to be from people who either did not know about
> Swift’s support for comma-separated case statements, or harbored an
> aesthetic preference for clustering such cases together with fallthrough
> statements.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong
> defense for supporting intentional fallthrough in Swift, removing the
> keyword would be a move in the direction of minimizing the language’s
> complexity while also discouraging poor coding style in switch statements.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> Thoughts?
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> Daniel
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>>
> >>>>>>>>>>>>
> >>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>
> >>>>>>>>>>>
> >>>>>>>>>>> _______________________________________________
> >>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>
> >>>>>>>>>>  _______________________________________________
> >>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>
> >>>>>>>>>
> >>>>>>>>> _______________________________________________
> >>>>>>>>> swift-evolution mailing list
> >>>>>>>>> swift-evolution at swift.org
> >>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>
> >>>>>>>>
> >>>>>>>> _______________________________________________
> >>>>>>>> swift-evolution mailing list
> >>>>>>>> swift-evolution at swift.org
> >>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> swift-evolution mailing list
> >>>>>>> swift-evolution at swift.org
> >>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>
> >>>>>> _______________________________________________
> >>>>>> swift-evolution mailing list
> >>>>>> swift-evolution at swift.org
> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>
> >>>>> _______________________________________________
> >>>>> swift-evolution mailing list
> >>>>> swift-evolution at swift.org
> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> swift-evolution mailing list
> >>>> swift-evolution at swift.org
> >>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>
> >
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
--
Dan Appel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c4c125eb/attachment.html>

From a.michail at me.com  Sun Dec  6 15:26:12 2015
From: a.michail at me.com (Amir Michail)
Date: Sun, 06 Dec 2015 16:26:12 -0500
Subject: [swift-evolution] Should be able to initialize list of lists with
2d static data without unexpected errors.
Message-ID: <2F2A126F-228D-479F-99A1-C40B472BBD44@me.com>

It’s very irritating trying to initialize a list of lists with static data and unpredictably encountering expression too complex errors.

One could then try to incrementally initialize such a list of lists with append for each row say.

Such initialization with simple 2d static data should never result in an expression too complex error.


From erica at ericasadun.com  Sun Dec  6 15:26:51 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 14:26:51 -0700
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>
Message-ID: <75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com>

A slightly updated proposal write-up with everyone's feedback: https://gist.github.com/erica/56d533b75d0a36e3908f <https://gist.github.com/erica/56d533b75d0a36e3908f>


> On Dec 6, 2015, at 2:13 PM, Tyler Fleming Cloutier <cloutiertyler at aol.com> wrote:
>
>
>> Lowered Readability and Maintainability
>>
>> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged.
>>
>> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:
>> Roland King writes:
>>
>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
>> {
>> 	// more than a few lines of code with early escape continues
>> }
>>
>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.
>>
>> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.
>>
>
> Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.
>
> The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.
>
> Something like the following might be nice to scope the variable exclusively to the loop.
>
> for var x = 0 while (someCondition()) {
> 	// code
> }

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/20f996f6/attachment.html>

From jj at johanjensen.dk  Sun Dec  6 15:27:18 2015
From: jj at johanjensen.dk (Johan Jensen)
Date: Sun, 6 Dec 2015 22:27:18 +0100
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>
Message-ID: <CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com>

Well, it is possible to just add an extra scope around the variable and the
loop:

do {
var i = 0
while i < 10 {
print(i)
i += 1
}
}

—Johan

On Sun, Dec 6, 2015 at 10:13 PM, Tyler Fleming Cloutier via swift-evolution
<swift-evolution at swift.org> wrote:

>
> *Lowered Readability and Maintainability*
>
> I have aesthetic reasons for disliking the for-loop. The C-style loop is
> harder to read especially for those not coming from C-style languages,
> easier to mess up at edge conditions, and is commonly used for side-effects
> which, in a language focused on safety, is not a feature to be encouraged.
>
> For example, one side effect that was mentioned on-list yesterday was the
> incrementor, which is guaranteed in C-style to execute late:
> Roland King writes:
>
>
> for var floatingThing = start ; floatingThing <= end ; floatingThing +=
> delta
> {
> // more than a few lines of code with early escape continues
> }
>
> shows intent of the loop very clearly, start, condition and increment all
> together at the top, and however you loop you always execute the increment
> part of the statement. Convert that to a while(), if you have a continue in
> the body, you have a good chance of not incrementing at all, or duplicating
> the increment code before every continue. So you can’t always nicely turn
> for into while. I second the point below about the loop variable being
> local to the for as well, I also like that.
>
> Late incrementor management is a feature that can be mimicked with defer,
> as pointed out by several other list members.
>
>
>
> Defer wouldn’t accomplish the exact same behavior because it would run if
> an exception was thrown, which is not the same as the last clause of a for
> loop, but perhaps is close enough.
>
> The only other concern I would have is not being able to scope my
> variables to the loop. I didn’t see it addressed, but perhaps its not very
> important in the end anyway.
>
> Something like the following might be nice to scope the variable
> exclusively to the loop.
>
> for var x = 0 while (someCondition()) {
> // code
> }
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/b607c0d4/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 15:28:05 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 16:28:05 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
Message-ID: <CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>

It seems reswitch *should* be useable even in cases that aren't a simple
"goto". Or am I missing something?

For instance, rewriting the example from earlier:

switch op {
case let .LOAD_INDIRECT(out, in):
reswitch(.LOAD(out, memory[in]))
case let .LOAD(out, in):
setReg(out, in)
// ...
}

or, a switch that calculates whether some number n is in a Lisp-style list
of numbers

switch lst {
case .Cons(let m, _) where m == n:
return true
case .Cons(_, let rest):
reswitch(rest)
case .Empty:
return false
}

I like reswitch: in some cases, the compiler could optimize to a
fallthrough, and in others, you could actually re-switch. But maybe I'm
missing something.

On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <
swift-evolution at swift.org> wrote:

> Yes, I’m aware that at this time the reswitch can be abused and maybe can
> be better refined to disallow such cases.
>
> Checking the case statement is not a problem by itself, but can be a
> problem if is coupled with a where clause that is not true when you
> fallthrought.
>
> I’ve written a really bad draft here
> https://gist.github.com/JGiola/f735212789bf2f697847
> If anyone wants to jump in and elaborate further is welcome. I will try to
> stay on par with this thread but I’m really bad at writing so every help is
> welcome.
>
> And if I remember correctly Daniel Jakult was the first one to made this
> proposal so if he wants to take on and then made the official proposal has
> every right to do so and I will be very glad if my gist can be a first
> reference :)
>
> - Jacopo
>
> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>
> wrote:
>
> Apologies, Jacopo, for missing the updated proposal, and thank you for
> your patience in summarizing it again.
>
> I’ve only glanced through it but my concern here is that it introduces a
> whole class of new and creative “foot-guns" :) In particular, it allows
> this construction to loop arbitrarily and creatively, particularly in the
> case of associated values.
>
> I’m not sure why not checking the case statement is considered a problem
> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a
> case that introduces binders (what would they be bound to?), and that this
> is statically checked (both of which seem reasonable assumptions to me,
> although if I’m wrong feel free to correct me), isn’t it the entire point
> of the fallthrough keyword that it skips checking the case statement? I can
> understand how that might be somewhat confusing (and perhaps it should be
> documented less prominently) but I’m not sure how it’s a *problem*,
> exactly...
>
> I think I’m still on the side of keeping fallthrough. What’s the downside
> of doing nothing? For instance in the case of ++ and -- those features
> complicate the design of a numerics library.
>
> Thanks,
> -Colin
>
> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <
> swift-evolution at jacopo.giola.org> wrote:
>
>  Hi Colin,
>
> the initial proposal was indeed to remove entirely the `fallthrough`
> keyword but many people expressed your similar concern and from that point
> the discussion was steered through an "enhancement" and better refinement
> of the keyword.
>
> The new idea is to substitute the old keyword with "reswitch" passing the
> desired new value on which the switch is applied.
> So something like this:
>
> switch (enum) {
> case .One:
> // do something
> reswitch .Two
> case .Two:
> // do something else
> default:
> // and so one
> }
>
> This new behaviour, IMO, is better suited for Swift because is more
> declarative of the developer intent and doesn't carry over unintentional
> misbehaviour.
> Is more declarative because you are forced to state in which case you want
> to go, and even if the order of the switch’ cases will change in the
> future, you don't fall in the wrong case by mistake.
>
> switch (enum) {
> case .One:
> // do something
> reswitch .Two
> case .OneAndAHalf
> // maybe this change is not made by you but by a messed up merge
> case .Two:
> // do something else
> default:
> // and so one
> }
>
> In this case if you are using the fallthrough keyboard your code is now
> broken by accident, and depending on what are you trying to do inside the
> cases you can have a hidden bug that your tests are not seeing right away.
>
> Another advantage is that in this way you can made more cases fallthrough
> in the same one even if they are not one over each other
>
> switch (enum) {
> case .One:
> // do something
> reswitch .Two
> case .OneAndAHalf
> // so something that you don’t want to do for .One
> reswitch .Two
> case .Two:
> // do something else that you may want to do for .One and .Two
> default:
> // and so one
> }
>
> I must say that this is a side effect that can be used to messed up the
> code flow in a way that is not intended, but is a new behaviour that gives
> more power to the switch statement.
>
> The reswitch keyword in addition is not a mere fallthrough on the new case
> without doing the optional checking attached to it, but is intended to be a
> new call and all the check are executed.
>
> switch (enum) {
> case .One:
> // do something
> x = 0;
> reswitch .Two
> case .OneAndAHalf
> // so something that you don’t want to do for .One
> reswitch .Two
> case .Two where x > 0:
> // do something else that you may want to do for .One and .Two
> element = array[x]
> default:
> // and so one
> }
> (I’m going by memory and by writing this snippets in the mail app
> directly, so the code must be incorrect in the syntax and for this I’m
> sorry).
>
> In this case if enum is .One the only case that is executed is case .One
> and the code doesn’t fallthrough in the .Two case because we are made the
> where invalid by changing the x to a value less than 1.
>
> Now I don’t remember who was the first one who mede this proposal, and I
> don’t know if he is working on a first draft to lay down the things better,
> but for me this can be a nice improvement and a neat break with the
> C-switch behaviour that Swift has trying to change from the very first beta
> disallowing the implicit fallthrough.
>
> I can be completely wrong but I see the `fallthrough`keyword as a
> “temporary” implementation for ease the transition from Obj-C to Swift and
> is time to improve it and made the switch statement even more powerful.
>
> - Jacopo
> Sent from my iPad
>
> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us
> anything; and has at least minimal utility, as I try to demonstrate.
>
> Apologies for jumping into this thread at an awkward point, but I’ve only
> just now subscribed to this list.
>
> I think the fallthrough keyword is useful in certain circumstances. I’ve
> also yet to see an example of where it creates a negative impact, either in
> code, optimization, or what have you. Other than “It’s like something in C,
> and C is old and busted” I’m unsure of the rationale for removing it. (Feel
> free to point me in the right direction.)
>
> Consider the Planet enum from the documentation. One of the simplest way
> to define the number of a planet (i.e. its 1-based index in the ordering of
> planets wrt. distance from the sun) is using a switch and fall-through:
>
> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>
> This technique is very extensible — for instance imagine computing the
> force induced by the gravity of the other planets on a particular planet.
> All that would need to change is the case statements.
>
> Yes, you could write this by putting the planets into a list and mapping
> or folding (or looping) over that, but unless the compiler can “unroll”
> that construct, you’re paying for an allocation simply bc of your choice of
> control flow. But in fact, you could imagine generalizing this construct
> into the implementation of fold for the Planet type — low-overhead folds
> for monomorphic types seems like a pretty compelling an natural use case
> for fallthrough to me.
>
> Thanks,
> -Colin
>
> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> +1 for this idea, but I will prefer the reswitch keyword instead of
> overloading continue with a new syntax.
>
> If this proposal is accepted, it must be coupled with a compiler check
> that the reswitch statements don't introduce an infinite "switch" loop.
>
> Sent from my iPad
>
> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> Very much thinking out loud and not really the implications, I wonder if
> we might just use "continue" instead of "reswitch".
>
> I very much like specifying what case to fall through into, no matter how
> we spell it.
>
> - Steve
>
> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> On Dec 4, 2015, at 11:37 PM, John Calsbeek < john.calsbeek+lists at gmail.com>
> wrote:
> `fallthrough` is conceptually similar to `goto` in that both allow natural
> expression of concepts that exist at the instruction level but are
> otherwise difficult to express with nested control structures.
> `fallthrough` is perhaps slightly less objectionable because control flow
> remains local, but it has a similar role.
>
> It is not particularly natural to write `switch` statements with
> `fallthrough` in the reverse order that can be seen in Duff’s Device and
> similar constructs (case 7 falls through to 6 which falls through to 5,
> etc.). It’s just because you know for certain that all the code in case 6
> would be duplicated in case 7, so 7 can transfer into 6 without a jump
> instruction. Communicating that to the compiler without `fallthrough`
> requires deeply nested `if`s.
>
>
> Right.  One idea that I’ve always had for “fallthrough” is that we might
> parameterize it in the future; parameterized it would mean “repeat the
> switch with this new value”, so that unparameterized fallthrough would mean
> “repeat the switch with a notional value that ends up in the next case”.
> There’s a very common pattern in switches of deferring to another case that
> I’ve always found very awkward to write in C, and while sometimes there’s
> no choice but to extract a helper function, there’s a
> still-fairly-structural code pattern here that I think we can sensibly
> support.
>
> On the other hand, there’s an argument that this is an inappropriate
> extension for “fallthrough” specifically, which is one reason we’ve never
> pursued it.
>
>
> Oh, I see that Joe already brought this up, spelled “reswitch”.
>
> John.
>
>
> John.
>
>
> One defense comes to mind: there is talk of Swift aiming at systems
> programming. Is writing a threaded interpreter loop within the potential
> scope of Swift? That’s a use case that could make use of both `fallthrough`
> and `goto` (computed goto, really).
>
> switch op {
> case LOAD_INDIRECT:
>    in0 = memory[in1]
>    fallthrough
> case LOAD:
>    out0 = memory[in0]
> //...
> }
>
> I am personally interested in the prospect of a language that can scale up
> to high-level concepts and down to “portable assembler,” but I don’t know
> if that is the right direction for Swift’s evolution.
>
> Cheers,
> John
>
> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:
>
> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:
> It's not actually Duff's Device. Duff's Device relies on the fact that C
> switch statements don't actually introduce a new scope, and so it overlaps
> a switch with a do-while loop. This lets it only test the number of bytes
> once, to jump into the middle of the loop, and then it switches over to a
> while loop that decrements a counter every 8 instructions. Basically, it's
> a trick for manual loop unrolling that deals with non-multiple-of-8 counts
> efficiently.
>
>
> To be pedantic, C switch statements do introduce a new scope.  What Duff’s
> Device exploits is that switch is allowed to jump into (almost) arbitrary
> scopes, and cases can appear anywhere recursively inside a switch.
>
> But your point that Swift’s switch requires cases to be at the top level
> within a switch and thus prevents the use of Duff’s Device is 100% correct.
>
> John.
>
>
> Steve's code is also an example of manual loop unrolling that deals with
> non-multiple-of-8 counts, but it has calculate the number of bytes on every
> iteration instead of once. It's a good example of one of the uses of
> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's
> Device in Swift.
>
> -Kevin Ballard
>
> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>
> Streza’s source code is an example of Duff’s Device, which is a big place
> where switch fallthrough is arguably the cleanest way to do things and the
> reason why I’d personally prefer to keep it as part of the language.
>
>
> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:
>
> Oh let it die, let it die. Any time I use fallthrough I find myself
> re-factoring to stop using it.
>
> *True fact*: On all of   gist.github.com, there are only 22 gist results
> for "fallthrough language:swift".
> Half of those are people just testing out the feature. Most of the
> remaining ones are just complex cases:
> *case .Enum1, .Enum2:*
> expressed as
> *case .Enum1: fallthrough*
> *case .Enum2:*
>
> And then there's streza:
> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty
> sure that ponies were harmed in the production of whatever that last bit
> is.
>
>
>
>
>
> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:
>
> In the spirit of some other proposals that remove C or C++ style
> artifacts, what do folks think about the possibility of removing the
> "fallthrough" keyword from the language?
>
> My understanding is this keyword is only used for the archaic seeming
> purpose of perpetuating C-style fallthrough from one switch statement to
> the subsequent one. The documentation hedges the use of this keyword in
> forbidding terms that make it clear its use is not encouraged. The presence
> of the keyword, while an improvement over C’s implicit fallthrough, is a
> mark of inelegance on an otherwise well-designed, opinionated
> implementation of swtich statements.
>
> The ugliness of fallthrough’s C-style behavior even demands a caveat in
> the documentation:
>
> "The fallthrough keyword does not check the case conditions for the switch
> case that it causes execution to fall into. The fallthrough keyword simply
> causes code execution to move directly to the statements inside the next
> case (or default case) block, as in C’s standard switch statement
> behavior."
>
> To my mind, the caveat explains just what is wrong with fallthrough, both
> in C or Swift: coded that is clearly labeled with deliberate conditions can
> nonetheless be reached.
>
> I quipped about this on Twitter, and the most common pushback I got seemed
> to be from people who either did not know about Swift’s support for
> comma-separated case statements, or harbored an aesthetic preference for
> clustering such cases together with fallthrough statements.
>
> In my opinion, unless somebody can think of a strong defense for
> supporting intentional fallthrough in Swift, removing the keyword would be
> a move in the direction of minimizing the language’s complexity while also
> discouraging poor coding style in switch statements.
>
> Thoughts?
>
> Daniel
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> *_______________________________________________*
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/01225289/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 15:32:14 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 16:32:14 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com>
References: <CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com>
<1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com>
Message-ID: <CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com>

To clarify, I would want parens around the entire expression (only when
necessary). So

let myColor = match yourColor
case .Blue :  .Red
case .Green: .Blue
case .Red: .Green
default: .Yellow

or

let myColor = match boolCondition
case true: .Blue
case false: .Red

or

let myColor = match boolCondition
case true: (match yourColor
case .Red: .Blue
default: .Yellow)
case false: .Red

But I actually think that the parens are unnecessary, as long as we require
matches to be exhaustive and for there to be no unreachable cases.

On Sun, Dec 6, 2015 at 4:17 PM, Paul Ossenbruggen <possen at gmail.com> wrote:

> I agree that ? may imply optional, this may be similar to what you
> suggested, just filling in the example: Not sure parenthesis are better
> than braces though:
>
> et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green,
> default: .Yellow )
>
> let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;
>  case .Red: .Green; default: .Yellow )
>
> let myColor = match yourColor (
> case .Blue :  .Reds
> case .Green: .Blue
> case .Red: .Green
> default: .Yellow
> )
>
> let myColor = match yourColor (
> .Blue :  .Reds
> .Green: .Blue
> .Red: .Green
> default: .Yellow
> )
>
> let myColor = match boollCondition ( .Blue, .Red )
>
>
>
> On Dec 6, 2015, at 12:54 PM, Alex Lew < alexl.mail+swift at gmail.com>
> wrote:
>
> Hmm. Something about braces inside expressions just feels wrong to me.
>
> I also read switch? and if? as being some optional-related versions of
> switch and if. And I don't love putting the condition / value-to-switch-on *before
> *the keyword, if we're going to use a keyword.
>
> (Also: exhaustiveness checking *could *theoretically allow resolution of
> ambiguity in nested switch expressions. We would just have to require that
> as soon as you've exhausted all possibilities, you don't add more cases and
> the expression is over.)
>
> On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com>
> wrote:
>
>> Yep probably does need braces: So for switch? if? suggestion i just
>> made.
>>
>> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red:
>> .Green, default: .Yellow }
>>
>> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;
>>  case .Red: .Green; default: .Yellow }
>>
>> let myColor = yourColor switch? {
>> case .Blue :  .Reds
>> case .Green: .Blue
>> case .Red: .Green
>> default: .Yellow
>> }
>>
>> let myColor = yourColor switch? {
>> .Blue :  .Reds
>> .Green: .Blue
>> .Red: .Green
>> default: .Yellow
>> }
>>
>> let myColor = condition if?  { .Blue; .Red }
>>
>> I don’t find that looks bad.
>>
>> - Paul
>>
>>
>> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> Thanks for the feedback, Matthew. It's sensible to me to consider
>> dropping the ternary operator. I like it because the analogy "C's if is to
>> Swift's if as C's ternary operator is to Swift's ternary operator" is (sort
>> of) satisfied. But it is also confusing, both for the reasons you mention,
>> and because ? has other meanings in Swift:
>>
>>  // compiler error without space betw thatColor and ?
>> let thisColor = thatColor?
>>      case .Red: .Green
>>      default: .Blue
>>
>> On the other hand, is it really worth it to have control flow expressions
>> if they don't let your code look nicer?
>>
>> let thisColor = switch thatColor {
>>      case .Red:
>>           return .Green;
>>      default:
>>           return .Yellow;
>> }
>>
>> really isn't much nicer than
>>
>> let thisColor: Color
>> switch thatColor {
>>      case .Red:
>>           thisColor = .Green
>>      default:
>>           thisColor = .Yellow
>> }
>>
>> Maybe we could do a compromise, something like
>>
>> let thisColor = switch thatColor
>>      case .Red: .Green // must be an expression
>>      default: .Yellow      // must be an expression
>>
>> Or we could introduce a new keyword? Like   *match*:
>>
>> let thisColor = match thatColor
>>       case .Red: .Green    // must be an expression
>>       default: .Yellow         // must be an expression
>>
>>
>> I sort of like the new-keyword approach, because even though this is
>> similar to a switch, it's not a switch: there's no fallthrough, you can't
>> put statements inside, etc.
>>
>> The problem with all these proposals:
>>
>> let thisColor = match thatColor
>>      case .Red: match thatOtherColor
>>                            case .Blue: .Green
>>                            case .Pink: .Yellow
>>                            default: .Orange
>>      default: .Orange
>>
>> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can
>> know because of exhaustiveness checking, but this won't always work.) You
>> could solve this problem either by using parentheses around the whole
>> expression when necessary
>>
>> let thisColor = match thatColor
>>      case .Red: (match thatOtherColor
>>                            case .Blue: .Green
>>                            case .Pink: .Yellow
>>                            default: .Orange)
>>      default: .Orange
>>
>> or by adding curly braces in again
>>
>> let thisColor = match thatColor {
>>      case .Red: match thatOtherColor {
>>                            case .Blue: .Green
>>                            case .Pink: .Yellow
>>                            default: .Orange
>>                         }
>>      default: .Orange
>> }
>>
>> But that starts to look like switch again. (Of course, the best way to
>> handle this is as a programmer is to just switch on the tuple (thatColor,
>> thatOtherColor), but the language should allow for nested control
>> expressions.)
>>
>>
>> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution   <
>> swift-evolution at swift.org>  wrote:
>>
>>> I am not a fan of this approach based on the ternary operator.  The
>>> ternary operator is already a bit of an anomaly in that all other operators
>>> are unary or binary and do not perform any control flow (beyond possibly
>>> short circuiting an autoclosure argument).
>>>
>>> I would much rather features that perform control flow continue to use
>>> keywords, but allow them to be expressions.
>>>
>>> Once we have control flow expressions I would like to see the ternary
>>> operator removed from the language as it would no longer server a purpose.
>>> Removing the ternary operator seems to fit nicely with the direction to
>>> remove some features that are carried over from C-based languages but don’t
>>> necessarily fit with the direction Swift is heading.
>>>
>>>
>>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> Ostensibly, case may not be necessary if you could delimit each case on
>>> one line with something (perhaps a comma, or something else if that would
>>> not fit well within the grammar):
>>>
>>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,
>>> default: .Yellow
>>>
>>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution
>>> wrote:
>>>
>>> I like this too, seems more powerful.  Also, would single line
>>> expressions be allowed?  If not would case be required for example:
>>>
>>> let myFavoriteColor = yourFavoriteColor ?
>>>      case .Blue: .Red
>>>      case .Green: .Blue
>>>      case .Red: .Green
>>>      default: .Yellow
>>>
>>>
>>>
>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> I really like this train of thought. +1
>>>
>>> l8r
>>> Sean
>>>
>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> What if we left the if { ...} else { ... } syntax alone (as a
>>> statement), and updated the ternary expression to be a more general pattern
>>> matching expression (closer to "switch")? Something like
>>>
>>> let x = condition ?
>>>    true: "Hello"
>>>    false: "Goodbye"
>>>
>>> let x = optionalValue ?
>>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>>    .None: "To Whom It May Concern"
>>>
>>> let myFavoriteColor = yourFavoriteColor ?
>>>      .Blue: .Red
>>>      .Green: .Blue
>>>      .Red: .Green
>>>
>>> let quadrant = (x, y) ?
>>>      let (x, y) where x < 50 && y < 50: "top left"
>>>      let (x, y) where x < 50 && y > 50: "bottom left"
>>>      let (x, y) where x > 50 && y < 50: "top right"
>>>      default: "bottom right"
>>>
>>> The colon comes from the fact that this is sort of a light-weight
>>> expression-based "switch" statement, where each branch can only contain an
>>> expression, not a series of statements.
>>>
>>> This is very similar to pattern matching expressions in languages like
>>> Haskell, ML, and Coq.
>>>
>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz   <thorsten.seitz at web.de
>>> >   wrote:
>>>
>>>
>>>
>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <
>>> swift-evolution at swift.org>:
>>>
>>> I don't think you can just get rid of the if statement in favor of an
>>> expression. You still want to be able to do this:
>>>
>>> if (condition) {
>>>     funcWithSideEffectsThatReturnsInt()
>>> } else {
>>>     funcWithSideEffectsThatReturnsString()
>>> }
>>>
>>> but that's not a valid expression (what is its type?).
>>>
>>>
>>>
>>> That would actually be no problem if Swift’s type system would have
>>> union types (Ceylon has union and intersection types which are quite
>>> awesome and enable lots of nice things quite naturally, see
>>> http://ceylon-lang.org/documentation/1.2/tour/types/).
>>>
>>> In that case the type of such an expression would just be the union of
>>> both types, which is written   Int | String   in Ceylon.
>>>
>>>
>>> -Thorsten
>>>
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> *_______________________________________________*
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> Untracked with   Trackbuster <https://trackbuster.com/?sig>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7f05a68f/attachment.html>

From cloutiertyler at aol.com  Sun Dec  6 15:32:53 2015
From: cloutiertyler at aol.com (Tyler Fleming Cloutier)
Date: Sun, 6 Dec 2015 13:32:53 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>
<75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com>
Message-ID: <E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com>

Cool! Thanks for updating the proposal with those concerns!

One thing though, could you possibly change

for var x = 0 while (someCondition()) {
to be
for var x = 0 while someCondition() {
in the gist?

I accidentally threw and extra set of parenthesis in there. Old habits die hard.

Tyler



> On Dec 6, 2015, at 1:26 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>
> A slightly updated proposal write-up with everyone's feedback: https://gist.github.com/erica/56d533b75d0a36e3908f <https://gist.github.com/erica/56d533b75d0a36e3908f>
>
>
>> On Dec 6, 2015, at 2:13 PM, Tyler Fleming Cloutier <cloutiertyler at aol.com <mailto:cloutiertyler at aol.com>> wrote:
>>
>>
>>> Lowered Readability and Maintainability
>>>
>>> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged.
>>>
>>> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:
>>> Roland King writes:
>>>
>>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
>>> {
>>> 	// more than a few lines of code with early escape continues
>>> }
>>>
>>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.
>>>
>>> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.
>>>
>>
>> Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.
>>
>> The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.
>>
>> Something like the following might be nice to scope the variable exclusively to the loop.
>>
>> for var x = 0 while (someCondition()) {
>> 	// code
>> }
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a350da55/attachment.html>

From cloutiertyler at aol.com  Sun Dec  6 15:34:33 2015
From: cloutiertyler at aol.com (Tyler Fleming Cloutier)
Date: Sun, 6 Dec 2015 13:34:33 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com>
<CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com>
Message-ID: <A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com>

This is true. Kind of an unfortunate extra level of indention though.


> On Dec 6, 2015, at 1:27 PM, Johan Jensen <jj at johanjensen.dk> wrote:
>
> Well, it is possible to just add an extra scope around the variable and the loop:
>
> do {
>     var i = 0
>     while i < 10 {
>         print(i)
>         i += 1
>     }
> }
>
> —Johan
>
> On Sun, Dec 6, 2015 at 10:13 PM, Tyler Fleming Cloutier via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> Lowered Readability and Maintainability
>>
>> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged.
>>
>> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:
>> Roland King writes:
>>
>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta
>> {
>> 	// more than a few lines of code with early escape continues
>> }
>>
>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that.
>>
>> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.
>>
>
> Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.
>
> The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.
>
> Something like the following might be nice to scope the variable exclusively to the loop.
>
> for var x = 0 while (someCondition()) {
> 	// code
> }
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7d6b1412/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 15:36:01 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 16:36:01 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
Message-ID: <CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com>

One question: what is the result of this code?

let x = .One

switch x {
case .One:
reswitch(.Two)
case .Two:
return x
}

.One or .Two? In other words, is x rebound inside the switch when we
reswitch?

On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:

> It seems reswitch *should* be useable even in cases that aren't a simple
> "goto". Or am I missing something?
>
> For instance, rewriting the example from earlier:
>
> switch op {
> case let .LOAD_INDIRECT(out, in):
>     reswitch(.LOAD(out, memory[in]))
> case let .LOAD(out, in):
>     setReg(out, in)
> // ...
> }
>
> or, a switch that calculates whether some number n is in a Lisp-style list
> of numbers
>
> switch lst {
> case .Cons(let m, _) where m == n:
>      return true
> case .Cons(_, let rest):
>     reswitch(rest)
> case .Empty:
>      return false
> }
>
> I like reswitch: in some cases, the compiler could optimize to a
> fallthrough, and in others, you could actually re-switch. But maybe I'm
> missing something.
>
> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> Yes, I’m aware that at this time the reswitch can be abused and maybe can
>> be better refined to disallow such cases.
>>
>> Checking the case statement is not a problem by itself, but can be a
>> problem if is coupled with a where clause that is not true when you
>> fallthrought.
>>
>> I’ve written a really bad draft here
>> https://gist.github.com/JGiola/f735212789bf2f697847
>> If anyone wants to jump in and elaborate further is welcome. I will try
>> to stay on par with this thread but I’m really bad at writing so every help
>> is welcome.
>>
>> And if I remember correctly Daniel Jakult was the first one to made this
>> proposal so if he wants to take on and then made the official proposal has
>> every right to do so and I will be very glad if my gist can be a first
>> reference :)
>>
>> - Jacopo
>>
>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>
>> wrote:
>>
>> Apologies, Jacopo, for missing the updated proposal, and thank you for
>> your patience in summarizing it again.
>>
>> I’ve only glanced through it but my concern here is that it introduces a
>> whole class of new and creative “foot-guns" :) In particular, it allows
>> this construction to loop arbitrarily and creatively, particularly in the
>> case of associated values.
>>
>> I’m not sure why not checking the case statement is considered a problem
>> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a
>> case that introduces binders (what would they be bound to?), and that this
>> is statically checked (both of which seem reasonable assumptions to me,
>> although if I’m wrong feel free to correct me), isn’t it the entire point
>> of the fallthrough keyword that it skips checking the case statement? I can
>> understand how that might be somewhat confusing (and perhaps it should be
>> documented less prominently) but I’m not sure how it’s a *problem*,
>> exactly...
>>
>> I think I’m still on the side of keeping fallthrough. What’s the downside
>> of doing nothing? For instance in the case of ++ and -- those features
>> complicate the design of a numerics library.
>>
>> Thanks,
>> -Colin
>>
>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <
>> swift-evolution at jacopo.giola.org> wrote:
>>
>>  Hi Colin,
>>
>> the initial proposal was indeed to remove entirely the `fallthrough`
>> keyword but many people expressed your similar concern and from that point
>> the discussion was steered through an "enhancement" and better refinement
>> of the keyword.
>>
>> The new idea is to substitute the old keyword with "reswitch" passing the
>> desired new value on which the switch is applied.
>> So something like this:
>>
>> switch (enum) {
>> case .One:
>> // do something
>> reswitch .Two
>> case .Two:
>> // do something else
>> default:
>> // and so one
>> }
>>
>> This new behaviour, IMO, is better suited for Swift because is more
>> declarative of the developer intent and doesn't carry over unintentional
>> misbehaviour.
>> Is more declarative because you are forced to state in which case you
>> want to go, and even if the order of the switch’ cases will change in the
>> future, you don't fall in the wrong case by mistake.
>>
>> switch (enum) {
>> case .One:
>> // do something
>> reswitch .Two
>> case .OneAndAHalf
>> // maybe this change is not made by you but by a messed up merge
>> case .Two:
>> // do something else
>> default:
>> // and so one
>> }
>>
>> In this case if you are using the fallthrough keyboard your code is now
>> broken by accident, and depending on what are you trying to do inside the
>> cases you can have a hidden bug that your tests are not seeing right away.
>>
>> Another advantage is that in this way you can made more cases fallthrough
>> in the same one even if they are not one over each other
>>
>> switch (enum) {
>> case .One:
>> // do something
>> reswitch .Two
>> case .OneAndAHalf
>> // so something that you don’t want to do for .One
>> reswitch .Two
>> case .Two:
>> // do something else that you may want to do for .One and .Two
>> default:
>> // and so one
>> }
>>
>> I must say that this is a side effect that can be used to messed up the
>> code flow in a way that is not intended, but is a new behaviour that gives
>> more power to the switch statement.
>>
>> The reswitch keyword in addition is not a mere fallthrough on the new
>> case without doing the optional checking attached to it, but is intended to
>> be a new call and all the check are executed.
>>
>> switch (enum) {
>> case .One:
>> // do something
>> x = 0;
>> reswitch .Two
>> case .OneAndAHalf
>> // so something that you don’t want to do for .One
>> reswitch .Two
>> case .Two where x > 0:
>> // do something else that you may want to do for .One and .Two
>> element = array[x]
>> default:
>> // and so one
>> }
>> (I’m going by memory and by writing this snippets in the mail app
>> directly, so the code must be incorrect in the syntax and for this I’m
>> sorry).
>>
>> In this case if enum is .One the only case that is executed is case .One
>> and the code doesn’t fallthrough in the .Two case because we are made the
>> where invalid by changing the x to a value less than 1.
>>
>> Now I don’t remember who was the first one who mede this proposal, and I
>> don’t know if he is working on a first draft to lay down the things better,
>> but for me this can be a nice improvement and a neat break with the
>> C-switch behaviour that Swift has trying to change from the very first beta
>> disallowing the implicit fallthrough.
>>
>> I can be completely wrong but I see the `fallthrough`keyword as a
>> “temporary” implementation for ease the transition from Obj-C to Swift and
>> is time to improve it and made the switch statement even more powerful.
>>
>> - Jacopo
>> Sent from my iPad
>>
>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us
>> anything; and has at least minimal utility, as I try to demonstrate.
>>
>> Apologies for jumping into this thread at an awkward point, but I’ve only
>> just now subscribed to this list.
>>
>> I think the fallthrough keyword is useful in certain circumstances. I’ve
>> also yet to see an example of where it creates a negative impact, either in
>> code, optimization, or what have you. Other than “It’s like something in C,
>> and C is old and busted” I’m unsure of the rationale for removing it. (Feel
>> free to point me in the right direction.)
>>
>> Consider the Planet enum from the documentation. One of the simplest way
>> to define the number of a planet (i.e. its 1-based index in the ordering of
>> planets wrt. distance from the sun) is using a switch and fall-through:
>>
>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>>
>> This technique is very extensible — for instance imagine computing the
>> force induced by the gravity of the other planets on a particular planet.
>> All that would need to change is the case statements.
>>
>> Yes, you could write this by putting the planets into a list and mapping
>> or folding (or looping) over that, but unless the compiler can “unroll”
>> that construct, you’re paying for an allocation simply bc of your choice of
>> control flow. But in fact, you could imagine generalizing this construct
>> into the implementation of fold for the Planet type — low-overhead folds
>> for monomorphic types seems like a pretty compelling an natural use case
>> for fallthrough to me.
>>
>> Thanks,
>> -Colin
>>
>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> +1 for this idea, but I will prefer the reswitch keyword instead of
>> overloading continue with a new syntax.
>>
>> If this proposal is accepted, it must be coupled with a compiler check
>> that the reswitch statements don't introduce an infinite "switch" loop.
>>
>> Sent from my iPad
>>
>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> Very much thinking out loud and not really the implications, I wonder if
>> we might just use "continue" instead of "reswitch".
>>
>> I very much like specifying what case to fall through into, no matter how
>> we spell it.
>>
>> - Steve
>>
>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <
>> john.calsbeek+lists at gmail.com> wrote:
>> `fallthrough` is conceptually similar to `goto` in that both allow
>> natural expression of concepts that exist at the instruction level but are
>> otherwise difficult to express with nested control structures.
>> `fallthrough` is perhaps slightly less objectionable because control flow
>> remains local, but it has a similar role.
>>
>> It is not particularly natural to write `switch` statements with
>> `fallthrough` in the reverse order that can be seen in Duff’s Device and
>> similar constructs (case 7 falls through to 6 which falls through to 5,
>> etc.). It’s just because you know for certain that all the code in case 6
>> would be duplicated in case 7, so 7 can transfer into 6 without a jump
>> instruction. Communicating that to the compiler without `fallthrough`
>> requires deeply nested `if`s.
>>
>>
>> Right.  One idea that I’ve always had for “fallthrough” is that we might
>> parameterize it in the future; parameterized it would mean “repeat the
>> switch with this new value”, so that unparameterized fallthrough would mean
>> “repeat the switch with a notional value that ends up in the next case”.
>> There’s a very common pattern in switches of deferring to another case that
>> I’ve always found very awkward to write in C, and while sometimes there’s
>> no choice but to extract a helper function, there’s a
>> still-fairly-structural code pattern here that I think we can sensibly
>> support.
>>
>> On the other hand, there’s an argument that this is an inappropriate
>> extension for “fallthrough” specifically, which is one reason we’ve never
>> pursued it.
>>
>>
>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>
>> John.
>>
>>
>> John.
>>
>>
>> One defense comes to mind: there is talk of Swift aiming at systems
>> programming. Is writing a threaded interpreter loop within the potential
>> scope of Swift? That’s a use case that could make use of both `fallthrough`
>> and `goto` (computed goto, really).
>>
>> switch op {
>> case LOAD_INDIRECT:
>>    in0 = memory[in1]
>>    fallthrough
>> case LOAD:
>>    out0 = memory[in0]
>> //...
>> }
>>
>> I am personally interested in the prospect of a language that can scale
>> up to high-level concepts and down to “portable assembler,” but I don’t
>> know if that is the right direction for Swift’s evolution.
>>
>> Cheers,
>> John
>>
>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:
>>
>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:
>> It's not actually Duff's Device. Duff's Device relies on the fact that C
>> switch statements don't actually introduce a new scope, and so it overlaps
>> a switch with a do-while loop. This lets it only test the number of bytes
>> once, to jump into the middle of the loop, and then it switches over to a
>> while loop that decrements a counter every 8 instructions. Basically, it's
>> a trick for manual loop unrolling that deals with non-multiple-of-8 counts
>> efficiently.
>>
>>
>> To be pedantic, C switch statements do introduce a new scope.  What
>> Duff’s Device exploits is that switch is allowed to jump into (almost)
>> arbitrary scopes, and cases can appear anywhere recursively inside a
>> switch.
>>
>> But your point that Swift’s switch requires cases to be at the top level
>> within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>
>> John.
>>
>>
>> Steve's code is also an example of manual loop unrolling that deals with
>> non-multiple-of-8 counts, but it has calculate the number of bytes on every
>> iteration instead of once. It's a good example of one of the uses of
>> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's
>> Device in Swift.
>>
>> -Kevin Ballard
>>
>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>
>> Streza’s source code is an example of Duff’s Device, which is a big place
>> where switch fallthrough is arguably the cleanest way to do things and the
>> reason why I’d personally prefer to keep it as part of the language.
>>
>>
>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:
>>
>> Oh let it die, let it die. Any time I use fallthrough I find myself
>> re-factoring to stop using it.
>>
>> *True fact*: On all of   gist.github.com, there are only 22 gist results
>> for "fallthrough language:swift".
>> Half of those are people just testing out the feature. Most of the
>> remaining ones are just complex cases:
>> *case .Enum1, .Enum2:*
>> expressed as
>> *case .Enum1: fallthrough*
>> *case .Enum2:*
>>
>> And then there's streza:
>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty
>> sure that ponies were harmed in the production of whatever that last bit
>> is.
>>
>>
>>
>>
>>
>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:
>>
>> In the spirit of some other proposals that remove C or C++ style
>> artifacts, what do folks think about the possibility of removing the
>> "fallthrough" keyword from the language?
>>
>> My understanding is this keyword is only used for the archaic seeming
>> purpose of perpetuating C-style fallthrough from one switch statement to
>> the subsequent one. The documentation hedges the use of this keyword in
>> forbidding terms that make it clear its use is not encouraged. The presence
>> of the keyword, while an improvement over C’s implicit fallthrough, is a
>> mark of inelegance on an otherwise well-designed, opinionated
>> implementation of swtich statements.
>>
>> The ugliness of fallthrough’s C-style behavior even demands a caveat in
>> the documentation:
>>
>> "The fallthrough keyword does not check the case conditions for the
>> switch case that it causes execution to fall into. The fallthrough keyword
>> simply causes code execution to move directly to the statements inside the
>> next case (or default case) block, as in C’s standard switch statement
>> behavior."
>>
>> To my mind, the caveat explains just what is wrong with fallthrough, both
>> in C or Swift: coded that is clearly labeled with deliberate conditions can
>> nonetheless be reached.
>>
>> I quipped about this on Twitter, and the most common pushback I got
>> seemed to be from people who either did not know about Swift’s support for
>> comma-separated case statements, or harbored an aesthetic preference for
>> clustering such cases together with fallthrough statements.
>>
>> In my opinion, unless somebody can think of a strong defense for
>> supporting intentional fallthrough in Swift, removing the keyword would be
>> a move in the direction of minimizing the language’s complexity while also
>> discouraging poor coding style in switch statements.
>>
>> Thoughts?
>>
>> Daniel
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> *_______________________________________________*
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> Untracked with Trackbuster <https://trackbuster.com/?sig>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/aa1365c7/attachment-0001.html>

From thorsten at portableinnovations.de  Sun Dec  6 15:35:28 2015
From: thorsten at portableinnovations.de (thorsten at portableinnovations.de)
Date: Sun, 6 Dec 2015 22:35:28 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<1449429569.13426
23.459603529.32C935BC@webmail.messagingengine.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
Message-ID: <07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>

I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.

Therefore the switch-expression should simply look like follows:

let thisColor = switch thatColor {
case .Red: .Green // must be an expression
default: .Yellow      // must be an expression
}

No returns needed in the case clauses.
Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).

-Thorsten

From tmandry at gmail.com  Sun Dec  6 15:38:58 2015
From: tmandry at gmail.com (Tyler Mandry)
Date: Sun, 6 Dec 2015 15:38:58 -0600
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
Message-ID: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>

What isn't clear to me from Chris's or John's comments is why the `if let
x? = foo` syntax was taken away. Was it for backward-compatibility? To me,
this syntax does have special syntactic support, and also seems to make it
clearer what's going on. It's also analogous to Swift's type inference for
generic <T?> types, for example:

func doSomething<T? where T: Equatable>(x: T?) -> T { ... }

Note the T? in brackets. If I pass an Int? to doSomething, the type is
"unwrapped" and T becomes Int. It seems like `if let x? = foo` would follow
the same pattern.

Was the syntax taken away for reasons unlikely to change, or is it up for
discussion? :)

--
Tyler Mandry
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/fc1b6148/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 15:43:13 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 16:43:13 -0500
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
References: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
Message-ID: <CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com>

let a: Int? = 3
if case let b? = a {
print(b)
}

works for me in Swift 2.2. Have they announced that they're taking this
away?


On Sun, Dec 6, 2015 at 4:38 PM, Tyler Mandry via swift-evolution <
swift-evolution at swift.org> wrote:

> What isn't clear to me from Chris's or John's comments is why the `if let
> x? = foo` syntax was taken away. Was it for backward-compatibility? To me,
> this syntax does have special syntactic support, and also seems to make it
> clearer what's going on. It's also analogous to Swift's type inference for
> generic <T?> types, for example:
>
>    func doSomething<T? where T: Equatable>(x: T?) -> T { ... }
>
> Note the T? in brackets. If I pass an Int? to doSomething, the type is
> "unwrapped" and T becomes Int. It seems like `if let x? = foo` would follow
> the same pattern.
>
> Was the syntax taken away for reasons unlikely to change, or is it up for
> discussion? :)
>
> --
> Tyler Mandry
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/869babf6/attachment.html>

From thorsten at portableinnovations.de  Sun Dec  6 15:43:53 2015
From: thorsten at portableinnovations.de (thorsten at portableinnovations.de)
Date: Sun, 6 Dec 2015 22:43:53 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<7D68F57E-C847-4E 0D-AF3A- FD1F2DC928A9@icloud.com>
<1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com>
Message-ID: <67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de>

I strongly dislike the one liner with only punctuation to separate the cases because it is very difficult to spot the pairs.

I fail to see why we have to have new syntax for the expression case.

-Thorsten

> Am 06.12.2015 um 21:30 schrieb Paul Ossenbruggen via swift-evolution <swift-evolution at swift.org>:
>
> let myColor = yourColor switch? .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow

From salutis at me.com  Sun Dec  6 15:44:21 2015
From: salutis at me.com (Rudolf Adamkovic)
Date: Sun, 06 Dec 2015 22:44:21 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<"1449429569.13426 23.459603529.32C935BC"@webmail.messagingengine.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
Message-ID: <45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>

> On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org> wrote:

>
> I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.

+1

>
> Therefore the switch-expression should simply look like follows:
>
> let thisColor = switch thatColor {
>         case .Red: .Green // must be an expression
>         default: .Yellow      // must be an expression
>     }
>
> No returns needed in the case clauses.

This actually looks great. One simple rule and zero new keywords.

Readable and simple to learn.

Fantastic!

> Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).
>
> -Thorsten
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From tmandry at gmail.com  Sun Dec  6 15:46:58 2015
From: tmandry at gmail.com (Tyler Mandry)
Date: Sun, 6 Dec 2015 15:46:58 -0600
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com>
References: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
<CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com>
Message-ID: <CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com>

Ah no, it's just that they at one time had support for taking away `case`
and doing `if let b? = a`. See the commit notes that Chris linked to here:
https://github.com/apple/swift/commit/20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9#diff-4513b692cdd5476630ebb66b73d5bf4b
.

I guess the current `if let b = a` syntax is what John was referring to as
special syntactic support, but I still don't see why the `?` was taken out
of the syntax.

On Sun, Dec 6, 2015 at 3:43 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:

> let a: Int? = 3
> if case let b? = a {
>     print(b)
> }
>
> works for me in Swift 2.2. Have they announced that they're taking this
> away?
>
>
> On Sun, Dec 6, 2015 at 4:38 PM, Tyler Mandry via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> What isn't clear to me from Chris's or John's comments is why the `if let
>> x? = foo` syntax was taken away. Was it for backward-compatibility? To me,
>> this syntax does have special syntactic support, and also seems to make it
>> clearer what's going on. It's also analogous to Swift's type inference for
>> generic <T?> types, for example:
>>
>>    func doSomething<T? where T: Equatable>(x: T?) -> T { ... }
>>
>> Note the T? in brackets. If I pass an Int? to doSomething, the type is
>> "unwrapped" and T becomes Int. It seems like `if let x? = foo` would follow
>> the same pattern.
>>
>> Was the syntax taken away for reasons unlikely to change, or is it up for
>> discussion? :)
>>
>> --
>> Tyler Mandry
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>


--
Tyler Mandry
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3b56af76/attachment.html>

From jp at jpsim.com  Sun Dec  6 15:49:10 2015
From: jp at jpsim.com (Jean-Pierre Simard)
Date: Sun, 6 Dec 2015 13:49:10 -0800
Subject: [swift-evolution] "bad smells" should be compiler errors with
suggestions on how to fix them
In-Reply-To: <9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com>
References: <557CCA5F-E52F-439C-B224-AC4990140373@gmail.com>
<1449324589110.9d79fd62@Nodemailer>
<CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com>
<E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com>
<49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com>
<4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com>
<9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com>
Message-ID: <CACyzo1jKFZZ2TLTxXYyd_o1j9d5HBAKmg3Doz7QN9O=JGViOtA@mail.gmail.com>

>
> Separate from compiler-enforced policies, I’d *love* to see someone tackle
> implementing a "go fmt” analog that reformats Swift code into a standard
> style, as well as a “clang format”  tool that could be used by IDEs for
> on-the-fly editing of code, as well as a “linter” / static analysis tool
> which can flag potential issues while having a higher tolerance for false
> positives.  These should be separate from the “always on” compiler
> diagnostics though.


I agree that a compiler cannot be too stylistically opinionated, and that
an opt-in, standalone linter/formatter is preferable.

As others have mentioned, there's a community-built tool called SwiftLint
<https://github.com/realm/SwiftLint> that does much of this today. It's an
AST-assisted tool to enforce code style conventions & automatically correct
certain violations. Rules can be enabled/disabled and parameterized either
inline in the source or via a YAML configuration file.

One of the tool's main limitations so far is that the Swift AST it operates
on is obtained from a reverse-engineered SourceKit interface and is
incomplete.

Myself and other SwiftLint contributors intend to replace the
reverse-engineered SourceKit backend with more official tooling that was
just open sourced, which will enable SwiftLint to do things like an
opinionated go-fmt/clang-format style formatting (source->AST-source) and
some types of static analysis like identifying cyclomatic complexity.

One thing I'd like to discuss with relevant Swift project owners (notably
Argyrios and Chris) is the possibility of moving SwiftLint development into
github.com/apple, which would increase the tool's exposure and pace of
development. I hope to make a more official proposal for how that
transition could happen in the upcoming week, probably in swift-dev.

On Sun, Dec 6, 2015 at 9:07 AM, Erica Sadun via swift-evolution <
swift-evolution at swift.org> wrote:

> On Dec 5, 2015, at 11:15 PM, Chris Lattner via swift-evolution <
> swift-evolution at swift.org> wrote:
> > Separate from compiler-enforced policies, I’d *love* to see someone
> tackle implementing a "go fmt” analog that reformats Swift code into a
> standard style, as well as a “clang format”  tool that could be used by
> IDEs for on-the-fly editing of code, as well as a “linter” / static
> analysis tool which can flag potential issues while having a higher
> tolerance for false positives.  These should be separate from the “always
> on” compiler diagnostics though.
> >
> > -Chris
>
> I have a fairly minimal held-together-by-bandaids linter I put together:
>
> https://github.com/erica/testlint
>
> I have hesitated to develop it much further because I didn't want to be
> committed to inter-process SourceKit hacking and did not yet have access to
> a reliable parse tree. In its current state, it's a regex-based
> line-by-line scan.
>
> The rules it follows are here:
> https://github.com/erica/testlint/blob/master/testlint/sources/Linter.m
> with fairly copious commenting
>
>
> -- Erica
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/f816565a/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 15:49:08 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 22:49:08 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
<CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com>
Message-ID: <ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org>

The result is .Two, because you are returning from the reswitch and in that case the original x is shadowed by the new execution.

- Jacopo

> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> One question: what is the result of this code?
>
> let x = .One
>
> switch x {
> case .One:
>    reswitch(.Two)
> case .Two:
>    return x
> }
>
> .One or .Two? In other words, is x rebound inside the switch when we reswitch?
>
> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com <mailto:alexl.mail+swift at gmail.com>> wrote:
> It seems reswitch should be useable even in cases that aren't a simple "goto". Or am I missing something?
>
> For instance, rewriting the example from earlier:
>
> switch op {
> case let .LOAD_INDIRECT(out, in):
>     reswitch(.LOAD(out, memory[in]))
> case let .LOAD(out, in):
>     setReg(out, in)
> // ...
> }
>
> or, a switch that calculates whether some number n is in a Lisp-style list of numbers
>
> switch lst {
> case .Cons(let m, _) where m == n:
>      return true
> case .Cons(_, let rest):
>     reswitch(rest)
> case .Empty:
>      return false
> }
>
> I like reswitch: in some cases, the compiler could optimize to a fallthrough, and in others, you could actually re-switch. But maybe I'm missing something.
>
> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.
>
> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.
>
> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 <https://gist.github.com/JGiola/f735212789bf2f697847>
> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.
>
> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
>
> - Jacopo
>
>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com <mailto:colin at springsandstruts.com>> wrote:
>>
>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
>>
>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
>>
>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
>>
>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
>>
>> Thanks,
>> -Colin
>>
>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola < swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:
>>>
>>>  Hi Colin,
>>>
>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>>>
>>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
>>> So something like this:
>>>
>>> switch (enum) {
>>>  case .One:
>>>  // do something
>>>  reswitch .Two
>>>  case .Two:
>>>  // do something else
>>>  default:
>>>  // and so one
>>> }
>>>
>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>>>
>>> switch (enum) {
>>>  case .One:
>>>  // do something
>>>  reswitch .Two
>>>  case .OneAndAHalf
>>>  // maybe this change is not made by you but by a messed up merge
>>>  case .Two:
>>>  // do something else
>>>  default:
>>>  // and so one
>>> }
>>>
>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>>>
>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>>>
>>> switch (enum) {
>>>  case .One:
>>>  // do something
>>>  reswitch .Two
>>>  case .OneAndAHalf
>>>  // so something that you don’t want to do for .One
>>>  reswitch .Two
>>>  case .Two:
>>>  // do something else that you may want to do for .One and .Two
>>>  default:
>>>  // and so one
>>> }
>>>
>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>>>
>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>>>
>>> switch (enum) {
>>>  case .One:
>>>  // do something
>>>  x = 0;
>>>  reswitch .Two
>>>  case .OneAndAHalf
>>>  // so something that you don’t want to do for .One
>>>  reswitch .Two
>>>  case .Two where x > 0:
>>>  // do something else that you may want to do for .One and .Two
>>>  element = array[x]
>>>  default:
>>>  // and so one
>>> }
>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>>>
>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>>>
>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>>>
>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>>>
>>> - Jacopo
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>>>
>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>>>
>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>>>
>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>>>
>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
>>>>
>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>>>
>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>>>
>>>> Thanks,
>>>> -Colin
>>>>
>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>>>
>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>>>
>>>>> Sent from my iPad
>>>>>
>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>>>
>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>>>
>>>>>> - Steve
>>>>>>
>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>
>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek < john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:
>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>>>
>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>>>
>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>>>
>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>>>
>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>>>
>>>>>>> John.
>>>>>>>
>>>>>>>>
>>>>>>>> John.
>>>>>>>>
>>>>>>>>>
>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>>>
>>>>>>>>> switch op {
>>>>>>>>> case LOAD_INDIRECT:
>>>>>>>>>    in0 = memory[in1]
>>>>>>>>>    fallthrough
>>>>>>>>> case LOAD:
>>>>>>>>>    out0 = memory[in0]
>>>>>>>>> //...
>>>>>>>>> }
>>>>>>>>>
>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>>>
>>>>>>>>> Cheers,
>>>>>>>>> John
>>>>>>>>>
>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
>>>>>>>>>>
>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org <mailto:kevin at sb.org>> wrote:
>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>>>
>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>>>
>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>>>
>>>>>>>>>> John.
>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>>>
>>>>>>>>>>> -Kevin Ballard
>>>>>>>>>>>
>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>>>
>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>>>
>>>>>>>>>>>>> True fact: On all of   gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>>>> expressed as
>>>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>>>
>>>>>>>>>>>>> And then there's streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>    I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com <mailto:jalkut at red-sweater.com>  wrote:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Daniel
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>>
>>>>>>>>>>  _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/51bacbae/attachment.html>

From possen at gmail.com  Sun Dec  6 15:50:03 2015
From: possen at gmail.com (possen p)
Date: Sun, 6 Dec 2015 13:50:03 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com>
References: <CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com>
<1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com>
<CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com>
Message-ID: <63E46D4F-9E50-4BD8-AB36-A4510BDFF4B0@gmail.com>

Got ya, so for a more complex example:

let myColor = (match yourColor
case .Blue :  .Reds
case .Green: .Blue
case .Red: match  shade .LightRed : LightGreen, .MediumRed :  .DarkGreen :  DarkRed
default: .Yellow
)

for booleans I would not want to list the true false cases out though.

let myColor = match boolCondition  .Blue, .Red



> On Dec 6, 2015, at 1:32 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> To clarify, I would want parens around the entire expression (only when necessary). So
>
> let myColor = match yourColor
>  case .Blue :  .Red
>  case .Green: .Blue
>  case .Red: .Green
>  default: .Yellow
>
> or
>
> let myColor = match boolCondition
>   case true: .Blue
>   case false: .Red
>
> or
>
> let myColor = match boolCondition
>   case true: (match yourColor
>                       case .Red: .Blue
>                       default: .Yellow)
>   case false: .Red
>
> But I actually think that the parens are unnecessary, as long as we require matches to be exhaustive and for there to be no unreachable cases.
>
> On Sun, Dec 6, 2015 at 4:17 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote:
> I agree that ? may imply optional, this may be similar to what you suggested, just filling in the example: Not sure parenthesis are better than braces though:
>
> et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow )
>
> let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow )
>
> let myColor = match yourColor (
>   case .Blue :  .Reds
>  case .Green: .Blue
>  case .Red: .Green
>  default: .Yellow
> )
>
> let myColor = match yourColor (
>   .Blue :  .Reds
>  .Green: .Blue
>  .Red: .Green
>  default: .Yellow
> )
>
> let myColor = match boollCondition ( .Blue, .Red )
>
>
>
>> On Dec 6, 2015, at 12:54 PM, Alex Lew < alexl.mail+swift at gmail.com <mailto:alexl.mail+swift at gmail.com>> wrote:
>>
>> Hmm. Something about braces inside expressions just feels wrong to me.
>>
>> I also read switch? and if? as being some optional-related versions of switch and if. And I don't love putting the condition / value-to-switch-on before the keyword, if we're going to use a keyword.
>>
>> (Also: exhaustiveness checking could theoretically allow resolution of ambiguity in nested switch expressions. We would just have to require that as soon as you've exhausted all possibilities, you don't add more cases and the expression is over.)
>>
>> On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote:
>> Yep probably does need braces: So for switch? if? suggestion i just made.
>>
>> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }
>>
>> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }
>>
>> let myColor = yourColor switch? {
>>  case .Blue :  .Reds
>>   case .Green: .Blue
>>  case .Red: .Green
>>  default: .Yellow
>> }
>>
>> let myColor = yourColor switch? {
>>  .Blue :  .Reds
>>  .Green: .Blue
>>  .Red: .Green
>>  default: .Yellow
>> }
>>
>> let myColor = condition if?  { .Blue; .Red }
>>
>> I don’t find that looks bad.
>>
>> - Paul
>>
>>
>>> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> Thanks for the feedback, Matthew. It's sensible to me to consider dropping the ternary operator. I like it because the analogy "C's if is to Swift's if as C's ternary operator is to Swift's ternary operator" is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:
>>>
>>>  // compiler error without space betw thatColor and ?
>>> let thisColor = thatColor?
>>>      case .Red: .Green
>>>      default: .Blue
>>>
>>> On the other hand, is it really worth it to have control flow expressions if they don't let your code look nicer?
>>>
>>> let thisColor = switch thatColor {
>>>      case .Red:
>>>           return .Green;
>>>      default:
>>>           return .Yellow;
>>> }
>>>
>>> really isn't much nicer than
>>>
>>> let thisColor: Color
>>> switch thatColor {
>>>      case .Red:
>>>           thisColor = .Green
>>>      default:
>>>           thisColor = .Yellow
>>> }
>>>
>>> Maybe we could do a compromise, something like
>>>
>>> let thisColor = switch thatColor
>>>      case .Red: .Green // must be an expression
>>>      default: .Yellow      // must be an expression
>>>
>>> Or we could introduce a new keyword? Like   match:
>>>
>>> let thisColor = match thatColor
>>>       case .Red: .Green    // must be an expression
>>>       default: .Yellow         // must be an expression
>>>
>>>
>>> I sort of like the new-keyword approach, because even though this is similar to a switch, it's not a switch: there's no fallthrough, you can't put statements inside, etc.
>>>
>>> The problem with all these proposals:
>>>
>>> let thisColor = match thatColor
>>>      case .Red: match thatOtherColor
>>>                            case .Blue: .Green
>>>                            case .Pink: .Yellow
>>>                            default: .Orange
>>>      default: .Orange
>>>
>>> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won't always work.) You could solve this problem either by using parentheses around the whole expression when necessary
>>>
>>> let thisColor = match thatColor
>>>      case .Red: (match thatOtherColor
>>>                            case .Blue: .Green
>>>                            case .Pink: .Yellow
>>>                            default: .Orange)
>>>      default: .Orange
>>>
>>> or by adding curly braces in again
>>>
>>> let thisColor = match thatColor {
>>>      case .Red: match thatOtherColor {
>>>                            case .Blue: .Green
>>>                            case .Pink: .Yellow
>>>                            default: .Orange
>>>                         }
>>>      default: .Orange
>>> }
>>>
>>> But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)
>>>
>>>
>>> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution   <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>  wrote:
>>> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).
>>>
>>> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.
>>>
>>> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.
>>>
>>>
>>>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <   swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):
>>>>
>>>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow
>>>>
>>>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:
>>>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:
>>>>>
>>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>>      case .Blue: .Red
>>>>>      case .Green: .Blue
>>>>>      case .Red: .Green
>>>>>      default: .Yellow
>>>>>
>>>>>
>>>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <   swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>
>>>>>> I really like this train of thought. +1
>>>>>>
>>>>>> l8r
>>>>>> Sean
>>>>>>
>>>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <   swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to "switch")? Something like
>>>>>>>
>>>>>>> let x = condition ?
>>>>>>>    true: "Hello"
>>>>>>>    false: "Goodbye"
>>>>>>>
>>>>>>> let x = optionalValue ?
>>>>>>>    .Some(let unwrapped): "Hello, \(unwrapped)"
>>>>>>>    .None: "To Whom It May Concern"
>>>>>>>
>>>>>>> let myFavoriteColor = yourFavoriteColor ?
>>>>>>>      .Blue: .Red
>>>>>>>      .Green: .Blue
>>>>>>>      .Red: .Green
>>>>>>>
>>>>>>> let quadrant = (x, y) ?
>>>>>>>      let (x, y) where x < 50 && y < 50: "top left"
>>>>>>>      let (x, y) where x < 50 && y > 50: "bottom left"
>>>>>>>      let (x, y) where x > 50 && y < 50: "top right"
>>>>>>>      default: "bottom right"
>>>>>>>
>>>>>>> The colon comes from the fact that this is sort of a light-weight expression-based "switch" statement, where each branch can only contain an expression, not a series of statements.
>>>>>>>
>>>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.
>>>>>>>
>>>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz   <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>>   wrote:
>>>>>>>
>>>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:
>>>>>>>>
>>>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:
>>>>>>>>
>>>>>>>> if (condition) {
>>>>>>>>     funcWithSideEffectsThatReturnsInt()
>>>>>>>> } else {
>>>>>>>>     funcWithSideEffectsThatReturnsString()
>>>>>>>> }
>>>>>>>>
>>>>>>>> but that's not a valid expression (what is its type?).
>>>>>>>
>>>>>>>
>>>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see   http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).
>>>>>>>
>>>>>>> In that case the type of such an expression would just be the union of both types, which is written   Int | String   in Ceylon.
>>>>>>>
>>>>>>>
>>>>>>> -Thorsten
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> Untracked with   Trackbuster <https://trackbuster.com/?sig>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4daf8bd3/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 15:52:01 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 16:52:01 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
Message-ID: <CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>

I agree that it's simplest to just reuse switch keyword, and keep braces.
+1.

Would you allow the same thing with if?

let thisColor = if condition { .Red } else { .Blue }

On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:

> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> >
> > I would prefer the expression to match the statement. The only
> difference would be that all parts that were statements now have to be
> expressions.
>
> +1
>
> >
> > Therefore the switch-expression should simply look like follows:
> >
> > let thisColor = switch thatColor {
> >         case .Red: .Green // must be an expression
> >         default: .Yellow      // must be an expression
> >     }
> >
> > No returns needed in the case clauses.
>
> This actually looks great. One simple rule and zero new keywords.
>
> Readable and simple to learn.
>
> Fantastic!
>
> > Formatting this as a one-liner would just require adding semicolons
> (though I wouldn't recommend this).
> >
> > -Thorsten
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org
> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/9423de10/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 15:55:12 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 16:55:12 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
<CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com>
<ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org>
Message-ID: <CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com>

Makes sense! So what about this case?

var x = 1
switch x {
case 1:
reswitch(2)
default:
x += 1
}
print(x)

Does that print 1?

On Sun, Dec 6, 2015 at 4:49 PM, Jacopo Andrea Giola <
swift-evolution at jacopo.giola.org> wrote:

> The result is .Two, because you are returning from the reswitch and in
> that case the original x is shadowed by the new execution.
>
> - Jacopo
>
> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> One question: what is the result of this code?
>
> let x = .One
>
> switch x {
> case .One:
>    reswitch(.Two)
> case .Two:
>    return x
> }
>
> .One or .Two? In other words, is x rebound inside the switch when we
> reswitch?
>
> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com>
> wrote:
>
>> It seems reswitch *should* be useable even in cases that aren't a simple
>> "goto". Or am I missing something?
>>
>> For instance, rewriting the example from earlier:
>>
>> switch op {
>> case let .LOAD_INDIRECT(out, in):
>>     reswitch(.LOAD(out, memory[in]))
>> case let .LOAD(out, in):
>>     setReg(out, in)
>> // ...
>> }
>>
>> or, a switch that calculates whether some number n is in a Lisp-style
>> list of numbers
>>
>> switch lst {
>> case .Cons(let m, _) where m == n:
>>      return true
>> case .Cons(_, let rest):
>>     reswitch(rest)
>> case .Empty:
>>      return false
>> }
>>
>> I like reswitch: in some cases, the compiler could optimize to a
>> fallthrough, and in others, you could actually re-switch. But maybe I'm
>> missing something.
>>
>> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>>> Yes, I’m aware that at this time the reswitch can be abused and maybe
>>> can be better refined to disallow such cases.
>>>
>>> Checking the case statement is not a problem by itself, but can be a
>>> problem if is coupled with a where clause that is not true when you
>>> fallthrought.
>>>
>>> I’ve written a really bad draft here
>>> https://gist.github.com/JGiola/f735212789bf2f697847
>>> If anyone wants to jump in and elaborate further is welcome. I will try
>>> to stay on par with this thread but I’m really bad at writing so every help
>>> is welcome.
>>>
>>> And if I remember correctly Daniel Jakult was the first one to made this
>>> proposal so if he wants to take on and then made the official proposal has
>>> every right to do so and I will be very glad if my gist can be a first
>>> reference :)
>>>
>>> - Jacopo
>>>
>>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>
>>> wrote:
>>>
>>> Apologies, Jacopo, for missing the updated proposal, and thank you for
>>> your patience in summarizing it again.
>>>
>>> I’ve only glanced through it but my concern here is that it introduces a
>>> whole class of new and creative “foot-guns" :) In particular, it allows
>>> this construction to loop arbitrarily and creatively, particularly in the
>>> case of associated values.
>>>
>>> I’m not sure why not checking the case statement is considered a problem
>>> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a
>>> case that introduces binders (what would they be bound to?), and that this
>>> is statically checked (both of which seem reasonable assumptions to me,
>>> although if I’m wrong feel free to correct me), isn’t it the entire point
>>> of the fallthrough keyword that it skips checking the case statement? I can
>>> understand how that might be somewhat confusing (and perhaps it should be
>>> documented less prominently) but I’m not sure how it’s a *problem*,
>>> exactly...
>>>
>>> I think I’m still on the side of keeping fallthrough. What’s the
>>> downside of doing nothing? For instance in the case of ++ and -- those
>>> features complicate the design of a numerics library.
>>>
>>> Thanks,
>>> -Colin
>>>
>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <
>>> swift-evolution at jacopo.giola.org> wrote:
>>>
>>>  Hi Colin,
>>>
>>> the initial proposal was indeed to remove entirely the `fallthrough`
>>> keyword but many people expressed your similar concern and from that point
>>> the discussion was steered through an "enhancement" and better refinement
>>> of the keyword.
>>>
>>> The new idea is to substitute the old keyword with "reswitch" passing
>>> the desired new value on which the switch is applied.
>>> So something like this:
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> reswitch .Two
>>> case .Two:
>>> // do something else
>>> default:
>>> // and so one
>>> }
>>>
>>> This new behaviour, IMO, is better suited for Swift because is more
>>> declarative of the developer intent and doesn't carry over unintentional
>>> misbehaviour.
>>> Is more declarative because you are forced to state in which case you
>>> want to go, and even if the order of the switch’ cases will change in the
>>> future, you don't fall in the wrong case by mistake.
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> reswitch .Two
>>> case .OneAndAHalf
>>> // maybe this change is not made by you but by a messed up merge
>>> case .Two:
>>> // do something else
>>> default:
>>> // and so one
>>> }
>>>
>>> In this case if you are using the fallthrough keyboard your code is now
>>> broken by accident, and depending on what are you trying to do inside the
>>> cases you can have a hidden bug that your tests are not seeing right away.
>>>
>>> Another advantage is that in this way you can made more
>>> cases fallthrough in the same one even if they are not one over each other
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> reswitch .Two
>>> case .OneAndAHalf
>>> // so something that you don’t want to do for .One
>>> reswitch .Two
>>> case .Two:
>>> // do something else that you may want to do for .One and .Two
>>> default:
>>> // and so one
>>> }
>>>
>>> I must say that this is a side effect that can be used to messed up the
>>> code flow in a way that is not intended, but is a new behaviour that gives
>>> more power to the switch statement.
>>>
>>> The reswitch keyword in addition is not a mere fallthrough on the new
>>> case without doing the optional checking attached to it, but is intended to
>>> be a new call and all the check are executed.
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> x = 0;
>>> reswitch .Two
>>> case .OneAndAHalf
>>> // so something that you don’t want to do for .One
>>> reswitch .Two
>>> case .Two where x > 0:
>>> // do something else that you may want to do for .One and .Two
>>> element = array[x]
>>> default:
>>> // and so one
>>> }
>>> (I’m going by memory and by writing this snippets in the mail app
>>> directly, so the code must be incorrect in the syntax and for this I’m
>>> sorry).
>>>
>>> In this case if enum is .One the only case that is executed is case .One
>>> and the code doesn’t fallthrough in the .Two case because we are made the
>>> where invalid by changing the x to a value less than 1.
>>>
>>> Now I don’t remember who was the first one who mede this proposal, and I
>>> don’t know if he is working on a first draft to lay down the things better,
>>> but for me this can be a nice improvement and a neat break with the
>>> C-switch behaviour that Swift has trying to change from the very first beta
>>> disallowing the implicit fallthrough.
>>>
>>> I can be completely wrong but I see the `fallthrough`keyword as a
>>> “temporary” implementation for ease the transition from Obj-C to Swift and
>>> is time to improve it and made the switch statement even more powerful.
>>>
>>> - Jacopo
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us
>>> anything; and has at least minimal utility, as I try to demonstrate.
>>>
>>> Apologies for jumping into this thread at an awkward point, but I’ve
>>> only just now subscribed to this list.
>>>
>>> I think the fallthrough keyword is useful in certain circumstances. I’ve
>>> also yet to see an example of where it creates a negative impact, either in
>>> code, optimization, or what have you. Other than “It’s like something in C,
>>> and C is old and busted” I’m unsure of the rationale for removing it. (Feel
>>> free to point me in the right direction.)
>>>
>>> Consider the Planet enum from the documentation. One of the simplest way
>>> to define the number of a planet (i.e. its 1-based index in the ordering of
>>> planets wrt. distance from the sun) is using a switch and fall-through:
>>>
>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>>>
>>> This technique is very extensible — for instance imagine computing the
>>> force induced by the gravity of the other planets on a particular planet.
>>> All that would need to change is the case statements.
>>>
>>> Yes, you could write this by putting the planets into a list and mapping
>>> or folding (or looping) over that, but unless the compiler can “unroll”
>>> that construct, you’re paying for an allocation simply bc of your choice of
>>> control flow. But in fact, you could imagine generalizing this construct
>>> into the implementation of fold for the Planet type — low-overhead folds
>>> for monomorphic types seems like a pretty compelling an natural use case
>>> for fallthrough to me.
>>>
>>> Thanks,
>>> -Colin
>>>
>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> +1 for this idea, but I will prefer the reswitch keyword instead of
>>> overloading continue with a new syntax.
>>>
>>> If this proposal is accepted, it must be coupled with a compiler check
>>> that the reswitch statements don't introduce an infinite "switch" loop.
>>>
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> Very much thinking out loud and not really the implications, I wonder if
>>> we might just use "continue" instead of "reswitch".
>>>
>>> I very much like specifying what case to fall through into, no matter
>>> how we spell it.
>>>
>>> - Steve
>>>
>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <
>>> john.calsbeek+lists at gmail.com> wrote:
>>> `fallthrough` is conceptually similar to `goto` in that both allow
>>> natural expression of concepts that exist at the instruction level but are
>>> otherwise difficult to express with nested control structures.
>>> `fallthrough` is perhaps slightly less objectionable because control flow
>>> remains local, but it has a similar role.
>>>
>>> It is not particularly natural to write `switch` statements with
>>> `fallthrough` in the reverse order that can be seen in Duff’s Device and
>>> similar constructs (case 7 falls through to 6 which falls through to 5,
>>> etc.). It’s just because you know for certain that all the code in case 6
>>> would be duplicated in case 7, so 7 can transfer into 6 without a jump
>>> instruction. Communicating that to the compiler without `fallthrough`
>>> requires deeply nested `if`s.
>>>
>>>
>>> Right.  One idea that I’ve always had for “fallthrough” is that we might
>>> parameterize it in the future; parameterized it would mean “repeat the
>>> switch with this new value”, so that unparameterized fallthrough would mean
>>> “repeat the switch with a notional value that ends up in the next case”.
>>> There’s a very common pattern in switches of deferring to another case that
>>> I’ve always found very awkward to write in C, and while sometimes there’s
>>> no choice but to extract a helper function, there’s a
>>> still-fairly-structural code pattern here that I think we can sensibly
>>> support.
>>>
>>> On the other hand, there’s an argument that this is an inappropriate
>>> extension for “fallthrough” specifically, which is one reason we’ve never
>>> pursued it.
>>>
>>>
>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>
>>> John.
>>>
>>>
>>> John.
>>>
>>>
>>> One defense comes to mind: there is talk of Swift aiming at systems
>>> programming. Is writing a threaded interpreter loop within the potential
>>> scope of Swift? That’s a use case that could make use of both `fallthrough`
>>> and `goto` (computed goto, really).
>>>
>>> switch op {
>>> case LOAD_INDIRECT:
>>>    in0 = memory[in1]
>>>    fallthrough
>>> case LOAD:
>>>    out0 = memory[in0]
>>> //...
>>> }
>>>
>>> I am personally interested in the prospect of a language that can scale
>>> up to high-level concepts and down to “portable assembler,” but I don’t
>>> know if that is the right direction for Swift’s evolution.
>>>
>>> Cheers,
>>> John
>>>
>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:
>>>
>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:
>>> It's not actually Duff's Device. Duff's Device relies on the fact that C
>>> switch statements don't actually introduce a new scope, and so it overlaps
>>> a switch with a do-while loop. This lets it only test the number of bytes
>>> once, to jump into the middle of the loop, and then it switches over to a
>>> while loop that decrements a counter every 8 instructions. Basically, it's
>>> a trick for manual loop unrolling that deals with non-multiple-of-8 counts
>>> efficiently.
>>>
>>>
>>> To be pedantic, C switch statements do introduce a new scope.  What
>>> Duff’s Device exploits is that switch is allowed to jump into (almost)
>>> arbitrary scopes, and cases can appear anywhere recursively inside a
>>> switch.
>>>
>>> But your point that Swift’s switch requires cases to be at the top level
>>> within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>
>>> John.
>>>
>>>
>>> Steve's code is also an example of manual loop unrolling that deals with
>>> non-multiple-of-8 counts, but it has calculate the number of bytes on every
>>> iteration instead of once. It's a good example of one of the uses of
>>> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's
>>> Device in Swift.
>>>
>>> -Kevin Ballard
>>>
>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>
>>> Streza’s source code is an example of Duff’s Device, which is a big
>>> place where switch fallthrough is arguably the cleanest way to do things
>>> and the reason why I’d personally prefer to keep it as part of the
>>> language.
>>>
>>>
>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:
>>>
>>> Oh let it die, let it die. Any time I use fallthrough I find myself
>>> re-factoring to stop using it.
>>>
>>> *True fact*: On all of   gist.github.com, there are only 22 gist
>>> results for "fallthrough language:swift".
>>> Half of those are people just testing out the feature. Most of the
>>> remaining ones are just complex cases:
>>> *case .Enum1, .Enum2:*
>>> expressed as
>>> *case .Enum1: fallthrough*
>>> *case .Enum2:*
>>>
>>> And then there's streza:
>>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty
>>> sure that ponies were harmed in the production of whatever that last bit
>>> is.
>>>
>>>
>>>
>>>
>>>
>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:
>>>
>>> In the spirit of some other proposals that remove C or C++ style
>>> artifacts, what do folks think about the possibility of removing the
>>> "fallthrough" keyword from the language?
>>>
>>> My understanding is this keyword is only used for the archaic seeming
>>> purpose of perpetuating C-style fallthrough from one switch statement to
>>> the subsequent one. The documentation hedges the use of this keyword in
>>> forbidding terms that make it clear its use is not encouraged. The presence
>>> of the keyword, while an improvement over C’s implicit fallthrough, is a
>>> mark of inelegance on an otherwise well-designed, opinionated
>>> implementation of swtich statements.
>>>
>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in
>>> the documentation:
>>>
>>> "The fallthrough keyword does not check the case conditions for the
>>> switch case that it causes execution to fall into. The fallthrough keyword
>>> simply causes code execution to move directly to the statements inside the
>>> next case (or default case) block, as in C’s standard switch statement
>>> behavior."
>>>
>>> To my mind, the caveat explains just what is wrong with fallthrough,
>>> both in C or Swift: coded that is clearly labeled with deliberate
>>> conditions can nonetheless be reached.
>>>
>>> I quipped about this on Twitter, and the most common pushback I got
>>> seemed to be from people who either did not know about Swift’s support for
>>> comma-separated case statements, or harbored an aesthetic preference for
>>> clustering such cases together with fallthrough statements.
>>>
>>> In my opinion, unless somebody can think of a strong defense for
>>> supporting intentional fallthrough in Swift, removing the keyword would be
>>> a move in the direction of minimizing the language’s complexity while also
>>> discouraging poor coding style in switch statements.
>>>
>>> Thoughts?
>>>
>>> Daniel
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>> *_______________________________________________*
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>> Untracked with Trackbuster <https://trackbuster.com/?sig>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/39d591f4/attachment.html>

From tmandry at gmail.com  Sun Dec  6 15:56:03 2015
From: tmandry at gmail.com (Tyler Mandry)
Date: Sun, 6 Dec 2015 15:56:03 -0600
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
Message-ID: <CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com>

I agree with Adrian here – the problem IMO is the fact that you can do `x <
5` *at all* if x is optional.

Allowing programmers to do `x? < 5` still doesn't make clear what the
actual result of the operation will be if x is nil. In fact, I would
actually *expect* the result of the operation to be a Bool?, not a Bool
which is always false if x is nil.

--
Tyler Mandry
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2acb8e0b/attachment.html>

From colin at springsandstruts.com  Sun Dec  6 15:57:40 2015
From: colin at springsandstruts.com (Colin Barrett)
Date: Sun, 6 Dec 2015 16:57:40 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
<CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com>
<ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org>
Message-ID: <EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com>

If you need control flow this complex, why not just use recursion? reswitch is, near as I can tell, a recursive call to an implicitly defined function (closing over the switch).

-Colin

> On Dec 6, 2015, at 4:49 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
>
> The result is .Two, because you are returning from the reswitch and in that case the original x is shadowed by the new execution.
>
> - Jacopo
>
>> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>>
>> One question: what is the result of this code?
>>
>> let x = .One
>>
>> switch x {
>> case .One:
>>    reswitch(.Two)
>> case .Two:
>>    return x
>> }
>>
>> .One or .Two? In other words, is x rebound inside the switch when we reswitch?
>>
>>> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>>> It seems reswitch should be useable even in cases that aren't a simple "goto". Or am I missing something?
>>>
>>> For instance, rewriting the example from earlier:
>>>
>>> switch op {
>>> case let .LOAD_INDIRECT(out, in):
>>>     reswitch(.LOAD(out, memory[in]))
>>> case let .LOAD(out, in):
>>>     setReg(out, in)
>>> // ...
>>> }
>>>
>>> or, a switch that calculates whether some number n is in a Lisp-style list of numbers
>>>
>>> switch lst {
>>> case .Cons(let m, _) where m == n:
>>>      return true
>>> case .Cons(_, let rest):
>>>     reswitch(rest)
>>> case .Empty:
>>>      return false
>>> }
>>>
>>> I like reswitch: in some cases, the compiler could optimize to a fallthrough, and in others, you could actually re-switch. But maybe I'm missing something.
>>>
>>>> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
>>>> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.
>>>>
>>>> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.
>>>>
>>>> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847
>>>> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.
>>>>
>>>> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
>>>>
>>>> - Jacopo
>>>>
>>>>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com> wrote:
>>>>>
>>>>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
>>>>>
>>>>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
>>>>>
>>>>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
>>>>>
>>>>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
>>>>>
>>>>> Thanks,
>>>>> -Colin
>>>>>
>>>>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola < swift-evolution at jacopo.giola.org> wrote:
>>>>>>
>>>>>>  Hi Colin,
>>>>>>
>>>>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>>>>>>
>>>>>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
>>>>>> So something like this:
>>>>>>
>>>>>> switch (enum) {
>>>>>>  case .One:
>>>>>>  // do something
>>>>>>  reswitch .Two
>>>>>>  case .Two:
>>>>>>  // do something else
>>>>>>  default:
>>>>>>  // and so one
>>>>>> }
>>>>>>
>>>>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
>>>>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>>>>>>
>>>>>> switch (enum) {
>>>>>>  case .One:
>>>>>>  // do something
>>>>>>  reswitch .Two
>>>>>>  case .OneAndAHalf
>>>>>>  // maybe this change is not made by you but by a messed up merge
>>>>>>  case .Two:
>>>>>>  // do something else
>>>>>>  default:
>>>>>>  // and so one
>>>>>> }
>>>>>>
>>>>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>>>>>>
>>>>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>>>>>>
>>>>>> switch (enum) {
>>>>>>  case .One:
>>>>>>  // do something
>>>>>>  reswitch .Two
>>>>>>  case .OneAndAHalf
>>>>>>  // so something that you don’t want to do for .One
>>>>>>  reswitch .Two
>>>>>>  case .Two:
>>>>>>  // do something else that you may want to do for .One and .Two
>>>>>>  default:
>>>>>>  // and so one
>>>>>> }
>>>>>>
>>>>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>>>>>>
>>>>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>>>>>>
>>>>>> switch (enum) {
>>>>>>  case .One:
>>>>>>  // do something
>>>>>>  x = 0;
>>>>>>  reswitch .Two
>>>>>>  case .OneAndAHalf
>>>>>>  // so something that you don’t want to do for .One
>>>>>>  reswitch .Two
>>>>>>  case .Two where x > 0:
>>>>>>  // do something else that you may want to do for .One and .Two
>>>>>>  element = array[x]
>>>>>>  default:
>>>>>>  // and so one
>>>>>> }
>>>>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>>>>>>
>>>>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>>>>>>
>>>>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>>>>>>
>>>>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>>>>>>
>>>>>> - Jacopo
>>>>>> Sent from my iPad
>>>>>>
>>>>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution < swift-evolution at swift.org> wrote:
>>>>>>
>>>>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>>>>>>
>>>>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>>>>>>
>>>>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>>>>>>
>>>>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>>>>>>
>>>>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>>>>>>>
>>>>>>> This technique is very extensible ― for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>>>>>>
>>>>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type ― low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>>>>>>
>>>>>>> Thanks,
>>>>>>> -Colin
>>>>>>>
>>>>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution < swift-evolution at swift.org> wrote:
>>>>>>>>
>>>>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>>>>>>
>>>>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>>>>>>
>>>>>>>> Sent from my iPad
>>>>>>>>
>>>>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution < swift-evolution at swift.org> wrote:
>>>>>>>>
>>>>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>>>>>>
>>>>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>>>>>>
>>>>>>>>> - Steve
>>>>>>>>>
>>>>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution < swift-evolution at swift.org> wrote:
>>>>>>>>>
>>>>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution < swift-evolution at swift.org> wrote:
>>>>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek < john.calsbeek+lists at gmail.com> wrote:
>>>>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>>>>>>
>>>>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>>>>>>
>>>>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>>>>>>
>>>>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>>>>>>
>>>>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>>>>>>
>>>>>>>>>> John.
>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>> John.
>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>>>>>>
>>>>>>>>>>>> switch op {
>>>>>>>>>>>> case LOAD_INDIRECT:
>>>>>>>>>>>>    in0 = memory[in1]
>>>>>>>>>>>>    fallthrough
>>>>>>>>>>>> case LOAD:
>>>>>>>>>>>>    out0 = memory[in0]
>>>>>>>>>>>> //...
>>>>>>>>>>>> }
>>>>>>>>>>>>
>>>>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>>>>>>
>>>>>>>>>>>> Cheers,
>>>>>>>>>>>> John
>>>>>>>>>>>>
>>>>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:
>>>>>>>>>>>>>
>>>>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:
>>>>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>>>>>>
>>>>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>>>>>>
>>>>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>>>>>>
>>>>>>>>>>>>> John.
>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> -Kevin Ballard
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> True fact: On all of   gist.github.com, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>>>>>>> expressed as
>>>>>>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> And then there's streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> Daniel
>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>
>>>>>>>>>>>>>  _______________________________________________
>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>
>>>> Untracked with Trackbuster
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4300b382/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 15:58:14 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 22:58:14 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>
<CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com>
Message-ID: <98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org>

Dan, you are using the word “safer” so at least is an improvement :)
but I don’t see it as a goto. goto is used with arbitrary label that move your code flow around without been bound in some limited construct. reswitch is limited in scope inside a switch, can be called only on typed value of the main switch, and will retain the constraint of been called at the end of the case as fallthrought so it will not mess up the case execution but will only try to execute the switch again on another case.

> On 06 Dec 2015, at 22:26, Dan Appel <dan.appel00 at gmail.com> wrote:
>
> For better or worse, I would like to note that `reswitch` is essentially a safer `goto`, so keep in mind all the bad things that can be done with it.
>
> On Sun, Dec 6, 2015 at 1:23 PM Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
> > On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:
> >
> > Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.
>
> I’m curious, how do you propose to do this?
>
> > Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.
>
> In your document you give the example:
>
> > case .Three where x > 0:
>
> Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:
>
> > case .Four(x) where x > 0:
>
> In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.
>
> In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.
>
> -Colin
>
> > I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 <https://gist.github.com/JGiola/f735212789bf2f697847>
> > If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.
> >
> > And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
> >
> > - Jacopo
> >
> >> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com <mailto:colin at springsandstruts.com>> wrote:
> >>
> >> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
> >>
> >> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
> >>
> >> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
> >>
> >> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
> >>
> >> Thanks,
> >> -Colin
> >>
> >>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:
> >>>
> >>>  Hi Colin,
> >>>
> >>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
> >>>
> >>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
> >>> So something like this:
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             reswitch .Two
> >>>     case .Two:
> >>>             // do something else
> >>>     default:
> >>>             // and so one
> >>> }
> >>>
> >>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
> >>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             reswitch .Two
> >>>     case .OneAndAHalf
> >>>             // maybe this change is not made by you but by a messed up merge
> >>>     case .Two:
> >>>             // do something else
> >>>     default:
> >>>             // and so one
> >>> }
> >>>
> >>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
> >>>
> >>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             reswitch .Two
> >>>     case .OneAndAHalf
> >>>             // so something that you don’t want to do for .One
> >>>             reswitch .Two
> >>>     case .Two:
> >>>             // do something else that you may want to do for .One and .Two
> >>>     default:
> >>>             // and so one
> >>> }
> >>>
> >>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
> >>>
> >>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
> >>>
> >>> switch (enum) {
> >>>     case .One:
> >>>             // do something
> >>>             x = 0;
> >>>             reswitch .Two
> >>>     case .OneAndAHalf
> >>>             // so something that you don’t want to do for .One
> >>>             reswitch .Two
> >>>     case .Two where x > 0:
> >>>             // do something else that you may want to do for .One and .Two
> >>>             element = array[x]
> >>>     default:
> >>>             // and so one
> >>> }
> >>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
> >>>
> >>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
> >>>
> >>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
> >>>
> >>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
> >>>
> >>> - Jacopo
> >>> Sent from my iPad
> >>>
> >>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> >>>
> >>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
> >>>>
> >>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
> >>>>
> >>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
> >>>>
> >>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
> >>>>
> >>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>
> >>>>
> >>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
> >>>>
> >>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
> >>>>
> >>>> Thanks,
> >>>> -Colin
> >>>>
> >>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> >>>>>
> >>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
> >>>>>
> >>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
> >>>>>
> >>>>> Sent from my iPad
> >>>>>
> >>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> >>>>>
> >>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
> >>>>>>
> >>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
> >>>>>>
> >>>>>> - Steve
> >>>>>>
> >>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> >>>>>>
> >>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> >>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek%2Blists at gmail.com>> wrote:
> >>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
> >>>>>>>>>
> >>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
> >>>>>>>>
> >>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
> >>>>>>>>
> >>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
> >>>>>>>
> >>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
> >>>>>>>
> >>>>>>> John.
> >>>>>>>
> >>>>>>>>
> >>>>>>>> John.
> >>>>>>>>
> >>>>>>>>>
> >>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
> >>>>>>>>>
> >>>>>>>>> switch op {
> >>>>>>>>> case LOAD_INDIRECT:
> >>>>>>>>>    in0 = memory[in1]
> >>>>>>>>>    fallthrough
> >>>>>>>>> case LOAD:
> >>>>>>>>>    out0 = memory[in0]
> >>>>>>>>> //...
> >>>>>>>>> }
> >>>>>>>>>
> >>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
> >>>>>>>>>
> >>>>>>>>> Cheers,
> >>>>>>>>> John
> >>>>>>>>>
> >>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:
> >>>>>>>>>>
> >>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:
> >>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
> >>>>>>>>>>
> >>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
> >>>>>>>>>>
> >>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
> >>>>>>>>>>
> >>>>>>>>>> John.
> >>>>>>>>>>
> >>>>>>>>>>>
> >>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
> >>>>>>>>>>>
> >>>>>>>>>>> -Kevin Ballard
> >>>>>>>>>>>
> >>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
> >>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
> >>>>>>>>>>>>
> >>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for "fallthrough language:swift".
> >>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
> >>>>>>>>>>>>> case .Enum1, .Enum2:
> >>>>>>>>>>>>> expressed as
> >>>>>>>>>>>>> case .Enum1: fallthrough
> >>>>>>>>>>>>> case .Enum2:
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> Thoughts?
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> Daniel
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>>>>>>
> >>>>>>>>>>>>
> >>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>>>>>
> >>>>>>>>>>>
> >>>>>>>>>>> _______________________________________________
> >>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>>>>
> >>>>>>>>>>  _______________________________________________
> >>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>>>
> >>>>>>>>>
> >>>>>>>>> _______________________________________________
> >>>>>>>>> swift-evolution mailing list
> >>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>>
> >>>>>>>>
> >>>>>>>> _______________________________________________
> >>>>>>>> swift-evolution mailing list
> >>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>>
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> swift-evolution mailing list
> >>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>>
> >>>>>> _______________________________________________
> >>>>>> swift-evolution mailing list
> >>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>>
> >>>>> _______________________________________________
> >>>>> swift-evolution mailing list
> >>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> swift-evolution mailing list
> >>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> >>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> >>
> >
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
> --
> Dan Appel

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8512a8fe/attachment.html>

From thorsten at portableinnovations.de  Sun Dec  6 16:03:21 2015
From: thorsten at portableinnovations.de (thorsten at portableinnovations.de)
Date: Sun, 6 Dec 2015 23:03:21 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
Message-ID: <E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de>

Initially I thought that reswitch (apart from the name :-) looked nice the example of Alex  seems to mix two parts of a recursive algorithm into one statement: pattern matching the head of a list and recursing.

Then I realized that instead of introducing reswitch you can simply extract the switch into a method and call that recursively. This would have the added benefit that instead of "reswitch" the (hopefully) expressive name of the function would be used, making the intent clearer:

func find(n: T, in list: List<T>) -> Bool {
switch list {
case .Cons(let m, _) where m == n:
return true
case .Cons(_, let rest):
return find(n, in: rest)
case .Empty:
return false
}
}

-Thorsten

> Am 06.12.2015 um 22:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:
>
> switch lst {
> case .Cons(let m, _) where m == n:
>      return true
> case .Cons(_, let rest):
>     reswitch(rest)
> case .Empty:
>      return false
> }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/28e4cb62/attachment.html>

From ilya.nikokoshev at gmail.com  Sun Dec  6 16:05:18 2015
From: ilya.nikokoshev at gmail.com (ilya)
Date: Sun, 06 Dec 2015 22:05:18 +0000
Subject: [swift-evolution] Overloading assignment operator
In-Reply-To: <2164F4EC-E460-4BD5-8ABB-26EAFBE8D439@portablesoftware.com>
References: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
<D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com>
<93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com>
<CAPh90aH=19TQOH5hxtnRwGg0igMgiazaGQeNQ0Hhqor1LtZc7w@mail.gmail.com>
<2164F4EC-E460-4BD5-8ABB-26EAFBE8D439@portablesoftware.com>
Message-ID: <CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com>

Yes, I meant for the email to go to the list.

> Nope, that doesn't work because of my comment above.  That's the change
to Swift I am hoping will be adopted for 3.0.

Did you try this? The idea is to write a function for multiplying a Number
and an Int, so the rhs will create a Number which will then be set to the
variable. It should work actually.

On Mon, Dec 7, 2015 at 00:47 Don Wills <don.wills at portablesoftware.com>
wrote:

> Hello Ilya,
>
> On Dec 6, 2015, at 1:09 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>
>
> On Sun, Dec 6, 2015 at 5:26 PM, Don Wills via swift-evolution <
> swift-evolution at swift.org> wrote:
>
>> Silvan,
>>
>> Yes, I understand the concern you raise.  I too have held that general
>> opinion of overloading operators in other languages for many years.  That
>> said, overloading arithmetic and other operators causes the same
>> opportunity for abuse.
>>
> For example, overloading + for integers to do something different (like
>> rounding instead of truncation) would make maintenance of existing programs
>> into a giant guessing game.
>>
>> That said, once the cat is out of the bag to overload operators, I don't
>> see how adding support for = makes things any worse.
>>
>>
> This is not really the same. You only use + explicitely, but the compiler
> must insert some assigments automatically, for example by copying when the
> function closes over some variables. It must know exactly what the
> semantics in this case is to be able to compile correct program.
>
>
> My example wasn't the best.  IMO, there is almost no conceptual difference
> between "amount = 5.5;" and "amount += 5.5;".  The second example works
> (that is += can be overloaded) where the first example is not allowed
> because when I try to define the "func = (...) {...}" overload
> implementation, the compiler squawks.
>
>
> FYI, the reason for my suggestion is to add support for fixed decimal
>> arithmetic just like that available in COBOL.  Yeh I can hear the groans
>> now.
>>
>
> I'm with you.
>
>
>> However, for business applications, fixed decimal arithmetic is a basic
>> feature that has been tossed away in new languages by language designers
>> who don't actually labor in the trenches.
>>
>
> I didn't look into the new Foundation, but doesn't it contain
> NSDecimalNumber?
>
>>
>>
> I've built a simple class to do just that - here is some sample code that
>> uses my Number class that gives an idea of what the code does:
>>
>> var amount = Number(left: 6, right: 2);
>> var result = Number(left: 9, right: 2);
>> amount <- 3.9;
>> amount += 1;
>> result <- amount * 4;
>> print(result)
>>
>>
> I'm not sure why you feel the need to overload = in this example. If
> Number * Int -> Number is defined, you can just use
>
> result = amount * 4
>
>
> Nope, that doesn't work because of my comment above.  That's the change to
> Swift I am hoping will be adopted for 3.0.
>
> Did you mean to not post your email to me only?  I haven't figured out the
> protocol for this email list yet.
>
> Don Wills
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/723002b6/attachment.html>

From thorsten at portableinnovations.de  Sun Dec  6 16:08:56 2015
From: thorsten at portableinnovations.de (thorsten at portableinnovations.de)
Date: Sun, 6 Dec 2015 23:08:56 +0100
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated with optional types
In-Reply-To: <CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com>
References: <CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com>
Message-ID: <24220A0F-DDDB-4CC7-ADE0-18ED197902E8@portableinnovations.de>

+1. I also think that < should not be defined for Optional.

-Thorsten

> Am 06.12.2015 um 22:56 schrieb Tyler Mandry via swift-evolution <swift-evolution at swift.org>:
>
> I agree with Adrian here – the problem IMO is the fact that you can do `x < 5` at all if x is optional.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/65f90155/attachment.html>

From possen at gmail.com  Sun Dec  6 16:11:35 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 14:11:35 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
Message-ID: <6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com>

so the rule would have to be that the “switch" or “if" must return a value of compatible type. Not sure I love all the braces in the “if" case but it does follow the existing language rules with the exception that it must be have an else.

let thisColor = if condition { .Red }   // illegal for expressions but not statements

Can still do this for statements:
if condition {
x = 40
}

likewise:
let thisColor = if condition { .Red } else { 21 } // illegal unless thisColor is Any

unless:
let thisColor : Any = if condition { .Red } else { 21 } // illegal unless thisColor is Any

It would be nice to omit braces in this expression case but not for statements:
let thisColor = if condition .Red else .Blue

in statements braces would be required:

if condition {
x = 32
} else {
y = 44
}

> >     }
> On Dec 6, 2015, at 1:52 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:
>
> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.
>
> Would you allow the same thing with if?
>
> let thisColor = if condition { .Red } else { .Blue }
>
> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com <mailto:salutis at me.com>> wrote:
> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
> >
> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.
>
> +1
>
> >
> > Therefore the switch-expression should simply look like follows:
> >
> > let thisColor = switch thatColor {
> >         case .Red: .Green // must be an expression
> >         default: .Yellow      // must be an expression
> >     }
> >
> > No returns needed in the case clauses.
>
> This actually looks great. One simple rule and zero new keywords.
>
> Readable and simple to learn.
>
> Fantastic!
>
> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).
> >
> > -Thorsten
> > _______________________________________________
> > swift-evolution mailing list
> > swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> > https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e03515fe/attachment.html>

From don.wills at portablesoftware.com  Sun Dec  6 16:11:42 2015
From: don.wills at portablesoftware.com (Don Wills)
Date: Sun, 6 Dec 2015 15:11:42 -0700
Subject: [swift-evolution] Overloading assignment operator
In-Reply-To: <CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com>
References: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
<D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com>
<93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com>
<CAPh90aH=19TQOH5hxtnRwGg0igMgiazaGQeNQ0Hhqor1LtZc7w@mail.gmail.com>
<2164F4EC-E460-4BD5-8ABB-26EAFBE8D439@portablesoftware.com>
<CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com>
Message-ID: <26787AE6-26C4-47D7-8529-043233D4A383@portablesoftware.com>

Hello Ilya,

> On Dec 6, 2015, at 3:05 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>
> Yes, I meant for the email to go to the list.
>
> > Nope, that doesn't work because of my comment above.  That's the change to Swift I am hoping will be adopted for 3.0.
>
> Did you try this? The idea is to write a function for multiplying a Number and an Int, so the rhs will create a Number which will then be set to the variable. It should work actually.

Yes, I've written a class named Number with many "func <operator> ( ... ) { ... }" implementations for the various permutations of Number, Double and operators.  They all work except for when <operator> is the equal sign.

Don

> On Mon, Dec 7, 2015 at 00:47 Don Wills <don.wills at portablesoftware.com <mailto:don.wills at portablesoftware.com>> wrote:
> Hello Ilya,
>
> On Dec 6, 2015, at 1:09 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>
>> On Sun, Dec 6, 2015 at 5:26 PM, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>> Silvan,
>>
>> Yes, I understand the concern you raise.  I too have held that general opinion of overloading operators in other languages for many years.  That said, overloading arithmetic and other operators causes the same opportunity for abuse.
>> For example, overloading + for integers to do something different (like rounding instead of truncation) would make maintenance of existing programs into a giant guessing game.
>>
>> That said, once the cat is out of the bag to overload operators, I don't see how adding support for = makes things any worse.
>>
>>
>> This is not really the same. You only use + explicitely, but the compiler must insert some assigments automatically, for example by copying when the function closes over some variables. It must know exactly what the semantics in this case is to be able to compile correct program.
>
> My example wasn't the best.  IMO, there is almost no conceptual difference between "amount = 5.5;" and "amount += 5.5;".  The second example works (that is += can be overloaded) where the first example is not allowed because when I try to define the "func = (...) {...}" overload implementation, the compiler squawks.
>
>
>> FYI, the reason for my suggestion is to add support for fixed decimal arithmetic just like that available in COBOL.  Yeh I can hear the groans now.
>>
>> I'm with you.
>>
>> However, for business applications, fixed decimal arithmetic is a basic feature that has been tossed away in new languages by language designers who don't actually labor in the trenches.
>>
>> I didn't look into the new Foundation, but doesn't it contain NSDecimalNumber?
>>
>> I've built a simple class to do just that - here is some sample code that uses my Number class that gives an idea of what the code does:
>>
>> var amount = Number(left: 6, right: 2);
>> var result = Number(left: 9, right: 2);
>> amount <- 3.9;
>> amount += 1;
>> result <- amount * 4;
>> print(result)
>>
>>
>> I'm not sure why you feel the need to overload = in this example. If Number * Int -> Number is defined, you can just use
>>
>> result = amount * 4
>
> Nope, that doesn't work because of my comment above.  That's the change to Swift I am hoping will be adopted for 3.0.
>
> Did you mean to not post your email to me only?  I haven't figured out the protocol for this email list yet.
>
> Don Wills
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/55d7ddd7/attachment-0001.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 16:12:30 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 17:12:30 -0500
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com>
<CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com>
<ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org>
<EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com>
Message-ID: <CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com>

Yes, thanks, Colin -- semantically, I think it's exactly equivalent to a
recursive call to an implicitly defined function closing over the switch.
In practice, the compiler may be able to translate it to a true fallthrough
in many cases.

In any case, I am not arguing for or against reswitch -- I kind of like it,
but also would be fine with keeping fallthrough as is. I just wanted to
better understand what the proposed semantics of reswitch actually were
(hence the var x question, which I guess would be similar to having your
recursive function declare a mutable parameter).

On Sun, Dec 6, 2015 at 4:57 PM, Colin Barrett <colin at springsandstruts.com>
wrote:

> If you need control flow this complex, why not just use recursion?
> reswitch is, near as I can tell, a recursive call to an implicitly defined
> function (closing over the switch).
>
> -Colin
>
> On Dec 6, 2015, at 4:49 PM, Jacopo Andrea Giola <
> swift-evolution at jacopo.giola.org> wrote:
>
> The result is .Two, because you are returning from the reswitch and in
> that case the original x is shadowed by the new execution.
>
> - Jacopo
>
> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> One question: what is the result of this code?
>
> let x = .One
>
> switch x {
> case .One:
>    reswitch(.Two)
> case .Two:
>    return x
> }
>
> .One or .Two? In other words, is x rebound inside the switch when we
> reswitch?
>
> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com>
> wrote:
>
>> It seems reswitch *should* be useable even in cases that aren't a simple
>> "goto". Or am I missing something?
>>
>> For instance, rewriting the example from earlier:
>>
>> switch op {
>> case let .LOAD_INDIRECT(out, in):
>>     reswitch(.LOAD(out, memory[in]))
>> case let .LOAD(out, in):
>>     setReg(out, in)
>> // ...
>> }
>>
>> or, a switch that calculates whether some number n is in a Lisp-style
>> list of numbers
>>
>> switch lst {
>> case .Cons(let m, _) where m == n:
>>      return true
>> case .Cons(_, let rest):
>>     reswitch(rest)
>> case .Empty:
>>      return false
>> }
>>
>> I like reswitch: in some cases, the compiler could optimize to a
>> fallthrough, and in others, you could actually re-switch. But maybe I'm
>> missing something.
>>
>> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>>> Yes, I’m aware that at this time the reswitch can be abused and maybe
>>> can be better refined to disallow such cases.
>>>
>>> Checking the case statement is not a problem by itself, but can be a
>>> problem if is coupled with a where clause that is not true when you
>>> fallthrought.
>>>
>>> I’ve written a really bad draft here
>>> https://gist.github.com/JGiola/f735212789bf2f697847
>>> If anyone wants to jump in and elaborate further is welcome. I will try
>>> to stay on par with this thread but I’m really bad at writing so every help
>>> is welcome.
>>>
>>> And if I remember correctly Daniel Jakult was the first one to made this
>>> proposal so if he wants to take on and then made the official proposal has
>>> every right to do so and I will be very glad if my gist can be a first
>>> reference :)
>>>
>>> - Jacopo
>>>
>>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>
>>> wrote:
>>>
>>> Apologies, Jacopo, for missing the updated proposal, and thank you for
>>> your patience in summarizing it again.
>>>
>>> I’ve only glanced through it but my concern here is that it introduces a
>>> whole class of new and creative “foot-guns" :) In particular, it allows
>>> this construction to loop arbitrarily and creatively, particularly in the
>>> case of associated values.
>>>
>>> I’m not sure why not checking the case statement is considered a problem
>>> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a
>>> case that introduces binders (what would they be bound to?), and that this
>>> is statically checked (both of which seem reasonable assumptions to me,
>>> although if I’m wrong feel free to correct me), isn’t it the entire point
>>> of the fallthrough keyword that it skips checking the case statement? I can
>>> understand how that might be somewhat confusing (and perhaps it should be
>>> documented less prominently) but I’m not sure how it’s a *problem*,
>>> exactly...
>>>
>>> I think I’m still on the side of keeping fallthrough. What’s the
>>> downside of doing nothing? For instance in the case of ++ and -- those
>>> features complicate the design of a numerics library.
>>>
>>> Thanks,
>>> -Colin
>>>
>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <
>>> swift-evolution at jacopo.giola.org> wrote:
>>>
>>>  Hi Colin,
>>>
>>> the initial proposal was indeed to remove entirely the `fallthrough`
>>> keyword but many people expressed your similar concern and from that point
>>> the discussion was steered through an "enhancement" and better refinement
>>> of the keyword.
>>>
>>> The new idea is to substitute the old keyword with "reswitch" passing
>>> the desired new value on which the switch is applied.
>>> So something like this:
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> reswitch .Two
>>> case .Two:
>>> // do something else
>>> default:
>>> // and so one
>>> }
>>>
>>> This new behaviour, IMO, is better suited for Swift because is more
>>> declarative of the developer intent and doesn't carry over unintentional
>>> misbehaviour.
>>> Is more declarative because you are forced to state in which case you
>>> want to go, and even if the order of the switch’ cases will change in the
>>> future, you don't fall in the wrong case by mistake.
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> reswitch .Two
>>> case .OneAndAHalf
>>> // maybe this change is not made by you but by a messed up merge
>>> case .Two:
>>> // do something else
>>> default:
>>> // and so one
>>> }
>>>
>>> In this case if you are using the fallthrough keyboard your code is now
>>> broken by accident, and depending on what are you trying to do inside the
>>> cases you can have a hidden bug that your tests are not seeing right away.
>>>
>>> Another advantage is that in this way you can made more
>>> cases fallthrough in the same one even if they are not one over each other
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> reswitch .Two
>>> case .OneAndAHalf
>>> // so something that you don’t want to do for .One
>>> reswitch .Two
>>> case .Two:
>>> // do something else that you may want to do for .One and .Two
>>> default:
>>> // and so one
>>> }
>>>
>>> I must say that this is a side effect that can be used to messed up the
>>> code flow in a way that is not intended, but is a new behaviour that gives
>>> more power to the switch statement.
>>>
>>> The reswitch keyword in addition is not a mere fallthrough on the new
>>> case without doing the optional checking attached to it, but is intended to
>>> be a new call and all the check are executed.
>>>
>>> switch (enum) {
>>> case .One:
>>> // do something
>>> x = 0;
>>> reswitch .Two
>>> case .OneAndAHalf
>>> // so something that you don’t want to do for .One
>>> reswitch .Two
>>> case .Two where x > 0:
>>> // do something else that you may want to do for .One and .Two
>>> element = array[x]
>>> default:
>>> // and so one
>>> }
>>> (I’m going by memory and by writing this snippets in the mail app
>>> directly, so the code must be incorrect in the syntax and for this I’m
>>> sorry).
>>>
>>> In this case if enum is .One the only case that is executed is case .One
>>> and the code doesn’t fallthrough in the .Two case because we are made the
>>> where invalid by changing the x to a value less than 1.
>>>
>>> Now I don’t remember who was the first one who mede this proposal, and I
>>> don’t know if he is working on a first draft to lay down the things better,
>>> but for me this can be a nice improvement and a neat break with the
>>> C-switch behaviour that Swift has trying to change from the very first beta
>>> disallowing the implicit fallthrough.
>>>
>>> I can be completely wrong but I see the `fallthrough`keyword as a
>>> “temporary” implementation for ease the transition from Obj-C to Swift and
>>> is time to improve it and made the switch statement even more powerful.
>>>
>>> - Jacopo
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us
>>> anything; and has at least minimal utility, as I try to demonstrate.
>>>
>>> Apologies for jumping into this thread at an awkward point, but I’ve
>>> only just now subscribed to this list.
>>>
>>> I think the fallthrough keyword is useful in certain circumstances. I’ve
>>> also yet to see an example of where it creates a negative impact, either in
>>> code, optimization, or what have you. Other than “It’s like something in C,
>>> and C is old and busted” I’m unsure of the rationale for removing it. (Feel
>>> free to point me in the right direction.)
>>>
>>> Consider the Planet enum from the documentation. One of the simplest way
>>> to define the number of a planet (i.e. its 1-based index in the ordering of
>>> planets wrt. distance from the sun) is using a switch and fall-through:
>>>
>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>>>
>>> This technique is very extensible — for instance imagine computing the
>>> force induced by the gravity of the other planets on a particular planet.
>>> All that would need to change is the case statements.
>>>
>>> Yes, you could write this by putting the planets into a list and mapping
>>> or folding (or looping) over that, but unless the compiler can “unroll”
>>> that construct, you’re paying for an allocation simply bc of your choice of
>>> control flow. But in fact, you could imagine generalizing this construct
>>> into the implementation of fold for the Planet type — low-overhead folds
>>> for monomorphic types seems like a pretty compelling an natural use case
>>> for fallthrough to me.
>>>
>>> Thanks,
>>> -Colin
>>>
>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> +1 for this idea, but I will prefer the reswitch keyword instead of
>>> overloading continue with a new syntax.
>>>
>>> If this proposal is accepted, it must be coupled with a compiler check
>>> that the reswitch statements don't introduce an infinite "switch" loop.
>>>
>>> Sent from my iPad
>>>
>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> Very much thinking out loud and not really the implications, I wonder if
>>> we might just use "continue" instead of "reswitch".
>>>
>>> I very much like specifying what case to fall through into, no matter
>>> how we spell it.
>>>
>>> - Steve
>>>
>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <
>>> swift-evolution at swift.org> wrote:
>>>
>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <
>>> john.calsbeek+lists at gmail.com> wrote:
>>> `fallthrough` is conceptually similar to `goto` in that both allow
>>> natural expression of concepts that exist at the instruction level but are
>>> otherwise difficult to express with nested control structures.
>>> `fallthrough` is perhaps slightly less objectionable because control flow
>>> remains local, but it has a similar role.
>>>
>>> It is not particularly natural to write `switch` statements with
>>> `fallthrough` in the reverse order that can be seen in Duff’s Device and
>>> similar constructs (case 7 falls through to 6 which falls through to 5,
>>> etc.). It’s just because you know for certain that all the code in case 6
>>> would be duplicated in case 7, so 7 can transfer into 6 without a jump
>>> instruction. Communicating that to the compiler without `fallthrough`
>>> requires deeply nested `if`s.
>>>
>>>
>>> Right.  One idea that I’ve always had for “fallthrough” is that we might
>>> parameterize it in the future; parameterized it would mean “repeat the
>>> switch with this new value”, so that unparameterized fallthrough would mean
>>> “repeat the switch with a notional value that ends up in the next case”.
>>> There’s a very common pattern in switches of deferring to another case that
>>> I’ve always found very awkward to write in C, and while sometimes there’s
>>> no choice but to extract a helper function, there’s a
>>> still-fairly-structural code pattern here that I think we can sensibly
>>> support.
>>>
>>> On the other hand, there’s an argument that this is an inappropriate
>>> extension for “fallthrough” specifically, which is one reason we’ve never
>>> pursued it.
>>>
>>>
>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>
>>> John.
>>>
>>>
>>> John.
>>>
>>>
>>> One defense comes to mind: there is talk of Swift aiming at systems
>>> programming. Is writing a threaded interpreter loop within the potential
>>> scope of Swift? That’s a use case that could make use of both `fallthrough`
>>> and `goto` (computed goto, really).
>>>
>>> switch op {
>>> case LOAD_INDIRECT:
>>>    in0 = memory[in1]
>>>    fallthrough
>>> case LOAD:
>>>    out0 = memory[in0]
>>> //...
>>> }
>>>
>>> I am personally interested in the prospect of a language that can scale
>>> up to high-level concepts and down to “portable assembler,” but I don’t
>>> know if that is the right direction for Swift’s evolution.
>>>
>>> Cheers,
>>> John
>>>
>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:
>>>
>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:
>>> It's not actually Duff's Device. Duff's Device relies on the fact that C
>>> switch statements don't actually introduce a new scope, and so it overlaps
>>> a switch with a do-while loop. This lets it only test the number of bytes
>>> once, to jump into the middle of the loop, and then it switches over to a
>>> while loop that decrements a counter every 8 instructions. Basically, it's
>>> a trick for manual loop unrolling that deals with non-multiple-of-8 counts
>>> efficiently.
>>>
>>>
>>> To be pedantic, C switch statements do introduce a new scope.  What
>>> Duff’s Device exploits is that switch is allowed to jump into (almost)
>>> arbitrary scopes, and cases can appear anywhere recursively inside a
>>> switch.
>>>
>>> But your point that Swift’s switch requires cases to be at the top level
>>> within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>
>>> John.
>>>
>>>
>>> Steve's code is also an example of manual loop unrolling that deals with
>>> non-multiple-of-8 counts, but it has calculate the number of bytes on every
>>> iteration instead of once. It's a good example of one of the uses of
>>> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's
>>> Device in Swift.
>>>
>>> -Kevin Ballard
>>>
>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>
>>> Streza’s source code is an example of Duff’s Device, which is a big
>>> place where switch fallthrough is arguably the cleanest way to do things
>>> and the reason why I’d personally prefer to keep it as part of the
>>> language.
>>>
>>>
>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:
>>>
>>> Oh let it die, let it die. Any time I use fallthrough I find myself
>>> re-factoring to stop using it.
>>>
>>> *True fact*: On all of   gist.github.com, there are only 22 gist
>>> results for "fallthrough language:swift".
>>> Half of those are people just testing out the feature. Most of the
>>> remaining ones are just complex cases:
>>> *case .Enum1, .Enum2:*
>>> expressed as
>>> *case .Enum1: fallthrough*
>>> *case .Enum2:*
>>>
>>> And then there's streza:
>>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty
>>> sure that ponies were harmed in the production of whatever that last bit
>>> is.
>>>
>>>
>>>
>>>
>>>
>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:
>>>
>>> In the spirit of some other proposals that remove C or C++ style
>>> artifacts, what do folks think about the possibility of removing the
>>> "fallthrough" keyword from the language?
>>>
>>> My understanding is this keyword is only used for the archaic seeming
>>> purpose of perpetuating C-style fallthrough from one switch statement to
>>> the subsequent one. The documentation hedges the use of this keyword in
>>> forbidding terms that make it clear its use is not encouraged. The presence
>>> of the keyword, while an improvement over C’s implicit fallthrough, is a
>>> mark of inelegance on an otherwise well-designed, opinionated
>>> implementation of swtich statements.
>>>
>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in
>>> the documentation:
>>>
>>> "The fallthrough keyword does not check the case conditions for the
>>> switch case that it causes execution to fall into. The fallthrough keyword
>>> simply causes code execution to move directly to the statements inside the
>>> next case (or default case) block, as in C’s standard switch statement
>>> behavior."
>>>
>>> To my mind, the caveat explains just what is wrong with fallthrough,
>>> both in C or Swift: coded that is clearly labeled with deliberate
>>> conditions can nonetheless be reached.
>>>
>>> I quipped about this on Twitter, and the most common pushback I got
>>> seemed to be from people who either did not know about Swift’s support for
>>> comma-separated case statements, or harbored an aesthetic preference for
>>> clustering such cases together with fallthrough statements.
>>>
>>> In my opinion, unless somebody can think of a strong defense for
>>> supporting intentional fallthrough in Swift, removing the keyword would be
>>> a move in the direction of minimizing the language’s complexity while also
>>> discouraging poor coding style in switch statements.
>>>
>>> Thoughts?
>>>
>>> Daniel
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>> *_______________________________________________*
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>>
>>> Untracked with Trackbuster <https://trackbuster.com/?sig>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/9d92b0c2/attachment.html>

From thorsten at portableinnovations.de  Sun Dec  6 16:12:43 2015
From: thorsten at portableinnovations.de (thorsten at portableinnovations.de)
Date: Sun, 6 Dec 2015 23:12:43 +0100
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4C F3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
Message-ID: <B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de>

Absolutely. Just the same rule: parts that were statements must be expressions. The else clause becomes mandatory.

-Thorsten

> Am 06.12.2015 um 22:52 schrieb Alex Lew <alexl.mail+swift at gmail.com>:
>
> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.
>
> Would you allow the same thing with if?
>
> let thisColor = if condition { .Red } else { .Blue }
>
>> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:
>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> >
>> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.
>>
>> +1
>>
>> >
>> > Therefore the switch-expression should simply look like follows:
>> >
>> > let thisColor = switch thatColor {
>> >         case .Red: .Green // must be an expression
>> >         default: .Yellow      // must be an expression
>> >     }
>> >
>> > No returns needed in the case clauses.
>>
>> This actually looks great. One simple rule and zero new keywords.
>>
>> Readable and simple to learn.
>>
>> Fantastic!
>>
>> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).
>> >
>> > -Thorsten
>> > _______________________________________________
>> > swift-evolution mailing list
>> > swift-evolution at swift.org
>> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/f4998b89/attachment.html>

From swift-evolution at jacopo.giola.org  Sun Dec  6 16:09:41 2015
From: swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)
Date: Sun, 6 Dec 2015 23:09:41 +0100
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>
Message-ID: <D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org>


> On 06 Dec 2015, at 22:23, Colin Barrett <colin at springsandstruts.com> wrote:
>
>>
>> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
>>
>> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.
>
> I’m curious, how do you propose to do this?

I really don’t know right now, I hope we can find a way.

>
>> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.
>
> In your document you give the example:
>
>> case .Three where x > 0:
>
> Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:
>
>> case .Four(x) where x > 0:
>
> In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.

Yes, maybe my example is not the most correct one, I’ve tried to come up with something obvious and easy to read/write, but the problem will remain for falltrhought as for the Swift iBook:

NOTE
The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behaviour.

For me this behaviour is not something that marry together with the where clause that we can add to the switch's cases.

>
> In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.
>
> -Colin

Well technically I wasn’t the original proposal, I’ve only appreciate the direction it took and now I’m here to try to spark more discussion to see if is a valid direction and if we can improve it :)

>
>> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847
>> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.
>>
>> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
>>
>> - Jacopo
>>
>>> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:
>>>
>>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
>>>
>>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
>>>
>>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
>>>
>>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
>>>
>>> Thanks,
>>> -Colin
>>>
>>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
>>>>
>>>> Hi Colin,
>>>>
>>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
>>>>
>>>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
>>>> So something like this:
>>>>
>>>> switch (enum) {
>>>> 	case .One:
>>>> 		// do something
>>>> 		reswitch .Two
>>>> 	case .Two:
>>>> 		// do something else
>>>> 	default:
>>>> 		// and so one
>>>> }
>>>>
>>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
>>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
>>>>
>>>> switch (enum) {
>>>> 	case .One:
>>>> 		// do something
>>>> 		reswitch .Two
>>>> 	case .OneAndAHalf
>>>> 		// maybe this change is not made by you but by a messed up merge
>>>> 	case .Two:
>>>> 		// do something else
>>>> 	default:
>>>> 		// and so one
>>>> }
>>>>
>>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
>>>>
>>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
>>>>
>>>> switch (enum) {
>>>> 	case .One:
>>>> 		// do something
>>>> 		reswitch .Two
>>>> 	case .OneAndAHalf
>>>> 		// so something that you don’t want to do for .One
>>>> 		reswitch .Two
>>>> 	case .Two:
>>>> 		// do something else that you may want to do for .One and .Two
>>>> 	default:
>>>> 		// and so one
>>>> }
>>>>
>>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
>>>>
>>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
>>>>
>>>> switch (enum) {
>>>> 	case .One:
>>>> 		// do something
>>>> 		x = 0;
>>>> 		reswitch .Two
>>>> 	case .OneAndAHalf
>>>> 		// so something that you don’t want to do for .One
>>>> 		reswitch .Two
>>>> 	case .Two where x > 0:
>>>> 		// do something else that you may want to do for .One and .Two
>>>> 		element = array[x]
>>>> 	default:
>>>> 		// and so one
>>>> }
>>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
>>>>
>>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
>>>>
>>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
>>>>
>>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
>>>>
>>>> - Jacopo
>>>> Sent from my iPad
>>>>
>>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
>>>>>
>>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
>>>>>
>>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
>>>>>
>>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
>>>>>
>>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
>>>>>
>>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
>>>>>
>>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
>>>>>
>>>>> Thanks,
>>>>> -Colin
>>>>>
>>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>
>>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
>>>>>>
>>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
>>>>>>
>>>>>> Sent from my iPad
>>>>>>
>>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>
>>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
>>>>>>>
>>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
>>>>>>>
>>>>>>> - Steve
>>>>>>>
>>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>>
>>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:
>>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
>>>>>>>>>>
>>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
>>>>>>>>>
>>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
>>>>>>>>>
>>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
>>>>>>>>
>>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
>>>>>>>>
>>>>>>>> John.
>>>>>>>>
>>>>>>>>>
>>>>>>>>> John.
>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
>>>>>>>>>>
>>>>>>>>>> switch op {
>>>>>>>>>> case LOAD_INDIRECT:
>>>>>>>>>>   in0 = memory[in1]
>>>>>>>>>>   fallthrough
>>>>>>>>>> case LOAD:
>>>>>>>>>>   out0 = memory[in0]
>>>>>>>>>> //...
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
>>>>>>>>>>
>>>>>>>>>> Cheers,
>>>>>>>>>> John
>>>>>>>>>>
>>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:
>>>>>>>>>>>
>>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
>>>>>>>>>>>
>>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
>>>>>>>>>>>
>>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
>>>>>>>>>>>
>>>>>>>>>>> John.
>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
>>>>>>>>>>>>
>>>>>>>>>>>> -Kevin Ballard
>>>>>>>>>>>>
>>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
>>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
>>>>>>>>>>>>>
>>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for "fallthrough language:swift".
>>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
>>>>>>>>>>>>>> case .Enum1, .Enum2:
>>>>>>>>>>>>>> expressed as
>>>>>>>>>>>>>> case .Enum1: fallthrough
>>>>>>>>>>>>>> case .Enum2:
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> Thoughts?
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> Daniel
>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>>
>>>>>>>>>>>>>>
>>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>>
>>>>>>>>>>>>>
>>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>>
>>>>>>>>>>>>
>>>>>>>>>>>> _______________________________________________
>>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>>
>>>>>>>>>>> _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution


From alexl.mail+swift at gmail.com  Sun Dec  6 16:14:54 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 17:14:54 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
<B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de>
Message-ID: <CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com>

👍

On Sun, Dec 6, 2015 at 5:12 PM, thorsten at portableinnovations.de <
thorsten at portableinnovations.de> wrote:

> Absolutely. Just the same rule: parts that were statements must be
> expressions. The else clause becomes mandatory.
>
> -Thorsten
>
> Am 06.12.2015 um 22:52 schrieb Alex Lew <alexl.mail+swift at gmail.com>:
>
> I agree that it's simplest to just reuse switch keyword, and keep braces.
> +1.
>
> Would you allow the same thing with if?
>
> let thisColor = if condition { .Red } else { .Blue }
>
> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:
>
>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> >
>> > I would prefer the expression to match the statement. The only
>> difference would be that all parts that were statements now have to be
>> expressions.
>>
>> +1
>>
>> >
>> > Therefore the switch-expression should simply look like follows:
>> >
>> > let thisColor = switch thatColor {
>> >         case .Red: .Green // must be an expression
>> >         default: .Yellow      // must be an expression
>> >     }
>> >
>> > No returns needed in the case clauses.
>>
>> This actually looks great. One simple rule and zero new keywords.
>>
>> Readable and simple to learn.
>>
>> Fantastic!
>>
>> > Formatting this as a one-liner would just require adding semicolons
>> (though I wouldn't recommend this).
>> >
>> > -Thorsten
>> > _______________________________________________
>> > swift-evolution mailing list
>> > swift-evolution at swift.org
>> > https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3fb93a4b/attachment.html>

From matthew at anandabits.com  Sun Dec  6 16:33:29 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 16:33:29 -0600
Subject: [swift-evolution] Proposal: Auto-convert for numbers when safe
In-Reply-To: <84057F09-3421-49B9-94C0-5ECF2AFE2A9D@apple.com>
References: <7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com>
<B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com>
<81BD0070-9DE9-49C5-9E0D-01EC1E496461@anandabits.com>
<84057F09-3421-49B9-94C0-5ECF2AFE2A9D@apple.com>
Message-ID: <8CE71278-5DEC-4C9A-BDFF-A03C47A2FCA6@anandabits.com>

I would be happy with any solution that provides failable conversion so I would support that as well.

Any chance we could see something like this in Swift 2.2 or Swift 3?  I was hoping the failable initializers might be low hanging fruit but it seems like the scoped feature would be more than that.

Sent from my iPad

> On Dec 6, 2015, at 4:04 PM, Chris Lattner <clattner at apple.com> wrote:
>
> Could definitely be interesting.  I’d personally like to turn it into a scoped feature along the lines of this post though:
>
> https://lists.swift.org/pipermail/swift-evolution/2015-December/000292.html
>
> -Chris
>
>> On Dec 6, 2015, at 5:29 AM, Matthew Johnson <matthew at anandabits.com> wrote:
>>
>> Related to this, but maybe easier to do in the short term: what do you think of adding failable overloads to the numeric conversion initializers Chris?
>>
>> They would throw or return nil if the runtime value could not be preserved rather than trap, truncate, etc.  Floating point types might allow a tolerance for small value changes due to precision, although I'm not sure if that would be good or not.   These initializers would be very useful when processing data from an external source such as JSON that has an expected type but cannot be trusted.
>>
>>
>>
>> Sent from my iPad
>>
>>>> On Dec 6, 2015, at 1:02 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:
>>>> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.
>>>>
>>>> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).
>>>>
>>>>
>>>> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).
>>>>
>>>> For example:
>>>> • If an Int is casting to a larger size (Int16 -> Int32)
>>>> • Float -> Double
>>>> • Float -> CGFloat
>>>> • Int -> Float, Double, or CGFloat (but not the other way)
>>>>
>>>> I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?
>>>
>>> I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms).  I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.
>>>
>>> The problem with doing this today is that there are a lot of dependencies we need to get resolved first.
>>>
>>> 1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions.  We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions.  We have thoughts on this, but should be discussed in a separate thread if you’re interested.
>>>
>>> 2. These promotions should be expressible in the library, not hard coded into the compiler.  This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs.  Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.
>>>
>>> 3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.
>>>
>>> There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats.  These issues are separable, and blocked on things like generic properties not being in place.
>>>
>>> It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.
>>>
>>> -Chris
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>

From clattner at apple.com  Sun Dec  6 16:39:34 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 14:39:34 -0800
Subject: [swift-evolution] mandatory "?" suffix for identifiers
associated	with optional types
In-Reply-To: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
References: <1FE8A847-AA48-43D9-895D-0124C265A634@me.com>
Message-ID: <439F0200-ECDD-46FD-A200-85533E4B2C65@apple.com>


> On Dec 4, 2015, at 7:20 AM, Amir Michail <a.michail at me.com> wrote:
>
> So for example the following (probable) bug would result in a compile error:
>
> let f = x < 5 // where x is optional and could be nil
>
> If that was really what was intended, you would need to write:
>
> let f = x? < 5

I don’t think this approach can work.

Consider the == operator for example: if optionals are are equatable then they will work with ==.  If they are not, they cannot be used as a dictionary key.  The former approach defeats your goals, the later approach defeats common problems from being solved.

-Chris

From clattner at apple.com  Sun Dec  6 16:42:37 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 14:42:37 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
References: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
Message-ID: <CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com>


> On Dec 6, 2015, at 1:38 PM, Tyler Mandry via swift-evolution <swift-evolution at swift.org> wrote:
>
> What isn't clear to me from Chris's or John's comments is why the `if let x? = foo` syntax was taken away. Was it for backward-compatibility?

FWIW, that syntax hasn’t been taken away, it just means something different now.

if let x = foo() {

captures is privileged syntax for testing an optional and binding to the thing inside of it.  The patch I linked to moved away from this, but at great cost: it uglified lots of common code.  Swift privileges optional in a number of ways (e.g. it is the result of as?, try?, etc) and the standard library uses it pervasively as well.  Optimizing for that common case makes sense.

-Chris



From clattner at apple.com  Sun Dec  6 16:47:16 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 14:47:16 -0800
Subject: [swift-evolution] Should be able to initialize list of lists
with 2d static data without unexpected errors.
In-Reply-To: <2F2A126F-228D-479F-99A1-C40B472BBD44@me.com>
References: <2F2A126F-228D-479F-99A1-C40B472BBD44@me.com>
Message-ID: <44256317-DBE6-428B-9E38-7410464FE58A@apple.com>


> On Dec 6, 2015, at 1:26 PM, Amir Michail via swift-evolution <swift-evolution at swift.org> wrote:
>
> It’s very irritating trying to initialize a list of lists with static data and unpredictably encountering expression too complex errors.
>
> One could then try to incrementally initialize such a list of lists with append for each row say.
>
> Such initialization with simple 2d static data should never result in an expression too complex error.

"Too complex” errors are not an evolution issue, they are an implementation issue.  Please feel free to submit PR’s to help improve the implementation!

-Chris

From tmandry at gmail.com  Sun Dec  6 16:48:10 2015
From: tmandry at gmail.com (Tyler Mandry)
Date: Sun, 6 Dec 2015 16:48:10 -0600
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com>
References: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
<CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com>
Message-ID: <CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com>

True, I meant why was the `?` taken out of the syntax. I suppose it can
feel redundant to have `if x? = try? foo()` or similar, in the cases you
mentioned. That said, in the common case of unwrapping a variable of
optional type (`let foo: Int?`) which is not written with a `?`, it can add
extra clarity.

On Sun, Dec 6, 2015 at 4:42 PM, Chris Lattner <clattner at apple.com> wrote:

>
> > On Dec 6, 2015, at 1:38 PM, Tyler Mandry via swift-evolution <
> swift-evolution at swift.org> wrote:
> >
> > What isn't clear to me from Chris's or John's comments is why the `if
> let x? = foo` syntax was taken away. Was it for backward-compatibility?
>
> FWIW, that syntax hasn’t been taken away, it just means something
> different now.
>
>         if let x = foo() {
>
> captures is privileged syntax for testing an optional and binding to the
> thing inside of it.  The patch I linked to moved away from this, but at
> great cost: it uglified lots of common code.  Swift privileges optional in
> a number of ways (e.g. it is the result of as?, try?, etc) and the standard
> library uses it pervasively as well.  Optimizing for that common case makes
> sense.
>
> -Chris
>
>
>


--
Tyler Mandry
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/efe3eb96/attachment.html>

From kevin at sb.org  Sun Dec  6 16:48:42 2015
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 06 Dec 2015 14:48:42 -0800
Subject: [swift-evolution] Proposal: Remove the "fallthrough" keyword
In-Reply-To: <D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
<A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com>
<D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org>
Message-ID: <1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com>

reswitch looks really confusing. Certainly significantly more confusing
than fallthrough.

I notice that all the examples here are using relatively trivial cases,
like `case .LOAD`. Sure it doesn't look confusing there. But it will
get confusing with complicated cases:

switch value {
case .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Garply)):
// do some stuff
reswitch(.Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)))
case .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)):
// do some more stuff
// ...
}

It also fails to account for those cases where you explicitly cannot
re-evaluate against the start of the case list because that won't match
the right case. Trivial example:

switch value {
case .Foo(let s) where seen[s] == nil:
seen[s] = true
fallthrough
case .Foo:
// ...
}

There's no way to use reswitch here to bypass that first case (any value
you might come up with may still pass that where clause and execute the
first case).

-Kevin Ballard

On Sun, Dec 6, 2015, at 02:09 PM, Jacopo Andrea Giola via
swift-evolution wrote:
>
> > On 06 Dec 2015, at 22:23, Colin Barrett <colin at springsandstruts.com> wrote:
> >
> >>
> >> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
> >>
> >> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.
> >
> > I’m curious, how do you propose to do this?
>
> I really don’t know right now, I hope we can find a way.
>
> >
> >> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.
> >
> > In your document you give the example:
> >
> >> case .Three where x > 0:
> >
> > Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:
> >
> >> case .Four(x) where x > 0:
> >
> > In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.
>
> Yes, maybe my example is not the most correct one, I’ve tried to come up
> with something obvious and easy to read/write, but the problem will
> remain for falltrhought as for the Swift iBook:
>
> NOTE
> The fallthrough keyword does not check the case conditions for the switch
> case that it causes execution to fall into. The fallthrough keyword
> simply causes code execution to move directly to the statements inside
> the next case (or default case) block, as in C’s standard switch
> statement behaviour.
>
> For me this behaviour is not something that marry together with the where
> clause that we can add to the switch's cases.
>
> >
> > In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.
> >
> > -Colin
>
> Well technically I wasn’t the original proposal, I’ve only appreciate the
> direction it took and now I’m here to try to spark more discussion to see
> if is a valid direction and if we can improve it :)
>
> >
> >> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847
> >> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.
> >>
> >> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
> >>
> >> - Jacopo
> >>
> >>> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:
> >>>
> >>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.
> >>>
> >>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.
> >>>
> >>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...
> >>>
> >>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.
> >>>
> >>> Thanks,
> >>> -Colin
> >>>
> >>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:
> >>>>
> >>>> Hi Colin,
> >>>>
> >>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an "enhancement" and better refinement of the keyword.
> >>>>
> >>>> The new idea is to substitute the old keyword with "reswitch" passing the desired new value on which the switch is applied.
> >>>> So something like this:
> >>>>
> >>>> switch (enum) {
> >>>> 	case .One:
> >>>> 		// do something
> >>>> 		reswitch .Two
> >>>> 	case .Two:
> >>>> 		// do something else
> >>>> 	default:
> >>>> 		// and so one
> >>>> }
> >>>>
> >>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.
> >>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.
> >>>>
> >>>> switch (enum) {
> >>>> 	case .One:
> >>>> 		// do something
> >>>> 		reswitch .Two
> >>>> 	case .OneAndAHalf
> >>>> 		// maybe this change is not made by you but by a messed up merge
> >>>> 	case .Two:
> >>>> 		// do something else
> >>>> 	default:
> >>>> 		// and so one
> >>>> }
> >>>>
> >>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.
> >>>>
> >>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other
> >>>>
> >>>> switch (enum) {
> >>>> 	case .One:
> >>>> 		// do something
> >>>> 		reswitch .Two
> >>>> 	case .OneAndAHalf
> >>>> 		// so something that you don’t want to do for .One
> >>>> 		reswitch .Two
> >>>> 	case .Two:
> >>>> 		// do something else that you may want to do for .One and .Two
> >>>> 	default:
> >>>> 		// and so one
> >>>> }
> >>>>
> >>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.
> >>>>
> >>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.
> >>>>
> >>>> switch (enum) {
> >>>> 	case .One:
> >>>> 		// do something
> >>>> 		x = 0;
> >>>> 		reswitch .Two
> >>>> 	case .OneAndAHalf
> >>>> 		// so something that you don’t want to do for .One
> >>>> 		reswitch .Two
> >>>> 	case .Two where x > 0:
> >>>> 		// do something else that you may want to do for .One and .Two
> >>>> 		element = array[x]
> >>>> 	default:
> >>>> 		// and so one
> >>>> }
> >>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).
> >>>>
> >>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.
> >>>>
> >>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.
> >>>>
> >>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.
> >>>>
> >>>> - Jacopo
> >>>> Sent from my iPad
> >>>>
> >>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org> wrote:
> >>>>
> >>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.
> >>>>>
> >>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.
> >>>>>
> >>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)
> >>>>>
> >>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:
> >>>>>
> >>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df
> >>>>>
> >>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.
> >>>>>
> >>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.
> >>>>>
> >>>>> Thanks,
> >>>>> -Colin
> >>>>>
> >>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
> >>>>>>
> >>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.
> >>>>>>
> >>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite "switch" loop.
> >>>>>>
> >>>>>> Sent from my iPad
> >>>>>>
> >>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:
> >>>>>>
> >>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use "continue" instead of "reswitch".
> >>>>>>>
> >>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.
> >>>>>>>
> >>>>>>> - Steve
> >>>>>>>
> >>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
> >>>>>>>
> >>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:
> >>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:
> >>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.
> >>>>>>>>>>
> >>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.
> >>>>>>>>>
> >>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.
> >>>>>>>>>
> >>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.
> >>>>>>>>
> >>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.
> >>>>>>>>
> >>>>>>>> John.
> >>>>>>>>
> >>>>>>>>>
> >>>>>>>>> John.
> >>>>>>>>>
> >>>>>>>>>>
> >>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).
> >>>>>>>>>>
> >>>>>>>>>> switch op {
> >>>>>>>>>> case LOAD_INDIRECT:
> >>>>>>>>>>   in0 = memory[in1]
> >>>>>>>>>>   fallthrough
> >>>>>>>>>> case LOAD:
> >>>>>>>>>>   out0 = memory[in0]
> >>>>>>>>>> //...
> >>>>>>>>>> }
> >>>>>>>>>>
> >>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.
> >>>>>>>>>>
> >>>>>>>>>> Cheers,
> >>>>>>>>>> John
> >>>>>>>>>>
> >>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:
> >>>>>>>>>>>
> >>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:
> >>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.
> >>>>>>>>>>>
> >>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.
> >>>>>>>>>>>
> >>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.
> >>>>>>>>>>>
> >>>>>>>>>>> John.
> >>>>>>>>>>>
> >>>>>>>>>>>>
> >>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.
> >>>>>>>>>>>>
> >>>>>>>>>>>> -Kevin Ballard
> >>>>>>>>>>>>
> >>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:
> >>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for "fallthrough language:swift".
> >>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:
> >>>>>>>>>>>>>> case .Enum1, .Enum2:
> >>>>>>>>>>>>>> expressed as
> >>>>>>>>>>>>>> case .Enum1: fallthrough
> >>>>>>>>>>>>>> case .Enum2:
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the "fallthrough" keyword from the language?
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> "The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior."
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> Thoughts?
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> Daniel
> >>>>>>>>>>>>>>>
> >>>>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>>
> >>>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>>>
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>>
> >>>>>>>>>>>>
> >>>>>>>>>>>> _______________________________________________
> >>>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>>
> >>>>>>>>>>> _______________________________________________
> >>>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>>
> >>>>>>>>>>
> >>>>>>>>>> _______________________________________________
> >>>>>>>>>> swift-evolution mailing list
> >>>>>>>>>> swift-evolution at swift.org
> >>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>>
> >>>>>>>>>
> >>>>>>>>> _______________________________________________
> >>>>>>>>> swift-evolution mailing list
> >>>>>>>>> swift-evolution at swift.org
> >>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>>
> >>>>>>>>
> >>>>>>>> _______________________________________________
> >>>>>>>> swift-evolution mailing list
> >>>>>>>> swift-evolution at swift.org
> >>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> swift-evolution mailing list
> >>>>>>> swift-evolution at swift.org
> >>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>>
> >>>>>> _______________________________________________
> >>>>>> swift-evolution mailing list
> >>>>>> swift-evolution at swift.org
> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
> >>>>>
> >>>>>
> >>>>> _______________________________________________
> >>>>> swift-evolution mailing list
> >>>>> swift-evolution at swift.org
> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

From clattner at apple.com  Sun Dec  6 16:51:27 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 14:51:27 -0800
Subject: [swift-evolution] Proposal: Optional Binding Shorthand Syntax
In-Reply-To: <CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com>
References: <CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com>
<CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com>
<CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com>
Message-ID: <226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com>


> On Dec 6, 2015, at 2:48 PM, Tyler Mandry <tmandry at gmail.com> wrote:
>
> True, I meant why was the `?` taken out of the syntax

Swift 2 does support ? patterns.

-Chris


From nickmshelley at gmail.com  Sun Dec  6 16:55:14 2015
From: nickmshelley at gmail.com (Nick Shelley)
Date: Sun, 6 Dec 2015 15:55:14 -0700
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions (David Hart)
In-Reply-To: <32D55766-386B-4584-8563-54AB8C1EDBFB@me.com>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
<32D55766-386B-4584-8563-54AB8C1EDBFB@me.com>
Message-ID: <CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>

I like that self is only required in closures because it serves as a good
reminder that there are memory and safety implications with using self in a
closure, such as creating retain cycles or having the closure run after
self has been deallocated.

I can't seem to find an official Apple Swift style guide, but github's (
https://github.com/github/swift-style-guide) suggests only using self in
closures with the rationale: "This makes the capturing semantics of self
stand out more in closures, and avoids verbosity elsewhere."

On Sat, Dec 5, 2015 at 3:16 AM, Yichen Cao <ycao at me.com> wrote:

> Teaching wise, its much less confusing for self to be required so students
> don't mix up instance properties and local vars. Especially when self is
> required in closures, it confuses students. If self is mandatory for all
> instance properties, it would be so much clearer and much easier to read.
>
> Yichen
>
> On Dec 5, 2015, at 18:11, swift-evolution-request at swift.org wrote:
>
> Re: Proposal: Re-instate mandatory self for accessing
>      instance properties and functions (David Hart)
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/5abb25b7/attachment.html>

From clattner at apple.com  Sun Dec  6 16:56:09 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 14:56:09 -0800
Subject: [swift-evolution] Control Flow Expressions
In-Reply-To: <CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com>
References: <DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com>
<7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com>
<CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com>
Message-ID: <04492F1A-DC29-41D3-B9CD-44E87AA44E49@apple.com>


> On Dec 6, 2015, at 12:17 PM, Per Melin <p at greendale.se> wrote:
>
> On Sat, Dec 5, 2015 at 7:15 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:
> Further, it is important to consider whether the code written using this will actually be *better* than the code written with these things as statements.  For example, the “switch” blocks tend to be very large, and turning them into expressions encourages additional indentation.
>
> If you give functions implicit return at the same time – as in Haskell, Erlang, Scala, Rust, Ruby, Lisp/Scheme/Clojure, etc –  there would be no need for additional indentation half of the time.

This isn’t something that I’m personally interested in.  I think that it is *feature* of swift that statements an declarations start with keywords.  This greatly simplifies the grammar in various ways, and allows declmodifiers to be introduced without taking keywords space.

For example, relevant to this proposal, if/when we support “tail return foo()" for example, you don’t want to take “tail” as a keyword to make “tail foo()” work.

> Not even Slava Pestov would factor Swift that aggressively.

Underestimating Slava is not a good idea! :-)

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8e87f6ef/attachment.html>

From clattner at apple.com  Sun Dec  6 16:59:32 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 14:59:32 -0800
Subject: [swift-evolution] Proposal: Syntax sugar for cps or async
functions similar to the "do try catch" for error handling.
In-Reply-To: <78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com>
References: <78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com>
Message-ID: <A4969909-2AD7-41AD-A0E3-07590FBA33D4@apple.com>


> On Dec 6, 2015, at 1:21 AM, Roy Fu via swift-evolution <swift-evolution at swift.org> wrote:
>
> Hi all,
>
> Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:

We are all very interested in doing things along these lines, but need to keep Swift 3 relatively focused to achieve our goals.  Please bring this idea back up as work on Swift 3 is winding down, for consideration in Swift 4.

-Chris

>
> func someFutureWrappedFunc(input: Int) future-> String{
>     doSomeStaffInBackground{ (result:String) in
>         fulfil result
>     }
> }
>
> do{
>     let resultX = perform someFutureWrappedFunc(param)
>     let resultY = perform anotherFutureWrappedFunc(resultX)
>     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)
>     self.someLabel.text = final
> } timeout let context {
>     //maybe some additional information
> }
>
> the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:
>
> doSomeStaffInBackground { (resultX) -> Void in
>
>     doSomeOtherStaff { (resultY) -> Void in
>
>         if resultY.someCondition(resultX) {
>
>             evenMakesItMadness(resultY) { (final) -> Void in
>
>                 //finally
>             }
>         }
>     }
> }
>
>
>
>
> For more context comparing this async syntax to the ‘do try catch’:
>
> do try catch:
> enum Result<T> {
>     case Success(T)
>     case Failure(ErrorType)
> }
>
> func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{
>     switch result{
>     case .Success(let v): return f(v)
>     case .Failure(let e): return .Failure(e)
>     }
> }
>
> func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {
>     return {
>         do{
>             return try .Success(f($0))
>         }catch let e{
>             return .Failure(e)
>         }
>     }
> }
>
> func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{
>     return{
>         switch f($0){
>         case .Success(let v): return v
>         case .Failure(let e): throw e
>         }
>     }
> }
>
> async:
>
> func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {
>     return{ cont in
>         async{ f($0)(cont) }
>     }
> }
>
> func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {
>     return {input in
>         {cont in
>             do{
>                 cont(perform f(input))
>             }catch _{
>
>             }
>         }
>     }
> }
>
> func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{
>     return{
>         f(input)({
>             fulfil $0
>         })
>     }
> }
>
>
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/262184eb/attachment.html>

From clattner at apple.com  Sun Dec  6 17:01:56 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 15:01:56 -0800
Subject: [swift-evolution] Proposal: helpers for initializing
properties	of same name as parameters
In-Reply-To: <475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>
<475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com>
Message-ID: <6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com>


> On Dec 6, 2015, at 7:41 AM, Matthew Johnson <matthew at anandabits.com> wrote:
>
> Thanks for chiming in on this thread.  I definitely understand the desire to wait on features like this until post-Swfit 3 and possibly post-hygienic macros as well.
>
> I would add to your list of memberwise initializer deficiencies the fact that it is “all or nothing”.  I’m wondering what you think of generalizing our “utterance” of the memberwise initializer in a way that allows the flexibility for the initializer itself to handle initialization of some of the members while allowing the compiler to generate the implementation for other members.  I described one idea for doing this in a post last night where I described an @initializable member attribute.  I’m not tied to that specific solution, but I do think it is highly desirable to have complier-generated memberwise initialization that is more flexible than an “all or nothing” solution.  What are your thoughts?

That would be great of course, but it depends on the details.  We’d need someone to make a specific proposal to hash out whether and how it can work.

-Chris

From jtbandes at gmail.com  Sun Dec  6 17:01:18 2015
From: jtbandes at gmail.com (Jacob Bandes-Storch)
Date: Sun, 6 Dec 2015 15:01:18 -0800
Subject: [swift-evolution] zip3, zip4, ...
Message-ID: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>

zip2 (aka "zip") is present in Swift. zip3 is often useful, but not
built-in.

It can be achieved by using multiple copies of zip2:

for (one, (two, three)) in zip(list1, zip(list2, list3)) ...

It seems like either of these could make sense:

- Put some reasonable number of implementations, like zip2...zip10, in the
standard library, using gyb.

- Have the compiler generate them on the fly as requested by the user.

Or, some alternate approaches:

- Don't do this right now, but count it as motivation for a macro system.

- Consider making Swift's pattern-matching system extensible, which might
allow custom array-based patterns, like "for [one, two, three] in
zip(list1, list2, list3)".  (I've been thinking of writing a proposal for
this anyway.)


Does anyone else care about zip3-and-higher? How do these options sound?

Jacob Bandes-Storch
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3955d001/attachment.html>

From clattner at apple.com  Sun Dec  6 17:03:32 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 15:03:32 -0800
Subject: [swift-evolution] Proposal: Update the API Design Guidelines to
reflect current Standard Library method naming conventions
In-Reply-To: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>
References: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>
Message-ID: <271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>


> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org> wrote:
>
> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.
>
> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.

Hi Daniel,

This is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.

If you’re interested in more details on this effort, check out this blog post:
https://swift.org/blog/swift-3-api-design/ <https://swift.org/blog/swift-3-api-design/>

It includes a link to the diff-in-progress for the standard library.

-Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8961cb30/attachment.html>

From jalkut at red-sweater.com  Sun Dec  6 17:06:03 2015
From: jalkut at red-sweater.com (jalkut at red-sweater.com)
Date: Sun, 6 Dec 2015 18:06:03 -0500
Subject: [swift-evolution] (5.391):Re: Proposal: Remove the
"fallthrough" keyword
In-Reply-To: <6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
References: <3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com>
<AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com>
<8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com>
<1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com>
<02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com>
<E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com>
<444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com>
<EF1675F6-7918-4262-B535-696104BFC405@apple.com>
<CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com>
<D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org>
<071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com>
<CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org>
<6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com>
<6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org>
Message-ID: <D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com>


> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:
>
> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)
>

Hi Jacopo - I have been interested to read the counter-arguments to my proposal to remove the keyword.

I’m also glad it helped to spark a proposal to try to refine the behavior with some kind of "reswitch" mechanism, but I don’t have any passion for pushing that particular proposal along.

My motivation in proposing to remove the fallthrough keyword was that it makes sense to be judicious about language features and keywords especially while the language is young. The feature still seems questionable to me, but if the prevailing opinion is that "fallthrough" or a similar case-jumping mechanism is worth keeping, then I respect that and will not be pushing my original proposal any further.

Daniel


From clattner at apple.com  Sun Dec  6 17:06:09 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 6 Dec 2015 15:06:09 -0800
Subject: [swift-evolution] Feedback for SE-0004: Remove the ++ and --
operators
In-Reply-To: <7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com>
References: <A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com>
<F9C56B7C-34E8-40A8-B232-1FA9CC0C1FB6@apple.com>
<7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com>
Message-ID: <7C63AD72-C9A4-4794-9F1F-7D978357F5C5@apple.com>

On Dec 6, 2015, at 6:22 AM, David Zarzycki <zarzycki at icloud.com> wrote:
>> That is definitely an interesting idea.  In practice, we won’t be able to remove ++/— from the compiler until the ~Spring 2017 release, since Swift 3 will want to parse the old code and reject it with a fixit hint.
>>
>>> Doing so would define away a type checking ambiguity where “let f = T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.
>>
>> Besides the general simplification potential for the language, is this a theoretical concern or an actual one?  You can currently do something like “let f = T->T = {$0^}” or “{^$0}” to disambiguate the prefix/postfix forms.
>
> It is just simplification that opens the door to further simplicity and self-consistency within the language. In addition to not needing the above workaround, one could remove the fixity keywords/attributes altogether, because they’d be inferable from context.
>
> If one wants to go deep down the rabbit hole, one could let developers avoid nested parenthesis and the “spiral call syntax problem” by allowing the language to use the same unary operator in either prefix or postfix positions. For example, instead of “(^(-(~x).a).b).c”, one could write “x~.a-.b^.c” to accomplish the same goal.

Ok, we can consider this when work on the Spring 2017 release is active.

-Chris

From gribozavr at gmail.com  Sun Dec  6 17:10:39 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 15:10:39 -0800
Subject: [swift-evolution] Proposal: Update the API Design Guidelines to
reflect current Standard Library method naming conventions
In-Reply-To: <271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>
References: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>
<271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>
Message-ID: <CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com>

On Sun, Dec 6, 2015 at 3:03 PM, Chris Lattner via swift-evolution <
swift-evolution at swift.org> wrote:

>
> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I love that the team has released API Design Guidelines and find them very
> helpful. One piece of advice, however, seems to be at odds with current
> Standard Library practice.
>
> Currently the methods sort() and sortInPlace() are the non-mutating and
> mutating versions of sorting a collection. Similarly, there are pairs of
> methods in Set named union() and unionInPlace(), intersect() and
> intersectInPlace() and so on.
>
>
> Hi Daniel,
>
> This is a known issue, and it is because we want to keep Swift 2.2
> reasonable source compatible with Swift 2.  The changes to the standard
> library will land after Swift 2.2 branches for its release in the spring.
>
> If you’re interested in more details on this effort, check out this blog
> post:
> https://swift.org/blog/swift-3-api-design/
>
> It includes a link to the diff-in-progress for the standard library.
>

Hi Chris,

I think Daniel is not highlighting the inconsistency, but saying that he
likes ~InPlace better:

On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <
swift-evolution at swift.org> wrote:
> Previously the sort methods were named sort() and sorted(). I never could
remember which is which.

Dmitri


--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c89eb2f0/attachment.html>

From brent at architechies.com  Sun Dec  6 17:22:24 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sun, 6 Dec 2015 15:22:24 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com>
References: <9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com>
Message-ID: <289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com>

> I think that the C-style for loop should be removed from Swift.

The silence you’re hearing on this proposal is because we just had a thread about this a couple days ago. :^) Take a look at the archives--most people seem to agree that the for loop ought to go. They’ve even started changing standard library for loops to for-in.

--
Brent Royal-Gordon
Architechies


From gribozavr at gmail.com  Sun Dec  6 17:24:01 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 15:24:01 -0800
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com>
References: <9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com>
<289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com>
Message-ID: <CA+Y5xYdpHCoCSwGi8MB3cWLd79XHNGo8BB2G=LJaPSPVtsq8Qg@mail.gmail.com>

On Sun, Dec 6, 2015 at 3:22 PM, Brent Royal-Gordon via swift-evolution
<swift-evolution at swift.org> wrote:
>They’ve even started changing standard library for loops to for-in.

The patch that was submitted changes the obvious cases.  It would be
good to see a patch that converts all instances, including the "hard"
ones.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From daniel at dimsumthinking.com  Sun Dec  6 17:33:38 2015
From: daniel at dimsumthinking.com (Daniel Steinberg)
Date: Sun, 6 Dec 2015 18:33:38 -0500
Subject: [swift-evolution] Proposal: Update the API Design Guidelines to
reflect current Standard Library method naming conventions
In-Reply-To: <271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>
References: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>
<271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>
Message-ID: <B9EC68C8-F4F2-4929-A76D-2F30ABF39F62@dimsumthinking.com>

Thank you
> On Dec 6, 2015, at 6:03 PM, Chris Lattner <clattner at apple.com> wrote:
>
>
>> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.
>>
>> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.
>
> Hi Daniel,
>
> This is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.
>
> If you’re interested in more details on this effort, check out this blog post:
> https://swift.org/blog/swift-3-api-design/ <https://swift.org/blog/swift-3-api-design/>
>
> It includes a link to the diff-in-progress for the standard library.
>
> -Chris
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e523f54d/attachment.html>

From erica at ericasadun.com  Sun Dec  6 17:34:15 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 16:34:15 -0700
Subject: [swift-evolution] zip3, zip4, ...
In-Reply-To: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>
References: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>
Message-ID: <1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com>

It's pretty easy to build your own Zips. Not sure the language really needs this. For example, I recently built a zip that produces (T?, T?) which fills one of the two with nil until both lists are consumed:

func longZip<S0: SequenceType, S1: SequenceType>(seq0: S0, _ seq1: S1) ->
AnyGenerator<(S0.Generator.Element?, S1.Generator.Element?)> {
var generators = (seq0.generate(), seq1.generate())
return anyGenerator {
let items = (generators.0.next(), generators.1.next())
if case (.None, .None) = items {return nil}
return items
}
}

I'm rather fond of this variant although I don't know if it's generally useful enough to be worth even considering for the language

-- E


> On Dec 6, 2015, at 4:01 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:
>
> zip2 (aka "zip") is present in Swift. zip3 is often useful, but not built-in.
>
> It can be achieved by using multiple copies of zip2:
>
>   for (one, (two, three)) in zip(list1, zip(list2, list3)) ...
>
> It seems like either of these could make sense:
>
> - Put some reasonable number of implementations, like zip2...zip10, in the standard library, using gyb.
>
> - Have the compiler generate them on the fly as requested by the user.
>
> Or, some alternate approaches:
>
> - Don't do this right now, but count it as motivation for a macro system.
>
> - Consider making Swift's pattern-matching system extensible, which might allow custom array-based patterns, like "for [one, two, three] in zip(list1, list2, list3)".  (I've been thinking of writing a proposal for this anyway.)
>
>
> Does anyone else care about zip3-and-higher? How do these options sound?
>
> Jacob Bandes-Storch
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a9a9edd4/attachment.html>

From daniel at dimsumthinking.com  Sun Dec  6 17:34:30 2015
From: daniel at dimsumthinking.com (Daniel Steinberg)
Date: Sun, 6 Dec 2015 18:34:30 -0500
Subject: [swift-evolution] Proposal: Update the API Design Guidelines to
reflect current Standard Library method naming conventions
In-Reply-To: <CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com>
References: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>
<271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>
<CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com>
Message-ID: <7C2CA2AE-E4BE-45BF-AD09-617F38B6736D@dimsumthinking.com>

Yes
> On Dec 6, 2015, at 6:10 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Sun, Dec 6, 2015 at 3:03 PM, Chris Lattner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.
>>
>> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.
>
> Hi Daniel,
>
> This is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.
>
> If you’re interested in more details on this effort, check out this blog post:
> https://swift.org/blog/swift-3-api-design/ <https://swift.org/blog/swift-3-api-design/>
>
> It includes a link to the diff-in-progress for the standard library.
>
> Hi Chris,
>
> I think Daniel is not highlighting the inconsistency, but saying that he likes ~InPlace better:
>
> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> > Previously the sort methods were named sort() and sorted(). I never could remember which is which.
>
> Dmitri
>
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>>*/

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/28fc8376/attachment.html>

From me at tal.by  Sun Dec  6 17:36:30 2015
From: me at tal.by (Tal Atlas)
Date: Sun, 06 Dec 2015 23:36:30 +0000
Subject: [swift-evolution] Proposal: helpers for initializing properties
of same name as parameters
In-Reply-To: <6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com>
References: <CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com>
<4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com>
<819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com>
<475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com>
<6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com>
Message-ID: <CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com>

I greatly appreciate the feedback from those working directly with the
language. Having read though the other proposals I would like to return to
my original proposal, as it seems to have the greatest flexibility and
simplicity from an api perspective. The most frequent pain point with
current initializers are structs with more than a few private stored
properties, the amount of boilerplate is rather annoying. The other benefit
is it gives the writer direct control over what the external api for the
given object is for each specific initializer. I”m not married to the
`init(self.var: Type)` syntax, but would be sad if any solution didn’t stem
from a similar sort of idea.

On Sun, Dec 6, 2015 at 6:02 PM Chris Lattner via swift-evolution <
swift-evolution at swift.org> wrote:

>
> > On Dec 6, 2015, at 7:41 AM, Matthew Johnson <matthew at anandabits.com>
> wrote:
> >
> > Thanks for chiming in on this thread.  I definitely understand the
> desire to wait on features like this until post-Swfit 3 and possibly
> post-hygienic macros as well.
> >
> > I would add to your list of memberwise initializer deficiencies the fact
> that it is “all or nothing”.  I’m wondering what you think of generalizing
> our “utterance” of the memberwise initializer in a way that allows the
> flexibility for the initializer itself to handle initialization of some of
> the members while allowing the compiler to generate the implementation for
> other members.  I described one idea for doing this in a post last night
> where I described an @initializable member attribute.  I’m not tied to that
> specific solution, but I do think it is highly desirable to have
> complier-generated memberwise initialization that is more flexible than an
> “all or nothing” solution.  What are your thoughts?
>
> That would be great of course, but it depends on the details.  We’d need
> someone to make a specific proposal to hash out whether and how it can work.
>
> -Chris
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2d4af16c/attachment.html>

From gribozavr at gmail.com  Sun Dec  6 17:37:03 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 15:37:03 -0800
Subject: [swift-evolution] zip3, zip4, ...
In-Reply-To: <1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com>
References: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>
<1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com>
Message-ID: <CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com>

On Sun, Dec 6, 2015 at 3:34 PM, Erica Sadun via swift-evolution <
swift-evolution at swift.org> wrote:

> It's pretty easy to build your own Zips. Not sure the language really
> needs this. For example, I recently built a zip that produces (T?, T?)
> which fills one of the two with nil until both lists are consumed:
>
> func longZip<S0: SequenceType, S1: SequenceType>(seq0: S0, _ seq1: S1) ->
>     AnyGenerator<(S0.Generator.Element?, S1.Generator.Element?)> {
>


Just wanted to point out that AnyGenerator has an inherent cost from the
type erasure.  The implementation in the standard library uses generics and
is fully optimizable.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ce69d57f/attachment.html>

From nvazquez1297 at gmail.com  Sun Dec  6 17:40:10 2015
From: nvazquez1297 at gmail.com (Nikolai Vazquez)
Date: Sun, 06 Dec 2015 23:40:10 +0000
Subject: [swift-evolution] Proposal: Tuple Convertible
Message-ID: <CANhuES0tvUB5Gx89W39utk1wVSbscOmJy3vFhwe3k++NPKBvcw@mail.gmail.com>

When working with points, I’ll sometimes make a typealias to an integer
tuple:

typealias Point = (x: Int, y: Int)

However, if I want to add extended functionality to my Point type, I would
have to change it to a struct, removing the ability to create one on the
fly with a tuple.

I’m proposing a TupleConvertible protocol that allows initialization from a
tuple directly.

struct Point: TupleConvertible {

var x, y: Int

init(x: Int, y: Int) {
self.x = x
self.y = y
}

init(tuple: (x: Int, y: Int)) {
self.init(x: tuple.x, y: tuple.y)
}

}

This would make it very easy to create new Point instances.

let somePoint: Point = (50, 120)let otherPoint = Point(x: 50, y: 120)

​
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/dd4af639/attachment.html>

From erica at ericasadun.com  Sun Dec  6 17:44:07 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 16:44:07 -0700
Subject: [swift-evolution] zip3, zip4, ...
In-Reply-To: <CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com>
References: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>
<1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com>
<CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com>
Message-ID: <03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com>

Is there an implementation in the stdlib for (T?, T?) like this?

> On Dec 6, 2015, at 4:37 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
> On Sun, Dec 6, 2015 at 3:34 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
> It's pretty easy to build your own Zips. Not sure the language really needs this. For example, I recently built a zip that produces (T?, T?) which fills one of the two with nil until both lists are consumed:
>
> func longZip<S0: SequenceType, S1: SequenceType>(seq0: S0, _ seq1: S1) ->
>     AnyGenerator<(S0.Generator.Element?, S1.Generator.Element?)> {
>
>
> Just wanted to point out that AnyGenerator has an inherent cost from the type erasure.  The implementation in the standard library uses generics and is fully optimizable.
>
> Dmitri
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>>*/

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4d7bcfae/attachment.html>

From gribozavr at gmail.com  Sun Dec  6 17:46:26 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 15:46:26 -0800
Subject: [swift-evolution] zip3, zip4, ...
In-Reply-To: <03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com>
References: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>
<1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com>
<CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com>
<03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com>
Message-ID: <CA+Y5xYcNfXfs1=xJUuuFZJ-1RjiM9qhp6vYGCJEPwZjdkNUaow@mail.gmail.com>

On Sun, Dec 6, 2015 at 3:44 PM, Erica Sadun <erica at ericasadun.com> wrote:
> Is there an implementation in the stdlib for (T?, T?) like this?

No.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From oisin.kidney at gmail.com  Sun Dec  6 17:49:18 2015
From: oisin.kidney at gmail.com (=?utf-8?Q?Donnacha_Ois=C3=ADn_Kidney?=)
Date: Sun, 6 Dec 2015 23:49:18 +0000
Subject: [swift-evolution] zip3, zip4, ...
In-Reply-To: <03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com>
References: <CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com>
<1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com>
<CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com>
<03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com>
Message-ID: <52258245-20CC-4C12-864C-31A8EA887E5E@gmail.com>

An implementation of this is actually pretty complicated, since you aren’t supposed to call a generator once it’s returned nil.

public struct NilPaddedZipGenerator<G0: GeneratorType, G1: GeneratorType> : GeneratorType {

private var (g0, g1): (G0?, G1?)

public mutating func next() -> (G0.Element?, G1.Element?)? {
let (e0,e1) = (g0?.next(),g1?.next())
switch (e0,e1) {
case (nil,nil): return nil
case (  _,nil): g1 = nil
case (nil,  _): g0 = nil
default: break
}
return (e0,e1)
}
}

public struct NilPaddedZip<S0: SequenceType, S1: SequenceType> : LazySequenceType {

private let (s0, s1): (S0, S1)
public func generate() -> NilPaddedZipGenerator<S0.Generator, S1.Generator> {
return NilPaddedZipGenerator(g0: s0.generate(), g1: s1.generate())
}
}

@warn_unused_result
public func zipWithPadding<S0: SequenceType, S1: SequenceType>(s0: S0, _ s1: S1)
-> NilPaddedZip<S0, S1> {
return NilPaddedZip(s0: s0, s1: s1)
}

> On 6 Dec 2015, at 23:44, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>
> Is there an implementation in the stdlib for (T?, T?) like this?
>
>> On Dec 6, 2015, at 4:37 PM, Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>> wrote:
>>
>> On Sun, Dec 6, 2015 at 3:34 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>> It's pretty easy to build your own Zips. Not sure the language really needs this. For example, I recently built a zip that produces (T?, T?) which fills one of the two with nil until both lists are consumed:
>>
>> func longZip<S0: SequenceType, S1: SequenceType>(seq0: S0, _ seq1: S1) ->
>>     AnyGenerator<(S0.Generator.Element?, S1.Generator.Element?)> {
>>
>>
>> Just wanted to point out that AnyGenerator has an inherent cost from the type erasure.  The implementation in the standard library uses generics and is fully optimizable.
>>
>> Dmitri
>>
>> --
>> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
>> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>>*/
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/49d9a866/attachment.html>

From gribozavr at gmail.com  Sun Dec  6 17:55:34 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 15:55:34 -0800
Subject: [swift-evolution] Proposal: failable numeric conversion
initializers
In-Reply-To: <70E0CB06-BF3D-41D5-8902-FA64A1FA7BE2@anandabits.com>
References: <70E0CB06-BF3D-41D5-8902-FA64A1FA7BE2@anandabits.com>
Message-ID: <CA+Y5xYeSeriEGiEV+zZsUfmWhX9W_K0XufPYA2UFTkiSudwNAA@mail.gmail.com>

On Sun, Dec 6, 2015 at 11:28 AM, Matthew Johnson via swift-evolution
<swift-evolution at swift.org> wrote:
> Problem:
> Swift numeric types all currently have a family of conversion initializers.  In many use cases they leave a lot to be desired.  Initializing an integer type with a floating point value will truncate any fractional portion of the number.  Initializing with an out-of-range value traps.
>
> Solution:
>
> Sometimes it would be more desirable to convert the runtime value if it can be done without losing information (or possibly with only minimal loss of precision when initializing a floating point type).  This could be easily accomplished if the standard library had a family of failable initializers for all numeric types, either returning an Optional or throwing when the initialization was not successful.
>
> I prefer the throwing version because failure can be automatically propagated up the call stack and the error could capture value that was provided and the type that failed to initialize which may be useful when debugging.  Also, `try?` allows callers to throw away the error if the detail isn’t necessary.  However, the Optional version would provide the basic functionality that is desired and would be sufficient if the community likes it better.
>
> //  Conversions from all integer types.
> init?(_ value: Int8)
> init?(_ value: Int16)
> init?(_ value: Int32)
> init?(_ value: Int64)
> init?(_ value: Int)
> init?(_ value: UInt8)
> init?(_ value: UInt16)
> init?(_ value: UInt32)
> init?(_ value: UInt64)
> init?(_ value: UInt)

One issue is that these initializers already exist with the signature
'init(_ value: IntXYZ)'.  Adding these failable initializers would
make code like the following ambiguous:

var u8 = getUInt8()
var myInt = Int(u8)

We need a label to distinguish these.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From stephen.celis at gmail.com  Sun Dec  6 18:01:23 2015
From: stephen.celis at gmail.com (Stephen Celis)
Date: Sun, 6 Dec 2015 19:01:23 -0500
Subject: [swift-evolution] Proposal: Tuple Convertible
In-Reply-To: <CANhuES0tvUB5Gx89W39utk1wVSbscOmJy3vFhwe3k++NPKBvcw@mail.gmail.com>
References: <CANhuES0tvUB5Gx89W39utk1wVSbscOmJy3vFhwe3k++NPKBvcw@mail.gmail.com>
Message-ID: <8821D625-0354-426C-B442-CF3AA1D421C5@gmail.com>

Do you mean a TupleLiteralConvertible? I’m also in favor of a ClosureLiteralConvertible (or FunctionLiteralConvertible).

Stephen

> On Dec 6, 2015, at 6:40 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:
>
> When working with points, I’ll sometimes make a typealias to an integer tuple:
>
> typealias Point = (x: Int, y: Int)
> However, if I want to add extended functionality to my Point type, I would have to change it to a struct, removing the ability to create one on the fly with a tuple.
>
> I’m proposing a TupleConvertible protocol that allows initialization from a tuple directly.
>
> struct Point: TupleConvertible {
>
>     var x, y: Int
>
>     init(x: Int, y: Int) {
>         self.x = x
>         self.y = y
>     }
>
>     init(tuple: (x: Int, y: Int)) {
>         self.init(x: tuple.x, y: tuple.y)
>     }
>
> }
> This would make it very easy to create new Point instances.
>
> let somePoint: Point = (50, 120)
> let otherPoint = Point(x: 50, y: 120)
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4a56088d/attachment.html>

From nvazquez1297 at gmail.com  Sun Dec  6 18:07:20 2015
From: nvazquez1297 at gmail.com (Nikolai Vazquez)
Date: Mon, 07 Dec 2015 00:07:20 +0000
Subject: [swift-evolution] Proposal: Tuple Convertible
In-Reply-To: <8821D625-0354-426C-B442-CF3AA1D421C5@gmail.com>
References: <CANhuES0tvUB5Gx89W39utk1wVSbscOmJy3vFhwe3k++NPKBvcw@mail.gmail.com>
<8821D625-0354-426C-B442-CF3AA1D421C5@gmail.com>
Message-ID: <CANhuES1pT6mf7AuKg5w=Rb2viboX379U+E-=1TbCckPpAYx0+Q@mail.gmail.com>

I was thinking it could work for variables that are already tuples but then
that goes against Swift's strict typing. So really it should only be for
tuple literals.

On Sun, Dec 6, 2015, 7:01 PM Stephen Celis <stephen.celis at gmail.com> wrote:

> Do you mean a TupleLiteralConvertible? I’m also in favor of a
> ClosureLiteralConvertible (or FunctionLiteralConvertible).
>
> Stephen
>
> On Dec 6, 2015, at 6:40 PM, Nikolai Vazquez via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> When working with points, I’ll sometimes make a typealias to an integer
> tuple:
>
> typealias Point = (x: Int, y: Int)
>
> However, if I want to add extended functionality to my Point type, I
> would have to change it to a struct, removing the ability to create one
> on the fly with a tuple.
>
> I’m proposing a TupleConvertible protocol that allows initialization from
> a tuple directly.
>
> struct Point: TupleConvertible {
>
>     var x, y: Int
>
>     init(x: Int, y: Int) {
>         self.x = x
>         self.y = y
>     }
>
>     init(tuple: (x: Int, y: Int)) {
>         self.init(x: tuple.x, y: tuple.y)
>     }
>
> }
>
> This would make it very easy to create new Point instances.
>
> let somePoint: Point = (50, 120)let otherPoint = Point(x: 50, y: 120)
>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/9c1f4b4a/attachment.html>

From clattner at apple.com  Sun Dec  6 18:38:41 2015
From: clattner at apple.com (Chris Lattner)
Date: Sun, 06 Dec 2015 16:38:41 -0800
Subject: [swift-evolution] Proposal: Update the API Design Guidelines to
reflect current Standard Library method naming conventions
In-Reply-To: <CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com>
References: <2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com>
<271820A9-BB4A-44F7-B227-E105D15B2327@apple.com>
<CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com>
Message-ID: <29F7EE3C-7967-4651-9C38-6D071AE543B0@apple.com>

Ah, sorry for the misunderstanding!

-Chris

> On Dec 6, 2015, at 3:10 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:
>
>> On Sun, Dec 6, 2015 at 3:03 PM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:
>>
>>> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.
>>>
>>> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.
>>
>> Hi Daniel,
>>
>> This is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.
>>
>> If you’re interested in more details on this effort, check out this blog post:
>> https://swift.org/blog/swift-3-api-design/
>>
>> It includes a link to the diff-in-progress for the standard library.
>
>
> Hi Chris,
>
> I think Daniel is not highlighting the inconsistency, but saying that he likes ~InPlace better:
>
> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org> wrote:
> > Previously the sort methods were named sort() and sorted(). I never could remember which is which.
>
> Dmitri
>
>
> --
> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
> (j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/fbcf019a/attachment.html>

From gribozavr at gmail.com  Sun Dec  6 19:04:57 2015
From: gribozavr at gmail.com (Dmitri Gribenko)
Date: Sun, 6 Dec 2015 17:04:57 -0800
Subject: [swift-evolution] Lazy flatMap for Optionals
In-Reply-To: <C3D6E59B-95E6-4A39-86C3-7FF7F33C38B5@gmail.com>
References: <5FD8E885-1900-4498-938D-161809D13746@gmail.com>
<CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com>
<C3D6E59B-95E6-4A39-86C3-7FF7F33C38B5@gmail.com>
Message-ID: <CA+Y5xYd2R3B5TfhRR-OX+DRohj=aUtJW3RxM2oBOsX42XK00pg@mail.gmail.com>

On Sun, Dec 6, 2015 at 8:06 AM, Donnacha Oisín Kidney
<oisin.kidney at gmail.com> wrote:
> (forgot to cc the mailing list)
>
> You can define it in terms of a map-filter-map chain, like this:
>
> extension LazySequenceType {
>
>   @warn_unused_result
>   public func flatMap<T>(transform: Elements.Generator.Element -> T?)
>     -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Elements, T?>>, T>
> {
>       return self
>         .map(transform)
>         .filter { opt in opt != nil }
>         .map { notNil in notNil! }
>   }
> }
>
> The version for LazyCollectionType can be done similarly:
>
> extension LazyCollectionType {
>
>   @warn_unused_result
>   public func flatMap<T>(transform: Elements.Generator.Element -> T?)
>     -> LazyMapCollection<LazyFilterCollection<LazyMapCollection<Elements,
> T?>>, T> {
>       return self
>         .map(transform)
>         .filter { opt in opt != nil }
>         .map { notNil in notNil! }
>   }
> }

I like this.

> The version for a LazyCollectionType with a BidirectionalIndexType would
> rely on a similar LazyFilterCollection, but a BidirectionalFilterCollection
> doesn’t exist (I think). Is that something that might be included in this
> proposal?

Indeed.  I think that would be a separate proposal.

Dmitri

--
main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if
(j){printf("%d\n",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/

From david at hartbit.com  Sun Dec  6 19:10:45 2015
From: david at hartbit.com (David Hart)
Date: Mon, 7 Dec 2015 02:10:45 +0100
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions (David Hart)
In-Reply-To: <CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
<32D55766-386B-4584-8563-54AB8C1EDBFB@me.com>
<CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>
Message-ID: <DE739335-2DEA-4AA2-A234-2491A12C00B2@hartbit.com>

Hi Nick,

I understand the quote "This makes the capturing semantics of self stand out more in closures”, but this is a very weak statement in Swift for me. Let me try to explain.

If we use the try keyword as an example:

try foobar()
barfoo()

If the previous lines of code compile without error, we know without a shadow of a doubt that foobar is a throwing function and that barfoo does not throw. The compiler will not compile the first line without the keyword and would not allow it in on the second line.

Now if we go back to the example of self in closures:

foobar({
print(self.description)
})

The self keyword in the previous lines of code does not tell us anything at all:

self might have been forced by the compiler to warn us.
self might have been a programmer choice if the closure was non-escaping.

And the reverse:

barfoo({
print(description)
})

This also does not tell us much:

The closure might be non-escaping.
description might be referring to a local variable (which we missed the declaration) shadowing the instance property in an escaping closure.

In both of these last examples, we can’t tell by having a quick look at the code at the point of call if we should really be careful about memory or not.

With the proposition, self gets some meaning back: it indicates which are local and which are instance properties.

David.


> On 06 Dec 2015, at 23:55, Nick Shelley via swift-evolution <swift-evolution at swift.org> wrote:
>
> I like that self is only required in closures because it serves as a good reminder that there are memory and safety implications with using self in a closure, such as creating retain cycles or having the closure run after self has been deallocated.
>
> I can't seem to find an official Apple Swift style guide, but github's (https://github.com/github/swift-style-guide <https://github.com/github/swift-style-guide>) suggests only using self in closures with the rationale: "This makes the capturing semantics of self stand out more in closures, and avoids verbosity elsewhere."
>
> On Sat, Dec 5, 2015 at 3:16 AM, Yichen Cao <ycao at me.com <mailto:ycao at me.com>> wrote:
> Teaching wise, its much less confusing for self to be required so students don't mix up instance properties and local vars. Especially when self is required in closures, it confuses students. If self is mandatory for all instance properties, it would be so much clearer and much easier to read.
>
> Yichen
>
>> On Dec 5, 2015, at 18:11, swift-evolution-request at swift.org <mailto:swift-evolution-request at swift.org> wrote:
>>
>> Re: Proposal: Re-instate mandatory self for	accessing
>>      instance properties and functions (David Hart)
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/6f5e3839/attachment.html>

From matthew at anandabits.com  Sun Dec  6 19:15:26 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 19:15:26 -0600
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4C F3-BD57- 47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
<B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de>
<CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com>
Message-ID: <2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com>

I also agree with this.  I see no value in different syntax for statements and expressions, just unnecessary complexity.

Modifying the current syntax is an orthogonal issue.  If anyone feels the current switch syntax is to verbose I would recommend writing a new proposal to change it.  If such a proposal were adopted the new syntax should be used for both statements and expressions.

Sent from my iPhone

> On Dec 6, 2015, at 4:14 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:
>
> 👍
>
>> On Sun, Dec 6, 2015 at 5:12 PM, thorsten at portableinnovations.de <thorsten at portableinnovations.de> wrote:
>> Absolutely. Just the same rule: parts that were statements must be expressions. The else clause becomes mandatory.
>>
>> -Thorsten
>>
>>> Am 06.12.2015 um 22:52 schrieb Alex Lew <alexl.mail+swift at gmail.com>:
>>>
>>> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.
>>>
>>> Would you allow the same thing with if?
>>>
>>> let thisColor = if condition { .Red } else { .Blue }
>>>
>>>> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:
>>>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> >
>>>> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.
>>>>
>>>> +1
>>>>
>>>> >
>>>> > Therefore the switch-expression should simply look like follows:
>>>> >
>>>> > let thisColor = switch thatColor {
>>>> >         case .Red: .Green // must be an expression
>>>> >         default: .Yellow      // must be an expression
>>>> >     }
>>>> >
>>>> > No returns needed in the case clauses.
>>>>
>>>> This actually looks great. One simple rule and zero new keywords.
>>>>
>>>> Readable and simple to learn.
>>>>
>>>> Fantastic!
>>>>
>>>> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).
>>>> >
>>>> > -Thorsten
>>>> > _______________________________________________
>>>> > swift-evolution mailing list
>>>> > swift-evolution at swift.org
>>>> > https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/5e6ab41e/attachment.html>

From matthew at anandabits.com  Sun Dec  6 20:04:05 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 20:04:05 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
Message-ID: <F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>

I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.

However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.

Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).

If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).

We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.

All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.

Sent from my iPhone

> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:
>
> It seems like setting properties just after init is the main use case here.
>
> I'm not against this idea, but I want to point out that this doesn't *need* to be solved by a change to the language. You can easily define a convenience init for UILabel that takes textAlignment, font, text, and numberOfLines as parameters. They could have default values so you can specify just the ones you need.
>
> I like the idea of being able to do configure objects/values conveniently, but I'm not sure how to justify a language change for it. Perhaps we just need better autogeneration of initializers during Obj-C header import.
>
> Jacob Bandes-Storch
>
>> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>> Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well
>>
>>> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com> wrote:
>>>
>>> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>>>
>>> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>>>
>>> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>>>
>>> -DW
>>>
>>>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>>>>
>>>> I applaud honest description of drawbacks in the proposal :)
>>>>
>>>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>>>
>>>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>>>
>>>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>>>
>>>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>>>>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>>>>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>>>>
>>>>> https://gist.github.com/erica/eb32feb22ba99629285a
>>>>>
>>>>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>>>>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>>>>
>>>>> Best,
>>>>>
>>>>> -- E
>>>>>
>>>>>
>>>>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>>>>>
>>>>>> Sorry, did I misunderstand the question?
>>>>>>
>>>>>> Did you asked whether my definition will work for immutable value types?
>>>>>> If that's the question, the answer is still yes, the link has an example :)
>>>>>>
>>>>>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>> I was specifically referring to value types. I apologize for not being clearer.
>>>>>>>
>>>>>>> -- E
>>>>>>>
>>>>>>>
>>>>>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>>>>>>>
>>>>>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift
>>>>>>>>
>>>>>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/).
>>>>>>>>>
>>>>>>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>>>>>>
>>>>>>>>> -- E
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>>>>>
>>>>>>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>>>>>>
>>>>>>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>>>>>>
>>>>>>>>>> let task = NSTask() +=+ {
>>>>>>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>>>>>>     $0.standardOutput = pipe
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> Note you can also use the configured object in the rhs:
>>>>>>>>>>
>>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>>     $0.textAlignment = .Center
>>>>>>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>     $0.text = currentQuestion.questionText
>>>>>>>>>>     $0.numberOfLines = 0
>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>>>>>>
>>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>>     .textAlignment = .Center
>>>>>>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>     .text = currentQuestion.questionText
>>>>>>>>>>     .numberOfLines = 0
>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> Actually I would be happy with something like
>>>>>>>>>>
>>>>>>>>>> let questionLabel = UILabel() .{
>>>>>>>>>>     ..textAlignment = .Center
>>>>>>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>     ..text = currentQuestion.questionText
>>>>>>>>>>     ..numberOfLines = 0
>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> Other thoughts?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>  _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/cc413b10/attachment.html>

From michel.fortin at michelf.ca  Sun Dec  6 20:10:50 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sun, 6 Dec 2015 21:10:50 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
<2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com>
<CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com>
Message-ID: <3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca>

Le 6 déc. 2015 à 16:08, ilya <ilya.nikokoshev at gmail.com> a écrit :

> There are a couple of ways of solving this issue:
>
> 1 refactor to where loop first, then convert to Swift

This assumes 1) that you have a working toolchain to compile, execute, and test the original code, and 2) that the other language has a way to express the loop in a similar way to Swift, or something close enough.


> 2 leave a fixit in Xcode that will perform while loop conversion

As it was pointed out earlier, converting to a while loop requires duplication of the "increment" part of the loop everywhere there is a `continue` inside the loop. While you could make a fixit that correctly does this, I would argue that duplicating code shouldn't be done so lightly (someone will have to edit or maintain it afterwards). It's unclear to me what else could be done here however, as I can't think of a refactoring that would prevent code duplication. (And defer shouldn't be used here because it has a different behaviour when an exception is thrown.)

The fixit probably should also introduce a do{} block to correctly scope the loop variable and avoid clashes with the surrounding context.

It remains that even with a fixit that changes the code like this, the various differences it'll create in line count, increment expression placement, indentation, and sometime duplicated code, are going to impair your ability to compare the two loops side by side when hunting for porting bugs. Also the Swift version, the one that compiles thanks to a fixit, will simply be less readable... to the point that it'll generally be better to just do the refactoring as you port, despite the downsides.

Before fixit:

for var i = 10; i >= 0; i -= 1 {
if i == 5 {
continue
}
for var j = 100; i >= 0; j -= 2 {
print("\(i) \(j)")
}
}

After fixit:

do {
var i = 10
while i >= 0 {
if i == 5 {
i -= 1
continue
}
do {
var j = 100;
while j >= 0 {
print("\(i) \(j)")
j -= 2
}
}
i -= 1
}
}


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From matthew at anandabits.com  Sun Dec  6 20:27:30 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 20:27:30 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
Message-ID: <F833B947-4FFD-485E-912A-31B50140660F@anandabits.com>

In thinking about this further I think I can summarize my position pretty concisely.

A criteria that has been used quite a bit in the feature removal threads and proposals is "if this feature was not already in the language would we add it".  I am using a variation of this criteria and asking "if Swift had a feature facilitating more flexible initialization and we could use that feature with Cocoa would we still want to add setup closures?".  I don't think we would.

Sent from my iPad

> On Dec 6, 2015, at 8:04 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>
> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>
> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>
> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>
> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>
> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>
> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>
> Sent from my iPhone
>
>> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> It seems like setting properties just after init is the main use case here.
>>
>> I'm not against this idea, but I want to point out that this doesn't *need* to be solved by a change to the language. You can easily define a convenience init for UILabel that takes textAlignment, font, text, and numberOfLines as parameters. They could have default values so you can specify just the ones you need.
>>
>> I like the idea of being able to do configure objects/values conveniently, but I'm not sure how to justify a language change for it. Perhaps we just need better autogeneration of initializers during Obj-C header import.
>>
>> Jacob Bandes-Storch
>>
>>> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>>> Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well
>>>
>>>> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com> wrote:
>>>>
>>>> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>>>>
>>>> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>>>>
>>>> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>>>>
>>>> -DW
>>>>
>>>>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>
>>>>> I applaud honest description of drawbacks in the proposal :)
>>>>>
>>>>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>>>>
>>>>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>>>>
>>>>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>>>>
>>>>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>>>>>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>>>>>
>>>>>> https://gist.github.com/erica/eb32feb22ba99629285a
>>>>>>
>>>>>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>>>>>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>>>>>
>>>>>> Best,
>>>>>>
>>>>>> -- E
>>>>>>
>>>>>>
>>>>>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>>>>>>
>>>>>>> Sorry, did I misunderstand the question?
>>>>>>>
>>>>>>> Did you asked whether my definition will work for immutable value types?
>>>>>>> If that's the question, the answer is still yes, the link has an example :)
>>>>>>>
>>>>>>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>> I was specifically referring to value types. I apologize for not being clearer.
>>>>>>>>
>>>>>>>> -- E
>>>>>>>>
>>>>>>>>
>>>>>>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:
>>>>>>>>>
>>>>>>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift
>>>>>>>>>
>>>>>>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com> wrote:
>>>>>>>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/).
>>>>>>>>>>
>>>>>>>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>>>>>>>
>>>>>>>>>> -- E
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:
>>>>>>>>>>>
>>>>>>>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>>>>>>>
>>>>>>>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>>>>>>>
>>>>>>>>>>> let task = NSTask() +=+ {
>>>>>>>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>>>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>>>>>>>     $0.standardOutput = pipe
>>>>>>>>>>> }
>>>>>>>>>>>
>>>>>>>>>>> Note you can also use the configured object in the rhs:
>>>>>>>>>>>
>>>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>>>     $0.textAlignment = .Center
>>>>>>>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>>     $0.text = currentQuestion.questionText
>>>>>>>>>>>     $0.numberOfLines = 0
>>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>>> }
>>>>>>>>>>>
>>>>>>>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>>>>>>>
>>>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>>>     .textAlignment = .Center
>>>>>>>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>>     .text = currentQuestion.questionText
>>>>>>>>>>>     .numberOfLines = 0
>>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>>> }
>>>>>>>>>>>
>>>>>>>>>>> Actually I would be happy with something like
>>>>>>>>>>>
>>>>>>>>>>> let questionLabel = UILabel() .{
>>>>>>>>>>>     ..textAlignment = .Center
>>>>>>>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>>     ..text = currentQuestion.questionText
>>>>>>>>>>>     ..numberOfLines = 0
>>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>>> }
>>>>>>>>>>>
>>>>>>>>>>> Other thoughts?
>>>>>>>>>>>
>>>>>>>>>>>
>>>>>>>>>>>  _______________________________________________
>>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>>> swift-evolution at swift.org
>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c9eb7107/attachment-0001.html>

From cheyo at masters3d.com  Sun Dec  6 20:32:15 2015
From: cheyo at masters3d.com (J. Cheyo Jimenez)
Date: Sun, 6 Dec 2015 20:32:15 -0600
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions (David Hart)
In-Reply-To: <CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
<32D55766-386B-4584-8563-54AB8C1EDBFB@me.com>
<CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>
Message-ID: <CAAcV4sbzcShO1JSmi=1X6VQ1a+kdj-zpVAOUe15OtLT7kM0dDg@mail.gmail.com>

-1 from me on this one.  I agree with Nick.  IMO forcing self would
actually make the code less readable with a sea of Selfs all over the
place. `Self` blindness. This is not something that should be forced but
something that a linter should `enforce` per project or organization
depending on their style guide.  If anything, I'd like a linter to tell me
when I am declaring self and self is not being captured.


On Sun, Dec 6, 2015 at 4:55 PM, Nick Shelley via swift-evolution <
swift-evolution at swift.org> wrote:

> I like that self is only required in closures because it serves as a good
> reminder that there are memory and safety implications with using self in a
> closure, such as creating retain cycles or having the closure run after
> self has been deallocated.
>
> I can't seem to find an official Apple Swift style guide, but github's (
> https://github.com/github/swift-style-guide) suggests only using self in
> closures with the rationale: "This makes the capturing semantics of self
> stand out more in closures, and avoids verbosity elsewhere."
>
> On Sat, Dec 5, 2015 at 3:16 AM, Yichen Cao <ycao at me.com> wrote:
>
>> Teaching wise, its much less confusing for self to be required so
>> students don't mix up instance properties and local vars. Especially when
>> self is required in closures, it confuses students. If self is mandatory
>> for all instance properties, it would be so much clearer and much easier to
>> read.
>>
>> Yichen
>>
>> On Dec 5, 2015, at 18:11, swift-evolution-request at swift.org wrote:
>>
>> Re: Proposal: Re-instate mandatory self for accessing
>>      instance properties and functions (David Hart)
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/0142dd1f/attachment.html>

From wjs at mac.com  Sun Dec  6 20:35:32 2015
From: wjs at mac.com (William Shipley)
Date: Sun, 06 Dec 2015 18:35:32 -0800
Subject: [swift-evolution] Auto-convert for numbers when safe
Message-ID: <7AC00FF2-72A9-44F0-8072-C2D645773F03@mac.com>

I’m new to this discussion and don’t really know what’s been tried before, so I’m probably asking stupid questions, but I *really* want auto-conversion…

What would be the drawback in terms of language design to just allowing types to specify what other types can automatically be “upconverted" to them? True, this could be used to create a cyclic graph, but that could just be disallowed in the compiler—you guys like writing code, right?

I think one of the issues with all this is that Swift allows us to skip specifying types, like:

let a = 1

let b: CGFloat = a + 3

And so it’d be easy to get into a morass where the poor compiler is all, “AH! I should go back in time and make ‘a’ a CGFloat automatically, not an Int like I want, so it’ll add with 3 and make a nice CGFloat!”

Is that the problem we’re fighting? If not, what was the issue with the (unreleased) auto-conversion code that was in Swift.

-Wil

From cantrell at pobox.com  Sun Dec  6 20:41:55 2015
From: cantrell at pobox.com (Paul Cantrell)
Date: Sun, 6 Dec 2015 20:41:55 -0600
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
Message-ID: <2F9C0A4A-4005-462F-83DD-795C6E838C3B@pobox.com>

People can do the (usually) trivial transformation to a while loop first. The cases where loop exits make the transformation nontrivial seem rare to me.

Doing a port of C, C++, Java, or C# code to Swift, that for→while transformation seems trivial next to, say, dealing with the differences in Swift’s type system, its memory management, or its handling of unsafe pointers — all things one would have to deal with in the first pass of a port.

I’m not sure easy porting from C is even a design consideration, but even if it is, it shouldn’t be a reason to hold back this proposal.

Cheers, P

> On Dec 6, 2015, at 2:37 PM, Michel Fortin via swift-evolution <swift-evolution at swift.org> wrote:
>
> There is actually one good reason I see in favor of keeping the C-style for loop, and only one: ease of porting existing code to Swift.
>
> If you are porting code from another language that uses C-style for loops, currently you can keep the loop as is while you translate all the syntactic differences everywhere. If Swift didn't had a C-style for loop, then you'd need to rethink the control flow at the same time you are converting everything else, increasing the risk of errors during what is already a delicate operation.
>
> C-style for loops are very common in code you can find everywhere because many languages have it, and therefore there is a lot of algorithms, sometime tricky algorithms you don't want to mess up, that rely on such loops. Even if you had the desire to convert all of them to for-in loops in your port, rewriting the control flow *at the same time* you are addressing all the other porting issues is much worse than doing it in a separate step *after* the crude port has been tested to work.
>
> In other words: you should avoid refactoring everything in one step. The C-style for loop enables that.
>
> --
> Michel Fortin
> michel.fortin at michelf.ca
> https://michelf.ca
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From kevin at klundberg.com  Sun Dec  6 20:45:13 2015
From: kevin at klundberg.com (Kevin Lundberg)
Date: Sun, 6 Dec 2015 21:45:13 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
<2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com>
<CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com>
<3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca>
Message-ID: <5664F2B9.5080808@klundberg.com>


> As it was pointed out earlier, converting to a while loop requires duplication of the "increment" part of the loop everywhere there is a `continue` inside the loop.
This is not necessarily true. `defer` could be used at the top of the
while loop scope to increment whenever the loop turns. The after-fixit
example you gave can be written like so:

do {
var i = 10
while i >= 0 {
defer { i -= 1 }
if i == 5 {
continue
}
do {
var j = 100;
while j >= 0 {
print("\(i) \(j)")
j -= 2
}
}
}
}



On 12/6/2015 9:10 PM, Michel Fortin via swift-evolution wrote:
> Le 6 déc. 2015 à 16:08, ilya <ilya.nikokoshev at gmail.com> a écrit :
>
>> There are a couple of ways of solving this issue:
>>
>> 1 refactor to where loop first, then convert to Swift
> This assumes 1) that you have a working toolchain to compile, execute, and test the original code, and 2) that the other language has a way to express the loop in a similar way to Swift, or something close enough.
>
>
>> 2 leave a fixit in Xcode that will perform while loop conversion
> As it was pointed out earlier, converting to a while loop requires duplication of the "increment" part of the loop everywhere there is a `continue` inside the loop. While you could make a fixit that correctly does this, I would argue that duplicating code shouldn't be done so lightly (someone will have to edit or maintain it afterwards). It's unclear to me what else could be done here however, as I can't think of a refactoring that would prevent code duplication. (And defer shouldn't be used here because it has a different behaviour when an exception is thrown.)
>
> The fixit probably should also introduce a do{} block to correctly scope the loop variable and avoid clashes with the surrounding context.
>
> It remains that even with a fixit that changes the code like this, the various differences it'll create in line count, increment expression placement, indentation, and sometime duplicated code, are going to impair your ability to compare the two loops side by side when hunting for porting bugs. Also the Swift version, the one that compiles thanks to a fixit, will simply be less readable... to the point that it'll generally be better to just do the refactoring as you port, despite the downsides.
>
> Before fixit:
>
> 	for var i = 10; i >= 0; i -= 1 {
> 		if i == 5 {
> 			continue
> 		}
> 		for var j = 100; i >= 0; j -= 2 {
> 			print("\(i) \(j)")
> 		}
> 	}
>
> After fixit:
>
> 	do {
> 		var i = 10
> 		while i >= 0 {
> 			if i == 5 {
> 				i -= 1
> 				continue
> 			}
> 			do {
> 				var j = 100;
> 				while j >= 0 {
> 					print("\(i) \(j)")
> 					j -= 2
> 				}
> 			}
> 			i -= 1
> 		}
> 	}
>
>


From erica at ericasadun.com  Sun Dec  6 20:45:10 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 19:45:10 -0700
Subject: [swift-evolution] Method cascading (was Re: Request for Discussion:
Setup closures)
In-Reply-To: <F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
Message-ID: <35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com>

Please note that the updated topic is no longer setup closures, which I have been convinced is the less compelling of the two related concepts, but method cascading.

Rather than re-invent the wheel, let me offer this reading list:

Dart language feature request: method cascades <https://docs.google.com/document/d/1U0PeHtVQHMQ8usy7xI5Luo01W5LuWR1acN5odgu_Mtw/edit?pli=1#heading=h.7yzml1vnq8eu>
Method Cascades in Dart <http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html>
8 Dart Features / Fluent APIs <http://radar.oreilly.com/2013/05/8-dart-features-those-fat-cats-dont-want-you-to-know.html>
Dart-like method cascading operator in Python <https://mail.python.org/pipermail//python-ideas/2013-November/024124.html>
Method Cascades (in Smalltalk) <http://devblog.avdi.org/2011/09/26/sbpp-4-method-cascades/>

-- E

> On Dec 6, 2015, at 7:04 PM, Matthew Johnson <matthew at anandabits.com> wrote:
>
> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>
> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>
> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>
> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>
> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>
> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>
> Sent from my iPhone
>
> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> It seems like setting properties just after init is the main use case here.
>>
>> I'm not against this idea, but I want to point out that this doesn't *need* to be solved by a change to the language. You can easily define a convenience init for UILabel that takes textAlignment, font, text, and numberOfLines as parameters. They could have default values so you can specify just the ones you need.
>>
>> I like the idea of being able to do configure objects/values conveniently, but I'm not sure how to justify a language change for it. Perhaps we just need better autogeneration of initializers during Obj-C header import.
>>
>> Jacob Bandes-Storch
>>
>> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>> Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well
>>
>>> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com <mailto:david at alkaline-solutions.com>> wrote:
>>>
>>> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>>>
>>> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>>>
>>> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>>>
>>> -DW
>>>
>>>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>> I applaud honest description of drawbacks in the proposal :)
>>>>
>>>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>>>
>>>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>>>
>>>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>>>
>>>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>>>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>>>
>>>> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>>>>
>>>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>>>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>>>
>>>> Best,
>>>>
>>>> -- E
>>>>
>>>>
>>>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>
>>>>> Sorry, did I misunderstand the question?
>>>>>
>>>>> Did you asked whether my definition will work for immutable value types?
>>>>> If that's the question, the answer is still yes, the link has an example :)
>>>>>
>>>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>> I was specifically referring to value types. I apologize for not being clearer.
>>>>>
>>>>> -- E
>>>>>
>>>>>
>>>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>
>>>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>>>>>
>>>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>>>>
>>>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>>>
>>>>>> -- E
>>>>>>
>>>>>>
>>>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>
>>>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>>>
>>>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>>>
>>>>>>> let task = NSTask() +=+ {
>>>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>>>     $0.standardOutput = pipe
>>>>>>> }
>>>>>>>
>>>>>>> Note you can also use the configured object in the rhs:
>>>>>>>
>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>     $0.textAlignment = .Center
>>>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>     $0.text = currentQuestion.questionText
>>>>>>>     $0.numberOfLines = 0
>>>>>>>     view.addSubview($0)
>>>>>>> }
>>>>>>>
>>>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>>>
>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>     .textAlignment = .Center
>>>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>     .text = currentQuestion.questionText
>>>>>>>     .numberOfLines = 0
>>>>>>>     view.addSubview($0)
>>>>>>> }
>>>>>>>
>>>>>>> Actually I would be happy with something like
>>>>>>>
>>>>>>> let questionLabel = UILabel() .{
>>>>>>>     ..textAlignment = .Center
>>>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>     ..text = currentQuestion.questionText
>>>>>>>     ..numberOfLines = 0
>>>>>>>     view.addSubview($0)
>>>>>>> }
>>>>>>>
>>>>>>> Other thoughts?
>>>>>>>
>>>>>>>
>>>>>>>  _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>  _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/462fd16d/attachment.html>

From possen at gmail.com  Sun Dec  6 21:11:36 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 19:11:36 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
<6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com>
Message-ID: <54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com>

In thinking about this, is there a way to have the compiler detect that something is a statement vs expression? Is it always clear to users when something is an expression vs a statement? In blurring the lines between expressions and statements complications arise anytime there is a return value returned by the result of “switch” or “if” it suddenly becomes an expression. Are there gray areas where it is hard to determine whether it is one vs the other when we use the those keywords? If it is not possible to determine for every situation or confusing to users, then maybe a new keyword for expressions is necessary. When a branch of an else returns void does it then become a statement? We should avoid shoehorning it in just to avoid another keyword.

let foo = if condition {
x = 1 // implied void -- illegal
} else {
10  // returns expression
}

also, I think this is confusing:

let foo = if condition {
function1()
} else {
function2()
}

it is not obvious that this is an assignment or that the functions return anything. Earlier I suggested something using =  to make it more clear. This is similar to the requirement that functions that throw are prefixed with with “try"

let foo if condition {
= function1()
} else {
= function2()
}

also for the literal case:

let foo  if condition {
=  1 // can’t accidentally put a non expression here.
} else {
= 10  // returns expression
}

Which makes it clear that it is an expression coming back from both sides of the “if”. The switch case is a little trickier because of the case.

let foo switch value {
= .Red:   function1()
= .Green  function2()
=  default: function3()
}

The equal emphasizes the functions return a value for each part of the switch and assigns to “foo”, but somehow is unsatisfying having that equal everywhere.

One the other hand,  the ternary operator being an expression this confusion does not exist, it is clear that function1() and function2() must return a value.

let foo = condition ? function1() : function2()

even when on separate lines:

let foo = condition ?
function1() :
function2()

So maybe Alex’s original suggestion works better where the ? operator is extended to support a switch like expression and keeping the two statements and expressions separate.

let foo = condition ?
.Red : .Green
.Green : Red

let foo = condition ?
.Red: function1()
.Green: function2()

let foo = condition ? .Red: function1() .Blue: function2() default:. function3()

also could include optional cases:

let foo = condition ? case .Red: function1(), case .Blue: functions(), default: function3()

Which brings us back full circle to the keyword because most people don’t like the ? operator which is why Alex suggested “match":

let foo = match condition
.Red: function1()
.Green: function2()
default: function3()

or with optional cases:

let foo = match condition
case .Red: function1()
case .Green: function2()
default: function3()

for booleans :

let too = match condition function() else function2()

I still like this better. A new keyword makes sure there is no confusion about expressions vs statements and avoids complications with the return values. Match would always be an expression, if/else/swtich are always statements. Also those keywords don’t change behavior if a user changes a statement into an expression by assigning the expression the else part would suddenly be required.

if condition {
function1()
}

is changed to

let foo = if condition {
function1()
}

is now an error, because there is no else. Now if function1() does not return a value. you have another error just changing it to assign completely changes the behavior of the “if” statement.

- Paul

> On Dec 6, 2015, at 2:11 PM, Paul Ossenbruggen <possen at gmail.com> wrote:
>
> so the rule would have to be that the “switch" or “if" must return a value of compatible type. Not sure I love all the braces in the “if" case but it does follow the existing language rules with the exception that it must be have an else.
>
> let thisColor = if condition { .Red }   // illegal for expressions but not statements
>
> Can still do this for statements:
> if condition {
> 	x = 40
> }
>
> likewise:
> let thisColor = if condition { .Red } else { 21 } // illegal unless thisColor is Any
>
> unless:
> let thisColor : Any = if condition { .Red } else { 21 } // illegal unless thisColor is Any
>
> It would be nice to omit braces in this expression case but not for statements:
> let thisColor = if condition .Red else .Blue
>
> in statements braces would be required:
>
> if condition {
> 	x = 32
> } else {
> 	y = 44
> }
>
>> >     }
>> On Dec 6, 2015, at 1:52 PM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.
>>
>> Would you allow the same thing with if?
>>
>> let thisColor = if condition { .Red } else { .Blue }
>>
>> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com <mailto:salutis at me.com>> wrote:
>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> >
>> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.
>>
>> +1
>>
>> >
>> > Therefore the switch-expression should simply look like follows:
>> >
>> > let thisColor = switch thatColor {
>> >         case .Red: .Green // must be an expression
>> >         default: .Yellow      // must be an expression
>> >     }
>> >
>> > No returns needed in the case clauses.
>>
>> This actually looks great. One simple rule and zero new keywords.
>>
>> Readable and simple to learn.
>>
>> Fantastic!
>>
>> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).
>> >
>> > -Thorsten
>> > _______________________________________________
>> > swift-evolution mailing list
>> > swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> > https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e55ec65c/attachment.html>

From matthew at anandabits.com  Sun Dec  6 21:12:28 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 21:12:28 -0600
Subject: [swift-evolution] Method cascading (was Re: Request for
Discussion: Setup closures)
In-Reply-To: <35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
<35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com>
Message-ID: <2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com>

Thanks for the links Erica.  I appreciate your sharing them.

A lot of the examples in these articles are variations on the initialization problem (which I believe is better solved in other ways).

The other major use case appears to be DSLs (I consider the graphics code examples to be effectively a DSL for hard-coding graphics data).  If one of the major use cases for method cascades is to create DSLs I think part of the discussion needs to address the question of whether or not this is the best tool to use to create DSLs in Swift (or at least certain classes of DSL).  If the answer is yes then I it becomes pretty easy for this feature to demonstrate its merit.  If Swift has (or can have) better tools for creating DSLs (hygienic macros?) then I think we need to look to other use cases to justify method cascades.

There were a few examples that don’t really fall into either of the two categories.  There is no doubt that this feature would reduce syntactic clutter in some code that could not be eliminated by any other feature.  Maybe they are pervasive enough to warrant language support and maybe not.  I haven’t seen enough real-world examples to convince me yet, but am keeping my mind open and looking forward to seeing more.


> On Dec 6, 2015, at 8:45 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>
> Please note that the updated topic is no longer setup closures, which I have been convinced is the less compelling of the two related concepts, but method cascading.
>
> Rather than re-invent the wheel, let me offer this reading list:
>
> Dart language feature request: method cascades <https://docs.google.com/document/d/1U0PeHtVQHMQ8usy7xI5Luo01W5LuWR1acN5odgu_Mtw/edit?pli=1#heading=h.7yzml1vnq8eu>
> Method Cascades in Dart <http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html>
> 8 Dart Features / Fluent APIs <http://radar.oreilly.com/2013/05/8-dart-features-those-fat-cats-dont-want-you-to-know.html>
> Dart-like method cascading operator in Python <https://mail.python.org/pipermail//python-ideas/2013-November/024124.html>
> Method Cascades (in Smalltalk) <http://devblog.avdi.org/2011/09/26/sbpp-4-method-cascades/>
>
> -- E
>
>> On Dec 6, 2015, at 7:04 PM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>
>> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>>
>> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>>
>> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>>
>> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>>
>> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>>
>> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>>
>> Sent from my iPhone
>>
>> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>>> It seems like setting properties just after init is the main use case here.
>>>
>>> I'm not against this idea, but I want to point out that this doesn't *need* to be solved by a change to the language. You can easily define a convenience init for UILabel that takes textAlignment, font, text, and numberOfLines as parameters. They could have default values so you can specify just the ones you need.
>>>
>>> I like the idea of being able to do configure objects/values conveniently, but I'm not sure how to justify a language change for it. Perhaps we just need better autogeneration of initializers during Obj-C header import.
>>>
>>> Jacob Bandes-Storch
>>>
>>> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>> Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well
>>>
>>>> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com <mailto:david at alkaline-solutions.com>> wrote:
>>>>
>>>> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>>>>
>>>> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>>>>
>>>> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>>>>
>>>> -DW
>>>>
>>>>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>
>>>>> I applaud honest description of drawbacks in the proposal :)
>>>>>
>>>>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>>>>
>>>>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>>>>
>>>>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>>>>
>>>>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>>>>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>>>>
>>>>> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>>>>>
>>>>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>>>>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>>>>
>>>>> Best,
>>>>>
>>>>> -- E
>>>>>
>>>>>
>>>>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>
>>>>>> Sorry, did I misunderstand the question?
>>>>>>
>>>>>> Did you asked whether my definition will work for immutable value types?
>>>>>> If that's the question, the answer is still yes, the link has an example :)
>>>>>>
>>>>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>> I was specifically referring to value types. I apologize for not being clearer.
>>>>>>
>>>>>> -- E
>>>>>>
>>>>>>
>>>>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>>
>>>>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>>>>>>
>>>>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>>>>>
>>>>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>>>>
>>>>>>> -- E
>>>>>>>
>>>>>>>
>>>>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>>
>>>>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>>>>
>>>>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>>>>
>>>>>>>> let task = NSTask() +=+ {
>>>>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>>>>     $0.standardOutput = pipe
>>>>>>>> }
>>>>>>>>
>>>>>>>> Note you can also use the configured object in the rhs:
>>>>>>>>
>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>     $0.textAlignment = .Center
>>>>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>     $0.text = currentQuestion.questionText
>>>>>>>>     $0.numberOfLines = 0
>>>>>>>>     view.addSubview($0)
>>>>>>>> }
>>>>>>>>
>>>>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>>>>
>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>     .textAlignment = .Center
>>>>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>     .text = currentQuestion.questionText
>>>>>>>>     .numberOfLines = 0
>>>>>>>>     view.addSubview($0)
>>>>>>>> }
>>>>>>>>
>>>>>>>> Actually I would be happy with something like
>>>>>>>>
>>>>>>>> let questionLabel = UILabel() .{
>>>>>>>>     ..textAlignment = .Center
>>>>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>     ..text = currentQuestion.questionText
>>>>>>>>     ..numberOfLines = 0
>>>>>>>>     view.addSubview($0)
>>>>>>>> }
>>>>>>>>
>>>>>>>> Other thoughts?
>>>>>>>>
>>>>>>>>
>>>>>>>>  _______________________________________________
>>>>>>>> swift-evolution mailing list
>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/48cce5a7/attachment.html>

From michel.fortin at michelf.ca  Sun Dec  6 21:16:35 2015
From: michel.fortin at michelf.ca (Michel Fortin)
Date: Sun, 6 Dec 2015 22:16:35 -0500
Subject: [swift-evolution] C-style For Loops
In-Reply-To: <5664F2B9.5080808@klundberg.com>
References: <AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de>
<CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com>
<40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com>
<9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca>
<2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com>
<CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com>
<3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca>
<5664F2B9.5080808@klundberg.com>
Message-ID: <5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca>

Le 6 déc. 2015 à 21:45, Kevin Lundberg <kevin at klundberg.com> a écrit :

>> As it was pointed out earlier, converting to a while loop requires duplication of the "increment" part of the loop everywhere there is a `continue` inside the loop.
> This is not necessarily true. `defer` could be used at the top of the
> while loop scope to increment whenever the loop turns. The after-fixit
> example you gave can be written like so:
>
> do {
> 	var i = 10
> 	while i >= 0 {
> 		defer { i -= 1 }
> 		if i == 5 {
> 			continue
> 		}
> 		do {
> 			var j = 100;
> 			while j >= 0 {
> 				print("\(i) \(j)")
> 				j -= 2
> 			}
> 		}
> 	}
> }

It won't matter that you use defer *in this particular case* because the "i -= 1" statement has no side effects, and nothing appears like it can throw in the loop body. But you can't assume this will always be the case, so the fixit shouldn't be allowed to change the semantics like that.

(As I tried to point out in the last sentence of the paragraph you quoted.)


--
Michel Fortin
michel.fortin at michelf.ca
https://michelf.ca


From erica at ericasadun.com  Sun Dec  6 21:27:55 2015
From: erica at ericasadun.com (Erica Sadun)
Date: Sun, 6 Dec 2015 20:27:55 -0700
Subject: [swift-evolution] Method cascading (was Re: Request for
Discussion: Setup closures)
In-Reply-To: <2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
<35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com>
<2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com>
Message-ID: <159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com>

Could you take a peek please at my updated writeup for a potential proposal here: https://gist.github.com/erica/eb32feb22ba99629285a

Thanks, -- E


> On Dec 6, 2015, at 8:12 PM, Matthew Johnson <matthew at anandabits.com> wrote:
>
> Thanks for the links Erica.  I appreciate your sharing them.
>
> A lot of the examples in these articles are variations on the initialization problem (which I believe is better solved in other ways).
>
> The other major use case appears to be DSLs (I consider the graphics code examples to be effectively a DSL for hard-coding graphics data).  If one of the major use cases for method cascades is to create DSLs I think part of the discussion needs to address the question of whether or not this is the best tool to use to create DSLs in Swift (or at least certain classes of DSL).  If the answer is yes then I it becomes pretty easy for this feature to demonstrate its merit.  If Swift has (or can have) better tools for creating DSLs (hygienic macros?) then I think we need to look to other use cases to justify method cascades.
>
> There were a few examples that don’t really fall into either of the two categories.  There is no doubt that this feature would reduce syntactic clutter in some code that could not be eliminated by any other feature.  Maybe they are pervasive enough to warrant language support and maybe not.  I haven’t seen enough real-world examples to convince me yet, but am keeping my mind open and looking forward to seeing more.
>
>
>> On Dec 6, 2015, at 8:45 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> Please note that the updated topic is no longer setup closures, which I have been convinced is the less compelling of the two related concepts, but method cascading.
>>
>> Rather than re-invent the wheel, let me offer this reading list:
>>
>> Dart language feature request: method cascades <https://docs.google.com/document/d/1U0PeHtVQHMQ8usy7xI5Luo01W5LuWR1acN5odgu_Mtw/edit?pli=1#heading=h.7yzml1vnq8eu>
>> Method Cascades in Dart <http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html>
>> 8 Dart Features / Fluent APIs <http://radar.oreilly.com/2013/05/8-dart-features-those-fat-cats-dont-want-you-to-know.html>
>> Dart-like method cascading operator in Python <https://mail.python.org/pipermail//python-ideas/2013-November/024124.html>
>> Method Cascades (in Smalltalk) <http://devblog.avdi.org/2011/09/26/sbpp-4-method-cascades/>
>>
>> -- E
>>
>>> On Dec 6, 2015, at 7:04 PM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>>
>>> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>>>
>>> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>>>
>>> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>>>
>>> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>>>
>>> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>>>
>>> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>>>
>>> Sent from my iPhone
>>>
>>> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>>> It seems like setting properties just after init is the main use case here.
>>>>
>>>> I'm not against this idea, but I want to point out that this doesn't *need* to be solved by a change to the language. You can easily define a convenience init for UILabel that takes textAlignment, font, text, and numberOfLines as parameters. They could have default values so you can specify just the ones you need.
>>>>
>>>> I like the idea of being able to do configure objects/values conveniently, but I'm not sure how to justify a language change for it. Perhaps we just need better autogeneration of initializers during Obj-C header import.
>>>>
>>>> Jacob Bandes-Storch
>>>>
>>>> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>> Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well
>>>>
>>>>> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com <mailto:david at alkaline-solutions.com>> wrote:
>>>>>
>>>>> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>>>>>
>>>>> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>>>>>
>>>>> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>>>>>
>>>>> -DW
>>>>>
>>>>>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>
>>>>>> I applaud honest description of drawbacks in the proposal :)
>>>>>>
>>>>>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>>>>>
>>>>>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>>>>>
>>>>>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>>>>>
>>>>>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>>>>>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>>>>>
>>>>>> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>>>>>>
>>>>>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>>>>>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>>>>>
>>>>>> Best,
>>>>>>
>>>>>> -- E
>>>>>>
>>>>>>
>>>>>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>>
>>>>>>> Sorry, did I misunderstand the question?
>>>>>>>
>>>>>>> Did you asked whether my definition will work for immutable value types?
>>>>>>> If that's the question, the answer is still yes, the link has an example :)
>>>>>>>
>>>>>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>> I was specifically referring to value types. I apologize for not being clearer.
>>>>>>>
>>>>>>> -- E
>>>>>>>
>>>>>>>
>>>>>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>>>
>>>>>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>>>>>>>
>>>>>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>>>>>>
>>>>>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>>>>>
>>>>>>>> -- E
>>>>>>>>
>>>>>>>>
>>>>>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>>>
>>>>>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>>>>>
>>>>>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>>>>>
>>>>>>>>> let task = NSTask() +=+ {
>>>>>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>>>>>     $0.standardOutput = pipe
>>>>>>>>> }
>>>>>>>>>
>>>>>>>>> Note you can also use the configured object in the rhs:
>>>>>>>>>
>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>     $0.textAlignment = .Center
>>>>>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>     $0.text = currentQuestion.questionText
>>>>>>>>>     $0.numberOfLines = 0
>>>>>>>>>     view.addSubview($0)
>>>>>>>>> }
>>>>>>>>>
>>>>>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>>>>>
>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>     .textAlignment = .Center
>>>>>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>     .text = currentQuestion.questionText
>>>>>>>>>     .numberOfLines = 0
>>>>>>>>>     view.addSubview($0)
>>>>>>>>> }
>>>>>>>>>
>>>>>>>>> Actually I would be happy with something like
>>>>>>>>>
>>>>>>>>> let questionLabel = UILabel() .{
>>>>>>>>>     ..textAlignment = .Center
>>>>>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>     ..text = currentQuestion.questionText
>>>>>>>>>     ..numberOfLines = 0
>>>>>>>>>     view.addSubview($0)
>>>>>>>>> }
>>>>>>>>>
>>>>>>>>> Other thoughts?
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>  _______________________________________________
>>>>>>>>> swift-evolution mailing list
>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>  _______________________________________________
>>>>>> swift-evolution mailing list
>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>
>>>>
>>>> _______________________________________________
>>>> swift-evolution mailing list
>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c6ae42e8/attachment.html>

From alexl.mail+swift at gmail.com  Sun Dec  6 21:45:24 2015
From: alexl.mail+swift at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 22:45:24 -0500
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
<6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com>
<54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com>
Message-ID: <CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com>

I think the compiler can just assume that if it's valid to have a statement
in a given context, the if or switch should be interpreted as a statement.

A convention of keeping if-expressions to one line, and switch-expressions
to one line per case, would make things relatively readable (though I don't
feel that strongly about the convention):

let foo = if condition { function1() } else { function2() }
let foo = switch color {
case .Red: function1()
case .Green: function2()
default: function3()
}

I'm still not totally convinced by Matthew's argument that making the
syntax lighter-weight is orthogonal to the expression/statement question.
In my mind, it makes sense to have both a heavier switch *statement*,
(which might have many sub-statements in each branch), and also a
lighter-weight option for a quick pattern-match inside an expression (like
the ones we've been discussing in this thread).

This is the whole idea behind the ternary operator in C, and the "a = value
if condition else otherValue" in Python, etc. That's why I kind of like the
ternary-operator-inspired syntax for pattern matching. It would be awful to
use for statements -- just like it would be awful to replace if/else
statements in C with the C ternary operator's syntax -- but I think it's
pretty readable for expressions. It just seems to fit: just like C's if,
while, for, and switch can now pattern match in Swift, so can ?: (not to
mention that the colons after each case "rhyme" with the original colon in
the ternary operator).

But I believe I'm in the minority on that opinion, which is totally fine. :)

I think the questions then become: first, as Chris has asked, do the
if/switch expressions provide enough of a benefit (in terms of conciseness)
to be worth implementing? And, as Matthew suggested: is there a
lighter-weight syntax that would make both statements and expressions more
succinct?

All best,
Alex

On Sun, Dec 6, 2015 at 10:11 PM, Paul Ossenbruggen <possen at gmail.com> wrote:

> In thinking about this, is there a way to have the compiler detect that
> something is a statement vs expression? Is it always clear to users when
> something is an expression vs a statement? In blurring the lines between
> expressions and statements complications arise anytime there is a return
> value returned by the result of “switch” or “if” it suddenly becomes an
> expression. Are there gray areas where it is hard to determine whether it
> is one vs the other when we use the those keywords? If it is not possible
> to determine for every situation or confusing to users, then maybe a new
> keyword for expressions is necessary. When a branch of an else returns void
> does it then become a statement? We should avoid shoehorning it in just to
> avoid another keyword.
>
> let foo = if condition {
> x = 1 // implied void -- illegal
> } else {
> 10  // returns expression
> }
>
> also, I think this is confusing:
>
> let foo = if condition {
> function1()
> } else {
> function2()
> }
>
> it is not obvious that this is an assignment or that the functions return
> anything. Earlier I suggested something using =  to make it more clear.
> This is similar to the requirement that functions that throw are prefixed
> with with “try"
>
> let foo if condition {
> = function1()
> } else {
> = function2()
> }
>
> also for the literal case:
>
> let foo  if condition {
> =  1 // can’t accidentally put a non expression here.
> } else {
> = 10  // returns expression
> }
>
> Which makes it clear that it is an expression coming back from both sides
> of the “if”. The switch case is a little trickier because of the case.
>
> let foo switch value {
> = .Red:   function1()
> = .Green  function2()
> =  default: function3()
> }
>
> The equal emphasizes the functions return a value for each part of the
> switch and assigns to “foo”, but somehow is unsatisfying having that equal
> everywhere.
>
> One the other hand,  the ternary operator being an expression this
> confusion does not exist, it is clear that function1() and function2() must
> return a value.
>
> let foo = condition ? function1() : function2()
>
> even when on separate lines:
>
> let foo = condition ?
> function1() :
> function2()
>
> So maybe Alex’s original suggestion works better where the ? operator is
> extended to support a switch like expression and keeping the two statements
> and expressions separate.
>
> let foo = condition ?
> .Red : .Green
> .Green : Red
>
> let foo = condition ?
> .Red: function1()
> .Green: function2()
>
> let foo = condition ? .Red: function1() .Blue: function2() default:.
> function3()
>
> also could include optional cases:
>
> let foo = condition ? case .Red: function1(), case .Blue: functions(),
> default: function3()
>
> Which brings us back full circle to the keyword because most people don’t
> like the ? operator which is why Alex suggested “match":
>
> let foo = match condition
> .Red: function1()
> .Green: function2()
> default: function3()
>
> or with optional cases:
>
> let foo = match condition
> case .Red: function1()
> case .Green: function2()
> default: function3()
>
> for booleans :
>
> let too = match condition function() else function2()
>
> I still like this better. A new keyword makes sure there is no confusion
> about expressions vs statements and avoids complications with the return
> values. Match would always be an expression, if/else/swtich are always
> statements. Also those keywords don’t change behavior if a user changes a
> statement into an expression by assigning the expression the else part
> would suddenly be required.
>
> if condition {
> function1()
> }
>
> is changed to
>
> let foo = if condition {
> function1()
> }
>
> is now an error, because there is no else. Now if function1() does not
> return a value. you have another error just changing it to assign
> completely changes the behavior of the “if” statement.
>
> - Paul
>
> On Dec 6, 2015, at 2:11 PM, Paul Ossenbruggen < possen at gmail.com> wrote:
>
> so the rule would have to be that the “switch" or “if" must return a value
> of compatible type. Not sure I love all the braces in the “if" case but it
> does follow the existing language rules with the exception that it must be
> have an else.
>
> let thisColor = if condition { .Red }   // illegal for expressions but not
> statements
>
> Can still do this for statements:
> if condition {
> x = 40
> }
>
> likewise:
> let thisColor = if condition { .Red } else { 21 } // illegal unless
> thisColor is Any
>
> unless:
> let thisColor : Any = if condition { .Red } else { 21 } // illegal unless
> thisColor is Any
>
> It would be nice to omit braces in this expression case but not for
> statements:
> let thisColor = if condition .Red else .Blue
>
> in statements braces would be required:
>
> if condition {
> x = 32
> } else {
> y = 44
> }
>
> >     }
>
> On Dec 6, 2015, at 1:52 PM, Alex Lew via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> I agree that it's simplest to just reuse switch keyword, and keep braces.
> +1.
>
> Would you allow the same thing with if?
>
> let thisColor = if condition { .Red } else { .Blue }
>
> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic   <salutis at me.com>  wrote:
>
>
>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> >
>> > I would prefer the expression to match the statement. The only
>> difference would be that all parts that were statements now have to be
>> expressions.
>>
>> +1
>>
>> >
>> > Therefore the switch-expression should simply look like follows:
>> >
>> > let thisColor = switch thatColor {
>> >         case .Red: .Green // must be an expression
>> >         default: .Yellow      // must be an expression
>> >     }
>> >
>> > No returns needed in the case clauses.
>>
>> This actually looks great. One simple rule and zero new keywords.
>>
>> Readable and simple to learn.
>>
>> Fantastic!
>>
>> > Formatting this as a one-liner would just require adding semicolons
>> (though I wouldn't recommend this).
>> >
>> > -Thorsten
>> > _______________________________________________
>> > swift-evolution mailing list
>> >   swift-evolution at swift.org
>> >   https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>
>  _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/a0e7475e/attachment.html>

From ahti333 at gmail.com  Sun Dec  6 21:47:05 2015
From: ahti333 at gmail.com (Lukas Stabe)
Date: Mon, 7 Dec 2015 04:47:05 +0100
Subject: [swift-evolution] Method cascading (was Re: Request for
Discussion: Setup closures)
In-Reply-To: <159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
<35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com>
<2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com>
<159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com>
Message-ID: <38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com>

The proposal sounds like a good start to me. I really like the idea of this feature (and have in the past in obj-c used the compound-statement-expression gnu extension to achieve similar-looking code).

One thing I found myself thinking about is: How would `with` work when used with optionals (think failable initializers)? Would the block just not be executed (making it similar to mapping over an optional)? That would sound like a big plus for this feature, since you wouldn’t need to either use optional chaining or check if the value was nil while doing further setup.

Another question for me is this:  Say I want to create an instance of a class, configure it, and then assign it to a property on some other object (it can’t be assigned before it’s fully configured). Could we adapt this proposal to handle that case, too (e.g. `with obj.prop = MyClass() { … }`)? I think it might feel more natural to move the `with` after the assignment (e.g. `obj.prop = with MyClass() { … }, so it could be used not just to assign to a local variable but in any context you want to use it, including method calls etc.

Lukas

> On 07 Dec 2015, at 04:27, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:
>
> Could you take a peek please at my updated writeup for a potential proposal here: https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>
> Thanks, -- E
>
>
>> On Dec 6, 2015, at 8:12 PM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>
>> Thanks for the links Erica.  I appreciate your sharing them.
>>
>> A lot of the examples in these articles are variations on the initialization problem (which I believe is better solved in other ways).
>>
>> The other major use case appears to be DSLs (I consider the graphics code examples to be effectively a DSL for hard-coding graphics data).  If one of the major use cases for method cascades is to create DSLs I think part of the discussion needs to address the question of whether or not this is the best tool to use to create DSLs in Swift (or at least certain classes of DSL).  If the answer is yes then I it becomes pretty easy for this feature to demonstrate its merit.  If Swift has (or can have) better tools for creating DSLs (hygienic macros?) then I think we need to look to other use cases to justify method cascades.
>>
>> There were a few examples that don’t really fall into either of the two categories.  There is no doubt that this feature would reduce syntactic clutter in some code that could not be eliminated by any other feature.  Maybe they are pervasive enough to warrant language support and maybe not.  I haven’t seen enough real-world examples to convince me yet, but am keeping my mind open and looking forward to seeing more.
>>
>>
>>> On Dec 6, 2015, at 8:45 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> Please note that the updated topic is no longer setup closures, which I have been convinced is the less compelling of the two related concepts, but method cascading.
>>>
>>> Rather than re-invent the wheel, let me offer this reading list:
>>>
>>> Dart language feature request: method cascades <https://docs.google.com/document/d/1U0PeHtVQHMQ8usy7xI5Luo01W5LuWR1acN5odgu_Mtw/edit?pli=1#heading=h.7yzml1vnq8eu>
>>> Method Cascades in Dart <http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html>
>>> 8 Dart Features / Fluent APIs <http://radar.oreilly.com/2013/05/8-dart-features-those-fat-cats-dont-want-you-to-know.html>
>>> Dart-like method cascading operator in Python <https://mail.python.org/pipermail//python-ideas/2013-November/024124.html>
>>> Method Cascades (in Smalltalk) <http://devblog.avdi.org/2011/09/26/sbpp-4-method-cascades/>
>>>
>>> -- E
>>>
>>>> On Dec 6, 2015, at 7:04 PM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:
>>>>
>>>> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>>>>
>>>> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>>>>
>>>> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>>>>
>>>> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>>>>
>>>> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>>>>
>>>> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>>>>
>>>> Sent from my iPhone
>>>>
>>>> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>
>>>>> It seems like setting properties just after init is the main use case here.
>>>>>
>>>>> I'm not against this idea, but I want to point out that this doesn't *need* to be solved by a change to the language. You can easily define a convenience init for UILabel that takes textAlignment, font, text, and numberOfLines as parameters. They could have default values so you can specify just the ones you need.
>>>>>
>>>>> I like the idea of being able to do configure objects/values conveniently, but I'm not sure how to justify a language change for it. Perhaps we just need better autogeneration of initializers during Obj-C header import.
>>>>>
>>>>> Jacob Bandes-Storch
>>>>>
>>>>> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>> Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well
>>>>>
>>>>>> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com <mailto:david at alkaline-solutions.com>> wrote:
>>>>>>
>>>>>> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.
>>>>>>
>>>>>> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope.
>>>>>>
>>>>>> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.
>>>>>>
>>>>>> -DW
>>>>>>
>>>>>>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>
>>>>>>> I applaud honest description of drawbacks in the proposal :)
>>>>>>>
>>>>>>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities.
>>>>>>>
>>>>>>> If one wants to work "inside" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context.
>>>>>>>
>>>>>>> Alternatively, I think it makes sense to continue working on configuration syntax, with "default" access to local context and "explicit" access to the object. Let's just replace $0 with something else.
>>>>>>>
>>>>>>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me.
>>>>>>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>> It's probably better at this point for me to collect my thoughts and summarize where I am at.
>>>>>>>
>>>>>>> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>
>>>>>>>
>>>>>>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and
>>>>>>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.
>>>>>>>
>>>>>>> Best,
>>>>>>>
>>>>>>> -- E
>>>>>>>
>>>>>>>
>>>>>>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>>>
>>>>>>>> Sorry, did I misunderstand the question?
>>>>>>>>
>>>>>>>> Did you asked whether my definition will work for immutable value types?
>>>>>>>> If that's the question, the answer is still yes, the link has an example :)
>>>>>>>>
>>>>>>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>> I was specifically referring to value types. I apologize for not being clearer.
>>>>>>>>
>>>>>>>> -- E
>>>>>>>>
>>>>>>>>
>>>>>>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:
>>>>>>>>>
>>>>>>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>
>>>>>>>>>
>>>>>>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:
>>>>>>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).
>>>>>>>>>
>>>>>>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.
>>>>>>>>>
>>>>>>>>> -- E
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>>>>>>>>
>>>>>>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...
>>>>>>>>>>
>>>>>>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:
>>>>>>>>>>
>>>>>>>>>> let task = NSTask() +=+ {
>>>>>>>>>>     $0.launchPath = "/usr/bin/mdfind"
>>>>>>>>>>     $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>>>>>>     $0.standardOutput = pipe
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> Note you can also use the configured object in the rhs:
>>>>>>>>>>
>>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>>     $0.textAlignment = .Center
>>>>>>>>>>     $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>     $0.text = currentQuestion.questionText
>>>>>>>>>>     $0.numberOfLines = 0
>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):
>>>>>>>>>>
>>>>>>>>>> let questionLabel = UILabel() +=+ {
>>>>>>>>>>     .textAlignment = .Center
>>>>>>>>>>     .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>     .text = currentQuestion.questionText
>>>>>>>>>>     .numberOfLines = 0
>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> Actually I would be happy with something like
>>>>>>>>>>
>>>>>>>>>> let questionLabel = UILabel() .{
>>>>>>>>>>     ..textAlignment = .Center
>>>>>>>>>>     ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>>>>>>     ..text = currentQuestion.questionText
>>>>>>>>>>     ..numberOfLines = 0
>>>>>>>>>>     view.addSubview($0)
>>>>>>>>>> }
>>>>>>>>>>
>>>>>>>>>> Other thoughts?
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>>  _______________________________________________
>>>>>>>>>> swift-evolution mailing list
>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>>>  _______________________________________________
>>>>>>> swift-evolution mailing list
>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/4bd4c8ea/attachment.html>

From david at alkaline-solutions.com  Sun Dec  6 22:08:09 2015
From: david at alkaline-solutions.com (David Waite)
Date: Sun, 6 Dec 2015 21:08:09 -0700
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <F833B947-4FFD-485E-912A-31B50140660F@anandabits.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
<F833B947-4FFD-485E-912A-31B50140660F@anandabits.com>
Message-ID: <DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com>

This is not something anyone else can evaluate, as you haven’t shared details on your alternate proposal.

-DW

> On Dec 6, 2015, at 7:27 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>
> In thinking about this further I think I can summarize my position pretty concisely.
>
> A criteria that has been used quite a bit in the feature removal threads and proposals is "if this feature was not already in the language would we add it".  I am using a variation of this criteria and asking "if Swift had a feature facilitating more flexible initialization and we could use that feature with Cocoa would we still want to add setup closures?".  I don't think we would.
>
> Sent from my iPad
>
> On Dec 6, 2015, at 8:04 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>
>> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>>
>> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>>
>> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>>
>> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>>
>> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>>
>> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>>
>> Sent from my iPhone

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2ce051ac/attachment.html>

From alexl.mail at gmail.com  Sun Dec  6 22:09:31 2015
From: alexl.mail at gmail.com (Alex Lew)
Date: Sun, 6 Dec 2015 23:09:31 -0500
Subject: [swift-evolution] Method cascading (was Re: Request for
Discussion: Setup closures)
In-Reply-To: <38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
<35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com>
<2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com>
<159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com>
<38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com>
Message-ID: <CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com>

Thanks for writing this up, Erica! +1 to method cascading and to Lukas's
idea of moving the `with` keyword to after the = sign, so that `with thing
{ ... }` just becomes an expression.

Some q's:

1. Have we thought about how the syntax would work with initializers that
take closures as their last arguments? Would you just no longer use
trailing closure syntax with them?

2. Erica, I'm curious to hear your thoughts on using Dart's .. style of
method cascading, which is mentioned in the proposal but not seriously
considered. It seems it would avoid the difficulties described in the
proposal (about what to do when names are both in outer scope and members
of newly bound self).

On Sun, Dec 6, 2015 at 10:47 PM, Lukas Stabe via swift-evolution <
swift-evolution at swift.org> wrote:

> The proposal sounds like a good start to me. I really like the idea of
> this feature (and have in the past in obj-c used the
> compound-statement-expression gnu extension to achieve similar-looking
> code).
>
> One thing I found myself thinking about is: How would `with` work when
> used with optionals (think failable initializers)? Would the block just not
> be executed (making it similar to mapping over an optional)? That would
> sound like a big plus for this feature, since you wouldn’t need to either
> use optional chaining or check if the value was nil while doing further
> setup.
>
> Another question for me is this:  Say I want to create an instance of a
> class, configure it, and then assign it to a property on some other object
> (it can’t be assigned before it’s fully configured). Could we adapt this
> proposal to handle that case, too (e.g. `with obj.prop = MyClass() { … }`)?
> I think it might feel more natural to move the `with` after the assignment
> (e.g. `obj.prop = with MyClass() { … }, so it could be used not just to
> assign to a local variable but in any context you want to use it, including
> method calls etc.
>
> Lukas
>
> On 07 Dec 2015, at 04:27, Erica Sadun via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> Could you take a peek please at my updated writeup for a potential
> proposal here:  https://gist.github.com/erica/eb32feb22ba99629285a
>
> Thanks, -- E
>
>
> On Dec 6, 2015, at 8:12 PM, Matthew Johnson < matthew at anandabits.com>
> wrote:
>
> Thanks for the links Erica.  I appreciate your sharing them.
>
> A lot of the examples in these articles are variations on the
> initialization problem (which I believe is better solved in other ways).
>
> The other major use case appears to be DSLs (I consider the graphics code
> examples to be effectively a DSL for hard-coding graphics data).  If one of
> the major use cases for method cascades is to create DSLs I think part of
> the discussion needs to address the question of whether or not this is the
> best tool to use to create DSLs in Swift (or at least certain classes of
> DSL).  If the answer is yes then I it becomes pretty easy for this feature
> to demonstrate its merit.  If Swift has (or can have) better tools for
> creating DSLs (hygienic macros?) then I think we need to look to other use
> cases to justify method cascades.
>
> There were a few examples that don’t really fall into either of the two
> categories.  There is no doubt that this feature would reduce syntactic
> clutter in some code that could not be eliminated by any other feature.
> Maybe they are pervasive enough to warrant language support and maybe not.
> I haven’t seen enough real-world examples to convince me yet, but am
> keeping my mind open and looking forward to seeing more.
>
>
> On Dec 6, 2015, at 8:45 PM, Erica Sadun via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> Please note that the updated topic is no longer setup closures, which I
> have been convinced is the less compelling of the two related concepts, but
> method cascading.
>
> Rather than re-invent the wheel, let me offer this reading list:
>
>
>    - *Dart language feature request: method cascades*
>    <https://docs.google.com/document/d/1U0PeHtVQHMQ8usy7xI5Luo01W5LuWR1acN5odgu_Mtw/edit?pli=1#heading=h.7yzml1vnq8eu>
>    - *Method Cascades in Dart*
>    <http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html>
>    - *8 Dart Features / Fluent APIs*
>    <http://radar.oreilly.com/2013/05/8-dart-features-those-fat-cats-dont-want-you-to-know.html>
>    - Dart-like method cascading operator in Python
>    <https://mail.python.org/pipermail//python-ideas/2013-November/024124.html>
>    - *Method Cascades (in Smalltalk)*
>    <http://devblog.avdi.org/2011/09/26/sbpp-4-method-cascades/>
>
>
> -- E
>
> On Dec 6, 2015, at 7:04 PM, Matthew Johnson < matthew at anandabits.com>
> wrote:
>
> I do agree that current approaches are a bit ugly, that they are common in
> Cocoa code, and that the proposal cleans this up.  I would even enjoy the
> cleaner syntax in my own code if the feature was adopted.
>
> However, I share Jacob's thought that focusing on improving initialization
> flexibility is where we should focus.  I think it is a better use of our
> time, effort and language feature "budget".  This might be a more complex
> problem to solve, but the payoff is much larger in the end.
>
> Ideally instances should be fully configured for their intended use when
> initialization completes.  I view the *need* for post-initialization setup
> as a deficiency in the language, the interface of the type, or both (even
> if a type must expose members that are mutated by users during the lifetime
> of an instance it should still be possible to fully configure an instance
> for its initial use during initialization).
>
> If we can remove the aforementioned deficiency we will not need "setup
> closures". Doing this will require a language feature as well as a way to
> take advantage of the new feature when using Cocoa (probably through the
> Objective-C API import mechanism).
>
> We obviously need to begin with the language feature so that is where I'm
> focusing right now.  I plan to write a first draft of a proposal soon.
>
> All of this aside, I am still interest in hearing about additional use
> cases for the "method cascade" idea.  If it is more broadly applicable I
> might find it more worthwhile.
>
> Sent from my iPhone
>
> On Dec 6, 2015, at 3:13 PM, Jacob Bandes-Storch via swift-evolution <
> swift-evolution at swift.org> wrote:
>
> It seems like setting properties just after init is the main use case
> here.
>
> I'm not against this idea, but I want to point out that this doesn't
> *need* to be solved by a change to the language. You can easily define a   convenience
> init  for UILabel that takes textAlignment, font, text, and numberOfLines
> as parameters. They could have default values so you can specify just the
> ones you need.
>
> I like the idea of being able to do configure objects/values conveniently,
> but I'm not sure how to justify a language change for it. Perhaps we just
> need better autogeneration of initializers during Obj-C header import.
>
> Jacob Bandes-Storch
>
> On Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution   <
> swift-evolution at swift.org>  wrote:
>
>> Do you want me to tweak that? Or remove it entirely? Also, I think I
>> forgot to name-drop you slightly earlier as well
>>
>> On Dec 6, 2015, at 2:04 PM, David Waite < david at alkaline-solutions.com>
>> wrote:
>>
>> I’m leaning away from “self in” style syntax - I think there are too many
>> cases where you still want to be able to bind and access the self of the
>> object your closure was declared within.
>>
>> I’m not sure you have to establish a new “self” however - have the type
>> of object given to with is known, so the methods/functions available to it
>> can be exposed as lexical scope.
>>
>> To keep code clarity, use of methods/functions which shadow something in
>> higher lexical scope should likely result in compiler errors.
>>
>> -DW
>>
>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>> I applaud honest description of drawbacks in the proposal :)
>>
>> There examples given, I think, demonstrate that using self without any
>> special access leads to unresolvable ambiguities.
>>
>> If one wants to work "inside" the configured object, this seems like a
>> good job for a private initializer. All of the ambiguities will be
>> resolved, because extracting the init away removes its ability to capture
>> names from the local context.
>>
>> Alternatively, I think it makes sense to continue working on
>> configuration syntax, with "default" access to local context and "explicit"
>> access to the object. Let's just replace $0 with something else.
>>
>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in
>> the right direction to me.
>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <
>> swift-evolution at swift.org> wrote:
>>
>>> It's probably better at this point for me to collect my thoughts and
>>> summarize where I am at.
>>>
>>> https://gist.github.com/erica/eb32feb22ba99629285a
>>>
>>> Please feel free to comment on-list about this proposal (github does not
>>> forward comment alerts) and
>>> then I will start a new list thread as a Proposal rather than as a
>>> Request for Discussion.
>>>
>>> Best,
>>>
>>> -- E
>>>
>>>
>>> On Dec 6, 2015, at 12:45 PM, ilya < ilya.nikokoshev at gmail.com> wrote:
>>>
>>> Sorry, did I misunderstand the question?
>>>
>>> Did you asked whether my definition will work for immutable value
>>> types?
>>> If that's the question, the answer is still yes, the link has an example
>>> :)
>>>
>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun   <erica at ericasadun.com>  wrote:
>>>
>>>
>>>> I was specifically referring to value types. I apologize for not being
>>>> clearer.
>>>>
>>>> -- E
>>>>
>>>>
>>>> On Dec 6, 2015, at 12:42 PM, ilya < ilya.nikokoshev at gmail.com> wrote:
>>>>
>>>> Yes, it works for immutable objects with the correct definition, see
>>>> the playground contents at
>>>> https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift
>>>>
>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun   <erica at ericasadun.com>  wrote:
>>>>
>>>>
>>>>> I have developed something similar as well (
>>>>> http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/).
>>>>>
>>>>>
>>>>> Is yours capable of handling enums and structs that would otherwise be
>>>>> let after declaration because mine is not.
>>>>>
>>>>> -- E
>>>>>
>>>>>
>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <
>>>>> swift-evolution at swift.org> wrote:
>>>>>
>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail
>>>>> to fully set up an instance for use.  Here's one example: ...
>>>>>
>>>>> FWIW, I created a configuration operator more then a year ago, and use
>>>>> it in all of my Swift projects:
>>>>>
>>>>> let task = NSTask() +=+ {
>>>>>      $0.launchPath = "/usr/bin/mdfind"
>>>>>      $0.arguments = ["kMDItemDisplayName == *.playground"]
>>>>>      $0.standardOutput = pipe
>>>>> }
>>>>>
>>>>> Note you can also use the configured object in the rhs:
>>>>>
>>>>> let questionLabel = UILabel() +=+ {
>>>>>      $0.textAlignment = .Center
>>>>>      $0.font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>      $0.text = currentQuestion.questionText
>>>>>      $0.numberOfLines = 0
>>>>>      view.addSubview($0)
>>>>> }
>>>>>
>>>>> This $0. certainly looks ugly and it would be great to be able to
>>>>> simplify this. I don't llike the following much though (dot-syntax can be
>>>>> ambiguos here, and using simply a method name is even worse):
>>>>>
>>>>> let questionLabel = UILabel() +=+ {
>>>>>      .textAlignment = .Center
>>>>>      .font =  UIFont(name:"DnealianManuscript", size: 72)
>>>>>      .text = currentQuestion.questionText
>>>>>      .numberOfLines = 0
>>>>>      view.addSubview($0)
>>>>> }
>>>>>
>>>>> Actually I would be happy with something like
>>>>>
>>>>> let questionLabel = UILabel() .{
>>>>>      ..textAlignment = .Center
>>>>>      ..font = UIFont(name:"DnealianManuscript", size: 72)
>>>>>      ..text = currentQuestion.questionText
>>>>>      ..numberOfLines = 0
>>>>>      view.addSubview($0)
>>>>> }
>>>>>
>>>>> Other thoughts?
>>>>>
>>>>>
>>>>>  _______________________________________________
>>>>> swift-evolution mailing list
>>>>> swift-evolution at swift.org
>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>
>>> _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org
>>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>>
>>  _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>>
>>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
> Untracked with Trackbuster <https://trackbuster.com/?sig>
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/42ff01f5/attachment.html>

From cantrell at pobox.com  Sun Dec  6 22:17:29 2015
From: cantrell at pobox.com (Paul Cantrell)
Date: Sun, 6 Dec 2015 22:17:29 -0600
Subject: [swift-evolution] Proposal: Universal dynamic dispatch for method
calls
Message-ID: <4309A904-7C8C-4305-A2E5-7AB9A927A756@pobox.com>

One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.

Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:

http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future

The upshot is that when we see this:

foo.bar()

…it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.

The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.

Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.

A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.

Thus:


PROPOSAL

Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).


I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.

Cheers,

Paul


From matthew at anandabits.com  Sun Dec  6 22:17:40 2015
From: matthew at anandabits.com (Matthew Johnson)
Date: Sun, 6 Dec 2015 22:17:40 -0600
Subject: [swift-evolution] Request for Discussion: Setup closures
In-Reply-To: <DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com>
References: <CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com>
<8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com>
<CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com>
<F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com>
<CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com>
<DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com>
<CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com>
<ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com>
<512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com>
<CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com>
<F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com>
<F833B947-4FFD-485E-912A-31B50140660F@anandabits.com>
<DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com>
Message-ID: <0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com>

I understand it's a hypothetical.  I posted a very rough sketch of a mechanism for doing this last night in a different thread.

I'm working on a more fleshed out proposal right now.  I won't have time to finish it tonight.  I hope to finish it in the next day or two and will share it as soon as I have fleshed it out enough to serve as a stake in the ground for discussion.

Sent from my iPad

> On Dec 6, 2015, at 10:08 PM, David Waite <david at alkaline-solutions.com> wrote:
>
> This is not something anyone else can evaluate, as you haven’t shared details on your alternate proposal.
>
> -DW
>
>> On Dec 6, 2015, at 7:27 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>>
>> In thinking about this further I think I can summarize my position pretty concisely.
>>
>> A criteria that has been used quite a bit in the feature removal threads and proposals is "if this feature was not already in the language would we add it".  I am using a variation of this criteria and asking "if Swift had a feature facilitating more flexible initialization and we could use that feature with Cocoa would we still want to add setup closures?".  I don't think we would.
>>
>> Sent from my iPad
>>
>>> On Dec 6, 2015, at 8:04 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:
>>>
>>> I do agree that current approaches are a bit ugly, that they are common in Cocoa code, and that the proposal cleans this up.  I would even enjoy the cleaner syntax in my own code if the feature was adopted.
>>>
>>> However, I share Jacob's thought that focusing on improving initialization flexibility is where we should focus.  I think it is a better use of our time, effort and language feature "budget".  This might be a more complex problem to solve, but the payoff is much larger in the end.
>>>
>>> Ideally instances should be fully configured for their intended use when initialization completes.  I view the *need* for post-initialization setup as a deficiency in the language, the interface of the type, or both (even if a type must expose members that are mutated by users during the lifetime of an instance it should still be possible to fully configure an instance for its initial use during initialization).
>>>
>>> If we can remove the aforementioned deficiency we will not need "setup closures". Doing this will require a language feature as well as a way to take advantage of the new feature when using Cocoa (probably through the Objective-C API import mechanism).
>>>
>>> We obviously need to begin with the language feature so that is where I'm focusing right now.  I plan to write a first draft of a proposal soon.
>>>
>>> All of this aside, I am still interest in hearing about additional use cases for the "method cascade" idea.  If it is more broadly applicable I might find it more worthwhile.
>>>
>>> Sent from my iPhone
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/86b26e34/attachment.html>

From brent at architechies.com  Sun Dec  6 22:21:21 2015
From: brent at architechies.com (Brent Royal-Gordon)
Date: Sun, 6 Dec 2015 20:21:21 -0800
Subject: [swift-evolution] Auto-convert for numbers when safe
In-Reply-To: <7AC00FF2-72A9-44F0-8072-C2D645773F03@mac.com>
References: <7AC00FF2-72A9-44F0-8072-C2D645773F03@mac.com>
Message-ID: <9FEE13D9-89A0-499C-AB35-133A9A4CA36A@architechies.com>

> I’m new to this discussion and don’t really know what’s been tried before, so I’m probably asking stupid questions, but I *really* want auto-conversion…
>
> What would be the drawback in terms of language design to just allowing types to specify what other types can automatically be “upconverted" to them? True, this could be used to create a cyclic graph, but that could just be disallowed in the compiler—you guys like writing code, right?

Chris Lattner discussed this yesterday. I can’t find it in the online archives, so I’ll copy-and-paste it here:

> From: Chris Lattner via swift-evolution <swift-evolution at swift.org>
> Date: December 5, 2015 at 11:02:47 PM PST
> To: Jonathan Hull <jhull at gbis.com>
> Cc: swift-evolution at swift.org
> Subject: Re: [swift-evolution] Proposal: Auto-convert for numbers when safe
>
> On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:
>> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.
>>
>> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).
>>
>>
>> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).
>>
>> For example:
>> • If an Int is casting to a larger size (Int16 -> Int32)
>> • Float -> Double
>> • Float -> CGFloat
>> • Int -> Float, Double, or CGFloat (but not the other way)
>>
>> I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?
>
> I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms).  I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.
>
> The problem with doing this today is that there are a lot of dependencies we need to get resolved first.
>
> 1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions.  We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions.  We have thoughts on this, but should be discussed in a separate thread if you’re interested.
>
> 2. These promotions should be expressible in the library, not hard coded into the compiler.  This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs.  Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.
>
> 3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.
>
> There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats.  These issues are separable, and blocked on things like generic properties not being in place.
>
> It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.
>
> -Chris

--
Brent Royal-Gordon
Architechies


From lingoerer at gmail.com  Sun Dec  6 22:57:31 2015
From: lingoerer at gmail.com (Roy Fu)
Date: Mon, 7 Dec 2015 12:57:31 +0800
Subject: [swift-evolution] Proposal: Universal dynamic dispatch for
method calls
In-Reply-To: <4309A904-7C8C-4305-A2E5-7AB9A927A756@pobox.com>
References: <4309A904-7C8C-4305-A2E5-7AB9A927A756@pobox.com>
Message-ID: <7A1FC29E-B438-4FCA-99E7-4DBBD0175432@gmail.com>

Hmmmm…. interesting point.
I probably didn’t catch the point quite well
when writing obj-c or ruby or etc (I mean smalltalk), we used to focus on the Instances at runtime.
however, now, we should rather focus on the Types at declaration much much more. (yes, I mean inheritance is not a good idea most of the time)
so, I’d rather prefer to just unify simple Protocol as Types and the Protocols with associated Types when higher order Types is added (
e.g.
extension SequenceType<T>:Functor {
}
)

> On Dec 7, 2015, at 12:17 PM, Paul Cantrell via swift-evolution <swift-evolution at swift.org> wrote:
>
> One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.
>
> Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:
>
>    http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future
>
> The upshot is that when we see this:
>
>    foo.bar()
>
> …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.
>
> The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.
>
> Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.
>
> A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.
>
> Thus:
>
>
> PROPOSAL
>
> Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).
>
>
> I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.
>
> Cheers,
>
> Paul
>
> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution


From possen at gmail.com  Sun Dec  6 23:09:33 2015
From: possen at gmail.com (Paul Ossenbruggen)
Date: Sun, 6 Dec 2015 21:09:33 -0800
Subject: [swift-evolution] ternary operator ?: suggestion
In-Reply-To: <CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com>
References: <CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com>
<CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com>
<C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com>
<18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com>
<2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io>
<BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com>
<CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com>
<CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com>
<40188000-3F42-4A8E-953A-70A76CE360DF@apple.com>
<BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com>
<909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net>
<0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com>
<49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net>
<CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com>
<49EEA2E6-55F2-49DE-A59F-A13017626370@web.de>
<CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com>
<4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com>
<11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com>
<CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com>
<07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de>
<45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com>
<CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com>
<6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com>
<54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com>
<CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com>
Message-ID: <6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com>

> This is the whole idea behind the ternary operator in C, and the "a = value if condition else otherValue" in Python, etc. That's why I kind of like the ternary-operator-inspired syntax for pattern matching. It would be awful to use for statements -- just like it would be awful to replace if/else statements in C with the C ternary operator's syntax -- but I think it's pretty readable for expressions. It just seems to fit: just like C's if, while, for, and switch can now pattern match in Swift, so can ?: (not to mention that the colons after each case "rhyme" with the original colon in the ternary operator).


Agreed, I don’t mind the repurpose of the ? or match. I think there is real value in having expressions and switch like expressions. It avoids this problem:

switch x  {
case 1: let y = 5
case 2: let y = 6
case 3: let y = 7
default: y = 8
}
print(y)

y is out of scope here so you currently have to write…

let y : Int
switch  x  {
case 1:  y = 5
case 2:  y = 6
case 3:  y = 7
default: y = 8
}
print(y)

y is in scope feels more clumsy but an expression would  be straight forward because type inference would take care or the result for you.

> On Dec 6, 2015, at 7:45 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:
>
> I think the compiler can just assume that if it's valid to have a statement in a given context, the if or switch should be interpreted as a statement.
>
> A convention of keeping if-expressions to one line, and switch-expressions to one line per case, would make things relatively readable (though I don't feel that strongly about the convention):
>
> let foo = if condition { function1() } else { function2() }
> let foo = switch color {
>     case .Red: function1()
>     case .Green: function2()
>     default: function3()
> }
>
> I'm still not totally convinced by Matthew's argument that making the syntax lighter-weight is orthogonal to the expression/statement question. In my mind, it makes sense to have both a heavier switch statement, (which might have many sub-statements in each branch), and also a lighter-weight option for a quick pattern-match inside an expression (like the ones we've been discussing in this thread).
>
> This is the whole idea behind the ternary operator in C, and the "a = value if condition else otherValue" in Python, etc. That's why I kind of like the ternary-operator-inspired syntax for pattern matching. It would be awful to use for statements -- just like it would be awful to replace if/else statements in C with the C ternary operator's syntax -- but I think it's pretty readable for expressions. It just seems to fit: just like C's if, while, for, and switch can now pattern match in Swift, so can ?: (not to mention that the colons after each case "rhyme" with the original colon in the ternary operator).
>
> But I believe I'm in the minority on that opinion, which is totally fine. :)
>
> I think the questions then become: first, as Chris has asked, do the if/switch expressions provide enough of a benefit (in terms of conciseness) to be worth implementing? And, as Matthew suggested: is there a lighter-weight syntax that would make both statements and expressions more succinct?
>
> All best,
> Alex
>
> On Sun, Dec 6, 2015 at 10:11 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote:
> In thinking about this, is there a way to have the compiler detect that something is a statement vs expression? Is it always clear to users when something is an expression vs a statement? In blurring the lines between expressions and statements complications arise anytime there is a return value returned by the result of “switch” or “if” it suddenly becomes an expression. Are there gray areas where it is hard to determine whether it is one vs the other when we use the those keywords? If it is not possible to determine for every situation or confusing to users, then maybe a new keyword for expressions is necessary. When a branch of an else returns void does it then become a statement? We should avoid shoehorning it in just to avoid another keyword.
>
> let foo = if condition {
>  x = 1 // implied void -- illegal
> } else {
>  10  // returns expression
> }
>
> also, I think this is confusing:
>
> let foo = if condition {
>  function1()
> } else {
>  function2()
> }
>
> it is not obvious that this is an assignment or that the functions return anything. Earlier I suggested something using =  to make it more clear. This is similar to the requirement that functions that throw are prefixed with with “try"
>
> let foo if condition {
>  = function1()
> } else {
>  = function2()
> }
>
> also for the literal case:
>
> let foo  if condition {
>  =  1 // can’t accidentally put a non expression here.
> } else {
>  = 10  // returns expression
> }
>
> Which makes it clear that it is an expression coming back from both sides of the “if”. The switch case is a little trickier because of the case.
>
> let foo switch value {
>  = .Red:   function1()
>  = .Green  function2()
>  =  default: function3()
> }
>
> The equal emphasizes the functions return a value for each part of the switch and assigns to “foo”, but somehow is unsatisfying having that equal everywhere.
>
> One the other hand,  the ternary operator being an expression this confusion does not exist, it is clear that function1() and function2() must return a value.
>
> let foo = condition ? function1() : function2()
>
> even when on separate lines:
>
> let foo = condition ?
>  function1() :
>  function2()
>
> So maybe Alex’s original suggestion works better where the ? operator is extended to support a switch like expression and keeping the two statements and expressions separate.
>
> let foo = condition ?
>  .Red : .Green
>  .Green : Red
>
> let foo = condition ?
>  .Red: function1()
>  .Green: function2()
>
> let foo = condition ? .Red: function1() .Blue: function2() default:. function3()
>
> also could include optional cases:
>
> let foo = condition ? case .Red: function1(), case .Blue: functions(), default: function3()
>
> Which brings us back full circle to the keyword because most people don’t like the ? operator which is why Alex suggested “match":
>
> let foo = match condition
>  .Red: function1()
>  .Green: function2()
>  default: function3()
>
> or with optional cases:
>
> let foo = match condition
>  case .Red: function1()
>  case .Green: function2()
>  default: function3()
>
> for booleans :
>
> let too = match condition function() else function2()
>
> I still like this better. A new keyword makes sure there is no confusion about expressions vs statements and avoids complications with the return values. Match would always be an expression, if/else/swtich are always statements. Also those keywords don’t change behavior if a user changes a statement into an expression by assigning the expression the else part would suddenly be required.
>
> if condition {
>  function1()
> }
>
> is changed to
>
> let foo = if condition {
>  function1()
> }
>
> is now an error, because there is no else. Now if function1() does not return a value. you have another error just changing it to assign completely changes the behavior of the “if” statement.
>
> - Paul
>
>> On Dec 6, 2015, at 2:11 PM, Paul Ossenbruggen < possen at gmail.com <mailto:possen at gmail.com>> wrote:
>>
>> so the rule would have to be that the “switch" or “if" must return a value of compatible type. Not sure I love all the braces in the “if" case but it does follow the existing language rules with the exception that it must be have an else.
>>
>> let thisColor = if condition { .Red }   // illegal for expressions but not statements
>>
>> Can still do this for statements:
>> if condition {
>>  x = 40
>> }
>>
>> likewise:
>> let thisColor = if condition { .Red } else { 21 } // illegal unless thisColor is Any
>>
>> unless:
>> let thisColor : Any = if condition { .Red } else { 21 } // illegal unless thisColor is Any
>>
>> It would be nice to omit braces in this expression case but not for statements:
>> let thisColor = if condition .Red else .Blue
>>
>> in statements braces would be required:
>>
>> if condition {
>>  x = 32
>> } else {
>>  y = 44
>> }
>>
>>> >     }
>>> On Dec 6, 2015, at 1:52 PM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.
>>>
>>> Would you allow the same thing with if?
>>>
>>> let thisColor = if condition { .Red } else { .Blue }
>>>
>>> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic   <salutis at me.com <mailto:salutis at me.com>>  wrote:
>>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>>
>>> >
>>> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.
>>>
>>> +1
>>>
>>> >
>>> > Therefore the switch-expression should simply look like follows:
>>> >
>>> > let thisColor = switch thatColor {
>>> >         case .Red: .Green // must be an expression
>>> >         default: .Yellow      // must be an expression
>>> >     }
>>> >
>>> > No returns needed in the case clauses.
>>>
>>> This actually looks great. One simple rule and zero new keywords.
>>>
>>> Readable and simple to learn.
>>>
>>> Fantastic!
>>>
>>> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).
>>> >
>>> > -Thorsten
>>> > _______________________________________________
>>> > swift-evolution mailing list
>>> >   swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> >   https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>
>>>
>>>  _______________________________________________
>>> swift-evolution mailing list
>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>
>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/9b61e822/attachment.html>

From kylebshr+swift-evolution at gmail.com  Sun Dec  6 23:19:33 2015
From: kylebshr+swift-evolution at gmail.com (Kyle Bashour)
Date: Mon, 7 Dec 2015 00:19:33 -0500
Subject: [swift-evolution] Reading from Standard In
Message-ID: <CAGkPYfk_ke-XCp22-EOjQXbn52UJhEcXccvT=7v6VByPCv825w@mail.gmail.com>

Hi Everyone,

I hope this is the best place to discuss this — if not, please point me in
the right direction! It seems like an appropriate topic for evolution
though.

According to my limited knowledge and basic research, Swift doesn't
currently have a simple way to read from standard input from the console.
The best solution I found was this StackOverflow solution
<http://stackoverflow.com/questions/24046952/xcode-6-swift-read-standard-input-console-to-string>,
but it doesn't seem to be implemented on Linux yet, and I think it should
be simpler than having to use NSFileHandle if Swift is to be used as a true
systems programming language.

Of course, if there is an easier way to do this, please let me know! Or a
reason why the SO solution is the best way to do this. Thanks for reading,
would love to hear thoughts on this. I also just joined the list, so if
this has already been discussed, apologies.

-- Kyle Bashour

@kylebshr
kylebashour.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/5bd40e03/attachment.html>

From rjmccall at apple.com  Sun Dec  6 23:21:20 2015
From: rjmccall at apple.com (John McCall)
Date: Sun, 06 Dec 2015 21:21:20 -0800
Subject: [swift-evolution] access control proposal
In-Reply-To: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>
References: <CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com>
Message-ID: <49615F0C-DAC5-4976-A6EF-E471DA77E3F1@apple.com>


> On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution <swift-evolution at swift.org> wrote:
>
> I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:
>
> 1) the meaning of the code changes depending on which file the class is in. It's very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it's better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it's better that the compiler does it automatically.
>
> 2) accessibility by file structure may cause some really short files.
>
> 3) It's impossible to group related classes in one file but still hide implementation details inside each class
>
> I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it's really important to have a separate keyword for backward compatibility, it would be the next best thing.

But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.

The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.

John.

From ndevries at apple.com  Sun Dec  6 23:28:22 2015
From: ndevries at apple.com (Nathan de Vries)
Date: Sun, 06 Dec 2015 21:28:22 -0800
Subject: [swift-evolution] Proposal: Allow willChange and didChange
observers on a property
In-Reply-To: <9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
References: <A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com>
<9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com>
Message-ID: <D52D800E-1C86-4B3C-94BC-55D28396EC5A@apple.com>

> On Dec 5, 2015, at 10:11 PM, Chris Lattner <clattner at apple.com> wrote:
>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:
>>
>> It's currently possible to define either or both of the following observers on a property:
>> willSet, called just before the value is stored
>> didSet, called immediately after the new value is stored
> ...
>
>> This would mean the following observers could be defined on a property:
>> willSet, called just before the value is stored
>> willChange, called just before the value is stored if the value is different to the previous value
>> didSet, called immediately after the new value is stored
>> didChange, called immediately after the new value is stored if the new value is different to the previous value
>
> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?

I did a little hand-waving in that direction:

"Property types conforming to Equatable would be checked for the implicit guard via ==, otherwise it would fall back on the identity operator (===) for value and reference types that don't conform to Equatable."

Do you see an issue with falling back on identity if a property's type doesn't conform to Equatable?

> Also, can a property have these observers as well as the existing ones?

I don't see any issue with someone deciding to exhaustively add all observers to a property, but practically I'd only expect a subset (one) of them to be implemented. In my case I'd almost exclusively use didChange.

> Would it be possible to add *one of* didChange or willChange - since less is better?

I never use willSet at the moment and can't imagine myself using willChange, so it was really only included for completeness. I'd be fine with limiting the addition to didChange only, with my only concern being the inconsistency of not providing willChange.

—Nathan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/1721bc95/attachment.html>

From austinzheng at gmail.com  Sun Dec  6 23:34:58 2015
From: austinzheng at gmail.com (Austin Zheng)
Date: Sun, 6 Dec 2015 21:34:58 -0800
Subject: [swift-evolution] Reading from Standard In
In-Reply-To: <CAGkPYfk_ke-XCp22-EOjQXbn52UJhEcXccvT=7v6VByPCv825w@mail.gmail.com>
References: <CAGkPYfk_ke-XCp22-EOjQXbn52UJhEcXccvT=7v6VByPCv825w@mail.gmail.com>
Message-ID: <48D567AF-3B86-4472-9D9D-B70FF34F7C7E@gmail.com>

Does the 'readline' function (introduced in Swift 2.x) work for your purposes? http://swiftdoc.org/v2.1/func/readLine/ <http://swiftdoc.org/v2.1/func/readLine/>

Austin

> On Dec 6, 2015, at 9:19 PM, Kyle Bashour via swift-evolution <swift-evolution at swift.org> wrote:
>
> Hi Everyone,
>
> I hope this is the best place to discuss this — if not, please point me in the right direction! It seems like an appropriate topic for evolution though.
>
> According to my limited knowledge and basic research, Swift doesn't currently have a simple way to read from standard input from the console. The best solution I found was this StackOverflow solution <http://stackoverflow.com/questions/24046952/xcode-6-swift-read-standard-input-console-to-string>, but it doesn't seem to be implemented on Linux yet, and I think it should be simpler than having to use NSFileHandle if Swift is to be used as a true systems programming language.
>
> Of course, if there is an easier way to do this, please let me know! Or a reason why the SO solution is the best way to do this. Thanks for reading, would love to hear thoughts on this. I also just joined the list, so if this has already been discussed, apologies.
>
> -- Kyle Bashour
>
> @kylebshr
> kylebashour.com <http://kylebashour.com/> _______________________________________________
> swift-evolution mailing list
> swift-evolution at swift.org
> https://lists.swift.org/mailman/listinfo/swift-evolution

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8476cd0c/attachment.html>

From rjmccall at apple.com  Sun Dec  6 23:54:15 2015
From: rjmccall at apple.com (John McCall)
Date: Sun, 06 Dec 2015 21:54:15 -0800
Subject: [swift-evolution] Overloading assignment operator
In-Reply-To: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
References: <19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com>
Message-ID: <D91A1DC9-2BC7-4862-B6BD-69AF1E702D97@apple.com>

> On Dec 6, 2015, at 5:44 AM, Don Wills via swift-evolution <swift-evolution at swift.org> wrote:
>
> The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded?

In your specific case, I think Alex Lew is completely correct: you really don’t want a ton of overloaded operators, you just want your decimal type to be literal-convertible.

But to answer the question more generally, no, I can’t foresee us ever allowing the overloading of =, no.  = always means simple initialization/assignment in Swift; that is, it always simply propagates values around.  That’s a very fundamental language concept to mess around with.

The way to fix your problem in a less ad hoc way is to allow user-defined implicit conversions, which is something we’ve talked about already in a different thread.  What I said there was that it will require a lot of very careful language/type-checker design work.  Here, I’d like to identity another problem: the behavior of implicit conversions can be very confusing for non-experts to reason about, and in the context of a language with a fair amount of other subtle behaviors (e.g. due to overloading), that’s a very dangerous thing to bring in.  Explicit type coercions are much easier for non-experts to reason about.

John.



From ycao at me.com  Sun Dec  6 17:52:10 2015
From: ycao at me.com (Yichen Cao)
Date: Mon, 07 Dec 2015 07:52:10 +0800
Subject: [swift-evolution] Proposal: Re-instate mandatory self for
accessing instance properties and functions (David Hart)
In-Reply-To: <CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>
References: <mailman.379.1449310286.15739.swift-evolution@swift.org>
<32D55766-386B-4584-8563-54AB8C1EDBFB@me.com>
<CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com>
Message-ID: <05322415-8F1B-4710-B495-52D5342137B6@me.com>

But swift is all about verbosity (with method naming and such brought from obj-c), having self is much clearer.

Yichen

> On Dec 7, 2015, at 06:55, Nick Shelley <nickmshelley at gmail.com> wrote:
>
> I like that self is only required in closures because it serves as a good reminder that there are memory and safety implications with using self in a closure, such as creating retain cycles or having the closure run after self has been deallocated.
>
> I can't seem to find an official Apple Swift style guide, but github's (https://github.com/github/swift-style-guide) suggests only using self in closures with the rationale: "This makes the capturing semantics of self stand out more in closures, and avoids verbosity elsewhere."
>
>> On Sat, Dec 5, 2015 at 3:16 AM, Yichen Cao <ycao at me.com> wrote:
>> Teaching wise, its much less confusing for self to be required so students don't mix up instance properties and local vars. Especially when self is required in closures, it confuses students. If self is mandatory for all instance properties, it would be so much clearer and much easier to read.
>>
>> Yichen
>>
>>> On Dec 5, 2015, at 18:11, swift-evolution-request at swift.org wrote:
>>>
>>> Re: Proposal: Re-instate mandatory self for	accessing
>>>      instance properties and functions (David Hart)
>>
>>
>> _______________________________________________
>> swift-evolution mailing list
>> swift-evolution at swift.org
>> https://lists.swift.org/mailman/listinfo/swift-evolution
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/66448896/attachment.html>

